msgid ""
msgstr ""
"Project-Id-Version: \n"
"POT-Creation-Date: \n"
"PO-Revision-Date: \n"
"Last-Translator: \n"
"Language-Team: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: pt_BR\n"
"X-Generator: Poedit 2.1.1\n"

#: book.translate.xml:140
#, fuzzy
msgid "FreeBSD Architecture Handbook"
msgstr "Manual de Arquitetura do FreeBSD"

#: book.translate.xml:143
#, fuzzy
msgid "<orgname>The FreeBSD Documentation Project</orgname>"
msgstr " <orgname> O projeto de documentaÁ„o do FreeBSD </orgname> "

#: book.translate.xml:224 book.translate.xml:145
#, fuzzy
msgid ""
"$FreeBSD: head/en_US.ISO8859-1/books/arch-handbook/book.xml 51016 2017-10-01 "
"12:11:13Z wosch $"
msgstr ""
"$ FreeBSD: head / en_US.ISO8859-1 / livros / arch-handbook / book.xml 51016 "
"2017-10-01 12: 11: 13Z wosch $"

#: book.translate.xml:147
#, fuzzy
msgid ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> <year>2004</"
"year> <year>2005</year> <year>2006</year> <year>2012</year> <year>2013</year> "
"<holder>The FreeBSD Documentation Project</holder>"
msgstr ""
" <year> 2000 </year><year> 2001 </year><year> 2002 </year><year> 2003 </year><year> "
"2004 </year><year> 2005 </year><year> 2006 </year><year> 2012 </year><year> 2013 </"
"year><holder> O projeto de documentaÁ„o do FreeBSD </holder> "

#: book.translate.xml:161
#, fuzzy
msgid "FreeBSD is a registered trademark of the FreeBSD Foundation."
msgstr "FreeBSD È uma marca registrada da FundaÁ„o FreeBSD."

#: book.translate.xml:163
#, fuzzy
msgid ""
"UNIX is a registered trademark of The Open Group in the United States and other "
"countries."
msgstr ""
"UNIX È uma marca registrada do The Open Group nos Estados Unidos e em outros paÌ≠ses."

#: book.translate.xml:165
#, fuzzy
msgid ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, and "
"TrueType are trademarks of Apple Inc., registered in the U.S. and other countries."
msgstr ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime e "
"TrueType s„o marcas comerciais da Apple Inc., registradas nos EUA e em outros paÌ≠ses."

#: book.translate.xml:170
#, fuzzy
msgid ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows NT are "
"either registered trademarks or trademarks of Microsoft Corporation in the United "
"States and/or other countries."
msgstr ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media e Windows NT s„o "
"marcas comerciais registradas ou marcas comerciais da Microsoft Corporation nos "
"Estados Unidos e / ou em outros paÌ≠ses."

#: book.translate.xml:174
#, fuzzy
msgid ""
"Many of the designations used by manufacturers and sellers to distinguish their "
"products are claimed as trademarks. Where those designations appear in this "
"document, and the FreeBSD Project was aware of the trademark claim, the designations "
"have been followed by the <quote>‚Ñ¢</quote> or the <quote>¬Æ</quote> symbol."
msgstr ""
"Muitas das designaÁÌµes usadas pelos fabricantes e vendedores para distinguir seus "
"produtos s„o reivindicadas como marcas comerciais. Onde essas designaÁÌµes aparecem "
"neste documento, e o Projeto FreeBSD estava ciente da reivindicaÁ„o de marca "
"registrada, as designaÁÌµes foram seguidas pela <quote> ‚Ñ¢ </quote> ou o <quote> ¬Æ "
"</quote> sÌ≠mbolo."

#: book.translate.xml:184
#, fuzzy
msgid "Copyright"
msgstr "Direito autoral"

#: book.translate.xml:186
#, fuzzy
msgid ""
"Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, HTML, PDF, "
"PostScript, RTF and so forth) with or without modification, are permitted provided "
"that the following conditions are met:"
msgstr ""
"RedistribuiÁ„o e uso em formul·rios de origem (XML DocBook) e ';compilados'; (XML, "
"HTML, PDF, PostScript, RTF e assim por diante) com ou sem modificaÁ„o, s„o "
"permitidos desde que as seguintes condiÁÌµes sejam atendidas:"

#: book.translate.xml:193
#, fuzzy
msgid ""
"Redistributions of source code (XML DocBook) must retain the above copyright notice, "
"this list of conditions and the following disclaimer as the first lines of this file "
"unmodified."
msgstr ""
"As redistribuiÁÌµes do cÛdigo-fonte (XML DocBook) devem manter o aviso de copyright "
"acima, esta lista de condiÁÌµes e o aviso de isenÁ„o de responsabilidade a seguir, "
"conforme as primeiras linhas deste arquivo n„o s„o modificadas."

#: book.translate.xml:4296 book.translate.xml:199
#, fuzzy
msgid ""
"Redistributions in compiled form (transformed to other DTDs, converted to PDF, "
"PostScript, RTF and other formats) must reproduce the above copyright notice, this "
"list of conditions and the following disclaimer in the documentation and/or other "
"materials provided with the distribution."
msgstr ""
"As redistribuiÁÌµes no formato compilado (transformadas em outros DTDs, convertidos "
"para PDF, PostScript, RTF e outros formatos) devem reproduzir o aviso de direitos "
"autorais acima, esta lista de condiÁÌµes e a seguinte declaraÁ„o de responsabilidade "
"na documentaÁ„o e / ou outros materiais fornecidos com a distribuiÁ„o. "

#: book.translate.xml:208
#, fuzzy
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT \"AS IS\" AND "
"ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED "
"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. "
"IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT BE LIABLE FOR ANY DIRECT, "
"INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT "
"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR "
"PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, "
"WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE "
"POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"ESTA DOCUMENTAÌáÌÉO Ìâ FORNECIDA PELO PROJETO DE DOCUMENTAÌáÌÉO DO FREEBSD\" COMO ESTÌÅ "
"\"E QUAISQUER GARANTIAS EXPRESSAS OU IMPLÌçCITAS, INCLUINDO, MAS NÌÉO SE LIMITANDO, ÌÄS "
"GARANTIAS IMPLÌçCITAS DE COMERCIALIZAÌáÌÉO E ADEQUAÌáÌÉO A UMA FINALIDADE ESPECÌçFICA SÌÉO "
"NEGADAS. EM NENHUMA CIRCUNSTÌÇNCIA O FREEBSD O PROJETO DE DOCUMENTAÌáÌÉO SERÌÅ "
"RESPONSÌÅVEL POR QUAISQUER DANOS DIRETOS, INDIRETOS, INCIDENTAIS, ESPECIAIS, "
"EXEMPLARES OU CONSEQÌúENCIAIS (INCLUINDO, MAS NÌÉO SE LIMITANDO A, AQUISIÌáÌÉO DE BENS "
"OU SERVIÌáOS SUBSTITUTOS; PERDA DE USO, DADOS OU LUCROS; OU INTERRUPÌáÌÉO DE NEGÌìCIOS), "
"SEMPRE CAUSADO E SOBRE QUALQUER TEORIA DE RESPONSABILIDADE, SEJA EM CONTRATO, "
"RESPONSABILIDADE ESTRITA, OU DELITO (INCLUINDO NEGLIGÌäNCIA OU DE OUTRA FORMA) "
"DECORRENTE DE QUALQUER FORMA DO USO DESTA DOCUMENTAÌáÌÉO, MESMO SE AVISADA DA "
"POSSIBILIDADE DE TAIS DANOS. "

#: book.translate.xml:227
#, fuzzy
msgid ""
"Welcome to the FreeBSD Architecture Handbook. This manual is a <emphasis>work in "
"progress</emphasis> and is the work of many individuals. Many sections do not yet "
"exist and some of those that do exist need to be updated. If you are interested in "
"helping with this project, send email to the <link xlink:href=\"http://lists.FreeBSD."
"org/mailman/listinfo/freebsd-doc\">FreeBSD documentation project mailing list</link>."
msgstr ""
"Bem-vindo ao FreeBSD Architecture Handbook. Este manual È um <emphasis> trabalho em "
"progresso </emphasis> e È o trabalho de muitas pessoas. Muitas seÁÌµes ainda n„o "
"existem e algumas que existem precisam ser atualizadas. Se vocÍ est· interessado em "
"ajudar com este projeto, envie um email para o <link xlink:href=\"http://lists."
"FreeBSD.org/mailman/listinfo/freebsd-doc\"> Lista de discuss„o do projeto de "
"documentaÁ„o do FreeBSD </link> "

#: book.translate.xml:234
#, fuzzy
msgid ""
"The latest version of this document is always available from the <link xlink:href="
"\"@@URL_RELPREFIX@@/index.html\">FreeBSD World Wide Web server</link>. It may also "
"be downloaded in a variety of formats and compression options from the <link xlink:"
"href=\"https://download.freebsd.org/ftp/doc/\">FreeBSD FTP server</link> or one of "
"the numerous <link xlink:href=\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/"
"mirrors-ftp.html\">mirror sites</link>."
msgstr ""
"A vers„o mais recente deste documento est· sempre disponÌ≠vel no site <link xlink:"
"href=\"@@URL_RELPREFIX@@/index.html\"> Servidor da World Wide Web do FreeBSD </"
"link> . Ele tambÈm pode ser baixado em v·rios formatos e opÁÌµes de compactaÁ„o do "
"<link xlink:href=\"https://download.freebsd.org/ftp/doc/\"> Servidor FTP FreeBSD </"
"link> ou um dos numerosos <link xlink:href=\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/"
"books/handbook/mirrors-ftp.html\"> sites espelho </link> "

#: book.translate.xml:243
#, fuzzy
msgid "Kernel"
msgstr "N˙cleo"

#: book.translate.xml:259
#, fuzzy
msgid "Bootstrapping and Kernel Initialization"
msgstr "Bootstrapping e inicializaÁ„o do kernel"

#: book.translate.xml:262
#, fuzzy
msgid ""
"<personname> <firstname>Sergey</firstname> <surname>Lyubka</surname> </personname> "
"<contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Sergey </firstname><surname> Lyubka </surname></"
"personname><contrib> ContribuÌ≠ram por </contrib> "

#: book.translate.xml:274
#, fuzzy
msgid ""
"<personname> <firstname>Sergio Andr√©s</firstname> <surname> G√≥mez del Real</"
"surname> </personname> <contrib>Updated and enhanced by </contrib>"
msgstr ""
" <personname><firstname> Sergio AndrÈs </firstname><surname> GÛmez del Real </"
"surname></personname><contrib> Atualizado e aprimorado por </contrib> "

#: book.translate.xml:19348 book.translate.xml:16381 book.translate.xml:4323
#: book.translate.xml:287
#, fuzzy
msgid "Synopsis"
msgstr "Sinopse"

#: book.translate.xml:20696 book.translate.xml:289
#, fuzzy
msgid "<primary>BIOS</primary>"
msgstr " <primary> BIOS </primary> "

#: book.translate.xml:290
#, fuzzy
msgid "<primary>firmware</primary>"
msgstr " <primary> firmware </primary> "

#: book.translate.xml:291
#, fuzzy
msgid "<primary>POST</primary>"
msgstr " <primary> POSTAR </primary> "

#: book.translate.xml:292
#, fuzzy
msgid "<primary>IA-32</primary>"
msgstr " <primary> IA-32 </primary> "

#: book.translate.xml:293
#, fuzzy
msgid "<primary>booting</primary>"
msgstr " <primary> inicializaÁ„o </primary> "

#: book.translate.xml:294
#, fuzzy
msgid "<primary>system initialization</primary>"
msgstr " <primary> inicializaÁ„o do sistema </primary> "

#: book.translate.xml:295
#, fuzzy
msgid ""
"This chapter is an overview of the boot and system initialization processes, "
"starting from the <acronym>BIOS</acronym> (firmware) <acronym>POST</acronym>, to the "
"first user process creation. Since the initial steps of system startup are very "
"architecture dependent, the IA-32 architecture is used as an example."
msgstr ""
"Este capÌ≠tulo È uma vis„o geral dos processos de inicializaÁ„o e inicializaÁ„o do "
"sistema, desde o <acronym>POST</acronym> da <acronym>BIOS</acronym> (firmware) atÈ a "
"primeira criaÁ„o do processo do usu·rio. Como as etapas iniciais da inicializaÁ„o do "
"sistema s„o muito dependentes da arquitetura, a arquitetura IA-32 È usada como um "
"exemplo."

#: book.translate.xml:301
#, fuzzy
msgid ""
"The FreeBSD boot process can be surprisingly complex. After control is passed from "
"the <acronym>BIOS</acronym>, a considerable amount of low-level configuration must "
"be done before the kernel can be loaded and executed. This setup must be done in a "
"simple and flexible manner, allowing the user a great deal of customization "
"possibilities."
msgstr ""
"O processo de inicializaÁ„o do FreeBSD pode ser surpreendentemente complexo. ApÛs o "
"controle ser passado do <acronym>BIOS</acronym> , uma quantidade consider·vel de "
"configuraÁ„o de baixo nÌ≠vel deve ser feita antes que o kernel possa ser carregado e "
"executado. Essa configuraÁ„o deve ser feita de maneira simples e flexÌ≠vel, "
"permitindo ao usu·rio uma grande quantidade de possibilidades de personalizaÁ„o. "

#: book.translate.xml:23316 book.translate.xml:310
#, fuzzy
msgid "Overview"
msgstr "Vis„o geral"

#: book.translate.xml:312
#, fuzzy
msgid ""
"The boot process is an extremely machine-dependent activity. Not only must code be "
"written for every computer architecture, but there may also be multiple types of "
"booting on the same architecture. For example, a directory listing of <filename>/usr/"
"src/sys/boot</filename> reveals a great amount of architecture-dependent code. There "
"is a directory for each of the various supported architectures. In the x86-specific "
"<filename>i386</filename> directory, there are subdirectories for different boot "
"standards like <filename>mbr</filename> (Master Boot Record), <filename>gpt</"
"filename> (<acronym>GUID</acronym> Partition Table), and <filename>efi</filename> "
"(Extensible Firmware Interface). Each boot standard has its own conventions and data "
"structures. The example that follows shows booting an x86 computer from an "
"<acronym>MBR</acronym> hard drive with the FreeBSD <filename>boot0</filename> multi-"
"boot loader stored in the very first sector. That boot code starts the FreeBSD three-"
"stage boot process."
msgstr ""
"O processo de inicializaÁ„o È uma atividade extremamente dependente da m·quina. N„o "
"sÛ deve ser escrito cÛdigo para cada arquitetura de computador, mas tambÈm pode "
"haver v·rios tipos de inicializaÁ„o na mesma arquitetura. Por exemplo, uma lista de "
"diretÛrios de <filename> / usr / src / sys / boot </filename> revela uma grande "
"quantidade de cÛdigo dependente de arquitetura. Existe um diretÛrio para cada uma "
"das v·rias arquiteturas suportadas. No x86-specific <filename> i386 </filename> "
"diretÛrio, existem subdiretÛrios para diferentes padrÌµes de inicializaÁ„o, como "
"<filename> mbr </filename> (Master Boot Record), <filename> gpt </filename> (Tabela "
"de PartiÁ„o <acronym>GUID</acronym> ) e <filename> efi </filename> (Interface de "
"Firmware ExtensÌ≠vel). Cada padr„o de inicializaÁ„o possui suas prÛprias convenÁÌµes "
"e estruturas de dados. O exemplo a seguir mostra a inicializaÁ„o de um computador "
"x86 de um disco rÌ≠gido <acronym>MBR</acronym> com o FreeBSD <filename> boot0 </"
"filename> carregador multi-boot armazenado no primeiro setor. Esse cÛdigo de "
"inicializaÁ„o inicia o processo de inicializaÁ„o de trÍs est·gios do FreeBSD. "

#: book.translate.xml:331
#, fuzzy
msgid ""
"The key to understanding this process is that it is a series of stages of increasing "
"complexity. These stages are <filename>boot1</filename>, <filename>boot2</filename>, "
"and <filename>loader</filename> (see <citerefentry><refentrytitle>boot</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> for more detail). The boot "
"system executes each stage in sequence. The last stage, <filename>loader</filename>, "
"is responsible for loading the FreeBSD kernel. Each stage is examined in the "
"following sections."
msgstr ""
"A chave para entender esse processo È que ele È uma sÈrie de est·gios de crescente "
"complexidade. Esses est·gios s„o <filename> boot1 </filename> , <filename> boot2 </"
"filename> e <filename> carregador </filename> (Vejo <citerefentry><refentrytitle> "
"bota </refentrytitle><manvolnum> 8 </manvolnum></citerefentry> para mais detalhes). "
"O sistema de inicializaÁ„o executa cada est·gio em seqÌºÍncia. O ˙ltimo est·gio "
"<filename> carregador </filename> , È respons·vel por carregar o kernel do FreeBSD. "
"Cada est·gio È examinado nas seÁÌµes seguintes. "

#: book.translate.xml:340
#, fuzzy
msgid ""
"Here is an example of the output generated by the different boot stages. Actual "
"output may differ from machine to machine:"
msgstr ""
"Aqui est· um exemplo da saÌ≠da gerada pelos diferentes est·gios de inicializaÁ„o. A "
"saÌ≠da real pode diferir de m·quina para m·quina:"

#: book.translate.xml:348
#, fuzzy
msgid "FreeBSD Component"
msgstr "Componente do FreeBSD"

#: book.translate.xml:349
#, fuzzy
msgid "Output (may vary)"
msgstr "SaÌ≠da (pode variar)"

#: book.translate.xml:353
#, fuzzy
msgid "<literal>boot0</literal>"
msgstr " <literal> boot0 </literal> "

msgid "\""
msgstr ""

#: book.translate.xml:361
#, fuzzy
msgid ""
"This prompt will appear if the user presses a key just after selecting an OS to boot "
"at the <literal>boot0</literal> stage."
msgstr ""
"Este aviso aparecer· se o usu·rio pressionar uma tecla logo apÛs selecionar um SO "
"para inicializar no <literal> boot0 </literal> etapa."

#: book.translate.xml:360
#, fuzzy
msgid "<literal>boot2</literal> <_:footnote-1/>"
msgstr " <literal> boot2 </literal> <_: nota de rodapÈ-1 /> "

#: book.translate.xml:371
#, fuzzy
msgid "<filename>loader</filename>"
msgstr " <filename> carregador </filename> "

#: book.translate.xml:385
#, fuzzy
msgid "kernel"
msgstr "n˙cleo"

#: book.translate.xml:400
#, fuzzy
msgid "The <acronym>BIOS</acronym>"
msgstr "O <acronym>BIOS</acronym> "

#: book.translate.xml:402
#, fuzzy
msgid ""
"When the computer powers on, the processor's registers are set to some predefined "
"values. One of the registers is the <emphasis>instruction pointer</emphasis> "
"register, and its value after a power on is well defined: it is a 32-bit value of "
"<literal>0xfffffff0</literal>. The instruction pointer register (also known as the "
"Program Counter) points to code to be executed by the processor. Another important "
"register is the <literal>cr0</literal> 32-bit control register, and its value just "
"after a reboot is <literal>0</literal>. One of <literal>cr0</literal>'s bits, the PE "
"(Protection Enabled) bit, indicates whether the processor is running in 32-bit "
"protected mode or 16-bit real mode. Since this bit is cleared at boot time, the "
"processor boots in 16-bit real mode. Real mode means, among other things, that "
"linear and physical addresses are identical. The reason for the processor not to "
"start immediately in 32-bit protected mode is backwards compatibility. In "
"particular, the boot process relies on the services provided by the <acronym>BIOS</"
"acronym>, and the <acronym>BIOS</acronym> itself works in legacy, 16-bit code."
msgstr ""
"Quando o computador liga, os registros do processador s„o ajustados para alguns "
"valores prÈ-definidos. Um dos registradores È o <emphasis> ponteiro de instruÁ„o </"
"emphasis> registrar, e seu valor apÛs um power on È bem definido: È um valor de 32 "
"bits de <literal> 0xfffffff0 </literal> . O registrador de ponteiro de instruÁ„o "
"(tambÈm conhecido como Contador de Programa) aponta para o cÛdigo a ser executado "
"pelo processador. Outro registro importante È o <literal> cr0 </literal> Registro de "
"controle de 32 bits, e seu valor logo apÛs a reinicializaÁ„o È <literal> 0 </"
"literal> . Um de <literal> cr0 </literal> ';s bits, o bit PE (Protection Enabled), "
"indica se o processador est· sendo executado no modo protegido de 32 bits ou no modo "
"real de 16 bits. Como esse bit È limpo no momento da inicializaÁ„o, o processador È "
"inicializado no modo real de 16 bits. O modo real significa, entre outras coisas, "
"que os endereÁos linear e fÌ≠sico s„o idÍnticos. O motivo para o processador n„o "
"iniciar imediatamente no modo protegido de 32 bits È compatÌ≠vel com versÌµes "
"anteriores. Em particular, o processo de inicializaÁ„o depende dos serviÁos "
"fornecidos pelo <acronym>BIOS</acronym> , e o prÛprio <acronym>BIOS</acronym> "
"funciona em cÛdigo legado de 16 bits. "

#: book.translate.xml:422
#, fuzzy
msgid ""
"The value of <literal>0xfffffff0</literal> is slightly less than 4¬†GB, so unless "
"the machine has 4¬†GB of physical memory, it cannot point to a valid memory address. "
"The computer's hardware translates this address so that it points to a "
"<acronym>BIOS</acronym> memory block."
msgstr ""
"O valor de <literal> 0xfffffff0 </literal> È um pouco menor que 4 GB, portanto, a "
"menos que a m·quina tenha 4 GB de memÛria fÌ≠sica, ela n„o pode apontar para um "
"endereÁo de memÛria v·lido. O hardware do computador traduz esse endereÁo para que "
"ele aponte para um bloco de memÛria da <acronym>BIOS</acronym> . "

#: book.translate.xml:428
#, fuzzy
msgid ""
"The <acronym>BIOS</acronym> (Basic Input Output System) is a chip on the motherboard "
"that has a relatively small amount of read-only memory (<acronym>ROM</acronym>). "
"This memory contains various low-level routines that are specific to the hardware "
"supplied with the motherboard. The processor will first jump to the address "
"0xfffffff0, which really resides in the <acronym>BIOS</acronym>'s memory. Usually "
"this address contains a jump instruction to the <acronym>BIOS</acronym>'s POST "
"routines."
msgstr ""
"O <acronym>BIOS</acronym> (Basic Input Output System) È um chip da placa-m„e que tem "
"uma quantidade relativamente pequena de memÛria somente leitura ( <acronym>ROM</"
"acronym> ). Essa memÛria contÈm v·rias rotinas de baixo nÌ≠vel que s„o especÌ≠ficas "
"para o hardware fornecido com a placa-m„e. O processador ir· primeiro saltar para o "
"endereÁo 0xfffffff0, que realmente reside na memÛria do <acronym>BIOS</acronym> . "
"Normalmente, este endereÁo contÈm uma instruÁ„o de salto para as rotinas de POST do "
"<acronym>BIOS</acronym> . "

#: book.translate.xml:438
#, fuzzy
msgid ""
"The <acronym>POST</acronym> (Power On Self Test) is a set of routines including the "
"memory check, system bus check, and other low-level initialization so the "
"<acronym>CPU</acronym> can set up the computer properly. The important step of this "
"stage is determining the boot device. Modern <acronym>BIOS</acronym> implementations "
"permit the selection of a boot device, allowing booting from a floppy, <acronym>CD-"
"ROM</acronym>, hard disk, or other devices."
msgstr ""
"O <acronym>POST</acronym> (Power On Self Test) È um conjunto de rotinas incluindo a "
"verificaÁ„o de memÛria, verificaÁ„o do barramento do sistema e outras "
"inicializaÁÌµes de baixo nÌ≠vel para que a <acronym>CPU</acronym> possa configurar o "
"computador corretamente. A etapa importante deste est·gio È determinar o dispositivo "
"de inicializaÁ„o. As implementaÁÌµes modernas do <acronym>BIOS</acronym> permitem a "
"seleÁ„o de um dispositivo de inicializaÁ„o, permitindo a inicializaÁ„o a partir de "
"um disquete, <acronym>CD-ROM</acronym> , disco rÌ≠gido ou outros dispositivos. "

#: book.translate.xml:447
#, fuzzy
msgid ""
"The very last thing in the <acronym>POST</acronym> is the <literal>INT 0x19</"
"literal> instruction. The <literal>INT 0x19</literal> handler reads 512 bytes from "
"the first sector of boot device into the memory at address <literal>0x7c00</"
"literal>. The term <emphasis>first sector</emphasis> originates from hard drive "
"architecture, where the magnetic plate is divided into a number of cylindrical "
"tracks. Tracks are numbered, and every track is divided into a number (usually 64) "
"of sectors. Track numbers start at 0, but sector numbers start from 1. Track 0 is "
"the outermost on the magnetic plate, and sector 1, the first sector, has a special "
"purpose. It is also called the <acronym>MBR</acronym>, or Master Boot Record. The "
"remaining sectors on the first track are never used."
msgstr ""
"A ˙ltima coisa no <acronym>POST</acronym> È a <literal> INT 0x19 </literal> "
"instruÁ„o. o <literal> INT 0x19 </literal> manipulador lÍ 512 bytes do primeiro "
"setor do dispositivo de inicializaÁ„o para a memÛria no endereÁo <literal> 0x7c00 </"
"literal> . O termo <emphasis> primeiro setor </emphasis> origina-se da arquitetura "
"do disco rÌ≠gido, onde a placa magnÈtica È dividida em v·rios trilhos cilÌ≠ndricos. As "
"faixas s„o numeradas e todas as faixas s„o divididas em um n˙mero (geralmente 64) de "
"setores. Os n˙meros das faixas comeÁam em 0, mas os n˙meros setoriais comeÁam em 1. "
"A faixa 0 È a mais externa na placa magnÈtica, e o setor 1, o primeiro setor, tem "
"uma finalidade especial. TambÈm È chamado de <acronym>MBR</acronym> ou Master Boot "
"Record. Os setores restantes na primeira faixa nunca s„o usados ‚Äã‚Äã\""

#: book.translate.xml:462
#, fuzzy
msgid ""
"This sector is our boot-sequence starting point. As we will see, this sector "
"contains a copy of our <filename>boot0</filename> program. A jump is made by the "
"<acronym>BIOS</acronym> to address <literal>0x7c00</literal> so it starts executing."
msgstr ""
"Este setor È o nosso ponto de partida da seqÌºÍncia de inicializaÁ„o. Como veremos, "
"este setor contÈm uma cÛpia do nosso <filename> boot0 </filename> programa. Um salto "
"È feito pelo <acronym>BIOS</acronym> para endereÁar <literal> 0x7c00 </literal> "
"ent„o comeÁa a execuÁ„o. "

#: book.translate.xml:470
#, fuzzy
msgid "The Master Boot Record (<literal>boot0</literal>)"
msgstr "O registro mestre de inicializaÁ„o ( <literal> boot0 </literal> ) "

#: book.translate.xml:472
#, fuzzy
msgid "<primary>MBR</primary>"
msgstr " <primary> MBR </primary> "

#: book.translate.xml:474
#, fuzzy
msgid ""
"After control is received from the <acronym>BIOS</acronym> at memory address "
"<literal>0x7c00</literal>, <filename>boot0</filename> starts executing. It is the "
"first piece of code under FreeBSD control. The task of <filename>boot0</filename> is "
"quite simple: scan the partition table and let the user choose which partition to "
"boot from. The Partition Table is a special, standard data structure embedded in the "
"<acronym>MBR</acronym> (hence embedded in <filename>boot0</filename>) describing the "
"four standard PC <quote>partitions</quote> <_:footnote-1/>. <filename>boot0</"
"filename> resides in the filesystem as <filename>/boot/boot0</filename>. It is a "
"small 512-byte file, and it is exactly what FreeBSD's installation procedure wrote "
"to the hard disk's <acronym>MBR</acronym> if you chose the <quote>bootmanager</"
"quote> option at installation time. Indeed, <filename>boot0</filename> <emphasis>is</"
"emphasis> the <acronym>MBR</acronym>."
msgstr ""
"Depois que o controle È recebido do <acronym>BIOS</acronym> no endereÁo de memÛria "
"<literal> 0x7c00 </literal> , <filename> boot0 </filename> comeÁa a executar. Ìâ o "
"primeiro pedaÁo de cÛdigo sob controle do FreeBSD. A tarefa de <filename> boot0 </"
"filename> È bastante simples: escaneie a tabela de partiÁÌµes e deixe o usu·rio "
"escolher de qual partiÁ„o inicializar. A Tabela de PartiÁ„o È uma estrutura de dados "
"padr„o especial incorporada no <acronym>MBR</acronym> (portanto, <filename> boot0 </"
"filename> ) descrevendo o quatro PC padr„o <quote> partiÁÌµes </quote> <_: nota de "
"rodapÈ 1 />. <filename> boot0 </filename> reside no sistema de arquivos como "
"<filename> / boot / boot0 </filename> . Ìâ um pequeno arquivo de 512 bytes, e È "
"exatamente o que o procedimento de instalaÁ„o do FreeBSD escreveu para o "
"<acronym>MBR</acronym> do disco rÌ≠gido se vocÍ escolheu <quote> bootmanager </quote> "
"opÁ„o no momento da instalaÁ„o. De fato, <filename> boot0 </filename><emphasis> È </"
"emphasis> o <acronym>MBR</acronym> \""

#: book.translate.xml:494
#, fuzzy
msgid ""
"As mentioned previously, the <literal>INT 0x19</literal> instruction causes the "
"<literal>INT 0x19</literal> handler to load an <acronym>MBR</acronym> "
"(<filename>boot0</filename>) into memory at address <literal>0x7c00</literal>. The "
"source file for <filename>boot0</filename> can be found in <filename>sys/boot/i386/"
"boot0/boot0.S</filename> - which is an awesome piece of code written by Robert "
"Nordier."
msgstr ""
"Como mencionado anteriormente, o <literal> INT 0x19 </literal> instruÁ„o faz com que "
"o <literal> INT 0x19 </literal> manipulador para carregar um <acronym>MBR</acronym> "
"( <filename> boot0 </filename> ) na memÛria no endereÁo <literal> 0x7c00 </"
"literal> . O arquivo de origem para <filename> boot0 </filename> pode ser encontrado "
"em <filename> sys / boot / i386 / boot0 / boot0.S </filename> - que È um pedaÁo incrÌ≠"
"vel de cÛdigo escrito por Robert Nordier \""

#: book.translate.xml:502
#, fuzzy
msgid ""
"A special structure starting from offset <literal>0x1be</literal> in the "
"<acronym>MBR</acronym> is called the <emphasis>partition table</emphasis>. It has "
"four records of 16 bytes each, called <emphasis>partition records</emphasis>, which "
"represent how the hard disk is partitioned, or, in FreeBSD's terminology, sliced. "
"One byte of those 16 says whether a partition (slice) is bootable or not. Exactly "
"one record must have that flag set, otherwise <filename>boot0</filename>'s code will "
"refuse to proceed."
msgstr ""
"Uma estrutura especial a partir de offset <literal> 0x1be </literal> no "
"<acronym>MBR</acronym> È chamado o <emphasis> tabela de partiÁÌµes </emphasis> . Tem "
"quatro registros de 16 bytes cada, chamados <emphasis> registros de partiÁÌµes </"
"emphasis> , que representam como o disco rÌ≠gido È particionado, ou, na terminologia "
"do FreeBSD, fatiado. Um byte desses 16 diz se uma partiÁ„o (fatia) È inicializ·vel "
"ou n„o. Exatamente um registro deve ter esse sinalizador definido, caso contr·rio "
"<filename> boot0 </filename> O cÛdigo da empresa se recusar· a prosseguir. "

#: book.translate.xml:512
#, fuzzy
msgid "A partition record has the following fields:"
msgstr "Um registro de partiÁ„o possui os seguintes campos:"

#: book.translate.xml:516
#, fuzzy
msgid "the 1-byte filesystem type"
msgstr "o tipo de sistema de arquivos de 1 byte"

#: book.translate.xml:520
#, fuzzy
msgid "the 1-byte bootable flag"
msgstr "o sinalizador de inicializaÁ„o de 1 byte"

#: book.translate.xml:524
#, fuzzy
msgid "the 6 byte descriptor in CHS format"
msgstr "o descritor de 6 bytes no formato CHS"

#: book.translate.xml:528
#, fuzzy
msgid "the 8 byte descriptor in LBA format"
msgstr "o descritor de 8 bytes no formato do LBA"

#: book.translate.xml:532
#, fuzzy
msgid ""
"A partition record descriptor contains information about where exactly the partition "
"resides on the drive. Both descriptors, <acronym>LBA</acronym> and <acronym>CHS</"
"acronym>, describe the same information, but in different ways: <acronym>LBA</"
"acronym> (Logical Block Addressing) has the starting sector for the partition and "
"the partition's length, while <acronym>CHS</acronym> (Cylinder Head Sector) has "
"coordinates for the first and last sectors of the partition. The partition table "
"ends with the special signature <literal>0xaa55</literal>."
msgstr ""
"Um descritor de registro de partiÁ„o contÈm informaÁÌµes sobre onde exatamente a "
"partiÁ„o reside na unidade. Ambos os descritores, <acronym>LBA</acronym> e "
"<acronym>CHS</acronym> , descrevem as mesmas informaÁÌµes, mas de maneiras "
"diferentes: <acronym>LBA</acronym> (Logical Block Addressing) tem o setor inicial da "
"partiÁ„o e da partiÁ„o. comprimento, enquanto <acronym>CHS</acronym> (Cylinder Head "
"Sector) tem coordenadas para o primeiro e ˙ltimo setores da partiÁ„o.A tabela de "
"partiÁ„o termina com a assinatura especial <literal> 0xaa55 </literal> "

#: book.translate.xml:543
#, fuzzy
msgid ""
"The <acronym>MBR</acronym> must fit into 512 bytes, a single disk sector. This "
"program uses low-level <quote>tricks</quote> like taking advantage of the side "
"effects of certain instructions and reusing register values from previous operations "
"to make the most out of the fewest possible instructions. Care must also be taken "
"when handling the partition table, which is embedded in the <acronym>MBR</acronym> "
"itself. For these reasons, be very careful when modifying <filename>boot0.S</"
"filename>."
msgstr ""
"O <acronym>MBR</acronym> deve caber em 512 bytes, um ˙nico setor de disco. Este "
"programa usa baixo nÌ≠vel <quote> truques </quote> como aproveitar os efeitos "
"colaterais de certas instruÁÌµes e reutilizar valores de registro de operaÁÌµes "
"anteriores para obter o m·ximo das instruÁÌµes possÌ≠veis. Cuidado tambÈm deve ser "
"tomado ao manusear a tabela de partiÁÌµes, que est· embutida no prÛprio "
"<acronym>MBR</acronym> . Por estas razÌµes, tenha muito cuidado ao modificar "
"<filename> boot0.S </filename> "

#: book.translate.xml:553
#, fuzzy
msgid ""
"Note that the <filename>boot0.S</filename> source file is assembled <quote>as is</"
"quote>: instructions are translated one by one to binary, with no additional "
"information (no <acronym>ELF</acronym> file format, for example). This kind of low-"
"level control is achieved at link time through special control flags passed to the "
"linker. For example, the text section of the program is set to be located at address "
"<literal>0x600</literal>. In practice this means that <filename>boot0</filename> "
"must be loaded to memory address <literal>0x600</literal> in order to function "
"properly."
msgstr ""
"Note que o <filename> boot0.S </filename> arquivo de origem È montado <quote> como È "
"</quote> : instruÁÌµes s„o traduzidas uma a uma para bin·rio, sem informaÁÌµes "
"adicionais (sem formato de arquivo <acronym>ELF</acronym> , por exemplo). Esse tipo "
"de controle de baixo nÌ≠vel È obtido no momento do link por meio de sinalizadores de "
"controle especiais passados ‚Äã‚Äãpara o vinculador. Por exemplo, a seÁ„o de texto do "
"programa est· configurada para estar localizada no endereÁo <literal> 0x600 </"
"literal> . Na pr·tica, isso significa que <filename> boot0 </filename> deve ser "
"carregado no endereÁo de memÛria <literal> 0x600 </literal> para funcionar "
"corretamente. "

#: book.translate.xml:564
#, fuzzy
msgid ""
"It is worth looking at the <filename>Makefile</filename> for <filename>boot0</"
"filename> (<filename>sys/boot/i386/boot0/Makefile</filename>), as it defines some of "
"the run-time behavior of <filename>boot0</filename>. For instance, if a terminal "
"connected to the serial port (COM1) is used for I/O, the macro <literal>SIO</"
"literal> must be defined (<literal>-DSIO</literal>). <literal>-DPXE</literal> "
"enables boot through <acronym>PXE</acronym> by pressing <keycap>F6</keycap>. "
"Additionally, the program defines a set of <emphasis>flags</emphasis> that allow "
"further modification of its behavior. All of this is illustrated in the "
"<filename>Makefile</filename>. For example, look at the linker directives which "
"command the linker to start the text section at address <literal>0x600</literal>, "
"and to build the output file <quote>as is</quote> (strip out any file formatting):"
msgstr ""
"Vale a pena olhar para o <filename> Makefile </filename> para <filename> boot0 </"
"filename> ( <filename> sys / boot / i386 / boot0 / Makefile </filename> ), uma vez "
"que define um pouco do comportamento em tempo de execuÁ„o de <filename> boot0 </"
"filename> . Por exemplo, se um terminal conectado Ì† porta serial (COM1) for usado "
"para E / S, a macro <literal> SIO </literal> deve ser definido ( <literal> -DSIO </"
"literal> ). <literal> -DPXE </literal> permite inicializar atravÈs do <acronym>PXE</"
"acronym> pressionando <keycap> F6 </keycap> . AlÈm disso, o programa define um "
"conjunto de <emphasis> bandeiras </emphasis> que permitem modificaÁÌµes adicionais "
"de seu comportamento. Tudo isso È ilustrado no <filename> Makefile </filename> . Por "
"exemplo, observe as diretivas do vinculador que comandam o vinculador para iniciar a "
"seÁ„o de texto no endereÁo <literal> 0x600 </literal> e para construir o arquivo de "
"saÌ≠da <quote> como È </quote> (tira qualquer formataÁ„o de arquivo): "

#: book.translate.xml:583
#, fuzzy
msgid "<filename>sys/boot/i386/boot0/Makefile</filename>"
msgstr " <filename> sys / boot / i386 / boot0 / Makefile </filename> "

#: book.translate.xml:590
#, fuzzy
msgid ""
"Let us now start our study of the <acronym>MBR</acronym>, or <filename>boot0</"
"filename>, starting where execution begins."
msgstr ""
"Vamos comeÁar agora nosso estudo do <acronym>MBR</acronym> , ou <filename> boot0 </"
"filename> , comeÁando onde a execuÁ„o comeÁa. "

#: book.translate.xml:595
#, fuzzy
msgid ""
"Some modifications have been made to some instructions in favor of better "
"exposition. For example, some macros are expanded, and some macro tests are omitted "
"when the result of the test is known. This applies to all of the code examples shown."
msgstr ""
"Algumas modificaÁÌµes foram feitas em algumas instruÁÌµes em favor de uma melhor "
"exposiÁ„o. Por exemplo, algumas macros s„o expandidas e alguns testes de macro s„o "
"omitidos quando o resultado do teste È conhecido. Isso se aplica a todos os exemplos "
"de cÛdigo mostrados."

#: book.translate.xml:907 book.translate.xml:837 book.translate.xml:819
#: book.translate.xml:800 book.translate.xml:756 book.translate.xml:728
#: book.translate.xml:698 book.translate.xml:631 book.translate.xml:603
#, fuzzy
msgid "<filename>sys/boot/i386/boot0/boot0.S</filename>"
msgstr " <filename> sys / boot / i386 / boot0 / boot0.S </filename> "

#: book.translate.xml:619
#, fuzzy
msgid ""
"When in doubt, we refer the reader to the official Intel manuals, which describe the "
"exact semantics for each instruction: <link xlink:href=\"http://www.intel.com/"
"content/www/us/en/processors/architectures-software-developer-manuals.html\"/>."
msgstr ""
"Em caso de d˙vida, encaminhamos o leitor para os manuais oficiais da Intel, que "
"descrevem a semÌ¢ntica exata de cada instruÁ„o: <link xlink:href=\"http://www.intel."
"com/content/www/us/en/processors/architectures-software-developer-manuals.html\"/> "

#: book.translate.xml:614
#, fuzzy
msgid ""
"This first block of code is the entry point of the program. It is where the "
"<acronym>BIOS</acronym> transfers control. First, it makes sure that the string "
"operations autoincrement its pointer operands (the <literal>cld</literal> "
"instruction) <_:footnote-1/>. Then, as it makes no assumption about the state of the "
"segment registers, it initializes them. Finally, it sets the stack pointer register "
"(<literal>%sp</literal>) to address <literal>0x7c00</literal>, so we have a working "
"stack."
msgstr ""
"Este primeiro bloco de cÛdigo È o ponto de entrada do programa. Ìâ onde o "
"<acronym>BIOS</acronym> transfere o controle. Primeiro, ele garante que as "
"operaÁÌµes de string autoincrementem seus operandos de ponteiro (o <literal> cld </"
"literal> instruÁ„o) <_: nota de rodapÈ-1 />. Ent„o, como n„o faz nenhuma suposiÁ„o "
"sobre o estado dos registradores de segmento, ele os inicializa. Finalmente, define "
"o registrador de ponteiro da pilha ( <literal> % sp </literal> ) endereÁar <literal> "
"0x7c00 </literal> , ent„o temos uma pilha de trabalho \""

#: book.translate.xml:627
#, fuzzy
msgid ""
"The next block is responsible for the relocation and subsequent jump to the "
"relocated code."
msgstr ""
"O prÛximo bloco È respons·vel pela realocaÁ„o e posterior salto para o cÛdigo "
"realocado."

#: book.translate.xml:646
#, fuzzy
msgid ""
"Because <filename>boot0</filename> is loaded by the <acronym>BIOS</acronym> to "
"address <literal>0x7C00</literal>, it copies itself to address <literal>0x600</"
"literal> and then transfers control there (recall that it was linked to execute at "
"address <literal>0x600</literal>). The source address, <literal>0x7c00</literal>, is "
"copied to register <literal>%si</literal>. The destination address, <literal>0x600</"
"literal>, to register <literal>%di</literal>. The number of bytes to copy, "
"<literal>512</literal> (the program's size), is copied to register <literal>%cx</"
"literal>. Next, the <literal>rep</literal> instruction repeats the instruction that "
"follows, that is, <literal>movsb</literal>, the number of times dictated by the "
"<literal>%cx</literal> register. The <literal>movsb</literal> instruction copies the "
"byte pointed to by <literal>%si</literal> to the address pointed to by <literal>%di</"
"literal>. This is repeated another 511 times. On each repetition, both the source "
"and destination registers, <literal>%si</literal> and <literal>%di</literal>, are "
"incremented by one. Thus, upon completion of the 512-byte copy, <literal>%di</"
"literal> has the value <literal>0x600</literal>+<literal>512</literal>= "
"<literal>0x800</literal>, and <literal>%si</literal> has the value <literal>0x7c00</"
"literal>+<literal>512</literal>= <literal>0x7e00</literal>; we have thus completed "
"the code <emphasis>relocation</emphasis>."
msgstr ""
"Porque <filename> boot0 </filename> È carregado pelo <acronym>BIOS</acronym> para "
"endereÁar <literal> 0x7C00 </literal> , copia-se para endereÁar <literal> 0x600 </"
"literal> e depois transfere o controle para l· (lembre-se de que estava ligado para "
"executar no endereÁo <literal> 0x600 </literal> ). O endereÁo de origem, <literal> "
"0x7c00 </literal> , È copiado para se registrar <literal> %si </literal> . O "
"endereÁo de destino, <literal> 0x600 </literal> , registrar <literal> % di </"
"literal> . O n˙mero de bytes para copiar, <literal> 512 </literal> (tamanho do "
"programa), È copiado para registrar <literal> % cx </literal> . Em seguida, o "
"<literal> representante </literal> instruÁ„o repete a instruÁ„o que se segue, isto "
"È, <literal> movsb </literal> , o n˙mero de vezes ditado pelo <literal> % cx </"
"literal> registo. o <literal> movsb </literal> instruÁ„o copia o byte apontado por "
"<literal> %si </literal> para o endereÁo apontado por <literal> % di </literal> . "
"Isso È repetido mais 511 vezes. Em cada repetiÁ„o, os registros de origem e destino, "
"<literal> %si </literal> e <literal> % di </literal> , s„o incrementados por um. "
"Assim, apÛs a conclus„o da cÛpia de 512 bytes, <literal> % di </literal> tem o valor "
"<literal> 0x600 </literal> + <literal> 512 </literal> = <literal> 0x800 </literal> e "
"<literal> %si </literal> tem o valor <literal> 0x7c00 </literal> + <literal> 512 </"
"literal> = <literal> 0x7e00 </literal> ; assim, completamos o cÛdigo <emphasis> "
"relocaÁ„o </emphasis> "

#: book.translate.xml:672
#, fuzzy
msgid ""
"Next, the destination register <literal>%di</literal> is copied to <literal>%bp</"
"literal>. <literal>%bp</literal> gets the value <literal>0x800</literal>. The value "
"<literal>16</literal> is copied to <literal>%cl</literal> in preparation for a new "
"string operation (like our previous <literal>movsb</literal>). Now, <literal>stosb</"
"literal> is executed 16 times. This instruction copies a <literal>0</literal> value "
"to the address pointed to by the destination register (<literal>%di</literal>, which "
"is <literal>0x800</literal>), and increments it. This is repeated another 15 times, "
"so <literal>%di</literal> ends up with value <literal>0x810</literal>. Effectively, "
"this clears the address range <literal>0x800</literal>-<literal>0x80f</literal>. "
"This range is used as a (fake) partition table for writing the <acronym>MBR</"
"acronym> back to disk. Finally, the sector field for the <acronym>CHS</acronym> "
"addressing of this fake partition is given the value 1 and a jump is made to the "
"main function from the relocated code. Note that until this jump to the relocated "
"code, any reference to an absolute address was avoided."
msgstr ""
"Em seguida, o registro de destino <literal> % di </literal> È copiado para <literal> "
"% pb </literal> . <literal> % pb </literal> ObtÈm o valor <literal> 0x800 </"
"literal> . O valor que <literal> 16 </literal> È copiado para <literal> % cl </"
"literal> em preparaÁ„o para uma nova operaÁ„o de string (como a nossa anterior "
"<literal> movsb </literal> ). Agora, <literal> stosb </literal> È executado 16 "
"vezes. Esta instruÁ„o copia um <literal> 0 </literal> valor para o endereÁo indicado "
"pelo registo de destino ( <literal> % di </literal> , qual È <literal> 0x800 </"
"literal> ) e incrementa-o. Isso È repetido mais 15 vezes, ent„o <literal> % di </"
"literal> acaba com valor <literal> 0x810 </literal> . Efetivamente, isso limpa o "
"intervalo de endereÁos <literal> 0x800 </literal> - <literal> 0x80f </literal> . "
"Esse intervalo È usado como uma tabela de partiÁÌµes (falsa) para gravar o "
"<acronym>MBR de</acronym> volta no disco. Finalmente, o campo setorial para o "
"endereÁamento <acronym>CHS</acronym> desta partiÁ„o falsa recebe o valor 1 e um "
"salto È feito para a funÁ„o principal a partir do cÛdigo realocado. Note que atÈ "
"este salto para o cÛdigo realocado, qualquer referÍncia a um endereÁo absoluto foi "
"evitada. "

#: book.translate.xml:693
#, fuzzy
msgid ""
"The following code block tests whether the drive number provided by the "
"<acronym>BIOS</acronym> should be used, or the one stored in <filename>boot0</"
"filename>."
msgstr ""
"O bloco de cÛdigo a seguir testa se o n˙mero da unidade fornecido pelo "
"<acronym>BIOS</acronym> deve ser usado ou aquele armazenado <filename> boot0 </"
"filename> "

#: book.translate.xml:707
#, fuzzy
msgid ""
"This code tests the <literal>SETDRV</literal> bit (<literal>0x20</literal>) in the "
"<emphasis>flags</emphasis> variable. Recall that register <literal>%bp</literal> "
"points to address location <literal>0x800</literal>, so the test is done to the "
"<emphasis>flags</emphasis> variable at address <literal>0x800</literal>-<literal>69</"
"literal>= <literal>0x7bb</literal>. This is an example of the type of modifications "
"that can be done to <filename>boot0</filename>. The <literal>SETDRV</literal> flag "
"is not set by default, but it can be set in the <filename>Makefile</filename>. When "
"set, the drive number stored in the <acronym>MBR</acronym> is used instead of the "
"one provided by the <acronym>BIOS</acronym>. We assume the defaults, and that the "
"<acronym>BIOS</acronym> provided a valid drive number, so we jump to "
"<literal>save_curdrive</literal>."
msgstr ""
"Este cÛdigo testa o <literal> SETDRV </literal> pouco ( <literal> 0x20 </literal> ) "
"no <emphasis> bandeiras </emphasis> vari·vel. Lembre-se de que registrar <literal> % "
"pb </literal> aponta para endereÁo local <literal> 0x800 </literal> , ent„o o teste "
"È feito para o <emphasis> bandeiras </emphasis> vari·vel no endereÁo <literal> 0x800 "
"</literal> - <literal> 69 </literal> = <literal> 0x7bb </literal> . Este È um "
"exemplo do tipo de modificaÁÌµes que podem ser feitas para <filename> boot0 </"
"filename> . o <literal> SETDRV </literal> flag n„o È definido por padr„o, mas pode "
"ser definido no <filename> Makefile </filename> . Quando definido, o n˙mero da "
"unidade armazenado no <acronym>MBR</acronym> È usado em vez daquele fornecido pelo "
"<acronym>BIOS</acronym> . NÛs assumimos os padrÌµes, e que o <acronym>BIOS</acronym> "
"forneceu um n˙mero de drive v·lido, ent„o nÛs pulamos para <literal> save_curdrive </"
"literal> "

#: book.translate.xml:723
#, fuzzy
msgid ""
"The next block saves the drive number provided by the <acronym>BIOS</acronym>, and "
"calls <literal>putn</literal> to print a new line on the screen."
msgstr ""
"O prÛximo bloco salva o n˙mero da unidade fornecido pelo <acronym>BIOS</acronym> e "
"as chamadas <literal> putn </literal> para imprimir uma nova linha na tela. "

#: book.translate.xml:741
#, fuzzy
msgid ""
"Note that we assume <varname>TEST</varname> is not defined, so the conditional code "
"in it is not assembled and will not appear in our executable <filename>boot0</"
"filename>."
msgstr ""
"Note que nÛs assumimos <varname> TESTE </varname> n„o est· definido, ent„o o cÛdigo "
"condicional nele n„o È montado e n„o aparecer· em nosso execut·vel <filename> boot0 "
"</filename> "

#: book.translate.xml:745
#, fuzzy
msgid ""
"Our next block implements the actual scanning of the partition table. It prints to "
"the screen the partition type for each of the four entries in the partition table. "
"It compares each type with a list of well-known operating system file systems. "
"Examples of recognized partition types are <acronym>NTFS</acronym> (<trademark class="
"\"registered\">Windows</trademark>, ID 0x7), <literal>ext2fs</literal> (<trademark "
"class=\"registered\">Linux</trademark>, ID 0x83), and, of course, <literal>ffs</"
"literal>/<literal>ufs2</literal> (FreeBSD, ID 0xa5). The implementation is fairly "
"simple."
msgstr ""
"Nosso prÛximo bloco implementa a varredura real da tabela de partiÁÌµes. Ela imprime "
"na tela o tipo de partiÁ„o para cada uma das quatro entradas na tabela de "
"partiÁÌµes. Ele compara cada tipo com uma lista de sistemas de arquivos conhecidos "
"do sistema operacional. Exemplos de tipos de partiÁ„o reconhecidos s„o "
"<acronym>NTFS</acronym> ( <trademark class=\"registered\"> janelas </trademark> , ID "
"0x7), <literal> ext2fs </literal> ( <trademark class=\"registered\"> Linux </"
"trademark> , ID 0x83) e, claro, <literal> ffs </literal> / <literal> ufs2 </literal> "
"(FreeBSD, ID 0xa5). A implementaÁ„o È bastante simples \""

#: book.translate.xml:783
#, fuzzy
msgid ""
"It is important to note that the active flag for each entry is cleared, so after the "
"scanning, <emphasis>no</emphasis> partition entry is active in our memory copy of "
"<filename>boot0</filename>. Later, the active flag will be set for the selected "
"partition. This ensures that only one active partition exists if the user chooses to "
"write the changes back to disk."
msgstr ""
"Ìâ importante observar que o sinalizador ativo de cada entrada È apagado, portanto, "
"apÛs a varredura, <emphasis> n„o </emphasis> entrada de partiÁ„o est· ativa em nossa "
"cÛpia da memÛria de <filename> boot0 </filename> . Mais tarde, o sinalizador ativo "
"ser· definido para a partiÁ„o selecionada. Isso garante que apenas uma partiÁ„o "
"ativa existir· se o usu·rio optar por gravar as alteraÁÌµes novamente no disco. "

#: book.translate.xml:791
#, fuzzy
msgid ""
"The next block tests for other drives. At startup, the <acronym>BIOS</acronym> "
"writes the number of drives present in the computer to address <literal>0x475</"
"literal>. If there are any other drives present, <filename>boot0</filename> prints "
"the current drive to screen. The user may command <filename>boot0</filename> to scan "
"partitions on another drive later."
msgstr ""
"O prÛximo bloco testa as outras unidades. Na inicializaÁ„o, o <acronym>BIOS</"
"acronym> grava o n˙mero de unidades presentes no computador para endereÁar <literal> "
"0x475 </literal> . Se houver outras unidades presentes, <filename> boot0 </filename> "
"imprime a unidade atual na tela. O usu·rio pode comandar <filename> boot0 </"
"filename> para digitalizar partiÁÌµes em outra unidade depois. "

#: book.translate.xml:810
#, fuzzy
msgid ""
"We make the assumption that a single drive is present, so the jump to "
"<literal>print_drive</literal> is not performed. We also assume nothing strange "
"happened, so we jump to <literal>print_prompt</literal>."
msgstr ""
"Supomos que uma ˙nica unidade est· presente, ent„o o salto para <literal> "
"print_drive </literal> n„o È executado. NÛs tambÈm assumimos que nada de estranho "
"aconteceu, ent„o nÛs pulamos para <literal> print_prompt </literal> "

#: book.translate.xml:815
#, fuzzy
msgid "This next block just prints out a prompt followed by the default option:"
msgstr "Este prÛximo bloco apenas imprime um prompt seguido pela opÁ„o padr„o:"

#: book.translate.xml:830
#, fuzzy
msgid ""
"Finally, a jump is performed to <literal>start_input</literal>, where the "
"<acronym>BIOS</acronym> services are used to start a timer and for reading user "
"input from the keyboard; if the timer expires, the default option will be selected:"
msgstr ""
"Finalmente, um salto È realizado para <literal> start_input </literal> , onde os "
"serviÁos da <acronym>BIOS</acronym> s„o usados ‚Äã‚Äãpara iniciar um timer e para ler a "
"entrada do usu·rio pelo teclado; se o temporizador expirar, a opÁ„o padr„o ser· "
"selecionada: "

#: book.translate.xml:854
#, fuzzy
msgid ""
"An interrupt is requested with number <literal>0x1a</literal> and argument "
"<literal>0</literal> in register <literal>%ah</literal>. The <acronym>BIOS</acronym> "
"has a predefined set of services, requested by applications as software-generated "
"interrupts through the <literal>int</literal> instruction and receiving arguments in "
"registers (in this case, <literal>%ah</literal>). Here, particularly, we are "
"requesting the number of clock ticks since last midnight; this value is computed by "
"the <acronym>BIOS</acronym> through the <acronym>RTC</acronym> (Real Time Clock). "
"This clock can be programmed to work at frequencies ranging from 2¬†Hz to 8192¬†Hz. "
"The <acronym>BIOS</acronym> sets it to 18.2¬†Hz at startup. When the request is "
"satisfied, a 32-bit result is returned by the <acronym>BIOS</acronym> in registers "
"<literal>%cx</literal> and <literal>%dx</literal> (lower bytes in <literal>%dx</"
"literal>). This result (the <literal>%dx</literal> part) is copied to register "
"<literal>%di</literal>, and the value of the <varname>TICKS</varname> variable is "
"added to <literal>%di</literal>. This variable resides in <filename>boot0</filename> "
"at offset <literal>_TICKS</literal> (a negative value) from register <literal>%bp</"
"literal> (which, recall, points to <literal>0x800</literal>). The default value of "
"this variable is <literal>0xb6</literal> (182 in decimal). Now, the idea is that "
"<filename>boot0</filename> constantly requests the time from the <acronym>BIOS</"
"acronym>, and when the value returned in register <literal>%dx</literal> is greater "
"than the value stored in <literal>%di</literal>, the time is up and the default "
"selection will be made. Since the RTC ticks 18.2 times per second, this condition "
"will be met after 10 seconds (this default behavior can be changed in the "
"<filename>Makefile</filename>). Until this time has passed, <filename>boot0</"
"filename> continually asks the <acronym>BIOS</acronym> for any user input; this is "
"done through <literal>int 0x16</literal>, argument <literal>1</literal> in <literal>"
"%ah</literal>."
msgstr ""
"Uma interrupÁ„o È solicitada com o n˙mero <literal> 0x1a </literal> e argumento "
"<literal> 0 </literal> no registo <literal> ah% </literal> . O <acronym>BIOS</"
"acronym> possui um conjunto predefinido de serviÁos, solicitados pelos aplicativos "
"como interrupÁÌµes geradas por software <literal> int </literal> instruÁ„o e receber "
"argumentos em registros (neste caso, <literal> ah% </literal> ). Aqui, "
"particularmente, estamos solicitando o n˙mero de pulsos de clock desde a ˙ltima meia-"
"noite; esse valor È calculado pelo <acronym>BIOS</acronym> por meio do <acronym>RTC</"
"acronym> (Real Time Clock). Este relÛgio pode ser programado para funcionar em "
"freqÌºÍncias que variam de 2 Hz a 8192 Hz. O <acronym>BIOS</acronym> define a 18,2 "
"Hz na inicializaÁ„o. Quando a solicitaÁ„o È satisfeita, um resultado de 32 bits È "
"retornado pelo <acronym>BIOS</acronym> em registros <literal> % cx </literal> e "
"<literal> % dx </literal> (bytes inferiores em <literal> % dx </literal> ). Este "
"resultado <literal> % dx </literal> parte) È copiado para registrar <literal> % di </"
"literal> e o valor do <varname> TICOS </varname> vari·vel È adicionada ao <literal> "
"% di </literal> . Esta vari·vel reside em <filename> boot0 </filename> no "
"deslocamento <literal> _TICKS </literal> (um valor negativo) do registro <literal> % "
"pb </literal> (que, lembre-se, aponta para <literal> 0x800 </literal> ). O valor "
"padr„o desta vari·vel È <literal> 0xb6 </literal> (182 em decimal). Agora, a ideia È "
"que <filename> boot0 </filename> constantemente solicita o tempo do <acronym>BIOS</"
"acronym> , e quando o valor retornou no registro <literal> % dx </literal> È maior "
"que o valor armazenado em <literal> % di </literal> , o tempo acabou e a seleÁ„o "
"padr„o ser· feita. Como o RTC È de 18,2 vezes por segundo, essa condiÁ„o ser· "
"atendida apÛs 10 segundos (esse comportamento padr„o pode ser alterado no <filename> "
"Makefile </filename> ). AtÈ esse tempo j· passou <filename> boot0 </filename> "
"continuamente pede ao <acronym>BIOS</acronym> por qualquer entrada do usu·rio; isso "
"È feito atravÈs <literal> int 0x16 </literal> argumento <literal> 1 </literal> "
"dentro <literal> ah% </literal> "

#: book.translate.xml:891
#, fuzzy
msgid ""
"Whether a key was pressed or the time expired, subsequent code validates the "
"selection. Based on the selection, the register <literal>%si</literal> is set to "
"point to the appropriate partition entry in the partition table. This new selection "
"overrides the previous default one. Indeed, it becomes the new default. Finally, the "
"ACTIVE flag of the selected partition is set. If it was enabled at compile time, the "
"in-memory version of <filename>boot0</filename> with these modified values is "
"written back to the <acronym>MBR</acronym> on disk. We leave the details of this "
"implementation to the reader."
msgstr ""
"Se uma tecla foi pressionada ou o tempo expirou, o cÛdigo subsequente valida a "
"seleÁ„o. Com base na seleÁ„o, o registro <literal> %si </literal> est· definido para "
"apontar para a entrada de partiÁ„o apropriada na tabela de partiÁÌµes. Essa nova "
"seleÁ„o substitui a padr„o anterior. De fato, ele se torna o novo padr„o. Por fim, o "
"sinalizador ACTIVE da partiÁ„o selecionada È definido. Se foi habilitado em tempo de "
"compilaÁ„o, a vers„o em memÛria do <filename> boot0 </filename> com esses valores "
"modificados È gravado de volta para o <acronym>MBR</acronym> no disco. Deixamos os "
"detalhes desta implementaÁ„o para o leitor \""

#: book.translate.xml:903
#, fuzzy
msgid ""
"We now end our study with the last code block from the <filename>boot0</filename> "
"program:"
msgstr ""
"Agora terminamos nosso estudo com o ˙ltimo bloco de cÛdigo do <filename> boot0 </"
"filename> programa:"

#: book.translate.xml:921
#, fuzzy
msgid ""
"Recall that <literal>%si</literal> points to the selected partition entry. This "
"entry tells us where the partition begins on disk. We assume, of course, that the "
"partition selected is actually a FreeBSD slice."
msgstr ""
"Lembre-se que <literal> %si </literal> aponta para a entrada de partiÁ„o "
"selecionada. Esta entrada nos diz onde a partiÁ„o comeÁa no disco. NÛs assumimos, È "
"claro, que a partiÁ„o selecionada È na verdade uma fatia do FreeBSD. "

#: book.translate.xml:927
#, fuzzy
msgid ""
"From now on, we will favor the use of the technically more accurate term "
"<quote>slice</quote> rather than <quote>partition</quote>."
msgstr ""
"A partir de agora, favoreceremos o uso do termo tecnicamente mais preciso <quote> "
"fatia </quote> ao invÈs de <quote> partiÁ„o </quote> "

#: book.translate.xml:932
#, fuzzy
msgid ""
"The transfer buffer is set to <literal>0x7c00</literal> (register <literal>%bx</"
"literal>), and a read for the first sector of the FreeBSD slice is requested by "
"calling <literal>intx13</literal>. We assume that everything went okay, so a jump to "
"<literal>beep</literal> is not performed. In particular, the new sector read must "
"end with the magic sequence <literal>0xaa55</literal>. Finally, the value at "
"<literal>%si</literal> (the pointer to the selected partition table) is preserved "
"for use by the next stage, and a jump is performed to address <literal>0x7c00</"
"literal>, where execution of our next stage (the just-read block) is started."
msgstr ""
"O buffer de transferÍncia est· configurado para <literal> 0x7c00 </literal> (registo "
"<literal> % bx </literal> ), e uma leitura para o primeiro setor da fatia FreeBSD È "
"solicitada chamando <literal> intx13 </literal> . NÛs assumimos que tudo correu bem, "
"ent„o um salto para <literal> bip </literal> n„o È executado. Em particular, o novo "
"setor lido deve terminar com a sequÍncia m·gica <literal> 0xaa55 </literal> . "
"Finalmente, o valor em <literal> %si </literal> (o ponteiro para a tabela de "
"partiÁÌµes selecionada) È preservado para uso pelo prÛximo est·gio, e um salto È "
"executado para endereÁar <literal> 0x7c00 </literal> , onde a execuÁ„o do nosso "
"prÛximo est·gio (o bloco de leitura justa) È iniciado. "

#: book.translate.xml:946
#, fuzzy
msgid "<literal>boot1</literal> Stage"
msgstr " <literal> boot1 </literal> Etapa"

#: book.translate.xml:948
#, fuzzy
msgid "So far we have gone through the following sequence:"
msgstr "AtÈ agora nÛs passamos pela seguinte sequÍncia:"

#: book.translate.xml:952
#, fuzzy
msgid ""
"The <acronym>BIOS</acronym> did some early hardware initialization, including the "
"<acronym>POST</acronym>. The <acronym>MBR</acronym> (<filename>boot0</filename>) was "
"loaded from absolute disk sector one to address <literal>0x7c00</literal>. Execution "
"control was passed to that location."
msgstr ""
"O <acronym>BIOS</acronym> fez algumas inicializaÁÌµes de hardware, incluindo o "
"<acronym>POST</acronym> . O <acronym>MBR</acronym> ( <filename> boot0 </filename> ) "
"foi carregado a partir do setor de disco absoluto para endereÁar <literal> 0x7c00 </"
"literal> . O controle de execuÁ„o foi passado para esse local \""

#: book.translate.xml:961
#, fuzzy
msgid ""
"<filename>boot0</filename> relocated itself to the location it was linked to execute "
"(<literal>0x600</literal>), followed by a jump to continue execution at the "
"appropriate place. Finally, <filename>boot0</filename> loaded the first disk sector "
"from the FreeBSD slice to address <literal>0x7c00</literal>. Execution control was "
"passed to that location."
msgstr ""
" <filename> boot0 </filename> mudou-se para o local que estava ligado para executar "
"( <literal> 0x600 </literal> ), seguido por um salto para continuar a execuÁ„o no "
"local apropriado. Finalmente, <filename> boot0 </filename> carregou o primeiro setor "
"de disco da fatia do FreeBSD para endereÁar <literal> 0x7c00 </literal> . O controle "
"de execuÁ„o foi passado para esse local \""

#: book.translate.xml:985
#, fuzzy
msgid ""
"There is a file <filename>/boot/boot1</filename>, but it is not the written to the "
"beginning of the FreeBSD slice. Instead, it is concatenated with <filename>boot2</"
"filename> to form <filename>boot</filename>, which <emphasis>is</emphasis> written "
"to the beginning of the FreeBSD slice and read at boot time."
msgstr ""
"Existe um arquivo <filename> / boot / boot1 </filename> , mas n„o È o escrito para o "
"comeÁo da fatia do FreeBSD. Em vez disso, È concatenado com <filename> boot2 </"
"filename> formar <filename> bota </filename> , qual <emphasis> È </emphasis> escrito "
"para o inÌ≠cio da fatia do FreeBSD e lido no momento da inicializaÁ„o. "

#: book.translate.xml:971
#, fuzzy
msgid ""
"<filename>boot1</filename> is the next step in the boot-loading sequence. It is the "
"first of three boot stages. Note that we have been dealing exclusively with disk "
"sectors. Indeed, the <acronym>BIOS</acronym> loads the absolute first sector, while "
"<filename>boot0</filename> loads the first sector of the FreeBSD slice. Both loads "
"are to address <literal>0x7c00</literal>. We can conceptually think of these disk "
"sectors as containing the files <filename>boot0</filename> and <filename>boot1</"
"filename>, respectively, but in reality this is not entirely true for "
"<filename>boot1</filename>. Strictly speaking, unlike <filename>boot0</filename>, "
"<filename>boot1</filename> is not part of the boot blocks <_:footnote-1/>. Instead, "
"a single, full-blown file, <filename>boot</filename> (<filename>/boot/boot</"
"filename>), is what ultimately is written to disk. This file is a combination of "
"<filename>boot1</filename>, <filename>boot2</filename> and the <literal>Boot "
"Extender</literal> (or <acronym>BTX</acronym>). This single file is greater in size "
"than a single sector (greater than 512 bytes). Fortunately, <filename>boot1</"
"filename> occupies <emphasis>exactly</emphasis> the first 512 bytes of this single "
"file, so when <filename>boot0</filename> loads the first sector of the FreeBSD slice "
"(512 bytes), it is actually loading <filename>boot1</filename> and transferring "
"control to it."
msgstr ""
" <filename> boot1 </filename> È o prÛximo passo na sequÍncia de carregamento de "
"inicializaÁ„o. Ìâ o primeiro de trÍs est·gios de inicializaÁ„o. Observe que estamos "
"lidando exclusivamente com setores de disco. De fato, o <acronym>BIOS</acronym> "
"carrega o primeiro setor absoluto, enquanto <filename> boot0 </filename> carrega o "
"primeiro setor da fatia do FreeBSD. Ambas as cargas s„o para resolver <literal> "
"0x7c00 </literal> . Podemos conceitualmente pensar nesses setores de disco como "
"contendo os arquivos <filename> boot0 </filename> e <filename> boot1 </filename> , "
"respectivamente, mas na realidade isso n„o È inteiramente verdade para <filename> "
"boot1 </filename> . Estritamente falando, diferentemente <filename> boot0 </"
"filename> , <filename> boot1 </filename> n„o faz parte dos blocos de inicializaÁ„o "
"<_: footnote-1 />. Em vez disso, um ˙nico arquivo completo, <filename> bota </"
"filename> ( <filename> / boot / boot </filename> ), È o que finalmente È gravado em "
"disco. Este arquivo È uma combinaÁ„o de <filename> boot1 </filename> , <filename> "
"boot2 </filename> e a <literal> Extensor de InicializaÁ„o </literal> (ou "
"<acronym>BTX</acronym> ). Este arquivo ˙nico È maior em tamanho do que um ˙nico "
"setor (maior que 512 bytes). Felizmente, <filename> boot1 </filename> ocupa "
"<emphasis> exatamente </emphasis> os primeiros 512 bytes deste arquivo ˙nico, ent„o "
"quando <filename> boot0 </filename> carrega o primeiro setor da fatia do FreeBSD "
"(512 bytes), ele est· realmente carregando <filename> boot1 </filename> e "
"transferindo o controle para ele. "

#: book.translate.xml:1005
#, fuzzy
msgid ""
"The main task of <filename>boot1</filename> is to load the next boot stage. This "
"next stage is somewhat more complex. It is composed of a server called the "
"<quote>Boot Extender</quote>, or <acronym>BTX</acronym>, and a client, called "
"<filename>boot2</filename>. As we will see, the last boot stage, <filename>loader</"
"filename>, is also a client of the <acronym>BTX</acronym> server."
msgstr ""
"A principal tarefa de <filename> boot1 </filename> È carregar o prÛximo est·gio de "
"inicializaÁ„o. Este prÛximo est·gio È um pouco mais complexo. Ìâ composto por um "
"servidor chamado <quote> Extensor de InicializaÁ„o </quote> , ou <acronym>BTX</"
"acronym> , e um cliente, chamado <filename> boot2 </filename> . Como veremos, o "
"˙ltimo est·gio de inicializaÁ„o <filename> carregador </filename> È tambÈm um "
"cliente do servidor <acronym>BTX</acronym> . "

#: book.translate.xml:1013
#, fuzzy
msgid ""
"Let us now look in detail at what exactly is done by <filename>boot1</filename>, "
"starting like we did for <filename>boot0</filename>, at its entry point:"
msgstr ""
"Vamos agora olhar em detalhes para o que exatamente È feito por <filename> boot1 </"
"filename> , comeÁando como fizemos para <filename> boot0 </filename> , no seu ponto "
"de entrada: "

#: book.translate.xml:1311 book.translate.xml:1205 book.translate.xml:1176
#: book.translate.xml:1149 book.translate.xml:1114 book.translate.xml:1069
#: book.translate.xml:1029 book.translate.xml:1018
#, fuzzy
msgid "<filename>sys/boot/i386/boot2/boot1.S</filename>"
msgstr " <filename> sys / boot / i386 / boot2 / boot1.S </filename> "

#: book.translate.xml:1024
#, fuzzy
msgid ""
"The entry point at <literal>start</literal> simply jumps past a special data area to "
"the label <literal>main</literal>, which in turn looks like this:"
msgstr ""
"O ponto de entrada em <literal> comeÁar </literal> simplesmente passa por uma ·rea "
"de dados especial para o rÛtulo <literal> a Principal </literal> , que por sua vez "
"se parece com isso: "

#: book.translate.xml:1045
#, fuzzy
msgid ""
"Just like <filename>boot0</filename>, this code relocates <filename>boot1</"
"filename>, this time to memory address <literal>0x700</literal>. However, unlike "
"<filename>boot0</filename>, it does not jump there. <filename>boot1</filename> is "
"linked to execute at address <literal>0x7c00</literal>, effectively where it was "
"loaded in the first place. The reason for this relocation will be discussed shortly."
msgstr ""
"Assim como <filename> boot0 </filename> , este cÛdigo realoca <filename> boot1 </"
"filename> , desta vez para endereÁo de memÛria <literal> 0x700 </literal> . No "
"entanto, ao contr·rio <filename> boot0 </filename> , n„o salta para l·. <filename> "
"boot1 </filename> est· ligado para executar no endereÁo <literal> 0x7c00 </"
"literal> , efetivamente onde foi carregado em primeiro lugar. A raz„o para essa "
"realocaÁ„o ser· discutida em breve. "

#: book.translate.xml:1058
#, fuzzy
msgid ""
"Actually we did pass a pointer to the slice entry in register <literal>%si</"
"literal>. However, <filename>boot1</filename> does not assume that it was loaded by "
"<filename>boot0</filename> (perhaps some other <acronym>MBR</acronym> loaded it, and "
"did not pass this information), so it assumes nothing."
msgstr ""
"Na verdade nÛs passamos um ponteiro para a entrada da fatia no registro <literal> "
"%si </literal> . Contudo, <filename> boot1 </filename> n„o assume que foi carregado "
"por <filename> boot0 </filename> (talvez algum outro <acronym>MBR tenha</acronym> "
"carregado e n„o tenha passado essa informaÁ„o), por isso n„o assume nada. "

#: book.translate.xml:1054
#, fuzzy
msgid ""
"Next comes a loop that looks for the FreeBSD slice. Although <filename>boot0</"
"filename> loaded <filename>boot1</filename> from the FreeBSD slice, no information "
"was passed to it about this <_:footnote-1/>, so <filename>boot1</filename> must "
"rescan the partition table to find where the FreeBSD slice starts. Therefore it "
"rereads the <acronym>MBR</acronym>:"
msgstr ""
"Em seguida vem um loop que procura a fatia do FreeBSD. Embora <filename> boot0 </"
"filename> carregado <filename> boot1 </filename> do slice do FreeBSD, nenhuma "
"informaÁ„o foi passada para ele sobre isso <_: footnote-1 />, ent„o <filename> boot1 "
"</filename> deve varrer novamente a tabela de partiÁÌµes para encontrar onde o slice "
"do FreeBSD È iniciado. Por isso, relÍ o <acronym>MBR</acronym> : "

#: book.translate.xml:1078
#, fuzzy
msgid ""
"In the code above, register <literal>%dl</literal> maintains information about the "
"boot device. This is passed on by the <acronym>BIOS</acronym> and preserved by the "
"<acronym>MBR</acronym>. Numbers <literal>0x80</literal> and greater tells us that we "
"are dealing with a hard drive, so a call is made to <literal>nread</literal>, where "
"the <acronym>MBR</acronym> is read. Arguments to <literal>nread</literal> are passed "
"through <literal>%si</literal> and <literal>%dh</literal>. The memory address at "
"label <literal>part4</literal> is copied to <literal>%si</literal>. This memory "
"address holds a <quote>fake partition</quote> to be used by <literal>nread</"
"literal>. The following is the data in the fake partition:"
msgstr ""
"No cÛdigo acima, registre <literal> % dl </literal> mantÈm informaÁÌµes sobre o "
"dispositivo de inicializaÁ„o. Isso È transmitido pelo <acronym>BIOS</acronym> e "
"preservado pelo <acronym>MBR</acronym> . N˙meros <literal> 0x80 </literal> e maior "
"nos diz que estamos lidando com um disco rÌ≠gido, ent„o uma chamada È feita para "
"<literal> nread </literal> , onde o <acronym>MBR</acronym> È lido. Argumentos para "
"<literal> nread </literal> s„o passados ‚Äã‚Äãpor <literal> %si </literal> e <literal> % "
"dh </literal> . O endereÁo de memÛria na etiqueta <literal> part4 </literal> È "
"copiado para <literal> %si </literal> . Este endereÁo de memÛria contÈm um <quote> "
"partiÁ„o falsa </quote> para ser usado por <literal> nread </literal> . A seguir, os "
"dados da partiÁ„o falsa: "

#: book.translate.xml:1473 book.translate.xml:1432 book.translate.xml:1400
#: book.translate.xml:1387 book.translate.xml:1094
#, fuzzy
msgid "<filename>sys/boot/i386/boot2/Makefile</filename>"
msgstr " <filename> sys / boot / i386 / boot2 / Makefile </filename> "

#: book.translate.xml:1103
#, fuzzy
msgid ""
"In particular, the <acronym>LBA</acronym> for this fake partition is hardcoded to "
"zero. This is used as an argument to the <acronym>BIOS</acronym> for reading "
"absolute sector one from the hard drive. Alternatively, CHS addressing could be "
"used. In this case, the fake partition holds cylinder 0, head 0 and sector 1, which "
"is equivalent to absolute sector one."
msgstr ""
"Em particular, o <acronym>LBA</acronym> para essa partiÁ„o falsa È codificado para "
"zero. Isso È usado como um argumento para o <acronym>BIOS</acronym> para ler o setor "
"absoluto do disco rÌ≠gido. Alternativamente, o endereÁamento CHS pode ser usado. "
"Nesse caso, a partiÁ„o falsa mantÈm cilindro 0, cabeÁa 0 e setor 1, o que equivale "
"ao setor absoluto um. "

#: book.translate.xml:1110
#, fuzzy
msgid "Let us now proceed to take a look at <literal>nread</literal>:"
msgstr "Vamos agora dar uma olhada <literal> nread </literal> : "

#: book.translate.xml:1128
#, fuzzy
msgid "In the context of 16-bit real mode, a word is 2 bytes."
msgstr "No contexto do modo real de 16 bits, uma palavra È de 2 bytes."

#: book.translate.xml:1125
#, fuzzy
msgid ""
"Recall that <literal>%si</literal> points to the fake partition. The word <_:"
"footnote-1/> at offset <literal>0x8</literal> is copied to register <literal>%ax</"
"literal> and word at offset <literal>0xa</literal> to <literal>%cx</literal>. They "
"are interpreted by the <acronym>BIOS</acronym> as the lower 4-byte value denoting "
"the LBA to be read (the upper four bytes are assumed to be zero). Register <literal>"
"%bx</literal> holds the memory address where the <acronym>MBR</acronym> will be "
"loaded. The instruction pushing <literal>%cs</literal> onto the stack is very "
"interesting. In this context, it accomplishes nothing. However, as we will see "
"shortly, <filename>boot2</filename>, in conjunction with the <acronym>BTX</acronym> "
"server, also uses <literal>xread.1</literal>. This mechanism will be discussed in "
"the next section."
msgstr ""
"Lembre-se que <literal> %si </literal> aponta para a partiÁ„o falsa. A palavra <_: "
"footnote-1 /> no deslocamento <literal> 0x8 </literal> È copiado para registrar "
"<literal> %machado </literal> e palavra no deslocamento <literal> 0xa </literal> "
"para <literal> % cx </literal> . Eles s„o interpretados pelo <acronym>BIOS</acronym> "
"como o valor inferior de 4 bytes que indica o LBA a ser lido (os quatro bytes "
"superiores s„o considerados como zero). registo <literal> % bx </literal> mantÈm o "
"endereÁo de memÛria onde o <acronym>MBR</acronym> ser· carregado. A instruÁ„o "
"empurrando <literal> % cs </literal> na pilha È muito interessante. Neste contexto, "
"n„o realiza nada. No entanto, como veremos em breve, <filename> boot2 </filename> , "
"em conjunto com o servidor <acronym>BTX</acronym> , tambÈm usa <literal> xread.1 </"
"literal> . Esse mecanismo ser· discutido na prÛxima seÁ„o. "

#: book.translate.xml:1144
#, fuzzy
msgid ""
"The code at <literal>xread.1</literal> further calls the <literal>read</literal> "
"function, which actually calls the <acronym>BIOS</acronym> asking for the disk "
"sector:"
msgstr ""
"O cÛdigo em <literal> xread.1 </literal> ainda chama o <literal> ler </literal> "
"funÁ„o, que realmente chama o <acronym>BIOS</acronym> pedindo o setor de disco: "

#: book.translate.xml:1167
#, fuzzy
msgid ""
"Note the long return instruction at the end of this block. This instruction pops out "
"the <literal>%cs</literal> register pushed by <literal>nread</literal>, and returns. "
"Finally, <literal>nread</literal> also returns."
msgstr ""
"Observe a instruÁ„o de retorno longo no final deste bloco. Esta instruÁ„o mostra a "
"<literal> % cs </literal> registrar empurrado por <literal> nread </literal> e "
"retorna. Finalmente, <literal> nread </literal> tambÈm retorna. "

#: book.translate.xml:1172
#, fuzzy
msgid ""
"With the <acronym>MBR</acronym> loaded to memory, the actual loop for searching the "
"FreeBSD slice begins:"
msgstr ""
"Com o <acronym>MBR</acronym> carregado na memÛria, o loop real para procurar a fatia "
"do FreeBSD comeÁa:"

#: book.translate.xml:1197
#, fuzzy
msgid ""
"If a FreeBSD slice is identified, execution continues at <literal>main.5</literal>. "
"Note that when a FreeBSD slice is found <literal>%si</literal> points to the "
"appropriate entry in the partition table, and <literal>%dh</literal> holds the "
"partition number. We assume that a FreeBSD slice is found, so we continue execution "
"at <literal>main.5</literal>:"
msgstr ""
"Se uma fatia do FreeBSD for identificada, a execuÁ„o continua em <literal> main.5 </"
"literal> . Note que quando uma fatia do FreeBSD È encontrada <literal> %si </"
"literal> aponta para a entrada apropriada na tabela de partiÁÌµes e <literal> % dh </"
"literal> mantÈm o n˙mero da partiÁ„o. NÛs assumimos que uma fatia do FreeBSD È "
"encontrada, ent„o continuamos a execuÁ„o em <literal> main.5 </literal> : "

#: book.translate.xml:1221
#, fuzzy
msgid ""
"Recall that at this point, register <literal>%si</literal> points to the FreeBSD "
"slice entry in the <acronym>MBR</acronym> partition table, so a call to "
"<literal>nread</literal> will effectively read sectors at the beginning of this "
"partition. The argument passed on register <literal>%dh</literal> tells "
"<literal>nread</literal> to read 16 disk sectors. Recall that the first 512 bytes, "
"or the first sector of the FreeBSD slice, coincides with the <filename>boot1</"
"filename> program. Also recall that the file written to the beginning of the FreeBSD "
"slice is not <filename>/boot/boot1</filename>, but <filename>/boot/boot</filename>. "
"Let us look at the size of these files in the filesystem:"
msgstr ""
"Lembre-se que neste momento, registre <literal> %si </literal> aponta para a entrada "
"de fatia do FreeBSD na <acronym>tabela de</acronym> partiÁ„o <acronym>MBR</"
"acronym> , ent„o uma chamada para <literal> nread </literal> efetivamente ler· "
"setores no inÌ≠cio desta partiÁ„o. O argumento passou no registro <literal> % dh </"
"literal> conta <literal> nread </literal> para ler 16 setores de disco. Lembre-se "
"que os primeiros 512 bytes, ou o primeiro setor da fatia do FreeBSD, coincide com o "
"<filename> boot1 </filename> programa. Lembre-se tambÈm que o arquivo gravado no inÌ≠"
"cio da fatia do FreeBSD n„o È <filename> / boot / boot1 </filename> , mas "
"<filename> / boot / boot </filename> . Vamos ver o tamanho desses arquivos no "
"sistema de arquivos: "

#: book.translate.xml:1239
#, fuzzy
msgid ""
"Both <filename>boot0</filename> and <filename>boot1</filename> are 512 bytes each, "
"so they fit <emphasis>exactly</emphasis> in one disk sector. <filename>boot2</"
"filename> is much bigger, holding both the <acronym>BTX</acronym> server and the "
"<filename>boot2</filename> client. Finally, a file called simply <filename>boot</"
"filename> is 512 bytes larger than <filename>boot2</filename>. This file is a "
"concatenation of <filename>boot1</filename> and <filename>boot2</filename>. As "
"already noted, <filename>boot0</filename> is the file written to the absolute first "
"disk sector (the <acronym>MBR</acronym>), and <filename>boot</filename> is the file "
"written to the first sector of the FreeBSD slice; <filename>boot1</filename> and "
"<filename>boot2</filename> are <emphasis>not</emphasis> written to disk. The command "
"used to concatenate <filename>boot1</filename> and <filename>boot2</filename> into a "
"single <filename>boot</filename> is merely <command>cat boot1 boot2 &gt; boot</"
"command>."
msgstr ""
"Ambos <filename> boot0 </filename> e <filename> boot1 </filename> s„o 512 bytes "
"cada, ent„o eles se encaixam <emphasis> exatamente </emphasis> em um setor de disco. "
"<filename> boot2 </filename> È muito maior, mantendo tanto o servidor <acronym>BTX</"
"acronym> quanto o <filename> boot2 </filename> cliente. Finalmente, um arquivo "
"chamado simplesmente <filename> bota </filename> È 512 bytes maior que <filename> "
"boot2 </filename> . Este arquivo È uma concatenaÁ„o de <filename> boot1 </filename> "
"e <filename> boot2 </filename> . Como j· foi dito, <filename> boot0 </filename> È o "
"arquivo gravado no primeiro setor de disco absoluto (o <acronym>MBR</acronym> ) e "
"<filename> bota </filename> È o arquivo escrito no primeiro setor da fatia do "
"FreeBSD; <filename> boot1 </filename> e <filename> boot2 </filename> estamos "
"<emphasis> n„o </emphasis> escrito em disco. O comando usado para concatenar "
"<filename> boot1 </filename> e <filename> boot2 </filename> em um ˙nico <filename> "
"bota </filename> È meramente <command> gato boot1 boot2&gt; boot </command> "

#: book.translate.xml:1266
#, fuzzy
msgid "512*16=8192 bytes, exactly the size of <filename>boot</filename>"
msgstr "512 * 16 = 8192 bytes, exatamente o tamanho de <filename> bota </filename> "

#: book.translate.xml:1258
#, fuzzy
msgid ""
"So <filename>boot1</filename> occupies exactly the first 512 bytes of "
"<filename>boot</filename> and, because <filename>boot</filename> is written to the "
"first sector of the FreeBSD slice, <filename>boot1</filename> fits exactly in this "
"first sector. Because <literal>nread</literal> reads the first 16 sectors of the "
"FreeBSD slice, it effectively reads the entire <filename>boot</filename> file <_:"
"footnote-1/>. We will see more details about how <filename>boot</filename> is formed "
"from <filename>boot1</filename> and <filename>boot2</filename> in the next section."
msgstr ""
"Assim <filename> boot1 </filename> ocupa exatamente os primeiros 512 bytes de "
"<filename> bota </filename> e porque <filename> bota </filename> È escrito para o "
"primeiro setor da fatia do FreeBSD, <filename> boot1 </filename> cabe exatamente "
"neste primeiro setor. Porque <literal> nread </literal> lÍ os primeiros 16 setores "
"da fatia do FreeBSD, lÍ efetivamente toda a <filename> bota </filename> arquivo<_: "
"nota de rodapÈ-1 />. Vamos ver mais detalhes sobre como <filename> bota </filename> "
"È formado a partir de <filename> boot1 </filename> e <filename> boot2 </filename> na "
"prÛxima seÁ„o. "

#: book.translate.xml:1282
#, fuzzy
msgid ""
"Historically known as <quote>disklabel</quote>. If you ever wondered where FreeBSD "
"stored this information, it is in this region. See "
"<citerefentry><refentrytitle>bsdlabel</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>"
msgstr ""
"Historicamente conhecido como <quote> disklabel </quote> . Se vocÍ j· se perguntou "
"onde o FreeBSD armazenou esta informaÁ„o, est· nesta regi„o. Vejo "
"<citerefentry><refentrytitle> bsdlabel </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> "

#: book.translate.xml:1272
#, fuzzy
msgid ""
"Recall that <literal>nread</literal> uses memory address <literal>0x8c00</literal> "
"as the transfer buffer to hold the sectors read. This address is conveniently "
"chosen. Indeed, because <filename>boot1</filename> belongs to the first 512 bytes, "
"it ends up in the address range <literal>0x8c00</literal>-<literal>0x8dff</literal>. "
"The 512 bytes that follows (range <literal>0x8e00</literal>-<literal>0x8fff</"
"literal>) is used to store the <emphasis>bsdlabel</emphasis> <_:footnote-1/>."
msgstr ""
"Lembre-se que <literal> nread </literal> usa endereÁo de memÛria <literal> 0x8c00 </"
"literal> como o buffer de transferÍncia para manter os setores lidos. Este endereÁo "
"È convenientemente escolhido. De fato, porque <filename> boot1 </filename> pertence "
"aos primeiros 512 bytes, acaba na faixa de endereÁos <literal> 0x8c00 </literal> - "
"<literal> 0x8dff </literal> . Os 512 bytes seguintes (intervalo <literal> 0x8e00 </"
"literal> - <literal> 0x8fff </literal> ) È usado para armazenar <emphasis> bsdlabel "
"</emphasis> <_: nota de rodapÈ-1 />. "

#: book.translate.xml:1286
#, fuzzy
msgid ""
"Starting at address <literal>0x9000</literal> is the beginning of the <acronym>BTX</"
"acronym> server, and immediately following is the <filename>boot2</filename> client. "
"The <acronym>BTX</acronym> server acts as a kernel, and executes in protected mode "
"in the most privileged level. In contrast, the <acronym>BTX</acronym> clients "
"(<filename>boot2</filename>, for example), execute in user mode. We will see how "
"this is accomplished in the next section. The code after the call to <literal>nread</"
"literal> locates the beginning of <filename>boot2</filename> in the memory buffer, "
"and copies it to memory address <literal>0xc000</literal>. This is because the "
"<acronym>BTX</acronym> server arranges <filename>boot2</filename> to execute in a "
"segment starting at <literal>0xa000</literal>. We explore this in detail in the "
"following section."
msgstr ""
"ComeÁando no endereÁo <literal> 0x9000 </literal> È o comeÁo do servidor "
"<acronym>BTX</acronym> , e imediatamente a seguir È <filename> boot2 </filename> "
"cliente. O servidor <acronym>BTX</acronym> atua como um kernel e È executado no modo "
"protegido no nÌ≠vel mais privilegiado. Em contraste, os clientes <acronym>BTX</"
"acronym> ( <filename> boot2 </filename> , por exemplo), executar no modo de usu·rio. "
"Vamos ver como isso È feito na prÛxima seÁ„o. O cÛdigo apÛs a chamada para <literal> "
"nread </literal> localiza o comeÁo de <filename> boot2 </filename> no buffer de "
"memÛria e copia para o endereÁo de memÛria <literal> 0xc000 </literal> . Isso ocorre "
"porque o servidor <acronym>BTX</acronym> organiza <filename> boot2 </filename> para "
"executar em um segmento a partir de <literal> 0xa000 </literal> . NÛs exploramos "
"isso em detalhes na seÁ„o seguinte. "

#: book.translate.xml:1305
#, fuzzy
msgid ""
"This is necessary for legacy reasons. Interested readers should see <link xlink:href="
"\"http://en.wikipedia.org/wiki/A20_line\"/>."
msgstr ""
"Isso È necess·rio por razÌµes de legado. Os leitores interessados ‚Äã‚Äãdevem ver <link "
"xlink:href=\"http://en.wikipedia.org/wiki/A20_line\"/> "

#: book.translate.xml:1302
#, fuzzy
msgid ""
"The last code block of <filename>boot1</filename> enables access to memory above 1MB "
"<_:footnote-1/> and concludes with a jump to the starting point of the <acronym>BTX</"
"acronym> server:"
msgstr ""
"O ˙ltimo bloco de cÛdigo de <filename> boot1 </filename> permite o acesso Ì† memÛria "
"acima de 1MB <_: footnote-1 /> e conclui com um salto para o ponto de partida do "
"servidor <acronym>BTX</acronym> : "

#: book.translate.xml:1335
#, fuzzy
msgid "Note that right before the jump, interrupts are enabled."
msgstr "Note que logo antes do salto, as interrupÁÌµes est„o habilitadas."

#: book.translate.xml:1340
#, fuzzy
msgid "The <acronym>BTX</acronym> Server"
msgstr "O servidor <acronym>BTX</acronym> "

#: book.translate.xml:1342
#, fuzzy
msgid ""
"Next in our boot sequence is the <acronym>BTX</acronym> Server. Let us quickly "
"remember how we got here:"
msgstr ""
"O prÛximo passo na nossa seqÌºÍncia de inicializaÁ„o È o servidor <acronym>BTX</"
"acronym> . Vamos lembrar rapidamente como chegamos aqui:"

#: book.translate.xml:1348
#, fuzzy
msgid ""
"The <acronym>BIOS</acronym> loads the absolute sector one (the <acronym>MBR</"
"acronym>, or <filename>boot0</filename>), to address <literal>0x7c00</literal> and "
"jumps there."
msgstr ""
"O <acronym>BIOS</acronym> carrega o setor absoluto (o <acronym>MBR</acronym> , ou "
"<filename> boot0 </filename> ), endereÁar <literal> 0x7c00 </literal> e pula l·. "

#: book.translate.xml:1355
#, fuzzy
msgid ""
"<filename>boot0</filename> relocates itself to <literal>0x600</literal>, the address "
"it was linked to execute, and jumps over there. It then reads the first sector of "
"the FreeBSD slice (which consists of <filename>boot1</filename>) into address "
"<literal>0x7c00</literal> and jumps over there."
msgstr ""
" <filename> boot0 </filename> se muda para <literal> 0x600 </literal> , o endereÁo "
"que estava ligado para executar e salta para l·. Ele ent„o lÍ o primeiro setor da "
"fatia do FreeBSD (que consiste em <filename> boot1 </filename> ) no endereÁo "
"<literal> 0x7c00 </literal> e pula ali "

#: book.translate.xml:1364
#, fuzzy
msgid ""
"<filename>boot1</filename> loads the first 16 sectors of the FreeBSD slice into "
"address <literal>0x8c00</literal>. This 16 sectors, or 8192 bytes, is the whole file "
"<filename>boot</filename>. The file is a concatenation of <filename>boot1</filename> "
"and <filename>boot2</filename>. <filename>boot2</filename>, in turn, contains the "
"<acronym>BTX</acronym> server and the <filename>boot2</filename> client. Finally, a "
"jump is made to address <literal>0x9010</literal>, the entry point of the "
"<acronym>BTX</acronym> server."
msgstr ""
" <filename> boot1 </filename> carrega os primeiros 16 setores da fatia do FreeBSD no "
"endereÁo <literal> 0x8c00 </literal> . Este 16 setores, ou 8192 bytes, È o arquivo "
"inteiro <filename> bota </filename> . O arquivo È uma concatenaÁ„o de <filename> "
"boot1 </filename> e <filename> boot2 </filename> . <filename> boot2 </filename> , "
"por sua vez, contÈm o servidor <acronym>BTX</acronym> eo <filename> boot2 </"
"filename> cliente. Finalmente, um salto È feito para abordar <literal> 0x9010 </"
"literal> , o ponto de entrada do servidor <acronym>BTX</acronym> . "

#: book.translate.xml:1377
#, fuzzy
msgid ""
"Before studying the <acronym>BTX</acronym> Server in detail, let us further review "
"how the single, all-in-one <filename>boot</filename> file is created. The way "
"<filename>boot</filename> is built is defined in its <filename>Makefile</filename> "
"(<filename>/usr/src/sys/boot/i386/boot2/Makefile</filename>). Let us look at the "
"rule that creates the <filename>boot</filename> file:"
msgstr ""
"Antes de estudar o <acronym>BTX</acronym> Server detalhadamente, vamos revisar ainda "
"mais como o single, all-in-one <filename> bota </filename> arquivo È criado. O "
"caminho <filename> bota </filename> È construÌ≠do È definido em sua <filename> "
"Makefile </filename> ( <filename> / usr / src / sys / boot / i386 / boot2 / Makefile "
"</filename> ). Vamos olhar para a regra que cria o <filename> bota </filename> "
"Arquivo:"

#: book.translate.xml:1393
#, fuzzy
msgid ""
"This tells us that <filename>boot1</filename> and <filename>boot2</filename> are "
"needed, and the rule simply concatenates them to produce a single file called "
"<filename>boot</filename>. The rules for creating <filename>boot1</filename> are "
"also quite simple:"
msgstr ""
"Isso nos diz que <filename> boot1 </filename> e <filename> boot2 </filename> s„o "
"necess·rios, e a regra simplesmente concatena-os para produzir um ˙nico arquivo "
"chamado <filename> bota </filename> . As regras para criar <filename> boot1 </"
"filename> tambÈm s„o bastante simples: "

#: book.translate.xml:1409
#, fuzzy
msgid ""
"To apply the rule for creating <filename>boot1</filename>, <filename>boot1.out</"
"filename> must be resolved. This, in turn, depends on the existence of "
"<filename>boot1.o</filename>. This last file is simply the result of assembling our "
"familiar <filename>boot1.S</filename>, without linking. Now, the rule for creating "
"<filename>boot1.out</filename> is applied. This tells us that <filename>boot1.o</"
"filename> should be linked with <literal>start</literal> as its entry point, and "
"starting at address <literal>0x7c00</literal>. Finally, <filename>boot1</filename> "
"is created from <filename>boot1.out</filename> applying the appropriate rule. This "
"rule is the <filename>objcopy</filename> command applied to <filename>boot1.out</"
"filename>. Note the flags passed to <filename>objcopy</filename>: <literal>-S</"
"literal> tells it to strip all relocation and symbolic information; <literal>-O "
"binary</literal> indicates the output format, that is, a simple, unformatted binary "
"file."
msgstr ""
"Para aplicar a regra para criar <filename> boot1 </filename> , <filename> boot1.out "
"</filename> deve ser resolvido. Isso, por sua vez, depende da existÍncia de "
"<filename> boot1.o </filename> . Este ˙ltimo arquivo È simplesmente o resultado da "
"montagem de nosso familiar <filename> boot1.S </filename> , sem vincular. Agora, a "
"regra para criar <filename> boot1.out </filename> È aplicado. Isso nos diz que "
"<filename> boot1.o </filename> deve estar ligado a <literal> comeÁar </literal> como "
"seu ponto de entrada, e comeÁando no endereÁo <literal> 0x7c00 </literal> . "
"Finalmente, <filename> boot1 </filename> È criado a partir de <filename> boot1.out </"
"filename> aplicar a regra apropriada. Esta regra È a <filename> objcopy </filename> "
"comando aplicado a <filename> boot1.out </filename> . Observe as bandeiras passadas "
"para <filename> objcopy </filename> : <literal> -S </literal> diz para remover toda "
"a relocaÁ„o e informaÁÌµes simbÛlicas; <literal> Bin·rio -O </literal> indica o "
"formato de saÌ≠da, isto È, um arquivo bin·rio simples e n„o formatado. "

#: book.translate.xml:1428
#, fuzzy
msgid ""
"Having <filename>boot1</filename>, let us take a look at how <filename>boot2</"
"filename> is constructed:"
msgstr ""
"Tendo <filename> boot1 </filename> , vamos dar uma olhada em como <filename> boot2 </"
"filename> Ìâ construÌ≠do:"

#: book.translate.xml:1468
#, fuzzy
msgid ""
"The mechanism for building <filename>boot2</filename> is far more elaborate. Let us "
"point out the most relevant facts. The dependency list is as follows:"
msgstr ""
"O mecanismo de construÁ„o <filename> boot2 </filename> È muito mais elaborado. Vamos "
"mostrar os fatos mais relevantes. A lista de dependÍncias È a seguinte: "

#: book.translate.xml:1484
#, fuzzy
msgid ""
"Note that initially there is no header file <filename>boot2.h</filename>, but its "
"creation depends on <filename>boot1.out</filename>, which we already have. The rule "
"for its creation is a bit terse, but the important thing is that the output, "
"<filename>boot2.h</filename>, is something like this:"
msgstr ""
"Note que inicialmente n„o h· arquivo de cabeÁalho <filename> boot2.h </filename> , "
"mas a sua criaÁ„o depende <filename> boot1.out </filename> que j· temos. A regra "
"para sua criaÁ„o È um pouco concisa, mas o importante È que a saÌ≠da, <filename> "
"boot2.h </filename> È algo assim: "

#: book.translate.xml:1492
#, fuzzy
msgid "<filename>sys/boot/i386/boot2/boot2.h</filename>"
msgstr " <filename> sys / boot / i386 / boot2 / boot2.h </filename> "

#: book.translate.xml:1498
#, fuzzy
msgid ""
"Recall that <filename>boot1</filename> was relocated (i.e., copied from "
"<literal>0x7c00</literal> to <literal>0x700</literal>). This relocation will now "
"make sense, because as we will see, the <acronym>BTX</acronym> server reclaims some "
"memory, including the space where <filename>boot1</filename> was originally loaded. "
"However, the <acronym>BTX</acronym> server needs access to <filename>boot1</"
"filename>'s <literal>xread</literal> function; this function, according to the "
"output of <filename>boot2.h</filename>, is at location <literal>0x725</literal>. "
"Indeed, the <acronym>BTX</acronym> server uses the <literal>xread</literal> function "
"from <filename>boot1</filename>'s relocated code. This function is now accessible "
"from within the <filename>boot2</filename> client."
msgstr ""
"Lembre-se que <filename> boot1 </filename> foi realocado (ou seja, copiado de "
"<literal> 0x7c00 </literal> para <literal> 0x700 </literal> ). Essa realocaÁ„o far· "
"agora sentido, porque, como veremos, o servidor <acronym>BTX</acronym> recupera "
"alguma memÛria, incluindo o espaÁo onde <filename> boot1 </filename> foi "
"originalmente carregado. No entanto, o servidor <acronym>BTX</acronym> precisa de "
"acesso a <filename> boot1 </filename> ';s <literal> xread </literal> funÁ„o; esta "
"funÁ„o, de acordo com a saÌ≠da de <filename> boot2.h </filename> est· no local "
"<literal> 0x725 </literal> . De fato, o servidor <acronym>BTX</acronym> usa o "
"<literal> xread </literal> funÁ„o de <filename> boot1 </filename> cÛdigo realocado. "
"Esta funÁ„o est· agora acessÌ≠vel a partir do <filename> boot2 </filename> cliente."

#: book.translate.xml:1515
#, fuzzy
msgid ""
"We next build <filename>boot2.s</filename> from files <filename>boot2.h</filename>, "
"<filename>boot2.c</filename> and <filename>/usr/src/sys/boot/common/ufsread.c</"
"filename>. The rule for this is to compile the code in <filename>boot2.c</filename> "
"(which includes <filename>boot2.h</filename> and <filename>ufsread.c</filename>) "
"into assembly code. Having <filename>boot2.s</filename>, the next rule assembles "
"<filename>boot2.s</filename>, creating the object file <filename>boot2.o</filename>. "
"The next rule directs the linker to link various files (<filename>crt0.o</filename>, "
"<filename>boot2.o</filename> and <filename>sio.o</filename>). Note that the output "
"file, <filename>boot2.out</filename>, is linked to execute at address "
"<literal>0x2000</literal>. Recall that <filename>boot2</filename> will be executed "
"in user mode, within a special user segment set up by the <acronym>BTX</acronym> "
"server. This segment starts at <literal>0xa000</literal>. Also, remember that the "
"<filename>boot2</filename> portion of <filename>boot</filename> was copied to "
"address <literal>0xc000</literal>, that is, offset <literal>0x2000</literal> from "
"the start of the user segment, so <filename>boot2</filename> will work properly when "
"we transfer control to it. Next, <filename>boot2.bin</filename> is created from "
"<filename>boot2.out</filename> by stripping its symbols and format information; "
"boot2.bin is a <emphasis>raw</emphasis> binary. Now, note that a file "
"<filename>boot2.ldr</filename> is created as a 512-byte file full of zeros. This "
"space is reserved for the bsdlabel."
msgstr ""
"Em seguida, construÌ≠mos <filename> boot2.s </filename> de arquivos <filename> boot2."
"h </filename> , <filename> boot2.c </filename> e <filename> /usr/src/sys/boot/common/"
"ufsread.c </filename> . A regra para isso È compilar o cÛdigo em <filename> boot2.c "
"</filename> (que inclui <filename> boot2.h </filename> e <filename> ufsread.c </"
"filename> ) no cÛdigo de montagem. Tendo <filename> boot2.s </filename> , a prÛxima "
"regra È montada <filename> boot2.s </filename> , criando o arquivo objeto <filename> "
"boot2.o </filename> . A prÛxima regra direciona o vinculador para vincular v·rios "
"arquivos ( <filename> crt0.o </filename> , <filename> boot2.o </filename> e "
"<filename> sio.o </filename> ). Note que o arquivo de saÌ≠da, <filename> boot2.out </"
"filename> , est· ligado para executar no endereÁo <literal> 0x2000 </literal> . "
"Lembre-se de que <filename> boot2 </filename> ser· executado no modo de usu·rio, "
"dentro de um segmento de usu·rio especial configurado pelo servidor <acronym>BTX</"
"acronym> . Este segmento comeÁa em <literal> 0xa000 </literal> . AlÈm disso, lembre-"
"se de que <filename> boot2 </filename> porÁ„o de <filename> bota </filename> foi "
"copiado para endereÁar <literal> 0xc000 </literal> , isto È, offset <literal> 0x2000 "
"</literal> desde o inÌ≠cio do segmento de usu·rio, ent„o <filename> boot2 </filename> "
"funcionar· corretamente quando transferirmos o controle para ele. PrÛximo, "
"<filename> boot2.bin </filename> È criado a partir de <filename> boot2.out </"
"filename> descascando seus sÌ≠mbolos e formando informaÁÌµes; boot2.bin È um "
"<emphasis> cru </emphasis> bin·rio. Agora, observe que um arquivo <filename> boot2."
"ldr </filename> È criado como um arquivo de 512 bytes cheio de zeros. Este espaÁo È "
"reservado para o bsdlabel. "

#: book.translate.xml:1544
#, fuzzy
msgid ""
"Now that we have files <filename>boot1</filename>, <filename>boot2.bin</filename> "
"and <filename>boot2.ldr</filename>, only the <acronym>BTX</acronym> server is "
"missing before creating the all-in-one <filename>boot</filename> file. The "
"<acronym>BTX</acronym> server is located in <filename>/usr/src/sys/boot/i386/btx/"
"btx</filename>; it has its own <filename>Makefile</filename> with its own set of "
"rules for building. The important thing to notice is that it is also compiled as a "
"<emphasis>raw</emphasis> binary, and that it is linked to execute at address "
"<literal>0x9000</literal>. The details can be found in <filename>/usr/src/sys/boot/"
"i386/btx/btx/Makefile</filename>."
msgstr ""
"Agora que temos arquivos <filename> boot1 </filename> , <filename> boot2.bin </"
"filename> e <filename> boot2.ldr </filename> , apenas o servidor <acronym>BTX</"
"acronym> est· ausente antes de criar o all-in-one <filename> bota </filename> "
"Arquivo. O servidor <acronym>BTX</acronym> est· localizado em <filename> / usr / "
"src / sys / boot / i386 / btx / btx </filename> ; tem o seu prÛprio <filename> "
"Makefile </filename> com seu prÛprio conjunto de regras para a construÁ„o. O "
"importante È notar que tambÈm È compilado como um <emphasis> cru </emphasis> "
"bin·rio, e que est· ligado para executar no endereÁo <literal> 0x9000 </literal> . "
"Os detalhes podem ser encontrados em <filename> / usr / src / sys / boot / i386 / "
"btx / btx / Makefile </filename> "

#: book.translate.xml:1558
#, fuzzy
msgid ""
"Having the files that comprise the <filename>boot</filename> program, the final step "
"is to <emphasis>merge</emphasis> them. This is done by a special program called "
"<filename>btxld</filename> (source located in <filename>/usr/src/usr.sbin/btxld</"
"filename>). Some arguments to this program include the name of the output file "
"(<filename>boot</filename>), its entry point (<literal>0x2000</literal>) and its "
"file format (raw binary). The various files are finally merged by this utility into "
"the file <filename>boot</filename>, which consists of <filename>boot1</filename>, "
"<filename>boot2</filename>, the <literal>bsdlabel</literal> and the <acronym>BTX</"
"acronym> server. This file, which takes exactly 16 sectors, or 8192 bytes, is what "
"is actually written to the beginning of the FreeBSD slice during instalation. Let us "
"now proceed to study the <acronym>BTX</acronym> server program."
msgstr ""
"Tendo os arquivos que compÌµem o <filename> bota </filename> programa, o passo final "
"È <emphasis> fundir </emphasis> eles. Isso È feito por um programa especial chamado "
"<filename> btxld </filename> (fonte localizada em <filename> /usr/src/usr.sbin/btxld "
"</filename> ). Alguns argumentos para este programa incluem o nome do arquivo de saÌ≠"
"da ( <filename> bota </filename> ), o seu ponto de entrada ( <literal> 0x2000 </"
"literal> ) e seu formato de arquivo (bin·rio bruto). Os v·rios arquivos s„o "
"finalmente mesclados por esse utilit·rio no arquivo <filename> bota </filename> , "
"que consiste em <filename> boot1 </filename> , <filename> boot2 </filename> , a "
"<literal> bsdlabel </literal> e o servidor <acronym>BTX</acronym> . Este arquivo, "
"que leva exatamente 16 setores, ou 8192 bytes, È o que realmente È gravado no inÌ≠cio "
"da fatia do FreeBSD durante a instalaÁ„o. Vamos agora continuar a estudar o programa "
"do servidor <acronym>BTX</acronym> . "

#: book.translate.xml:1577
#, fuzzy
msgid ""
"The <acronym>BTX</acronym> server prepares a simple environment and switches from 16-"
"bit real mode to 32-bit protected mode, right before passing control to the client. "
"This includes initializing and updating the following data structures:"
msgstr ""
"O servidor <acronym>BTX</acronym> prepara um ambiente simples e alterna do modo real "
"de 16 bits para o modo protegido de 32 bits, antes de passar o controle para o "
"cliente. Isso inclui inicializar e atualizar as seguintes estruturas de dados:"

#: book.translate.xml:1583
#, fuzzy
msgid "<primary>virtual v86 mode</primary>"
msgstr " <primary> modo virtual v86 </primary> "

#: book.translate.xml:1586
#, fuzzy
msgid ""
"Modifies the <literal>Interrupt Vector Table (IVT)</literal>. The <acronym>IVT</"
"acronym> provides exception and interrupt handlers for Real-Mode code."
msgstr ""
"Modifica o <literal> Tabela de vetores de interrupÁ„o (IVT) </literal> . O "
"<acronym>IVT</acronym> fornece manipuladores de exceÁ„o e interrupÁ„o para o cÛdigo "
"de modo real. "

#: book.translate.xml:1593
#, fuzzy
msgid ""
"The <literal>Interrupt Descriptor Table (IDT)</literal> is created. Entries are "
"provided for processor exceptions, hardware interrupts, two system calls and V86 "
"interface. The IDT provides exception and interrupt handlers for Protected-Mode code."
msgstr ""
"O <literal> Tabela de descritores de interrupÁ„o (IDT) </literal> È criado. Entradas "
"s„o fornecidas para exceÁÌµes de processador, interrupÁÌµes de hardware, duas "
"chamadas de sistema e interface V86. O IDT fornece manipuladores de exceÁ„o e "
"interrupÁ„o para o cÛdigo de modo protegido. "

#: book.translate.xml:1601
#, fuzzy
msgid ""
"A <literal>Task-State Segment (TSS)</literal> is created. This is necessary because "
"the processor works in the <emphasis>least</emphasis> privileged level when "
"executing the client (<filename>boot2</filename>), but in the <emphasis>most</"
"emphasis> privileged level when executing the <acronym>BTX</acronym> server."
msgstr ""
"UMA <literal> Segmento Estado-tarefa (TSS) </literal> È criado. Isso È necess·rio "
"porque o processador funciona no <emphasis> menos </emphasis> nÌ≠vel privilegiado ao "
"executar o cliente ( <filename> boot2 </filename> ), mas no <emphasis> a maioria </"
"emphasis> nÌ≠vel privilegiado ao executar o servidor <acronym>BTX</acronym> . "

#: book.translate.xml:1615
#, fuzzy
msgid ""
"Real-mode code and data are necessary when switching back to real mode from "
"protected mode, as suggested by the Intel manuals."
msgstr ""
"CÛdigo e dados de modo real s„o necess·rios ao retornar ao modo real a partir do "
"modo protegido, conforme sugerido pelos manuais da Intel."

#: book.translate.xml:1610
#, fuzzy
msgid ""
"The <acronym>GDT</acronym> (Global Descriptor Table) is set up. Entries "
"(descriptors) are provided for supervisor code and data, user code and data, and "
"real-mode code and data. <_:footnote-1/>"
msgstr ""
"A <acronym>GDT</acronym> (Global Descriptor Table) est· configurada. Entradas "
"(descritores) s„o fornecidas para cÛdigo de supervisor e dados, cÛdigo de usu·rio e "
"dados, e cÛdigo e dados em modo real. <_: Footnote-1 />"

#: book.translate.xml:1621
#, fuzzy
msgid ""
"Let us now start studying the actual implementation. Recall that <filename>boot1</"
"filename> made a jump to address <literal>0x9010</literal>, the <acronym>BTX</"
"acronym> server's entry point. Before studying program execution there, note that "
"the <acronym>BTX</acronym> server has a special header at address range "
"<literal>0x9000-0x900f</literal>, right before its entry point. This header is "
"defined as follows:"
msgstr ""
"Vamos agora comeÁar a estudar a implementaÁ„o real. Lembre-se que <filename> boot1 </"
"filename> fez um salto para abordar <literal> 0x9010 </literal> , o ponto de entrada "
"do servidor <acronym>BTX</acronym> . Antes de estudar a execuÁ„o do programa, "
"observe que o servidor <acronym>BTX</acronym> possui um cabeÁalho especial na faixa "
"de endereÁos <literal> 0x9000-0x900f </literal> , antes do seu ponto de entrada. "
"Esse cabeÁalho È definido da seguinte maneira: "

#: book.translate.xml:1904 book.translate.xml:1855 book.translate.xml:1830
#: book.translate.xml:1759 book.translate.xml:1731 book.translate.xml:1690
#: book.translate.xml:1661 book.translate.xml:1630
#, fuzzy
msgid "<filename>sys/boot/i386/btx/btx/btx.S</filename>"
msgstr " <filename> sys / boot / i386 / btx / btx / btx.S </filename> "

#: book.translate.xml:1647
#, fuzzy
msgid ""
"Note the first two bytes are <literal>0xeb</literal> and <literal>0xe</literal>. In "
"the IA-32 architecture, these two bytes are interpreted as a relative jump past the "
"header into the entry point, so in theory, <filename>boot1</filename> could jump "
"here (address <literal>0x9000</literal>) instead of address <literal>0x9010</"
"literal>. Note that the last field in the <acronym>BTX</acronym> header is a pointer "
"to the client's (<filename>boot2</filename>) entry point. This field is patched at "
"link time."
msgstr ""
"Note que os dois primeiros bytes s„o <literal> 0xeb </literal> e <literal> 0xe </"
"literal> . Na arquitetura IA-32, esses dois bytes s„o interpretados como um salto "
"relativo apÛs o cabeÁalho para o ponto de entrada, ent„o, em teoria, <filename> "
"boot1 </filename> poderia pular aqui (endereÁo <literal> 0x9000 </literal> ) em vez "
"de endereÁo <literal> 0x9010 </literal> . Observe que o ˙ltimo campo no cabeÁalho "
"<acronym>BTX</acronym> È um ponteiro para o cliente ( <filename> boot2 </filename> ) "
"ponto de entrada. Este campo È corrigido no momento do link. "

#: book.translate.xml:1657
#, fuzzy
msgid ""
"Immediately following the header is the <acronym>BTX</acronym> server's entry point:"
msgstr ""
"Imediatamente apÛs o cabeÁalho È o ponto de entrada do servidor <acronym>BTX</"
"acronym> :"

#: book.translate.xml:1676
#, fuzzy
msgid ""
"This code disables interrupts, sets up a working stack (starting at address "
"<literal>0x1800</literal>) and clears the flags in the EFLAGS register. Note that "
"the <literal>popfl</literal> instruction pops out a doubleword (4 bytes) from the "
"stack and places it in the EFLAGS register. Because the value actually popped is "
"<literal>2</literal>, the EFLAGS register is effectively cleared (IA-32 requires "
"that bit 2 of the EFLAGS register always be 1)."
msgstr ""
"Esse cÛdigo desabilita as interrupÁÌµes, configura uma pilha de trabalho (iniciando "
"no endereÁo <literal> 0x1800 </literal> ) e apaga as bandeiras no registro EFLAGS. "
"Note que o <literal> popfl </literal> A instruÁ„o extrai uma palavra dupla (4 bytes) "
"da pilha e a coloca no registro EFLAGS. Porque o valor realmente estourou È "
"<literal> 2 </literal> , o registro EFLAGS È efetivamente limpo (o IA-32 requer que "
"o bit 2 do registro EFLAGS seja sempre 1). "

#: book.translate.xml:1685
#, fuzzy
msgid ""
"Our next code block clears (sets to <literal>0</literal>) the memory range "
"<literal>0x5e00-0x8fff</literal>. This range is where the various data structures "
"will be created:"
msgstr ""
"Nosso prÛximo bloco de cÛdigo È apagado <literal> 0 </literal> ) o intervalo de "
"memÛria <literal> 0x5e00-0x8fff </literal> . Este intervalo È onde as v·rias "
"estruturas de dados ser„o criadas: "

#: book.translate.xml:1701
#, fuzzy
msgid ""
"Recall that <filename>boot1</filename> was originally loaded to address "
"<literal>0x7c00</literal>, so, with this memory initialization, that copy "
"effectively dissapeared. However, also recall that <filename>boot1</filename> was "
"relocated to <literal>0x700</literal>, so <emphasis>that</emphasis> copy is still in "
"memory, and the <acronym>BTX</acronym> server will make use of it."
msgstr ""
"Lembre-se que <filename> boot1 </filename> foi originalmente carregado para resolver "
"<literal> 0x7c00 </literal> Assim, com esta inicializaÁ„o de memÛria, essa cÛpia "
"efetivamente desapareceu. No entanto, lembre-se tambÈm que <filename> boot1 </"
"filename> foi transferido para <literal> 0x700 </literal> , assim <emphasis> aquele "
"</emphasis> a cÛpia ainda est· na memÛria, e o servidor <acronym>BTX</acronym> far· "
"uso dela. "

#: book.translate.xml:1709
#, fuzzy
msgid ""
"Next, the real-mode <acronym>IVT</acronym> (Interrupt Vector Table is updated. The "
"<acronym>IVT</acronym> is an array of segment/offset pairs for exception and "
"interrupt handlers. The <acronym>BIOS</acronym> normally maps hardware interrupts to "
"interrupt vectors <literal>0x8</literal> to <literal>0xf</literal> and "
"<literal>0x70</literal> to <literal>0x77</literal> but, as will be seen, the 8259A "
"Programmable Interrupt Controller, the chip controlling the actual mapping of "
"hardware interrupts to interrupt vectors, is programmed to remap these interrupt "
"vectors from <literal>0x8-0xf</literal> to <literal>0x20-0x27</literal> and from "
"<literal>0x70-0x77</literal> to <literal>0x28-0x2f</literal>. Thus, interrupt "
"handlers are provided for interrupt vectors <literal>0x20-0x2f</literal>. The reason "
"the <acronym>BIOS</acronym>-provided handlers are not used directly is because they "
"work in 16-bit real mode, but not 32-bit protected mode. Processor mode will be "
"switched to 32-bit protected mode shortly. However, the <acronym>BTX</acronym> "
"server sets up a mechanism to effectively use the handlers provided by the "
"<acronym>BIOS</acronym>:"
msgstr ""
"Em seguida, o <acronym>IVT em</acronym> modo real (tabela de vetores de interrupÁ„o "
"È atualizado. O <acronym>IVT</acronym> È uma matriz de pares de segmento / "
"deslocamento para manipuladores de exceÁ„o e interrupÁÌµes. O <acronym>BIOS</"
"acronym> normalmente mapeia interrupÁÌµes de hardware para interromper vetores "
"<literal> 0x8 </literal> para <literal> 0xf </literal> e <literal> 0x70 </literal> "
"para <literal> 0x77 </literal> mas, como ser· visto, o Controlador de InterrupÁ„o "
"Program·vel 8259A, o chip que controla o mapeamento real de interrupÁÌµes de "
"hardware para vetores de interrupÁ„o, È programado para remapear esses vetores de "
"interrupÁ„o de <literal> 0x8-0xf </literal> para <literal> 0x20-0x27 </literal> e de "
"<literal> 0x70-0x77 </literal> para <literal> 0x28-0x2f </literal> . Assim, "
"manipuladores de interrupÁ„o s„o fornecidos para vetores de interrupÁ„o <literal> "
"0x20-0x2f </literal> . A raz„o pela qual os manipuladores fornecidos pelo "
"<acronym>BIOS</acronym> n„o s„o usados ‚Äã‚Äãdiretamente È porque eles funcionam no modo "
"real de 16 bits, mas n„o no modo protegido de 32 bits. O modo do processador ser· "
"alternado para o modo protegido de 32 bits em breve. No entanto, o servidor "
"<acronym>BTX</acronym> configura um mecanismo para usar efetivamente os "
"manipuladores fornecidos pelo <acronym>BIOS</acronym> : "

#: book.translate.xml:1747
#, fuzzy
msgid ""
"The next block creates the <acronym>IDT</acronym> (Interrupt Descriptor Table). The "
"<acronym>IDT</acronym> is analogous, in protected mode, to the <acronym>IVT</"
"acronym> in real mode. That is, the <acronym>IDT</acronym> describes the various "
"exception and interrupt handlers used when the processor is executing in protected "
"mode. In essence, it also consists of an array of segment/offset pairs, although the "
"structure is somewhat more complex, because segments in protected mode are different "
"than in real mode, and various protection mechanisms apply:"
msgstr ""
"O prÛximo bloco cria o <acronym>IDT</acronym> (Interrupt Descriptor Table). O "
"<acronym>IDT</acronym> È an·logo, no modo protegido, ao <acronym>IVT</acronym> em "
"modo real. Ou seja, o <acronym>IDT</acronym> descreve os v·rios manipuladores de "
"exceÁ„o e interrupÁÌµes usados ‚Äã‚Äãquando o processador est· executando em modo "
"protegido. Em essÍncia, ele tambÈm consiste em uma matriz de pares segmento / "
"offset, embora a estrutura seja um pouco mais complexa, porque os segmentos no modo "
"protegido s„o diferentes do modo real, e v·rios mecanismos de proteÁ„o se aplicam: "

#: book.translate.xml:1787
#, fuzzy
msgid ""
"Each entry in the <literal>IDT</literal> is 8 bytes long. Besides the segment/offset "
"information, they also describe the segment type, privilege level, and whether the "
"segment is present in memory or not. The construction is such that interrupt vectors "
"from <literal>0</literal> to <literal>0xf</literal> (exceptions) are handled by "
"function <literal>intx00</literal>; vector <literal>0x10</literal> (also an "
"exception) is handled by <literal>intx10</literal>; hardware interrupts, which are "
"later configured to start at interrupt vector <literal>0x20</literal> all the way to "
"interrupt vector <literal>0x2f</literal>, are handled by function <literal>intx20</"
"literal>. Lastly, interrupt vector <literal>0x30</literal>, which is used for system "
"calls, is handled by <literal>intx30</literal>, and vectors <literal>0x31</literal> "
"and <literal>0x32</literal> are handled by <literal>intx31</literal>. It must be "
"noted that only descriptors for interrupt vectors <literal>0x30</literal>, "
"<literal>0x31</literal> and <literal>0x32</literal> are given privilege level 3, the "
"same privilege level as the <filename>boot2</filename> client, which means the "
"client can execute a software-generated interrupt to this vectors through the "
"<literal>int</literal> instruction without failing (this is the way <filename>boot2</"
"filename> use the services provided by the <acronym>BTX</acronym> server). Also, "
"note that <emphasis>only</emphasis> software-generated interrupts are protected from "
"code executing in lesser privilege levels. Hardware-generated interrupts and "
"processor-generated exceptions are <emphasis>always</emphasis> handled adequately, "
"regardless of the actual privileges involved."
msgstr ""
"Cada entrada no <literal> IDT </literal> tem 8 bytes de comprimento. AlÈm das "
"informaÁÌµes de segmento / deslocamento, elas tambÈm descrevem o tipo de segmento, nÌ≠"
"vel de privilÈgio e se o segmento est· presente na memÛria ou n„o. A construÁ„o È "
"tal que interrompe vetores de <literal> 0 </literal> para <literal> 0xf </literal> "
"(exceÁÌµes) s„o tratadas por funÁ„o <literal> intx00 </literal> ; vetor <literal> "
"0x10 </literal> (tambÈm uma exceÁ„o) È tratado por <literal> intx10 </literal> ; "
"interrupÁÌµes de hardware, que s„o configuradas posteriormente para iniciar no vetor "
"de interrupÁ„o <literal> 0x20 </literal> todo o caminho para interromper o vetor "
"<literal> 0x2f </literal> , s„o manipulados por funÁ„o <literal> intx20 </literal> . "
"Por fim, vetor de interrupÁ„o <literal> 0x30 </literal> , que È usado para chamadas "
"do sistema, È manipulado por <literal> intx30 </literal> e vetores <literal> 0x31 </"
"literal> e <literal> 0x32 </literal> s„o manipulados por <literal> intx31 </"
"literal> . Deve-se notar que apenas descritores para vetores de interrupÁ„o "
"<literal> 0x30 </literal> , <literal> 0x31 </literal> e <literal> 0x32 </literal> "
"recebem o nÌ≠vel de privilÈgio 3, o mesmo nÌ≠vel de privilÈgio que o <filename> boot2 "
"</filename> cliente, o que significa que o cliente pode executar uma interrupÁ„o "
"gerada por software para esses vetores <literal> int </literal> instruÁ„o sem falhar "
"(este È o caminho <filename> boot2 </filename> usar os serviÁos fornecidos pelo "
"servidor <acronym>BTX</acronym> ). AlÈm disso, note que <emphasis> sÛ </emphasis> "
"interrupÁÌµes geradas por software s„o protegidas do cÛdigo executado em nÌ≠veis de "
"privilÈgios menores. InterrupÁÌµes geradas por hardware e exceÁÌµes geradas pelo "
"processador s„o <emphasis> sempre </emphasis> manuseado de forma adequada, "
"independentemente dos privilÈgios reais envolvidos. "

#: book.translate.xml:1817
#, fuzzy
msgid ""
"The next step is to initialize the <acronym>TSS</acronym> (Task-State Segment). The "
"<acronym>TSS</acronym> is a hardware feature that helps the operating system or "
"executive software implement multitasking functionality through process abstraction. "
"The IA-32 architecture demands the creation and use of <emphasis>at least</emphasis> "
"one <acronym>TSS</acronym> if multitasking facilities are used or different "
"privilege levels are defined. Because the <filename>boot2</filename> client is "
"executed in privilege level 3, but the <acronym>BTX</acronym> server does in "
"privilege level 0, a <acronym>TSS</acronym> must be defined:"
msgstr ""
"O prÛximo passo È inicializar o <acronym>TSS</acronym> (Task-State Segment). O "
"<acronym>TSS</acronym> È um recurso de hardware que ajuda o sistema operacional ou o "
"software executivo a implementar a funcionalidade multitarefa por meio da abstraÁ„o "
"do processo. A arquitetura IA-32 exige a criaÁ„o eo uso de <emphasis> finalmente </"
"emphasis> um <acronym>TSS</acronym> se forem usados ‚Äã‚Äãrecursos multitarefa ou se "
"forem definidos nÌ≠veis de privilÈgios diferentes. Porque o <filename> boot2 </"
"filename> cliente È executado no nÌ≠vel de privilÈgio 3, mas o servidor <acronym>BTX</"
"acronym> faz no nÌ≠vel de privilÈgio 0, um <acronym>TSS</acronym> deve ser definido: "

#: book.translate.xml:1840
#, fuzzy
msgid ""
"Note that a value is given for the Privilege Level 0 stack pointer and stack segment "
"in the <acronym>TSS</acronym>. This is needed because, if an interrupt or exception "
"is received while executing <filename>boot2</filename> in Privilege Level 3, a "
"change to Privilege Level 0 is automatically performed by the processor, so a new "
"working stack is needed. Finally, the I/O Map Base Address field of the "
"<acronym>TSS</acronym> is given a value, which is a 16-bit offset from the beginning "
"of the <acronym>TSS</acronym> to the I/O Permission Bitmap and the Interrupt "
"Redirection Bitmap."
msgstr ""
"Note que um valor È dado para o ponteiro de pilha e segmento de pilha do Privilege "
"Level 0 no <acronym>TSS</acronym> . Isso È necess·rio porque, se uma interrupÁ„o ou "
"exceÁ„o for recebida durante a execuÁ„o <filename> boot2 </filename> No Privilege "
"Level 3, uma alteraÁ„o no Privilege Level 0 È executada automaticamente pelo "
"processador, portanto, È necess·ria uma nova pilha de trabalho. Finalmente, o campo "
"EndereÁo de Mapeamento de E / S do <acronym>TSS</acronym> recebe um valor, que È um "
"deslocamento de 16 bits desde o inÌ≠cio do <acronym>TSS</acronym> atÈ o Bitmap de "
"Permiss„o de E / S e o Bitmap de Redirecionamento de InterrupÁÌµes. "

#: book.translate.xml:1850
#, fuzzy
msgid ""
"After the <acronym>IDT</acronym> and <acronym>TSS</acronym> are created, the "
"processor is ready to switch to protected mode. This is done in the next block:"
msgstr ""
"Depois que o <acronym>IDT</acronym> e o <acronym>TSS</acronym> s„o criados, o "
"processador est· pronto para mudar para o modo protegido. Isso È feito no prÛximo "
"bloco:"

#: book.translate.xml:1874
#, fuzzy
msgid ""
"First, a call is made to <literal>setpic</literal> to program the 8259A "
"<acronym>PIC</acronym> (Programmable Interrupt Controller). This chip is connected "
"to multiple hardware interrupt sources. Upon receiving an interrupt from a device, "
"it signals the processor with the appropriate interrupt vector. This can be "
"customized so that specific interrupts are associated with specific interrupt "
"vectors, as explained before. Next, the <acronym>IDTR</acronym> (Interrupt "
"Descriptor Table Register) and <acronym>GDTR</acronym> (Global Descriptor Table "
"Register) are loaded with the instructions <literal>lidt</literal> and "
"<literal>lgdt</literal>, respectively. These registers are loaded with the base "
"address and limit address for the <acronym>IDT</acronym> and <acronym>GDT</acronym>. "
"The following three instructions set the Protection Enable (PE) bit of the <literal>"
"%cr0</literal> register. This effectively switches the processor to 32-bit protected "
"mode. Next, a long jump is made to <literal>init.8</literal> using segment selector "
"SEL_SCODE, which selects the Supervisor Code Segment. The processor is effectively "
"executing in CPL 0, the most privileged level, after this jump. Finally, the "
"Supervisor Data Segment is selected for the stack by assigning the segment selector "
"SEL_SDATA to the <literal>%ss</literal> register. This data segment also has a "
"privilege level of <literal>0</literal>."
msgstr ""
"Primeiro, uma chamada È feita para <literal> setpic </literal> para programar o "
"8259A <acronym>PIC</acronym> (Programmable Interrupt Controller). Este chip est· "
"conectado a v·rias fontes de interrupÁ„o de hardware. Ao receber uma interrupÁ„o de "
"um dispositivo, ele sinaliza ao processador o vetor de interrupÁ„o apropriado. Isso "
"pode ser personalizado para que interrupÁÌµes especÌ≠ficas sejam associadas a vetores "
"de interrupÁ„o especÌ≠ficos, conforme explicado anteriormente. Em seguida, o "
"<acronym>IDTR</acronym> (Registro da Tabela de Descritores de InterrupÁÌµes) e o "
"<acronym>GDTR</acronym> (Registro da Tabela de Descritores Globais) s„o carregados "
"com as instruÁÌµes <literal> lidt </literal> e <literal> lgdt </literal> , "
"respectivamente. Esses registros s„o carregados com o endereÁo base e o endereÁo "
"limite para o <acronym>IDT</acronym> e o <acronym>GDT</acronym> . As trÍs "
"instruÁÌµes a seguir definem o bit Protection Enable (PE) do <literal> % cr0 </"
"literal> registo. Isso efetivamente alterna o processador para o modo protegido de "
"32 bits. Em seguida, um longo salto È feito para <literal> init.8 </literal> usando "
"o seletor de segmento SEL_SCODE, que seleciona o segmento de cÛdigo de supervisor. O "
"processador est· efetivamente executando em CPL 0, o nÌ≠vel mais privilegiado, apÛs "
"esse salto. Finalmente, o Segmento de Dados do Supervisor È selecionado para a "
"pilha, atribuindo o seletor de segmento SEL_SDATA <literal> % ss </literal> registo. "
"Esse segmento de dados tambÈm tem um nÌ≠vel de privilÈgio de <literal> 0 </literal> "

#: book.translate.xml:1897
#, fuzzy
msgid ""
"Our last code block is responsible for loading the <acronym>TR</acronym> (Task "
"Register) with the segment selector for the <acronym>TSS</acronym> we created "
"earlier, and setting the User Mode environment before passing execution control to "
"the <filename>boot2</filename> client."
msgstr ""
"Nosso ˙ltimo bloco de cÛdigo È respons·vel por carregar o <acronym>TR</acronym> "
"(Task Register) com o seletor de segmento para o <acronym>TSS</acronym> que criamos "
"anteriormente e configurar o ambiente do Modo de Usu·rio antes de passar o controle "
"de execuÁ„o para o <filename> boot2 </filename> cliente."

#: book.translate.xml:1938
#, fuzzy
msgid ""
"Note that the client's environment include a stack segment selector and stack "
"pointer (registers <literal>%ss</literal> and <literal>%esp</literal>). Indeed, once "
"the <acronym>TR</acronym> is loaded with the appropriate stack segment selector "
"(instruction <literal>ltr</literal>), the stack pointer is calculated and pushed "
"onto the stack along with the stack's segment selector. Next, the value "
"<literal>0x202</literal> is pushed onto the stack; it is the value that the EFLAGS "
"will get when control is passed to the client. Also, the User Mode code segment "
"selector and the client's entry point are pushed. Recall that this entry point is "
"patched in the <acronym>BTX</acronym> header at link time. Finally, segment "
"selectors (stored in register <literal>%ecx</literal>) for the segment registers "
"<literal>%gs, %fs, %ds and %es</literal> are pushed onto the stack, along with the "
"value at <literal>%edx</literal> (<literal>0xa000</literal>). Keep in mind the "
"various values that have been pushed onto the stack (they will be popped out "
"shortly). Next, values for the remaining general purpose registers are also pushed "
"onto the stack (note the <literal>loop</literal> that pushes the value <literal>0</"
"literal> seven times). Now, values will be started to be popped out of the stack. "
"First, the <literal>popa</literal> instruction pops out of the stack the latest "
"seven values pushed. They are stored in the general purpose registers in order "
"<literal>%edi, %esi, %ebp, %ebx, %edx, %ecx, %eax</literal>. Then, the various "
"segment selectors pushed are popped into the various segment registers. Five values "
"still remain on the stack. They are popped when the <literal>iret</literal> "
"instruction is executed. This instruction first pops the value that was pushed from "
"the <acronym>BTX</acronym> header. This value is a pointer to <filename>boot2</"
"filename>'s entry point. It is placed in the register <literal>%eip</literal>, the "
"instruction pointer register. Next, the segment selector for the User Code Segment "
"is popped and copied to register <literal>%cs</literal>. Remember that this "
"segment's privilege level is 3, the least privileged level. This means that we must "
"provide values for the stack of this privilege level. This is why the processor, "
"besides further popping the value for the EFLAGS register, does two more pops out of "
"the stack. These values go to the stack pointer (<literal>%esp</literal>) and the "
"stack segment (<literal>%ss</literal>). Now, execution continues at <literal>boot0</"
"literal>'s entry point."
msgstr ""
"Note que o ambiente do cliente inclui um seletor de segmento de pilha e ponteiro de "
"pilha (registros <literal> % ss </literal> e <literal> % esp </literal> ). Na "
"verdade, uma vez que o <acronym>TR</acronym> È carregado com o seletor de segmento "
"de pilha apropriado (instruÁ„o <literal> ltr </literal> ), o ponteiro da pilha È "
"calculado e colocado na pilha junto com o seletor de segmento da pilha. Em seguida, "
"o valor <literal> 0x202 </literal> È empurrado para a pilha; È o valor que o EFLAGS "
"obter· quando o controle for passado para o cliente. AlÈm disso, o seletor de "
"segmento de cÛdigo do modo de usu·rio e o ponto de entrada do cliente s„o "
"pressionados. Lembre-se de que esse ponto de entrada È corrigido no cabeÁalho "
"<acronym>BTX</acronym> no momento do link. Finalmente, os seletores de segmento "
"(armazenados no registrador <literal> % ecx </literal> ) para os registros de "
"segmento <literal> % gs,% fs,% ds e% es </literal> s„o empurrados para a pilha, "
"juntamente com o valor em <literal> % edx </literal> ( <literal> 0xa000 </"
"literal> ). Tenha em mente os v·rios valores que foram colocados na pilha (eles "
"ser„o exibidos em breve). Em seguida, os valores dos demais registradores de "
"propÛsito geral tambÈm s„o colocados na pilha (observe <literal> laÁo </literal> que "
"empurra o valor <literal> 0 </literal> sete vezes). Agora, os valores ser„o "
"iniciados para serem removidos da pilha. Primeiro, o <literal> popa </literal> "
"instruÁ„o sai da pilha os ˙ltimos sete valores empurrados. Eles s„o armazenados nos "
"registros de propÛsito geral para <literal> % edi,% esi,% ebp,% ebx,% edx,% ecx,% "
"eax </literal> . Em seguida, os v·rios seletores de segmento pressionados s„o "
"exibidos nos v·rios registros de segmento. Cinco valores ainda permanecem na pilha. "
"Eles s„o popped quando o <literal> iret </literal> instruÁ„o È executada. Esta "
"instruÁ„o primeiro mostra o valor que foi empurrado do cabeÁalho <acronym>BTX</"
"acronym> . Este valor È um ponteiro para <filename> boot2 </filename> ponto de "
"entrada. Ele È colocado no registro <literal> % eip </literal> , o registrador de "
"ponteiros de instruÁ„o. Em seguida, o seletor de segmento do segmento de cÛdigo do "
"usu·rio È exibido e copiado para registro <literal> % cs </literal> . Lembre-se de "
"que o nÌ≠vel de privilÈgio deste segmento È 3, o nÌ≠vel menos privilegiado. Isso "
"significa que devemos fornecer valores para a pilha desse nÌ≠vel de privilÈgio. Ìâ por "
"isso que o processador, alÈm de aumentar o valor do registrador EFLAGS, faz mais "
"dois pops da pilha. Esses valores v„o para o ponteiro da pilha ( <literal> % esp </"
"literal> ) e o segmento da pilha ( <literal> % ss </literal> ). Agora, a execuÁ„o "
"continua em <literal> boot0 </literal> ponto de entrada. "

#: book.translate.xml:1983
#, fuzzy
msgid ""
"It is important to note how the User Code Segment is defined. This segment's "
"<emphasis>base address</emphasis> is set to <literal>0xa000</literal>. This means "
"that code memory addresses are <emphasis>relative</emphasis> to address 0xa000; if "
"code being executed is fetched from address <literal>0x2000</literal>, the "
"<emphasis>actual</emphasis> memory addressed is <literal>0xa000+0x2000=0xc000</"
"literal>."
msgstr ""
"Ìâ importante observar como o segmento de cÛdigo do usu·rio È definido. Esse segmento "
"È <emphasis> endereÁo base </emphasis> est· configurado para <literal> 0xa000 </"
"literal> . Isso significa que os endereÁos de memÛria de cÛdigo s„o <emphasis> "
"relativo </emphasis> para endereÁar 0xa000; se o cÛdigo que est· sendo executado for "
"buscado no endereÁo <literal> 0x2000 </literal> , a <emphasis> real </emphasis> "
"memÛria endereÁada È <literal> 0xa000 + 0x2000 = 0xc000 </literal> "

#: book.translate.xml:1994
#, fuzzy
msgid "<application>boot2</application> Stage"
msgstr " <application> boot2 </application> Etapa"

#: book.translate.xml:1996
#, fuzzy
msgid ""
"<literal>boot2</literal> defines an important structure, <literal>struct bootinfo</"
"literal>. This structure is initialized by <literal>boot2</literal> and passed to "
"the loader, and then further to the kernel. Some nodes of this structures are set by "
"<literal>boot2</literal>, the rest by the loader. This structure, among other "
"information, contains the kernel filename, <acronym>BIOS</acronym> harddisk "
"geometry, <acronym>BIOS</acronym> drive number for boot device, physical memory "
"available, <literal>envp</literal> pointer etc. The definition for it is:"
msgstr ""
" <literal> boot2 </literal> define uma estrutura importante, <literal> struct "
"bootinfo </literal> . Essa estrutura È inicializada por <literal> boot2 </literal> e "
"passou para o carregador e depois para o kernel. Alguns nÛs desta estrutura s„o "
"definidos por <literal> boot2 </literal> , o resto pelo carregador. Esta estrutura, "
"entre outras informaÁÌµes, contÈm o nome do arquivo do kernel, <acronym>BIOS</"
"acronym> geometria disco rÌ≠gido, n˙mero da unidade <acronym>BIOS</acronym> para "
"dispositivo de inicializaÁ„o, memÛria fÌ≠sica disponÌ≠vel, <literal> envp </literal> "
"ponteiro etc. A definiÁ„o para isso È: "

#: book.translate.xml:2029
#, fuzzy
msgid ""
"<literal>boot2</literal> enters into an infinite loop waiting for user input, then "
"calls <function>load()</function>. If the user does not press anything, the loop "
"breaks by a timeout, so <function>load()</function> will load the default file "
"(<filename>/boot/loader</filename>). Functions <function>ino_t lookup(char "
"*filename)</function> and <function>int xfsread(ino_t inode, void *buf, size_t "
"nbyte)</function> are used to read the content of a file into memory. <filename>/"
"boot/loader</filename> is an <acronym>ELF</acronym> binary, but where the "
"<acronym>ELF</acronym> header is prepended with <filename>a.out</filename>'s "
"<literal>struct exec</literal> structure. <function>load()</function> scans the "
"loader's ELF header, loading the content of <filename>/boot/loader</filename> into "
"memory, and passing the execution to the loader's entry:"
msgstr ""
" <literal> boot2 </literal> entra em um loop infinito esperando por entrada do "
"usu·rio, ent„o chama <function> carga() </function> . Se o usu·rio n„o pressionar "
"nada, o loop ser· interrompido por um tempo limite, <function> carga() </function> "
"ir· carregar o arquivo padr„o ( <filename> / boot / loader </filename> ). FunÁÌµes "
"<function> pesquisa ino_t (char * filename) </function> e <function> int xfsread "
"(inodo_t inode, void * buf, tamanho_t nbyte) </function> s„o usados ‚Äã‚Äãpara ler o "
"conte˙do de um arquivo na memÛria. <filename> / boot / loader </filename> È um "
"bin·rio <acronym>ELF</acronym> , mas onde o cabeÁalho <acronym>ELF</acronym> È "
"prefixado com <filename> a.out </filename> ';s <literal> struct exec </literal> "
"estrutura. <function> carga() </function> varre o cabeÁalho ELF do carregador, "
"carregando o conte˙do do <filename> / boot / loader </filename> na memÛria e "
"passando a execuÁ„o para a entrada do carregador: "

#: book.translate.xml:2051
#, fuzzy
msgid "<application>loader</application> Stage"
msgstr " <application> carregador </application> Etapa"

#: book.translate.xml:2053
#, fuzzy
msgid ""
"<application>loader</application> is a <acronym>BTX</acronym> client as well. I will "
"not describe it here in detail, there is a comprehensive manpage written by Mike "
"Smith, <citerefentry><refentrytitle>loader</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>. The underlying mechanisms and <acronym>BTX</acronym> were discussed "
"above."
msgstr ""
" <application> carregador </application> È um cliente <acronym>BTX</acronym> tambÈm. "
"Eu n„o vou descrevÍ-lo aqui em detalhes, h· uma manpage abrangente escrito por Mike "
"Smith, <citerefentry><refentrytitle> carregador </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> . Os mecanismos subjacentes e <acronym>BTX</acronym> foram "
"discutidos acima \""

#: book.translate.xml:2058
#, fuzzy
msgid ""
"The main task for the loader is to boot the kernel. When the kernel is loaded into "
"memory, it is being called by the loader:"
msgstr ""
"A tarefa principal do carregador È inicializar o kernel. Quando o kernel È carregado "
"na memÛria, ele est· sendo chamado pelo carregador:"

#: book.translate.xml:2068
#, fuzzy
msgid "Kernel Initialization"
msgstr "InicializaÁ„o do Kernel"

#: book.translate.xml:2070
#, fuzzy
msgid ""
"Let us take a look at the command that links the kernel. This will help identify the "
"exact location where the loader passes execution to the kernel. This location is the "
"kernel's actual entry point."
msgstr ""
"Vamos dar uma olhada no comando que liga o kernel. Isso ajudar· a identificar a "
"localizaÁ„o exata onde o carregador passa a execuÁ„o para o kernel. Esta localizaÁ„o "
"È o ponto de entrada real do kernel."

#: book.translate.xml:2080
#, fuzzy
msgid "<primary>ELF</primary>"
msgstr " <primary> DUENDE </primary> "

#: book.translate.xml:2081
#, fuzzy
msgid ""
"A few interesting things can be seen here. First, the kernel is an ELF dynamically "
"linked binary, but the dynamic linker for kernel is <filename>/red/herring</"
"filename>, which is definitely a bogus file. Second, taking a look at the file "
"<filename>sys/conf/ldscript.i386</filename> gives an idea about what "
"<application>ld</application> options are used when compiling a kernel. Reading "
"through the first few lines, the string"
msgstr ""
"Algumas coisas interessantes podem ser vistas aqui. Primeiro, o kernel È um bin·rio "
"ELF dinamicamente vinculado, mas o vinculador dinÌ¢mico para o kernel È <filename> / "
"vermelho / arenque </filename> , que È definitivamente um arquivo falso. Em segundo "
"lugar, dando uma olhada no arquivo <filename> sys / conf / ldscript.i386 </filename> "
"d· uma ideia sobre o que <application> ld </application> opÁÌµes s„o usadas ao "
"compilar um kernel. Lendo as primeiras linhas, a string "

#: book.translate.xml:2093
#, fuzzy
msgid ""
"says that a kernel's entry point is the symbol `btext'. This symbol is defined in "
"<filename>locore.s</filename>:"
msgstr ""
"diz que o ponto de entrada de um kernel È o sÌ≠mbolo\" btext \". Este sÌ≠mbolo È "
"definido em <filename> locore.s </filename> : "

#: book.translate.xml:2105
#, fuzzy
msgid ""
"First, the register EFLAGS is set to a predefined value of 0x00000002. Then all the "
"segment registers are initialized:"
msgstr ""
"Primeiro, o registrador EFLAGS È configurado para um valor predefinido de "
"0x00000002. Ent„o todos os registradores de segmento s„o inicializados:"

#: book.translate.xml:2122
#, fuzzy
msgid ""
"btext calls the routines <function>recover_bootinfo()</function>, "
"<function>identify_cpu()</function>, <function>create_pagetables()</function>, which "
"are also defined in <filename>locore.s</filename>. Here is a description of what "
"they do:"
msgstr ""
"btext chama as rotinas <function> recover_bootinfo () </function> , <function> "
"identify_cpu () </function> , <function> create_pagetables () </function> , que "
"tambÈm s„o definidos em <filename> locore.s </filename> . Aqui est· uma descriÁ„o do "
"que eles fazem: "

#: book.translate.xml:2133
#, fuzzy
msgid "<function>recover_bootinfo</function>"
msgstr " <function> recover_bootinfo </function> "

#: book.translate.xml:2134
#, fuzzy
msgid ""
"This routine parses the parameters to the kernel passed from the bootstrap. The "
"kernel may have been booted in 3 ways: by the loader, described above, by the old "
"disk boot blocks, or by the old diskless boot procedure. This function determines "
"the booting method, and stores the <literal>struct bootinfo</literal> structure into "
"the kernel memory."
msgstr ""
"Esta rotina analisa os parÌ¢metros para o kernel passado a partir do bootstrap. O "
"kernel pode ter sido inicializado de 3 maneiras: pelo carregador, descrito acima, "
"pelos blocos de inicializaÁ„o de disco antigos ou pelo antigo procedimento de "
"inicializaÁ„o sem disco. Essa funÁ„o determina o mÈtodo de inicializaÁ„o, e armazena "
"o <literal> struct bootinfo </literal> estrutura na memÛria do kernel. "

#: book.translate.xml:2144
#, fuzzy
msgid "<function>identify_cpu</function>"
msgstr " <function> identify_cpu </function> "

#: book.translate.xml:2145
#, fuzzy
msgid ""
"This functions tries to find out what CPU it is running on, storing the value found "
"in a variable <varname>_cpu</varname>."
msgstr ""
"Esta funÁ„o tenta descobrir em qual CPU ela est· rodando, armazenando o valor "
"encontrado em uma vari·vel <varname> _CPU </varname> "

#: book.translate.xml:2151
#, fuzzy
msgid "<function>create_pagetables</function>"
msgstr " <function> create_pagetables </function> "

#: book.translate.xml:2152
#, fuzzy
msgid ""
"This function allocates and fills out a Page Table Directory at the top of the "
"kernel memory area."
msgstr ""
"Esta funÁ„o aloca e preenche um DiretÛrio de Tabelas de P·ginas no topo da ·rea de "
"memÛria do kernel."

#: book.translate.xml:2159
#, fuzzy
msgid "The next steps are enabling VME, if the CPU supports it:"
msgstr "Os prÛximos passos s„o habilitar o VME, se a CPU suportar:"

#: book.translate.xml:2168
#, fuzzy
msgid "Then, enabling paging:"
msgstr "Ent„o, habilitando paginaÁ„o:"

#: book.translate.xml:2177
#, fuzzy
msgid ""
"The next three lines of code are because the paging was set, so the jump is needed "
"to continue the execution in virtualized address space:"
msgstr ""
"As prÛximas trÍs linhas de cÛdigo s„o porque a paginaÁ„o foi definida, portanto, o "
"salto È necess·rio para continuar a execuÁ„o no espaÁo de endereÁo virtualizado:"

#: book.translate.xml:2187
#, fuzzy
msgid ""
"The function <function>init386()</function> is called with a pointer to the first "
"free physical page, after that <function>mi_startup()</function>. <function>init386</"
"function> is an architecture dependent initialization function, and "
"<function>mi_startup()</function> is an architecture independent one (the 'mi_' "
"prefix stands for Machine Independent). The kernel never returns from "
"<function>mi_startup()</function>, and by calling it, the kernel finishes booting:"
msgstr ""
"A funÁ„o <function> init386 () </function> È chamado com um ponteiro para a primeira "
"p·gina fÌ≠sica livre, depois disso <function> mi_startup () </function> . <function> "
"init386 </function> È uma funÁ„o de inicializaÁ„o dependente da arquitetura e "
"<function> mi_startup () </function> È uma arquitetura independente (o prefixo ';"
"mi_'; significa Independente da M·quina). O kernel nunca retorna de <function> "
"mi_startup () </function> e, ao cham·-lo, o kernel conclui a inicializaÁ„o: "

#: book.translate.xml:2204
#, fuzzy
msgid "<function>init386()</function>"
msgstr " <function> init386 () </function> "

#: book.translate.xml:2206
#, fuzzy
msgid ""
"<function>init386()</function> is defined in <filename>sys/i386/i386/machdep.c</"
"filename> and performs low-level initialization specific to the i386 chip. The "
"switch to protected mode was performed by the loader. The loader has created the "
"very first task, in which the kernel continues to operate. Before looking at the "
"code, consider the tasks the processor must complete to initialize protected mode "
"execution:"
msgstr ""
" <function> init386 () </function> È definido em <filename> sys / i386 / i386 / "
"machdep.c </filename> e executa inicializaÁ„o de baixo nÌ≠vel especÌ≠fica para o chip "
"i386. A mudanÁa para o modo protegido foi realizada pelo carregador. O carregador "
"criou a primeira tarefa, na qual o kernel continua a operar. Antes de examinar o "
"cÛdigo, considere as tarefas que o processador deve concluir para inicializar a "
"execuÁ„o do modo protegido: "

#: book.translate.xml:2217
#, fuzzy
msgid ""
"Initialize the kernel tunable parameters, passed from the bootstrapping program."
msgstr ""
"Inicialize os parÌ¢metros ajust·veis ‚Äã‚Äãdo kernel, passados ‚Äã‚Äãdo programa de "
"bootstrapping."

#: book.translate.xml:2222
#, fuzzy
msgid "Prepare the GDT."
msgstr "Prepare o GDT."

#: book.translate.xml:2226
#, fuzzy
msgid "Prepare the IDT."
msgstr "Prepare o IDT."

#: book.translate.xml:2230
#, fuzzy
msgid "Initialize the system console."
msgstr "Inicialize o console do sistema."

#: book.translate.xml:2234
#, fuzzy
msgid "Initialize the DDB, if it is compiled into kernel."
msgstr "Inicialize o DDB, se ele for compilado no kernel."

#: book.translate.xml:2239
#, fuzzy
msgid "Initialize the TSS."
msgstr "Inicialize o TSS."

#: book.translate.xml:2243
#, fuzzy
msgid "Prepare the LDT."
msgstr "Prepare o LDT."

#: book.translate.xml:2247
#, fuzzy
msgid "Set up proc0's pcb."
msgstr "Configure o pcb do proc0."

#: book.translate.xml:2251
#, fuzzy
msgid "<primary>parameters</primary>"
msgstr " <primary> ParÌ¢metros </primary> "

#: book.translate.xml:2252
#, fuzzy
msgid ""
"<function>init386()</function> initializes the tunable parameters passed from "
"bootstrap by setting the environment pointer (envp) and calling "
"<function>init_param1()</function>. The envp pointer has been passed from loader in "
"the <literal>bootinfo</literal> structure:"
msgstr ""
" <function> init386 () </function> inicializa os parÌ¢metros ajust·veis ‚Äã‚Äãpassados "
"‚Äã‚Äãdo bootstrap definindo o ponteiro de ambiente (envp) e chamando <function> "
"init_param1 () </function> . O ponteiro envp foi passado do carregador no <literal> "
"bootinfo </literal> estrutura:"

#: book.translate.xml:2264
#, fuzzy
msgid ""
"<function>init_param1()</function> is defined in <filename>sys/kern/subr_param.c</"
"filename>. That file has a number of sysctls, and two functions, "
"<function>init_param1()</function> and <function>init_param2()</function>, that are "
"called from <function>init386()</function>:"
msgstr ""
" <function> init_param1 () </function> È definido em <filename> sys / kern / "
"subr_param.c </filename> . Esse arquivo tem um n˙mero de sysctls e duas funÁÌµes, "
"<function> init_param1 () </function> e <function> init_param2 () </function> , que "
"s„o chamados de <function> init386 () </function> : "

#: book.translate.xml:2275
#, fuzzy
msgid "TUNABLE_&lt;typename&gt;_FETCH is used to fetch the value from the environment:"
msgstr "TUNABLE_ &lt;typename&gt; _FETCH È usado para buscar o valor do ambiente:"

#: book.translate.xml:2281
#, fuzzy
msgid ""
"Sysctl <literal>kern.hz</literal> is the system clock tick. Additionally, these "
"sysctls are set by <function>init_param1()</function>: <literal>kern.maxswzone, kern."
"maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern.dflssiz, kern.maxssiz, "
"kern.sgrowsiz</literal>."
msgstr ""
"Sysctl <literal> kern.hz </literal> È o tick do relÛgio do sistema. AlÈm disso, "
"esses sysctls s„o definidos por <function> init_param1 () </function> : <literal> "
"kern.maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern."
"dflssiz, kern.maxssiz, kern.sgrowsiz </literal> "

#: book.translate.xml:2287
#, fuzzy
msgid "<primary>Global Descriptors Table (GDT)</primary>"
msgstr " <primary> Tabela de Descritores Globais (GDT) </primary> "

#: book.translate.xml:2291
#, fuzzy
msgid ""
"Then <function>init386()</function> prepares the Global Descriptors Table (GDT). "
"Every task on an x86 is running in its own virtual address space, and this space is "
"addressed by a segment:offset pair. Say, for instance, the current instruction to be "
"executed by the processor lies at CS:EIP, then the linear virtual address for that "
"instruction would be <quote>the virtual address of code segment CS</quote> + EIP. "
"For convenience, segments begin at virtual address 0 and end at a 4Gb boundary. "
"Therefore, the instruction's linear virtual address for this example would just be "
"the value of EIP. Segment registers such as CS, DS etc are the selectors, i.e., "
"indexes, into GDT (to be more precise, an index is not a selector itself, but the "
"INDEX field of a selector). FreeBSD's GDT holds descriptors for 15 selectors per CPU:"
msgstr ""
"Ent„o <function> init386 () </function> prepara a Tabela de Descritores Globais "
"(GDT). Toda tarefa em um x86 est· sendo executada em seu prÛprio espaÁo de endereÁo "
"virtual e esse espaÁo È endereÁado por um par segmento: offset. Digamos, por "
"exemplo, que a instruÁ„o atual a ser executada pelo processador esteja em CS: EIP, "
"ent„o o endereÁo virtual linear para aquela instruÁ„o seria <quote> o endereÁo "
"virtual do segmento de cÛdigo CS </quote> + EIP. Por conveniÍncia, os segmentos "
"comeÁam no endereÁo virtual 0 e terminam em um limite de 4 Gb. Portanto, o endereÁo "
"virtual linear da instruÁ„o para este exemplo seria apenas o valor de EIP. Registros "
"de segmento como CS, DS etc. s„o os seletores, isto È, Ì≠ndices, em GDT (para ser "
"mais preciso, um Ì≠ndice n„o È um seletor em si, mas o campo INDEX de um seletor). O "
"GDT do FreeBSD possui descritores para 15 seletores por CPU: "

#: book.translate.xml:2330
#, fuzzy
msgid ""
"Note that those #defines are not selectors themselves, but just a field INDEX of a "
"selector, so they are exactly the indices of the GDT. for example, an actual "
"selector for the kernel code (GCODE_SEL) has the value 0x08."
msgstr ""
"Note que esses #defines n„o s„o seletores, mas apenas um campo INDEX de um seletor, "
"ent„o eles s„o exatamente os Ì≠ndices do GDT. Por exemplo, um seletor real para o "
"cÛdigo do kernel (GCODE_SEL) tem o valor 0x08."

#: book.translate.xml:2335
#, fuzzy
msgid "<primary>Interrupt Descriptor Table (IDT)</primary>"
msgstr " <primary> Tabela de descritores de interrupÁ„o (IDT) </primary> "

#: book.translate.xml:2337
#, fuzzy
msgid ""
"The next step is to initialize the Interrupt Descriptor Table (IDT). This table is "
"referenced by the processor when a software or hardware interrupt occurs. For "
"example, to make a system call, user application issues the <literal>INT 0x80</"
"literal> instruction. This is a software interrupt, so the processor's hardware "
"looks up a record with index 0x80 in the IDT. This record points to the routine that "
"handles this interrupt, in this particular case, this will be the kernel's syscall "
"gate. The IDT may have a maximum of 256 (0x100) records. The kernel allocates NIDT "
"records for the IDT, where NIDT is the maximum (256):"
msgstr ""
"O prÛximo passo È inicializar a Tabela de Descritores de InterrupÁÌµes (IDT). Essa "
"tabela È referenciada pelo processador quando ocorre uma interrupÁ„o de software ou "
"hardware. Por exemplo, para fazer uma chamada de sistema, o aplicativo de usu·rio "
"emite a <literal> INT 0x80 </literal> instruÁ„o. Esta È uma interrupÁ„o de software, "
"portanto, o hardware do processador procura um registro com o Ì≠ndice 0x80 no IDT. "
"Este registro aponta para a rotina que lida com esta interrupÁ„o, neste caso "
"particular, este ser· o syscall do kernel. O IDT pode ter um m·ximo de 256 (0x100) "
"registros. O kernel aloca registros NIDT para o IDT, onde NIDT È o m·ximo (256): "

#: book.translate.xml:2353
#, fuzzy
msgid ""
"For each interrupt, an appropriate handler is set. The syscall gate for <literal>INT "
"0x80</literal> is set as well:"
msgstr ""
"Para cada interrupÁ„o, um manipulador apropriado È definido. O syscall gate para "
"<literal> INT 0x80 </literal> est· definido tambÈm: "

#: book.translate.xml:2361
#, fuzzy
msgid ""
"So when a userland application issues the <literal>INT 0x80</literal> instruction, "
"control will transfer to the function <function>_Xint0x80_syscall</function>, which "
"is in the kernel code segment and will be executed with supervisor privileges."
msgstr ""
"Ent„o, quando um aplicativo userland emite o <literal> INT 0x80 </literal> "
"instruÁ„o, controle ir· transferir para a funÁ„o <function> _Xint0x80_syscall </"
"function> , que est· no segmento de cÛdigo do kernel e ser· executado com "
"privilÈgios de supervisor. "

#: book.translate.xml:2367
#, fuzzy
msgid "Console and DDB are then initialized:"
msgstr "Console e DDB s„o inicializados:"

#: book.translate.xml:2368
#, fuzzy
msgid "<primary>DDB</primary>"
msgstr " <primary> DDB </primary> "

#: book.translate.xml:2379
#, fuzzy
msgid ""
"The Task State Segment is another x86 protected mode structure, the TSS is used by "
"the hardware to store task information when a task switch occurs."
msgstr ""
"O segmento de estado da tarefa È outra estrutura de modo protegido x86, o TSS È "
"usado pelo hardware para armazenar informaÁÌµes de tarefa quando ocorre uma alternÌ"
"¢ncia de tarefa."

#: book.translate.xml:2383
#, fuzzy
msgid ""
"The Local Descriptors Table is used to reference userland code and data. Several "
"selectors are defined to point to the LDT, they are the system call gates and the "
"user code and data selectors:"
msgstr ""
"A Tabela de Descritores Locais È usada para referenciar cÛdigos e dados da terra do "
"usu·rio. V·rios seletores s„o definidos para apontar para o LDT, eles s„o as portas "
"de chamada do sistema e os seletores de cÛdigo e dados do usu·rio:"

#: book.translate.xml:2400
#, fuzzy
msgid ""
"Next, proc0's Process Control Block (<literal>struct pcb</literal>) structure is "
"initialized. proc0 is a <literal>struct proc</literal> structure that describes a "
"kernel process. It is always present while the kernel is running, therefore it is "
"declared as global:"
msgstr ""
"Em seguida, o bloco de controle de processo do proc0 ( <literal> pcb struct </"
"literal> ) estrutura È inicializada. proc0 È um <literal> struct proc </literal> "
"estrutura que descreve um processo do kernel. Est· sempre presente enquanto o kernel "
"est· rodando, portanto È declarado como global: "

#: book.translate.xml:2409
#, fuzzy
msgid ""
"The structure <literal>struct pcb</literal> is a part of a proc structure. It is "
"defined in <filename>/usr/include/machine/pcb.h</filename> and has a process's "
"information specific to the i386 architecture, such as registers values."
msgstr ""
"A estrutura <literal> pcb struct </literal> faz parte de uma estrutura proc. Est· "
"definido em <filename> /usr/include/machine/pcb.h </filename> e possui uma "
"informaÁ„o especÌ≠fica do processo para a arquitetura i386, como valores de "
"registros. "

#: book.translate.xml:2417
#, fuzzy
msgid "<function>mi_startup()</function>"
msgstr " <function> mi_startup () </function> "

#: book.translate.xml:2419
#, fuzzy
msgid ""
"This function performs a bubble sort of all the system initialization objects and "
"then calls the entry of each object one by one:"
msgstr ""
"Esta funÁ„o executa um tipo de bolha de todos os objetos de inicializaÁ„o do sistema "
"e, em seguida, chama a entrada de cada objeto, um por um:"

#: book.translate.xml:2433
#, fuzzy
msgid ""
"Although the sysinit framework is described in the <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/developers-handbook\">Developers' "
"Handbook</link>, I will discuss the internals of it."
msgstr ""
"Embora o framework sysinit seja descrito no <link xlink:href=\"@@URL_RELPREFIX@@/doc/"
"en_US.ISO8859-1/books/developers-handbook\"> Manual dos Desenvolvedores </link> , "
"Vou discutir os aspectos internos dele. "

#: book.translate.xml:2436
#, fuzzy
msgid "<primary>sysinit objects</primary>"
msgstr " <primary> objetos sysinit </primary> "

#: book.translate.xml:2437
#, fuzzy
msgid ""
"Every system initialization object (sysinit object) is created by calling a "
"SYSINIT() macro. Let us take as example an <literal>announce</literal> sysinit "
"object. This object prints the copyright message:"
msgstr ""
"Todo objeto de inicializaÁ„o do sistema (objeto sysinit) È criado chamando uma macro "
"SYSINIT (). Vamos tomar como exemplo <literal> anunciar </literal> objeto sysinit. "
"Este objeto imprime a mensagem de direitos autorais: "

#: book.translate.xml:2450
#, fuzzy
msgid ""
"The subsystem ID for this object is SI_SUB_COPYRIGHT (0x0800001), which comes right "
"after the SI_SUB_CONSOLE (0x0800000). So, the copyright message will be printed out "
"first, just after the console initialization."
msgstr ""
"O ID do subsistema para este objeto È SI_SUB_COPYRIGHT (0x0800001), que vem logo "
"apÛs o SI_SUB_CONSOLE (0x0800000). Assim, a mensagem de copyright ser· impressa "
"primeiro, logo apÛs a inicializaÁ„o do console."

#: book.translate.xml:2455
#, fuzzy
msgid ""
"Let us take a look at what exactly the macro <literal>SYSINIT()</literal> does. It "
"expands to a <literal>C_SYSINIT()</literal> macro. The <literal>C_SYSINIT()</"
"literal> macro then expands to a static <literal>struct sysinit</literal> structure "
"declaration with another <literal>DATA_SET</literal> macro call:"
msgstr ""
"Vamos dar uma olhada no que exatamente a macro <literal> SYSINIT () </literal> faz. "
"Ele se expande para um <literal> C_SYSINIT () </literal> macro. o <literal> "
"C_SYSINIT () </literal> macro, em seguida, se expande para uma est·tica <literal> "
"struct sysinit </literal> declaraÁ„o de estrutura com outro <literal> DATA_SET </"
"literal> chamada macro: "

#: book.translate.xml:2472
#, fuzzy
msgid ""
"The <literal>DATA_SET()</literal> macro expands to a <literal>MAKE_SET()</literal>, "
"and that macro is the point where all the sysinit magic is hidden:"
msgstr ""
"O <literal> DATA_SET () </literal> macro se expande para um <literal> MAKE_SET () </"
"literal> e essa macro È o ponto onde toda a magia sysinit est· escondida: "

#: book.translate.xml:2486
#, fuzzy
msgid "In our case, the following declaration will occur:"
msgstr "No nosso caso, a seguinte declaraÁ„o ir· ocorrer:"

#: book.translate.xml:2501
#, fuzzy
msgid ""
"The first <literal>__asm</literal> instruction will create an ELF section within the "
"kernel's executable. This will happen at kernel link time. The section will have the "
"name <literal>.set.sysinit_set</literal>. The content of this section is one 32-bit "
"value, the address of announce_sys_init structure, and that is what the second "
"<literal>__asm</literal> is. The third <literal>__asm</literal> instruction marks "
"the end of a section. If a directive with the same section name occurred before, the "
"content, i.e., the 32-bit value, will be appended to the existing section, so "
"forming an array of 32-bit pointers."
msgstr ""
"O primeiro <literal> __asm </literal> instruÁ„o ir· criar uma seÁ„o ELF dentro do "
"execut·vel do kernel. Isso acontecer· no momento do link do kernel. A seÁ„o ter· o "
"nome <literal> .set.sysinit_set </literal> . O conte˙do desta seÁ„o È um valor de 32 "
"bits, o endereÁo da estrutura announce_sys_init, e È isso que o segundo <literal> "
"__asm </literal> È. O terceiro <literal> __asm </literal> instruÁ„o marca o fim de "
"uma seÁ„o. Se uma diretiva com o mesmo nome de seÁ„o ocorreu antes, o conte˙do, ou "
"seja, o valor de 32 bits, ser· anexado Ì† seÁ„o existente, formando assim uma matriz "
"de ponteiros de 32 bits. "

#: book.translate.xml:2514
#, fuzzy
msgid ""
"Running <application>objdump</application> on a kernel binary, you may notice the "
"presence of such small sections:"
msgstr ""
"Corrida <application> objdump </application> em um bin·rio do kernel, vocÍ pode "
"notar a presenÁa de seÁÌµes t„o pequenas: "

#: book.translate.xml:2532
#, fuzzy
msgid ""
"This screen dump shows that the size of .set.sysinit_set section is 0x664 bytes, so "
"<literal>0x664/sizeof(void *)</literal> sysinit objects are compiled into the "
"kernel. The other sections such as <literal>.set.sysctl_set</literal> represent "
"other linker sets."
msgstr ""
"Este dump de tela mostra que o tamanho da seÁ„o .set.sysinit_set È 0x664 bytes, "
"ent„o <literal> 0x664 / sizeof (void *) </literal> objetos sysinit s„o compilados no "
"kernel. As outras seÁÌµes, como <literal> .set.sysctl_set </literal> representam "
"outros conjuntos de linkers. "

#: book.translate.xml:2538
#, fuzzy
msgid ""
"By defining a variable of type <literal>struct linker_set</literal> the content of "
"<literal>.set.sysinit_set</literal> section will be <quote>collected</quote> into "
"that variable:"
msgstr ""
"Definindo uma vari·vel do tipo <literal> struct linker_set </literal> o conte˙do de "
"<literal> .set.sysinit_set </literal> seÁ„o ser· <quote> coletado </quote> para essa "
"vari·vel: "

#: book.translate.xml:2546
#, fuzzy
msgid "The <literal>struct linker_set</literal> is defined as follows:"
msgstr "O <literal> struct linker_set </literal> È definido da seguinte forma: "

#: book.translate.xml:2555
#, fuzzy
msgid ""
"The first node will be equal to the number of a sysinit objects, and the second node "
"will be a NULL-terminated array of pointers to them."
msgstr ""
"O primeiro nÛ ser· igual ao n˙mero de objetos sysinit, e o segundo nÛ ser· uma "
"matriz terminada em NULL de ponteiros para eles."

#: book.translate.xml:2559
#, fuzzy
msgid ""
"Returning to the <function>mi_startup()</function> discussion, it is must be clear "
"now, how the sysinit objects are being organized. The <function>mi_startup()</"
"function> function sorts them and calls each. The very last object is the system "
"scheduler:"
msgstr ""
"Voltando ao <function> mi_startup () </function> discuss„o, È preciso estar claro "
"agora, como os objetos sysinit est„o sendo organizados. o <function> mi_startup () </"
"function> funÁ„o classifica-los e chama cada um. O ˙ltimo objeto È o agendador do "
"sistema: "

#: book.translate.xml:2575
#, fuzzy
msgid ""
"The system scheduler sysinit object is defined in the file <filename>sys/vm/vm_glue."
"c</filename>, and the entry point for that object is <function>scheduler()</"
"function>. That function is actually an infinite loop, and it represents a process "
"with PID 0, the swapper process. The proc0 structure, mentioned before, is used to "
"describe it."
msgstr ""
"O objeto sysinit do planejador do sistema È definido no arquivo <filename> sys / "
"vm / vm_glue.c </filename> , e o ponto de entrada para esse objeto È <function> "
"Agendador() </function> . Essa funÁ„o È na verdade um loop infinito e representa um "
"processo com PID 0, o processo de swapper. A estrutura proc0, mencionada "
"anteriormente, È usada para descrevÍ-la. "

#: book.translate.xml:2582
#, fuzzy
msgid ""
"The first user process, called <emphasis>init</emphasis>, is created by the sysinit "
"object <literal>init</literal>:"
msgstr ""
"O primeiro processo do usu·rio, chamado <emphasis> nisso </emphasis> , È criado pelo "
"objeto sysinit <literal> nisso </literal> : "

#: book.translate.xml:2604
#, fuzzy
msgid ""
"The <function>create_init()</function> allocates a new process by calling "
"<function>fork1()</function>, but does not mark it runnable. When this new process "
"is scheduled for execution by the scheduler, the <function>start_init()</function> "
"will be called. That function is defined in <filename>init_main.c</filename>. It "
"tries to load and exec the <filename>init</filename> binary, probing <filename>/sbin/"
"init</filename> first, then <filename>/sbin/oinit</filename>, <filename>/sbin/init."
"bak</filename>, and finally <filename>/stand/sysinstall</filename>:"
msgstr ""
"O <function> create_init () </function> aloca um novo processo chamando <function> "
"fork1 () </function> , mas n„o o marca execut·vel. Quando este novo processo È "
"agendado para execuÁ„o pelo agendador, o <function> start_init () </function> ser· "
"chamado. Essa funÁ„o È definida em <filename> init_main.c </filename> . Ele tenta "
"carregar e executar o <filename> nisso </filename> bin·rio, sondando <filename> / "
"sbin / init </filename> primeiro, ent„o <filename> / sbin / oinit </filename> , "
"<filename> /sbin/init.bak </filename> , e finalmente <filename> / stand / sysinstall "
"</filename> : "

#: book.translate.xml:2635
#, fuzzy
msgid "Locking Notes"
msgstr "Notas de Bloqueio"

#: book.translate.xml:2637
#, fuzzy
msgid "<primary>SMP Next Generation Project</primary>"
msgstr " <primary> Projeto SMP Next Generation </primary> "

#: book.translate.xml:2638
#, fuzzy
msgid ""
"<emphasis>This chapter is maintained by the FreeBSD SMP Next Generation Project.</"
"emphasis>"
msgstr ""
" <emphasis> Este capÌ≠tulo È mantido pelo projeto FreeBSD SMP Next Generation. </"
"emphasis> "

#: book.translate.xml:2641
#, fuzzy
msgid "<primary>locking</primary>"
msgstr " <primary> bloqueio </primary> "

#: book.translate.xml:2642
#, fuzzy
msgid "<primary>multi-processing</primary>"
msgstr " <primary> multiprocessamento </primary> "

#: book.translate.xml:2643
#, fuzzy
msgid "<primary>mutexes</primary>"
msgstr " <primary> mutexes </primary> "

#: book.translate.xml:2644
#, fuzzy
msgid "<primary>lockmgr</primary>"
msgstr " <primary> lockmgr </primary> "

#: book.translate.xml:2645
#, fuzzy
msgid "<primary>atomic operations</primary>"
msgstr " <primary> operaÁÌµes atÌ¥micas </primary> "

#: book.translate.xml:2646
#, fuzzy
msgid ""
"This document outlines the locking used in the FreeBSD kernel to permit effective "
"multi-processing within the kernel. Locking can be achieved via several means. Data "
"structures can be protected by mutexes or <citerefentry><refentrytitle>lockmgr</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> locks. A few variables are "
"protected simply by always using atomic operations to access them."
msgstr ""
"Este documento descreve o bloqueio usado no kernel do FreeBSD para permitir um "
"multiprocessamento efetivo dentro do kernel. O bloqueio pode ser alcanÁado atravÈs "
"de v·rios meios. As estruturas de dados podem ser protegidas por mutexes ou "
"<citerefentry><refentrytitle> lockmgr </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> fechaduras. Algumas vari·veis ‚Äã‚Äãs„o protegidas simplesmente por usar "
"sempre operaÁÌµes atÌ¥micas para acess·-las. "

#: book.translate.xml:2654
#, fuzzy
msgid "Mutexes"
msgstr "Mutexes"

#: book.translate.xml:2656
#, fuzzy
msgid ""
"A mutex is simply a lock used to guarantee mutual exclusion. Specifically, a mutex "
"may only be owned by one entity at a time. If another entity wishes to obtain a "
"mutex that is already owned, it must wait until the mutex is released. In the "
"FreeBSD kernel, mutexes are owned by processes."
msgstr ""
"Um mutex È simplesmente um bloqueio usado para garantir a exclus„o m˙tua. "
"Especificamente, um mutex sÛ pode pertencer a uma entidade por vez. Se outra "
"entidade desejar obter um mutex que j· È de propriedade, ele deve aguardar atÈ que o "
"mutex seja liberado. No kernel do FreeBSD, os mutexes s„o de propriedade de "
"processos. "

#: book.translate.xml:2662
#, fuzzy
msgid ""
"Mutexes may be recursively acquired, but they are intended to be held for a short "
"period of time. Specifically, one may not sleep while holding a mutex. If you need "
"to hold a lock across a sleep, use a <citerefentry><refentrytitle>lockmgr</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> lock."
msgstr ""
"Mutexes podem ser recursivamente adquiridos, mas eles devem ser mantidos por um "
"curto perÌ≠odo de tempo. Especificamente, um n„o pode dormir enquanto segura um "
"mutex. Se vocÍ precisar segurar uma trava atravÈs de um sono, use um "
"<citerefentry><refentrytitle> lockmgr </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> bloqueio \""

#: book.translate.xml:2667
#, fuzzy
msgid "Each mutex has several properties of interest:"
msgstr "Cada mutex tem v·rias propriedades de interesse:"

#: book.translate.xml:2918 book.translate.xml:2758 book.translate.xml:2671
#, fuzzy
msgid "Variable Name"
msgstr "Nome vari·vel"

#: book.translate.xml:2673
#, fuzzy
msgid "The name of the <type>struct mtx</type> variable in the kernel source."
msgstr "O nome do <type> struct mtx </type> vari·vel na fonte do kernel. "

#: book.translate.xml:2759 book.translate.xml:2679
#, fuzzy
msgid "Logical Name"
msgstr "Nome lÛgico"

#: book.translate.xml:2681
#, fuzzy
msgid ""
"The name of the mutex assigned to it by <function>mtx_init</function>. This name is "
"displayed in KTR trace messages and witness errors and warnings and is used to "
"distinguish mutexes in the witness code."
msgstr ""
"O nome do mutex atribuÌ≠do a ele por <function> mtx_init </function> . Esse nome È "
"exibido em mensagens de rastreamento KTR e testemunha de erros e avisos e È usado "
"para distinguir mutexes no cÛdigo da testemunha. "

#: book.translate.xml:2760 book.translate.xml:2689
#, fuzzy
msgid "Type"
msgstr "Tipo"

#: book.translate.xml:2691
#, fuzzy
msgid ""
"The type of the mutex in terms of the <constant>MTX_*</constant> flags. The meaning "
"for each flag is related to its meaning as documented in "
"<citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>."
msgstr ""
"O tipo do mutex em termos de <constant> MTX_ * </constant> bandeiras. O significado "
"para cada bandeira est· relacionado ao seu significado conforme documentado em "
"<citerefentry><refentrytitle> mutex </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> "

#: book.translate.xml:2851 book.translate.xml:2698
#, fuzzy
msgid "<constant>MTX_DEF</constant>"
msgstr " <constant> MTX_DEF </constant> "

#: book.translate.xml:2700
#, fuzzy
msgid "A sleep mutex"
msgstr "Um mutex do sono"

#: book.translate.xml:2705
#, fuzzy
msgid "<constant>MTX_SPIN</constant>"
msgstr " <constant> MTX_SPIN </constant> "

#: book.translate.xml:2707
#, fuzzy
msgid "A spin mutex"
msgstr "Um mutex spin"

#: book.translate.xml:2712
#, fuzzy
msgid "<constant>MTX_RECURSE</constant>"
msgstr " <constant> MTX_RECURSE </constant> "

#: book.translate.xml:2714
#, fuzzy
msgid "This mutex is allowed to recurse."
msgstr "Esse mutex pode recorrer."

#: book.translate.xml:2919 book.translate.xml:2761 book.translate.xml:2722
#, fuzzy
msgid "Protectees"
msgstr "Protegidos"

#: book.translate.xml:2724
#, fuzzy
msgid ""
"A list of data structures or data structure members that this entry protects. For "
"data structure members, the name will be in the form of <varname remap=\"structname"
"\">structure name</varname>.<varname remap=\"structfield\">member name</varname>."
msgstr ""
"Uma lista de estruturas de dados ou membros da estrutura de dados que esta entrada "
"protege. Para membros da estrutura de dados, o nome estar· na forma de <varname "
"remap=\"structname\"> nome da estrutura </varname> . <varname remap=\"structfield\"> "
"nome do membro </varname> "

#: book.translate.xml:2762 book.translate.xml:2732
#, fuzzy
msgid "Dependent Functions"
msgstr "FunÁÌµes dependentes"

#: book.translate.xml:2734
#, fuzzy
msgid "Functions that can only be called if this mutex is held."
msgstr "FunÁÌµes que sÛ podem ser chamadas se este mutex for mantido."

#: book.translate.xml:2741
#, fuzzy
msgid "Mutex List"
msgstr "Lista Mutex"

#: book.translate.xml:2743
#, fuzzy
msgid "<primary>locks</primary> <secondary>sched_lock</secondary>"
msgstr " <primary> fechaduras </primary><secondary> sched_lock </secondary> "

#: book.translate.xml:2746
#, fuzzy
msgid "<primary>locks</primary> <secondary>vm86pcb_lock</secondary>"
msgstr " <primary> fechaduras </primary><secondary> vm86pcb_lock </secondary> "

#: book.translate.xml:2749
#, fuzzy
msgid "<primary>locks</primary> <secondary>Giant</secondary>"
msgstr " <primary> fechaduras </primary><secondary> Gigante </secondary> "

#: book.translate.xml:2752
#, fuzzy
msgid "<primary>locks</primary> <secondary>callout_lock</secondary>"
msgstr " <primary> fechaduras </primary><secondary> callout_lock </secondary> "

#: book.translate.xml:2769
#, fuzzy
msgid "sched_lock"
msgstr "sched_lock"

#: book.translate.xml:2770
#, fuzzy
msgid "<quote>sched lock</quote>"
msgstr " <quote> bloqueio de programaÁ„o </quote> "

#: book.translate.xml:2878 book.translate.xml:2771
#, fuzzy
msgid "<constant>MTX_SPIN</constant> | <constant>MTX_RECURSE</constant>"
msgstr " <constant> MTX_SPIN </constant> | <constant> MTX_RECURSE </constant> "

#: book.translate.xml:2825
#, fuzzy
msgid ""
"<function>setrunqueue</function>, <function>remrunqueue</function>, "
"<function>mi_switch</function>, <function>chooseproc</function>, "
"<function>schedclock</function>, <function>resetpriority</function>, "
"<function>updatepri</function>, <function>maybe_resched</function>, "
"<function>cpu_switch</function>, <function>cpu_throw</function>, "
"<function>need_resched</function>, <function>resched_wanted</function>, "
"<function>clear_resched</function>, <function>aston</function>, <function>astoff</"
"function>, <function>astpending</function>, <function>calcru</function>, "
"<function>proc_compare</function>"
msgstr ""
" <function> setrunqueue </function> , <function> remrunqueue </function> , "
"<function> mi_switch </function> , <function> chooseproc </function> , <function> "
"schedclock </function> , <function> resetpriority </function> , <function> updatepri "
"</function> , <function> maybe_resched </function> , <function> cpu_switch </"
"function> , <function> cpu_throw </function> , <function> need_resched </function> , "
"<function> resched_wanted </function> , <function> clear_resched </function> , "
"<function> aston </function> , <function> astoff </function> , <function> aspendendo "
"</function> , <function> calcru </function> , <function> proc_compare </function> "

#: book.translate.xml:2849
#, fuzzy
msgid "vm86pcb_lock"
msgstr "vm86pcb_lock"

#: book.translate.xml:2850
#, fuzzy
msgid "<quote>vm86pcb lock</quote>"
msgstr " <quote> bloqueio vm86pcb </quote> "

#: book.translate.xml:2854
#, fuzzy
msgid "<varname>vm86pcb</varname>"
msgstr " <varname> vm86pcb </varname> "

#: book.translate.xml:2857
#, fuzzy
msgid "<function>vm86_bioscall</function>"
msgstr " <function> vm86_bioscall </function> "

#: book.translate.xml:2864
#, fuzzy
msgid "Giant"
msgstr "Gigante"

#: book.translate.xml:2865
#, fuzzy
msgid "<quote>Giant</quote>"
msgstr " <quote> Gigante </quote> "

#: book.translate.xml:2866
#, fuzzy
msgid "<constant>MTX_DEF</constant> | <constant>MTX_RECURSE</constant>"
msgstr " <constant> MTX_DEF </constant> | <constant> MTX_RECURSE </constant> "

#: book.translate.xml:2870
#, fuzzy
msgid "nearly everything"
msgstr "quase tudo"

#: book.translate.xml:2871
#, fuzzy
msgid "lots"
msgstr "grande quantidade"

#: book.translate.xml:2876
#, fuzzy
msgid "callout_lock"
msgstr "callout_lock"

#: book.translate.xml:2877
#, fuzzy
msgid "<quote>callout lock</quote>"
msgstr " <quote> bloqueio de texto explicativo </quote> "

#: book.translate.xml:2882
#, fuzzy
msgid ""
"<varname>callfree</varname>, <varname>callwheel</varname>, <varname>nextsoftcheck</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_itcallout</varname>, <varname remap=\"structname\">proc</varname>.<varname "
"remap=\"structfield\">p_slpcallout</varname>, <varname>softticks</varname>, "
"<varname>ticks</varname>"
msgstr ""
" <varname> callfree </varname> , <varname> volante </varname> , <varname> "
"nextsoftcheck </varname> , <varname remap=\"structname\"> proc </varname> . <varname "
"remap=\"structfield\"> p_itcallout </varname> , <varname remap=\"structname\"> proc "
"</varname> . <varname remap=\"structfield\"> p_slpcallout </varname> , <varname> "
"softticks </varname> , <varname> carrapatos </varname> "

#: book.translate.xml:2900
#, fuzzy
msgid "Shared Exclusive Locks"
msgstr "Bloqueios exclusivos compartilhados"

#: book.translate.xml:2902
#, fuzzy
msgid ""
"These locks provide basic reader-writer type functionality and may be held by a "
"sleeping process. Currently they are backed by <citerefentry><refentrytitle>lockmgr</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>."
msgstr ""
"Esses bloqueios fornecem funcionalidade b·sica do tipo leitor-gravador e podem ser "
"mantidos por um processo de suspens„o. Atualmente, eles s„o protegidos por "
"<citerefentry><refentrytitle> lockmgr </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> "

#: book.translate.xml:2905
#, fuzzy
msgid "<primary>locks</primary> <secondary>shared exclusive</secondary>"
msgstr ""
" <primary> fechaduras </primary><secondary> exclusivo compartilhado </secondary> "

#: book.translate.xml:2909
#, fuzzy
msgid "Shared Exclusive Lock List"
msgstr "Lista de bloqueio exclusiva compartilhada"

#: book.translate.xml:2910
#, fuzzy
msgid "<primary>locks</primary> <secondary>allproc_lock</secondary>"
msgstr " <primary> fechaduras </primary><secondary> allproc_lock </secondary> "

#: book.translate.xml:2912
#, fuzzy
msgid "<primary>locks</primary> <secondary>proctree_lock</secondary>"
msgstr " <primary> fechaduras </primary><secondary> proctree_lock </secondary> "

#: book.translate.xml:2924
#, fuzzy
msgid "<varname>allproc_lock</varname>"
msgstr " <varname> allproc_lock </varname> "

#: book.translate.xml:2925
#, fuzzy
msgid ""
"<varname>allproc</varname> <varname>zombproc</varname> <varname>pidhashtbl</varname> "
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield\">p_list</"
"varname> <varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_hash</varname> <varname>nextpid</varname>"
msgstr ""
" <varname> allproc </varname><varname> zombproc </varname><varname> pidhashtbl </"
"varname><varname remap=\"structname\"> proc </varname> . <varname remap=\"structfield"
"\"> p_list </varname><varname remap=\"structname\"> proc </varname> . <varname remap="
"\"structfield\"> p_hash </varname><varname> nextpid </varname> "

#: book.translate.xml:2935
#, fuzzy
msgid "<varname>proctree_lock</varname>"
msgstr " <varname> proctree_lock </varname> "

#: book.translate.xml:2936
#, fuzzy
msgid ""
"<varname remap=\"structname\">proc</varname>.<varname remap=\"structfield"
"\">p_children</varname> <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sibling</varname>"
msgstr ""
" <varname remap=\"structname\"> proc </varname> . <varname remap=\"structfield\"> "
"p_children </varname><varname remap=\"structname\"> proc </varname> . <varname remap="
"\"structfield\"> p_sibling </varname> "

#: book.translate.xml:2947
#, fuzzy
msgid "Atomically Protected Variables"
msgstr "Vari·veis ‚Äã‚ÄãAtomicamente Protegidas"

#: book.translate.xml:2949
#, fuzzy
msgid "<primary>atomically protected variables</primary>"
msgstr " <primary> vari·veis ‚Äã‚Äãatomicamente protegidas </primary> "

#: book.translate.xml:2951
#, fuzzy
msgid ""
"An atomically protected variable is a special variable that is not protected by an "
"explicit lock. Instead, all data accesses to the variables use special atomic "
"operations as described in <citerefentry><refentrytitle>atomic</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>. Very few variables are "
"treated this way, although other synchronization primitives such as mutexes are "
"implemented with atomically protected variables."
msgstr ""
"Uma vari·vel atomicamente protegida È uma vari·vel especial que n„o È protegida por "
"um bloqueio explÌ≠cito. Em vez disso, todos os acessos a dados para as vari·veis "
"‚Äã‚Äãusam operaÁÌµes atÌ¥micas especiais, como descrito em "
"<citerefentry><refentrytitle> atÌ¥mico </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> . Muito poucas vari·veis ‚Äã‚Äãs„o tratadas dessa maneira, embora outras "
"primitivas de sincronizaÁ„o, como mutexes, sejam implementadas com vari·veis "
"‚Äã‚Äãprotegidas atomicamente. "

#: book.translate.xml:2977
#, fuzzy
msgid "<primary>Object-Oriented</primary>"
msgstr " <primary> Orientado a Objeto </primary> "

#: book.translate.xml:2978
#, fuzzy
msgid "<primary>binary compatibility</primary>"
msgstr " <primary> compatibilidade bin·ria </primary> "

#: book.translate.xml:2979
#, fuzzy
msgid ""
"Kernel Objects, or <firstterm>Kobj</firstterm> provides an object-oriented C "
"programming system for the kernel. As such the data being operated on carries the "
"description of how to operate on it. This allows operations to be added and removed "
"from an interface at run time and without breaking binary compatibility."
msgstr ""
"Objetos do Kernel, ou <firstterm> Kobj </firstterm> fornece um sistema de "
"programaÁ„o C orientado a objeto para o kernel. Como tal, os dados que est„o sendo "
"operados contÍm a descriÁ„o de como oper·-lo. Isso permite que as operaÁÌµes sejam "
"adicionadas e removidas de uma interface em tempo de execuÁ„o e sem quebrar a "
"compatibilidade bin·ria. "

#: book.translate.xml:4050 book.translate.xml:2987
#, fuzzy
msgid "Terminology"
msgstr "Terminologia"

#: book.translate.xml:2989
#, fuzzy
msgid "<primary>object</primary>"
msgstr " <primary> objeto </primary> "

#: book.translate.xml:2990
#, fuzzy
msgid "<primary>method</primary>"
msgstr " <primary> mÈtodo </primary> "

#: book.translate.xml:2991
#, fuzzy
msgid "<primary>class</primary>"
msgstr " <primary> classe </primary> "

#: book.translate.xml:2992
#, fuzzy
msgid "<primary>interface</primary>"
msgstr " <primary> interface </primary> "

#: book.translate.xml:2996
#, fuzzy
msgid "Object"
msgstr "Objeto"

#: book.translate.xml:2997
#, fuzzy
msgid "A set of data - data structure - data allocation."
msgstr "Um conjunto de dados - estrutura de dados - alocaÁ„o de dados."

#: book.translate.xml:3002
#, fuzzy
msgid "Method"
msgstr "MÈtodo"

#: book.translate.xml:3004
#, fuzzy
msgid "An operation - function."
msgstr "Uma operaÁ„o - funÁ„o."

#: book.translate.xml:3008
#, fuzzy
msgid "Class"
msgstr "Classe"

#: book.translate.xml:3010
#, fuzzy
msgid "One or more methods."
msgstr "Um ou mais mÈtodos."

#: book.translate.xml:4111 book.translate.xml:3014
#, fuzzy
msgid "Interface"
msgstr "Interface"

#: book.translate.xml:3016
#, fuzzy
msgid "A standard set of one or more methods."
msgstr "Um conjunto padr„o de um ou mais mÈtodos."

#: book.translate.xml:3023
#, fuzzy
msgid "Kobj Operation"
msgstr "OperaÁ„o Kobj"

#: book.translate.xml:3025
#, fuzzy
msgid ""
"Kobj works by generating descriptions of methods. Each description holds a unique id "
"as well as a default function. The description's address is used to uniquely "
"identify the method within a class' method table."
msgstr ""
"O Kobj funciona gerando descriÁÌµes de mÈtodos. Cada descriÁ„o possui um ID ˙nico, "
"bem como uma funÁ„o padr„o. O endereÁo da descriÁ„o È usado para identificar "
"exclusivamente o mÈtodo dentro da tabela de mÈtodos de uma classe."

#: book.translate.xml:3030
#, fuzzy
msgid ""
"A class is built by creating a method table associating one or more functions with "
"method descriptions. Before use the class is compiled. The compilation allocates a "
"cache and associates it with the class. A unique id is assigned to each method "
"description within the method table of the class if not already done so by another "
"referencing class compilation. For every method to be used a function is generated "
"by script to qualify arguments and automatically reference the method description "
"for a lookup. The generated function looks up the method by using the unique id "
"associated with the method description as a hash into the cache associated with the "
"object's class. If the method is not cached the generated function proceeds to use "
"the class' table to find the method. If the method is found then the associated "
"function within the class is used; otherwise, the default function associated with "
"the method description is used."
msgstr ""
"Uma classe È construÌ≠da criando uma tabela de mÈtodos associando uma ou mais "
"funÁÌµes com descriÁÌµes de mÈtodos. Antes de usar, a classe È compilada. A "
"compilaÁ„o aloca um cache e o associa Ì† classe. Um ID ˙nico È atribuÌ≠do a cada "
"descriÁ„o de mÈtodo dentro do mÈtodo. tabela da classe, se ainda n„o tiver sido "
"feita por outra compilaÁ„o de classe de referÍncia.Para cada mÈtodo a ser usado, uma "
"funÁ„o È gerada pelo script para qualificar argumentos e automaticamente referenciar "
"a descriÁ„o do mÈtodo para uma pesquisa.A funÁ„o gerada procura o mÈtodo usando a ID "
"˙nico associado Ì† descriÁ„o do mÈtodo como um hash no cache associado Ì† classe do "
"objeto.Se o mÈtodo n„o È armazenado em cache, a funÁ„o gerada continua a usar a "
"tabela da classe para localizar o mÈtodo.Se o mÈtodo for encontrado, a funÁ„o "
"associada a classe È usada, caso contr·rio, a funÁ„o padr„o associada Ì† descriÁ„o "
"do mÈtodo È usada. "

#: book.translate.xml:3047
#, fuzzy
msgid "These indirections can be visualized as the following:"
msgstr "Essas indireÁÌµes podem ser visualizadas da seguinte forma:"

#: book.translate.xml:3055
#, fuzzy
msgid "Using Kobj"
msgstr "Usando o Kobj"

#: book.translate.xml:3058
#, fuzzy
msgid "Structures"
msgstr "Estruturas"

#: book.translate.xml:3064
#, fuzzy
msgid "Functions"
msgstr "FunÁÌµes"

#: book.translate.xml:4120 book.translate.xml:3075
#, fuzzy
msgid "Macros"
msgstr "Macros"

#: book.translate.xml:4114 book.translate.xml:3084
#, fuzzy
msgid "Headers"
msgstr "CabeÁalhos"

#: book.translate.xml:3091
#, fuzzy
msgid "Creating an Interface Template"
msgstr "Criando um modelo de interface"

#: book.translate.xml:3093
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>interface</secondary>"
msgstr " <primary> Objetos do Kernel </primary><secondary> interface </secondary> "

#: book.translate.xml:3096
#, fuzzy
msgid ""
"The first step in using Kobj is to create an Interface. Creating the interface "
"involves creating a template that the script <filename>src/sys/kern/makeobjops.pl</"
"filename> can use to generate the header and code for the method declarations and "
"method lookup functions."
msgstr ""
"O primeiro passo para usar o Kobj È criar uma interface. Criar a interface envolve "
"criar um modelo que o script <filename> src / sys / kern / makeobjops.pl </filename> "
"pode usar para gerar o cabeÁalho e cÛdigo para as declaraÁÌµes de mÈtodo e funÁÌµes "
"de pesquisa de mÈtodo. "

#: book.translate.xml:3103
#, fuzzy
msgid ""
"Within this template the following keywords are used: <literal>#include</literal>, "
"<literal>INTERFACE</literal>, <literal>CODE</literal>, <literal>METHOD</literal>, "
"<literal>STATICMETHOD</literal>, and <literal>DEFAULT</literal>."
msgstr ""
"Nesse modelo, as seguintes palavras-chave s„o usadas: <literal> #incluir </"
"literal> , <literal> INTERFACE </literal> , <literal> CÌìDIGO </literal> , <literal> "
"MÌâTODO </literal> , <literal> STATICMETHOD </literal> e <literal> PADRÌÉO </literal> "

#: book.translate.xml:3109
#, fuzzy
msgid ""
"The <literal>#include</literal> statement and what follows it is copied verbatim to "
"the head of the generated code file."
msgstr ""
"O <literal> #incluir </literal> declaraÁ„o e o que se segue È copiado textualmente "
"para a cabeÁa do arquivo de cÛdigo gerado. "

#: book.translate.xml:3196 book.translate.xml:3159 book.translate.xml:3143
#: book.translate.xml:3130 book.translate.xml:3122 book.translate.xml:3113
#, fuzzy
msgid "For example:"
msgstr "Por exemplo:"

#: book.translate.xml:3117
#, fuzzy
msgid ""
"The <literal>INTERFACE</literal> keyword is used to define the interface name. This "
"name is concatenated with each method name as [interface name]_[method name]. Its "
"syntax is INTERFACE [interface name];."
msgstr ""
"O <literal> INTERFACE </literal> palavra-chave È usada para definir o nome da "
"interface. Este nome È concatenado com cada nome de mÈtodo como [nome da interface] "
"_ [nome do mÈtodo]. Sua sintaxe È INTERFACE [nome da interface] ;"

#: book.translate.xml:3126
#, fuzzy
msgid ""
"The <literal>CODE</literal> keyword copies its arguments verbatim into the code "
"file. Its syntax is <literal>CODE { [whatever] };</literal>"
msgstr ""
"O <literal> CÌìDIGO </literal> A palavra-chave copia seus argumentos literalmente no "
"arquivo de cÛdigo. Sua sintaxe È <literal> CODE {[qualquer que seja]}; </literal> "

#: book.translate.xml:3139
#, fuzzy
msgid ""
"The <literal>METHOD</literal> keyword describes a method. Its syntax is "
"<literal>METHOD [return type] [method name] { [object [, arguments]] };</literal>"
msgstr ""
"O <literal> MÌâTODO </literal> palavra-chave descreve um mÈtodo. Sua sintaxe È "
"<literal> MÌâTODO [tipo de retorno] [nome do mÈtodo] {[objeto [, argumentos]]}; </"
"literal> "

#: book.translate.xml:3151
#, fuzzy
msgid ""
"The <literal>DEFAULT</literal> keyword may follow the <literal>METHOD</literal> "
"keyword. It extends the <literal>METHOD</literal> key word to include the default "
"function for method. The extended syntax is <literal>METHOD [return type] [method "
"name] { [object; [other arguments]] }DEFAULT [default function];</literal>"
msgstr ""
"O <literal> PADRÌÉO </literal> palavra-chave pode seguir o <literal> MÌâTODO </"
"literal> palavra chave. Estende o <literal> MÌâTODO </literal> palavra-chave para "
"incluir a funÁ„o padr„o para o mÈtodo. A sintaxe estendida È <literal> MÌâTODO [tipo "
"de retorno] [nome do mÈtodo] {[objeto; [outros argumentos]]} PADRÌÉO [funÁ„o padr„o]; "
"</literal> "

#: book.translate.xml:3167
#, fuzzy
msgid ""
"The <literal>STATICMETHOD</literal> keyword is used like the <literal>METHOD</"
"literal> keyword except the kobj data is not at the head of the object structure so "
"casting to kobj_t would be incorrect. Instead <literal>STATICMETHOD</literal> relies "
"on the Kobj data being referenced as 'ops'. This is also useful for calling methods "
"directly out of a class's method table."
msgstr ""
"O <literal> STATICMETHOD </literal> palavra-chave È usada como o <literal> MÌâTODO </"
"literal> a palavra-chave, exceto os dados do kobj, n„o est· na cabeÁa da estrutura "
"do objeto, portanto, converter para kobj_t seria incorreto. Em vez de <literal> "
"STATICMETHOD </literal> depende dos dados do Kobj sendo referenciados como ';ops';. "
"Isso tambÈm È ˙til para chamar mÈtodos diretamente da tabela de mÈtodos de uma "
"classe. "

#: book.translate.xml:3174
#, fuzzy
msgid "Other complete examples:"
msgstr "Outros exemplos completos:"

#: book.translate.xml:3182
#, fuzzy
msgid "Creating a Class"
msgstr "Criando uma classe"

#: book.translate.xml:3184
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>class</secondary>"
msgstr " <primary> Objetos do Kernel </primary><secondary> classe </secondary> "

#: book.translate.xml:3187
#, fuzzy
msgid ""
"The second step in using Kobj is to create a class. A class consists of a name, a "
"table of methods, and the size of objects if Kobj's object handling facilities are "
"used. To create the class use the macro <function>DEFINE_CLASS()</function>. To "
"create the method table create an array of kobj_method_t terminated by a NULL entry. "
"Each non-NULL entry may be created using the macro <function>KOBJMETHOD()</function>."
msgstr ""
"O segundo passo para usar o Kobj È criar uma classe. Uma classe consiste em um nome, "
"uma tabela de mÈtodos e o tamanho dos objetos se os recursos de manipulaÁ„o de "
"objetos do Kobj forem usados. Para criar a classe use a macro <function> "
"DEFINE_CLASS () </function> . Para criar a tabela de mÈtodos, crie uma matriz de "
"kobj_method_t terminada por uma entrada NULL. Cada entrada n„o-NULL pode ser criada "
"usando a macro <function> KOBJMETHOD () </function> "

#: book.translate.xml:3206
#, fuzzy
msgid ""
"The class must be <quote>compiled</quote>. Depending on the state of the system at "
"the time that the class is to be initialized a statically allocated cache, "
"<quote>ops table</quote> have to be used. This can be accomplished by declaring a "
"<varname remap=\"structname\">struct kobj_ops</varname> and using "
"<function>kobj_class_compile_static();</function> otherwise, "
"<function>kobj_class_compile()</function> should be used."
msgstr ""
"A aula deve ser <quote> compilado </quote> . Dependendo do estado do sistema no "
"momento em que a classe ser· inicializada, um cache alocado estaticamente, <quote> "
"mesa de operaÁÌµes </quote> tem que ser usado. Isso pode ser feito declarando um "
"<varname remap=\"structname\"> struct kobj_ops </varname> e usando <function> "
"kobj_class_compile_static (); </function> de outra forma, <function> "
"kobj_class_compile () </function> deve ser usado."

#: book.translate.xml:3216
#, fuzzy
msgid "Creating an Object"
msgstr "Criando um Objeto"

#: book.translate.xml:3218
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>object</secondary>"
msgstr " <primary> Objetos do Kernel </primary><secondary> objeto </secondary> "

#: book.translate.xml:3221
#, fuzzy
msgid ""
"The third step in using Kobj involves how to define the object. Kobj object creation "
"routines assume that Kobj data is at the head of an object. If this in not "
"appropriate you will have to allocate the object yourself and then use "
"<function>kobj_init()</function> on the Kobj portion of it; otherwise, you may use "
"<function>kobj_create()</function> to allocate and initialize the Kobj portion of "
"the object automatically. <function>kobj_init()</function> may also be used to "
"change the class that an object uses."
msgstr ""
"A terceira etapa no uso do Kobj envolve como definir o objeto. As rotinas de criaÁ„o "
"de objetos do Kobj assumem que os dados do Kobj est„o na cabeÁa de um objeto. Se "
"isso n„o for apropriado, vocÍ ter· que alocar o objeto e usar <function> kobj_init "
"() </function> na porÁ„o de Kobj; caso contr·rio, vocÍ pode usar <function> "
"kobj_create () </function> para alocar e inicializar a parte Kobj do objeto "
"automaticamente. <function> kobj_init () </function> tambÈm pode ser usado para "
"alterar a classe que um objeto usa. "

#: book.translate.xml:3231
#, fuzzy
msgid "To integrate Kobj into the object you should use the macro KOBJ_FIELDS."
msgstr "Para integrar o Kobj no objeto vocÍ deve usar a macro KOBJ_FIELDS."

#: book.translate.xml:3234
#, fuzzy
msgid "For example"
msgstr "Por exemplo"

#: book.translate.xml:3244
#, fuzzy
msgid "Calling Methods"
msgstr "MÈtodos de Chamada"

#: book.translate.xml:3246
#, fuzzy
msgid ""
"The last step in using Kobj is to simply use the generated functions to use the "
"desired method within the object's class. This is as simple as using the interface "
"name and the method name with a few modifications. The interface name should be "
"concatenated with the method name using a '_' between them, all in upper case."
msgstr ""
"O ˙ltimo passo para usar o Kobj È simplesmente usar as funÁÌµes geradas para usar o "
"mÈtodo desejado dentro da classe do objeto. Isso È t„o simples quanto usar o nome da "
"interface e o nome do mÈtodo com algumas modificaÁÌµes. O nome da interface deve ser "
"concatenado com o nome do mÈtodo usando um ';_'; entre eles, tudo em mai˙sculas. "

#: book.translate.xml:3253
#, fuzzy
msgid ""
"For example, if the interface name was foo and the method was bar then the call "
"would be:"
msgstr ""
"Por exemplo, se o nome da interface fosse foo e o mÈtodo fosse bar, a chamada seria:"

#: book.translate.xml:3261
#, fuzzy
msgid "Cleaning Up"
msgstr "Limpando"

#: book.translate.xml:3263
#, fuzzy
msgid ""
"When an object allocated through <function>kobj_create()</function> is no longer "
"needed <function>kobj_delete()</function> may be called on it, and when a class is "
"no longer being used <function>kobj_class_free()</function> may be called on it."
msgstr ""
"Quando um objeto alocado atravÈs <function> kobj_create () </function> n„o È mais "
"necess·rio <function> kobj_delete () </function> pode ser chamado, e quando uma aula "
"n„o est· mais sendo usada <function> kobj_class_free () </function> pode ser "
"chamado. "

#: book.translate.xml:3279
#, fuzzy
msgid "The Jail Subsystem"
msgstr "O Subsistema da Cadeia"

#: book.translate.xml:3280
#, fuzzy
msgid ""
"<personname><firstname>Evan</firstname><surname>Sarmiento</surname></"
"personname><affiliation> <_:address-1/> </affiliation>"
msgstr ""
" <personname><firstname> Evan </firstname><surname> Sarmiento </surname></"
"personname><affiliation> <_: endereÁo-1 /> </affiliation> "

#: book.translate.xml:3283
#, fuzzy
msgid ""
"<year>2001</year> <holder role=\"mailto:evms@cs.bu.edu\">Evan Sarmiento</holder>"
msgstr ""
" <year> 2001 </year><holder role=\"mailto:evms@cs.bu.edu\"> Evan Sarmiento </holder> "

#: book.translate.xml:3290
#, fuzzy
msgid "<primary>security</primary>"
msgstr " <primary> seguranÁa </primary> "

#: book.translate.xml:15339 book.translate.xml:3291
#, fuzzy
msgid "<primary>Jail</primary>"
msgstr " <primary> Cadeia </primary> "

#: book.translate.xml:3292
#, fuzzy
msgid "<primary>root</primary>"
msgstr " <primary> raiz </primary> "

#: book.translate.xml:3294
#, fuzzy
msgid ""
"On most <trademark class=\"registered\">UNIX</trademark> systems, <literal>root</"
"literal> has omnipotent power. This promotes insecurity. If an attacker gained "
"<literal>root</literal> on a system, he would have every function at his fingertips. "
"In FreeBSD there are sysctls which dilute the power of <literal>root</literal>, in "
"order to minimize the damage caused by an attacker. Specifically, one of these "
"functions is called <literal>secure levels</literal>. Similarly, another function "
"which is present from FreeBSD 4.0 and onward, is a utility called "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>. <application>Jail</application> chroots an environment and sets "
"certain restrictions on processes which are forked within the <application>jail</"
"application>. For example, a jailed process cannot affect processes outside the "
"<application>jail</application>, utilize certain system calls, or inflict any damage "
"on the host environment."
msgstr ""
"Na maioria <trademark class=\"registered\"> UNIX </trademark> sistemas, <literal> "
"raiz </literal> tem poder onipotente. Isso promove inseguranÁa. Se um atacante "
"ganhou <literal> raiz </literal> em um sistema, ele teria todas as funÁÌµes na ponta "
"dos dedos. No FreeBSD existem sysctls que diluem o poder de <literal> raiz </"
"literal> , a fim de minimizar os danos causados ‚Äã‚Äãpor um invasor. Especificamente, "
"uma dessas funÁÌµes È chamada <literal> nÌ≠veis seguros </literal> . Similarmente, "
"outra funÁ„o presente no FreeBSD 4.0 e em diante, È um utilit·rio chamado "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> . <application> Cadeia </application> chroots um ambiente e define "
"certas restriÁÌµes em processos que s„o bifurcados dentro do <application> cadeia </"
"application> . Por exemplo, um processo preso n„o pode afetar processos fora do "
"<application> cadeia </application> , utilizar determinadas chamadas do sistema ou "
"causar danos ao ambiente do host. "

#: book.translate.xml:3308
#, fuzzy
msgid ""
"<application>Jail</application> is becoming the new security model. People are "
"running potentially vulnerable servers such as <application>Apache</application>, "
"<application>BIND</application>, and <application>sendmail</application> within "
"jails, so that if an attacker gains <literal>root</literal> within the "
"<application>jail</application>, it is only an annoyance, and not a devastation. "
"This article mainly focuses on the internals (source code) of <application>jail</"
"application>. For information on how to set up a jail see the <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/jails.html\">handbook entry "
"on jails</link>."
msgstr ""
" <application> Cadeia </application> est· se tornando o novo modelo de seguranÁa. As "
"pessoas est„o executando servidores potencialmente vulner·veis, como <application> "
"Apache </application> , <application> LIGAR </application> e <application> enviar "
"correio </application> dentro de cadeias, de modo que se um atacante ganha <literal> "
"raiz </literal> dentro do <application> cadeia </application> , È apenas um "
"aborrecimento e n„o uma devastaÁ„o. Este artigo foca principalmente os internos "
"(cÛdigo fonte) de <application> cadeia </application> . Para obter informaÁÌµes "
"sobre como configurar uma cadeia, consulte o <link xlink:href=\"@@URL_RELPREFIX@@/"
"doc/en_US.ISO8859-1/books/handbook/jails.html\"> entrada do manual nas cadeias </"
"link> "

#: book.translate.xml:3318
#, fuzzy
msgid "Architecture"
msgstr "Arquitetura"

#: book.translate.xml:3320
#, fuzzy
msgid ""
"<application>Jail</application> consists of two realms: the userland program, "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>, and the code implemented within the kernel: the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and associated restrictions. I will be discussing the "
"userland program and then how <application>jail</application> is implemented within "
"the kernel."
msgstr ""
" <application> Cadeia </application> consiste em dois reinos: o programa userland, "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> , eo cÛdigo implementado dentro do kernel: o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> chamada do sistema e restriÁÌµes associadas. Eu estarei discutindo o "
"programa userland e, em seguida, como <application> cadeia </application> È "
"implementado dentro do kernel. "

#: book.translate.xml:3329
#, fuzzy
msgid "Userland Code"
msgstr "CÛdigo da Terra de Usu·rio"

#: book.translate.xml:3331
#, fuzzy
msgid "<primary>Jail</primary> <secondary>Userland Program</secondary>"
msgstr " <primary> Cadeia </primary><secondary> Programa Userland </secondary> "

#: book.translate.xml:3334
#, fuzzy
msgid ""
"The source for the userland <application>jail</application> is located in <filename>/"
"usr/src/usr.sbin/jail</filename>, consisting of one file, <filename>jail.c</"
"filename>. The program takes these arguments: the path of the <application>jail</"
"application>, hostname, IP address, and the command to be executed."
msgstr ""
"A fonte para a terra do usu·rio <application> cadeia </application> est· localizado "
"em <filename> /usr/src/usr.sbin/jail </filename> , consistindo de um arquivo, "
"<filename> jail.c </filename> . O programa pega esses argumentos: o caminho do "
"<application> cadeia </application> , hostname, endereÁo IP e o comando a ser "
"executado. "

#: book.translate.xml:3341
#, fuzzy
msgid "Data Structures"
msgstr "Estruturas de dados"

#: book.translate.xml:3343
#, fuzzy
msgid ""
"In <filename>jail.c</filename>, the first thing I would note is the declaration of "
"an important structure <literal>struct jail j;</literal> which was included from "
"<filename>/usr/include/sys/jail.h</filename>."
msgstr ""
"Dentro <filename> jail.c </filename> , a primeira coisa que eu gostaria de observar "
"È a declaraÁ„o de uma estrutura importante <literal> struct jail j; </literal> que "
"foi incluÌ≠do a partir de <filename> /usr/include/sys/jail.h </filename> "

#: book.translate.xml:3348
#, fuzzy
msgid "The definition of the <literal>jail</literal> structure is:"
msgstr "A definiÁ„o do <literal> cadeia </literal> estrutura È: "

#: book.translate.xml:3360
#, fuzzy
msgid ""
"As you can see, there is an entry for each of the arguments passed to the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program, and indeed, they are set during its execution."
msgstr ""
"Como vocÍ pode ver, h· uma entrada para cada um dos argumentos passados ‚Äã‚Äãpara o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> programa, e, de fato, eles s„o definidos durante a sua execuÁ„o \""

#: book.translate.xml:3379
#, fuzzy
msgid "Networking"
msgstr "Networking"

#: book.translate.xml:3381
#, fuzzy
msgid ""
"One of the arguments passed to the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> program is an IP address with "
"which the <application>jail</application> can be accessed over the network. "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> translates the IP address given into host byte order and then stores "
"it in <literal>j</literal> (the <literal>jail</literal> structure)."
msgstr ""
"Um dos argumentos passou para o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> programa È um endereÁo IP "
"com o qual o <application> cadeia </application> pode ser acessado pela rede. "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> traduz o endereÁo IP dado em ordem de byte host e, em seguida, "
"armazena em <literal> j </literal> (a <literal> cadeia </literal> estrutura)."

#: book.translate.xml:3394
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>inet_aton</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> function \"interprets the specified character string as an Internet "
"address, placing the address into the structure provided.\" The <literal>ip_number</"
"literal> member in the <literal>jail</literal> structure is set only when the IP "
"address placed onto the <literal>in</literal> structure by "
"<citerefentry><refentrytitle>inet_aton</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> is translated into host byte order by "
"<citerefentry><refentrytitle>ntohl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."
msgstr ""
"O <citerefentry><refentrytitle> inet_aton </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> A funÁ„o \\ \"interpreta a cadeia de caracteres "
"especificada como um endereÁo da Internet, colocando o endereÁo na estrutura "
"fornecida. \" <literal> ip_number </literal> membro no <literal> cadeia </literal> "
"estrutura È definida apenas quando o endereÁo IP colocado no <literal> dentro </"
"literal> estrutura por <citerefentry><refentrytitle> inet_aton </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> È traduzido em ordem de byte "
"host por <citerefentry><refentrytitle> ntohl </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> "

#: book.translate.xml:3405
#, fuzzy
msgid "Jailing the Process"
msgstr "Prendendo o Processo"

#: book.translate.xml:3407
#, fuzzy
msgid ""
"Finally, the userland program jails the process. <application>Jail</application> now "
"becomes an imprisoned process itself and then executes the command given using "
"<citerefentry><refentrytitle>execv</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."
msgstr ""
"Finalmente, o programa userland reprime o processo. <application> Cadeia </"
"application> agora se torna um processo preso em si e, em seguida, executa o comando "
"dado usando <citerefentry><refentrytitle> execv </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> "

#: book.translate.xml:3417
#, fuzzy
msgid ""
"As you can see, the <literal>jail()</literal> function is called, and its argument "
"is the <literal>jail</literal> structure which has been filled with the arguments "
"given to the program. Finally, the program you specify is executed. I will now "
"discuss how <application>jail</application> is implemented within the kernel."
msgstr ""
"Como vocÍ pode ver, o <literal> cadeia() </literal> funÁ„o È chamada, e seu "
"argumento È o <literal> cadeia </literal> estrutura que foi preenchida com os "
"argumentos dados ao programa. Finalmente, o programa que vocÍ especifica È "
"executado. Agora vou discutir como <application> cadeia </application> È "
"implementado dentro do kernel. "

#: book.translate.xml:3427
#, fuzzy
msgid "Kernel Space"
msgstr "EspaÁo do Kernel"

#: book.translate.xml:3429
#, fuzzy
msgid "<primary>Jail</primary> <secondary>Kernel Architecture</secondary>"
msgstr " <primary> Cadeia </primary><secondary> Arquitetura do Kernel </secondary> "

#: book.translate.xml:3432
#, fuzzy
msgid ""
"We will now be looking at the file <filename>/usr/src/sys/kern/kern_jail.c</"
"filename>. This is the file where the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call, appropriate "
"sysctls, and networking functions are defined."
msgstr ""
"Vamos agora olhar para o arquivo <filename> /usr/src/sys/kern/kern_jail.c </"
"filename> . Este È o arquivo onde o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema, sysctls "
"apropriados e funÁÌµes de rede s„o definidos. "

#: book.translate.xml:3438
#, fuzzy
msgid "sysctls"
msgstr "sysctls"

#: book.translate.xml:3440
#, fuzzy
msgid "<primary>sysctl</primary>"
msgstr " <primary> sysctl </primary> "

#: book.translate.xml:3442
#, fuzzy
msgid "In <filename>kern_jail.c</filename>, the following sysctls are defined:"
msgstr ""
"Dentro <filename> kern_jail.c </filename> , os seguintes sysctls s„o definidos: "

#: book.translate.xml:3482
#, fuzzy
msgid ""
"Each of these sysctls can be accessed by the user through the "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program. Throughout the kernel, these specific sysctls are recognized "
"by their name. For example, the name of the first sysctl is <literal>security.jail."
"set_hostname_allowed</literal>."
msgstr ""
"Cada um desses sysctls pode ser acessado pelo usu·rio atravÈs do "
"<citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> programa. Em todo o kernel, esses sysctls especÌ≠ficos s„o reconhecidos "
"pelo nome. Por exemplo, o nome do primeiro sysctl È <literal> security.jail."
"set_hostname_allowed </literal> "

#: book.translate.xml:3490
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> System Call"
msgstr ""
" <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> Chamada de sistema "

#: book.translate.xml:3492
#, fuzzy
msgid ""
"Like all system calls, the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call takes two "
"arguments, <literal>struct thread *td</literal> and <literal>struct jail_args *uap</"
"literal>. <literal>td</literal> is a pointer to the <literal>thread</literal> "
"structure which describes the calling thread. In this context, <literal>uap</"
"literal> is a pointer to the structure in which a pointer to the <literal>jail</"
"literal> structure passed by the userland <filename>jail.c</filename> is contained. "
"When I described the userland program before, you saw that the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call was given a <literal>jail</literal> structure as its own "
"argument."
msgstr ""
"Como todas as chamadas do sistema, o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema leva dois "
"argumentos, <literal> struct thread * td </literal> e <literal> struct jail_args * "
"uap </literal> . <literal> td </literal> È um ponteiro para o <literal> fio </"
"literal> estrutura que descreve o segmento de chamada. Neste contexto, <literal> uap "
"</literal> È um ponteiro para a estrutura em que um ponteiro para o <literal> cadeia "
"</literal> estrutura passada pelo userland <filename> jail.c </filename> Est· "
"contido. Quando eu descrevi o programa userland antes, vocÍ viu que o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> chamada de sistema foi dada uma <literal> cadeia </literal> estrutura "
"como seu prÛprio argumento \""

#: book.translate.xml:3513
#, fuzzy
msgid ""
"Therefore, <literal>uap-&gt;jail</literal> can be used to access the <literal>jail</"
"literal> structure which was passed to the system call. Next, the system call copies "
"the <literal>jail</literal> structure into kernel space using the "
"<citerefentry><refentrytitle>copyin</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> function. <citerefentry><refentrytitle>copyin</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> takes three arguments: the "
"address of the data which is to be copied into kernel space, <literal>uap-&gt;jail</"
"literal>, where to store it, <literal>j</literal> and the size of the storage. The "
"<literal>jail</literal> structure pointed by <literal>uap-&gt;jail</literal> is "
"copied into kernel space and is stored in another <literal>jail</literal> structure, "
"<literal>j</literal>."
msgstr ""
"Assim sendo, <literal> uap-&gt; cadeia </literal> pode ser usado para acessar o "
"<literal> cadeia </literal> estrutura que foi passada para a chamada do sistema. Em "
"seguida, a chamada do sistema copia <literal> cadeia </literal> estrutura no espaÁo "
"do kernel usando o <citerefentry><refentrytitle> copiando </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> funÁ„o. "
"<citerefentry><refentrytitle> copiando </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> leva trÍs argumentos: o endereÁo dos dados que devem ser copiados no "
"espaÁo do kernel, <literal> uap-&gt; cadeia </literal> , onde armazen·-lo <literal> "
"j </literal> e o tamanho do armazenamento. o <literal> cadeia </literal> estrutura "
"apontada por <literal> uap-&gt; cadeia </literal> È copiado para o espaÁo do kernel "
"e È armazenado em outro <literal> cadeia </literal> estrutura, <literal> j </"
"literal> "

#: book.translate.xml:3529
#, fuzzy
msgid ""
"There is another important structure defined in <filename>jail.h</filename>. It is "
"the <literal>prison</literal> structure. The <literal>prison</literal> structure is "
"used exclusively within kernel space. Here is the definition of the <literal>prison</"
"literal> structure."
msgstr ""
"Existe outra estrutura importante definida em <filename> jail.h </filename> . Ìâ o "
"<literal> pris„o </literal> estrutura. o <literal> pris„o </literal> estrutura È "
"usada exclusivamente dentro do espaÁo do kernel. Aqui est· a definiÁ„o do <literal> "
"pris„o </literal> estrutura."

#: book.translate.xml:3551
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call then allocates memory for a <literal>prison</literal> "
"structure and copies data between the <literal>jail</literal> and <literal>prison</"
"literal> structure."
msgstr ""
"O <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> chamada de sistema, em seguida, aloca memÛria para um <literal> pris„o "
"</literal> estrutura e copia dados entre o <literal> cadeia </literal> e <literal> "
"pris„o </literal> estrutura."

#: book.translate.xml:3567
#, fuzzy
msgid ""
"Next, we will discuss another important system call "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, which implements the function to put a process into the "
"<application>jail</application>."
msgstr ""
"Em seguida, discutiremos outra importante chamada do sistema "
"<citerefentry><refentrytitle> jail_attach </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , que implementa a funÁ„o de colocar um processo no "
"<application> cadeia </application> "

#: book.translate.xml:3578
#, fuzzy
msgid ""
"This system call makes the changes that can distinguish a jailed process from those "
"unjailed ones. To understand what <citerefentry><refentrytitle>jail_attach</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> does for us, certain "
"background information is needed."
msgstr ""
"Esta chamada de sistema faz as mudanÁas que podem distinguir um processo preso "
"daqueles que foram desencadeados. Para entender o que <citerefentry><refentrytitle> "
"jail_attach </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> para nÛs, "
"certas informaÁÌµes b·sicas s„o necess·rias \""

#: book.translate.xml:3582
#, fuzzy
msgid ""
"On FreeBSD, each kernel visible thread is identified by its <literal>thread</"
"literal> structure, while the processes are described by their <literal>proc</"
"literal> structures. You can find the definitions of the <literal>thread</literal> "
"and <literal>proc</literal> structure in <filename>/usr/include/sys/proc.h</"
"filename>. For example, the <literal>td</literal> argument in any system call is "
"actually a pointer to the calling thread's <literal>thread</literal> structure, as "
"stated before. The <literal>td_proc</literal> member in the <literal>thread</"
"literal> structure pointed by <literal>td</literal> is a pointer to the "
"<literal>proc</literal> structure which represents the process that contains the "
"thread represented by <literal>td</literal>. The <literal>proc</literal> structure "
"contains members which can describe the owner's identity(<literal>p_ucred</"
"literal>), the process resource limits(<literal>p_limit</literal>), and so on. In "
"the <literal>ucred</literal> structure pointed by <literal>p_ucred</literal> member "
"in the <literal>proc</literal> structure, there is a pointer to the <literal>prison</"
"literal> structure(<literal>cr_prison</literal>)."
msgstr ""
"No FreeBSD, cada thread visÌ≠vel do kernel È identificado por sua <literal> fio </"
"literal> estrutura, enquanto os processos s„o descritos por seus <literal> proc </"
"literal> estruturas. VocÍ pode encontrar as definiÁÌµes do <literal> fio </literal> "
"e <literal> proc </literal> estrutura em <filename> /usr/include/sys/proc.h </"
"filename> . Por exemplo, o <literal> td </literal> argumento em qualquer chamada do "
"sistema È realmente um ponteiro para o segmento de chamada <literal> fio </literal> "
"estrutura, como dito anteriormente. o <literal> td_proc </literal> membro no "
"<literal> fio </literal> estrutura apontada por <literal> td </literal> È um "
"ponteiro para o <literal> proc </literal> estrutura que representa o processo que "
"contÈm o segmento representado por <literal> td </literal> . o <literal> proc </"
"literal> estrutura contÈm membros que podem descrever a identidade do propriet·rio "
"( <literal> p_ucred </literal> ), os limites de recursos do processo ( <literal> "
"p_limit </literal> ), e assim por diante. No <literal> ucred </literal> estrutura "
"apontada por <literal> p_ucred </literal> membro no <literal> proc </literal> "
"estrutura, h· um ponteiro para o <literal> pris„o </literal> estrutura( <literal> "
"cr_prison </literal> ) "

#: book.translate.xml:3623
#, fuzzy
msgid ""
"In <filename>kern_jail.c</filename>, the function <literal>jail()</literal> then "
"calls function <literal>jail_attach()</literal> with a given <literal>jid</literal>. "
"And <literal>jail_attach()</literal> calls function <literal>change_root()</literal> "
"to change the root directory of the calling process. The <literal>jail_attach()</"
"literal> then creates a new <literal>ucred</literal> structure, and attaches the "
"newly created <literal>ucred</literal> structure to the calling process after it has "
"successfully attached the <literal>prison</literal> structure to the <literal>ucred</"
"literal> structure. From then on, the calling process is recognized as jailed. When "
"the kernel routine <literal>jailed()</literal> is called in the kernel with the "
"newly created <literal>ucred</literal> structure as its argument, it returns 1 to "
"tell that the credential is connected with a <application>jail</application>. The "
"public ancestor process of all the process forked within the <application>jail</"
"application>, is the process which runs <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, as it calls the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call. When a program is executed through "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, it inherits the jailed property of its parent's <literal>ucred</"
"literal> structure, therefore it has a jailed <literal>ucred</literal> structure."
msgstr ""
"Dentro <filename> kern_jail.c </filename> , a funÁ„o <literal> cadeia() </literal> "
"ent„o chama a funÁ„o <literal> jail_attach () </literal> com um dado <literal> jid </"
"literal> . E <literal> jail_attach () </literal> chama a funÁ„o <literal> "
"change_root () </literal> para alterar o diretÛrio raiz do processo de chamada. o "
"<literal> jail_attach () </literal> ent„o cria um novo <literal> ucred </literal> "
"estrutura e anexa o recÈm-criado <literal> ucred </literal> estrutura para o "
"processo de chamada depois de ter anexado com sucesso o <literal> pris„o </literal> "
"estrutura para o <literal> ucred </literal> estrutura. A partir de ent„o, o processo "
"de chamada È reconhecido como encarcerado. Quando a rotina do kernel <literal> preso "
"() </literal> È chamado no kernel com o recÈm-criado <literal> ucred </literal> "
"estrutura como seu argumento, ele retorna 1 para dizer que a credencial est· "
"conectada <application> cadeia </application> . O processo ancestral p˙blico de todo "
"o processo bifurcado dentro do <application> cadeia </application> È o processo que "
"executa <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> como ele chama <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada do sistema. Quando "
"um programa È executado atravÈs de <citerefentry><refentrytitle> execve </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> , herda a propriedade "
"encarcerada de seus pais <literal> ucred </literal> estrutura, portanto, tem uma "
"pris„o <literal> ucred </literal> estrutura."

#: book.translate.xml:3675
#, fuzzy
msgid ""
"When a process is forked from its parent process, the "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call uses <literal>crhold()</literal> to maintain the "
"credential for the newly forked process. It inherently keep the newly forked child's "
"credential consistent with its parent, so the child process is also jailed."
msgstr ""
"Quando um processo È bifurcado de seu processo pai, o <citerefentry><refentrytitle> "
"garfo </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> utilizaÁÌµes de "
"chamadas do sistema <literal> crhold () </literal> para manter a credencial do "
"processo recÈm-bifurcado. Ìâ inerentemente manter a credencial da crianÁa recÈm-"
"bifurcada consistente com seu pai, de modo que o processo filho tambÈm È preso \""

#: book.translate.xml:3691
#, fuzzy
msgid "Restrictions"
msgstr "RestriÁÌµes"

#: book.translate.xml:3693
#, fuzzy
msgid ""
"Throughout the kernel there are access restrictions relating to jailed processes. "
"Usually, these restrictions only check whether the process is jailed, and if so, "
"returns an error. For example:"
msgstr ""
"Em todo o kernel existem restriÁÌµes de acesso relacionadas a processos presos. "
"Geralmente, essas restriÁÌµes apenas verificam se o processo est· preso e, em caso "
"afirmativo, retorna um erro. Por exemplo:"

#: book.translate.xml:3703
#, fuzzy
msgid "SysV IPC"
msgstr "SysV IPC"

#: book.translate.xml:3705
#, fuzzy
msgid "<primary>System V IPC</primary>"
msgstr " <primary> IPC do sistema V </primary> "

#: book.translate.xml:3707
#, fuzzy
msgid ""
"System V IPC is based on messages. Processes can send each other these messages "
"which tell them how to act. The functions which deal with messages are: "
"<citerefentry><refentrytitle>msgctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>msgget</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>msgsnd</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>msgrcv</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>. Earlier, I mentioned that there were certain sysctls you could turn "
"on or off in order to affect the behavior of <application>jail</application>. One of "
"these sysctls was <literal>security.jail.sysvipc_allowed</literal>. By default, this "
"sysctl is set to 0. If it were set to 1, it would defeat the whole purpose of having "
"a <application>jail</application>; privileged users from the <application>jail</"
"application> would be able to affect processes outside the jailed environment. The "
"difference between a message and a signal is that the message only consists of the "
"signal number."
msgstr ""
"O IPC do sistema V È baseado em mensagens. Os processos podem enviar uns aos outros "
"mensagens que lhes dizem como agir. As funÁÌµes que lidam com as mensagens s„o: "
"<citerefentry><refentrytitle> msgctl </refentrytitle><manvolnum> 3 </manvolnum></"
"citerefentry> , <citerefentry><refentrytitle> msgget </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> msgsnd </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> msgrcv </refentrytitle><manvolnum> 3 </manvolnum></"
"citerefentry> . Anteriormente, mencionei que havia certos sysctls que vocÍ podia "
"ativar ou desativar para afetar o comportamento de <application> cadeia </"
"application> . Um desses sysctls foi <literal> security.jail.sysvipc_allowed </"
"literal> . Por padr„o, este sysctl È definido como 0. Se fosse definido como 1, ele "
"derrotaria todo o propÛsito de ter um <application> cadeia </application> ; usu·rios "
"privilegiados do <application> cadeia </application> seria capaz de afetar processos "
"fora do ambiente preso. A diferenÁa entre uma mensagem e um sinal È que a mensagem "
"consiste apenas no n˙mero do sinal. "

#: book.translate.xml:3722
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_msg.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_msg.c </filename> : "

#: book.translate.xml:3725
#, fuzzy
msgid ""
"<literal>msgget(key, msgflg)</literal>: <literal>msgget</literal> returns (and "
"possibly creates) a message descriptor that designates a message queue for use in "
"other functions."
msgstr ""
" <literal> msgget (chave, msgflg) </literal> : <literal> msgget </literal> retorna "
"(e possivelmente cria) um descritor de mensagens que designa uma fila de mensagens "
"para uso em outras funÁÌµes. "

#: book.translate.xml:3730
#, fuzzy
msgid ""
"<literal>msgctl(msgid, cmd, buf)</literal>: Using this function, a process can query "
"the status of a message descriptor."
msgstr ""
" <literal> msgctl (msgid, cmd, buf) </literal> : Usando esta funÁ„o, um processo "
"pode consultar o status de um descritor de mensagem. "

#: book.translate.xml:3734
#, fuzzy
msgid ""
"<literal>msgsnd(msgid, msgp, msgsz, msgflg)</literal>: <literal>msgsnd</literal> "
"sends a message to a process."
msgstr ""
" <literal> msgsnd (msgid, msgp, msgsz, msgflg) </literal> : <literal> msgsnd </"
"literal> envia uma mensagem para um processo \""

#: book.translate.xml:3738
#, fuzzy
msgid ""
"<literal>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</literal>: a process receives "
"messages using this function"
msgstr ""
" <literal> msgrid (msgid, msgp, msgsz, msgtyp, msgflg) </literal> : um processo "
"recebe mensagens usando esta funÁ„o "

#: book.translate.xml:3744
#, fuzzy
msgid ""
"In each of the system calls corresponding to these functions, there is this "
"conditional:"
msgstr ""
"Em cada uma das chamadas do sistema correspondentes a estas funÁÌµes, existe esta "
"condicional:"

#: book.translate.xml:3751
#, fuzzy
msgid "<primary>semaphores</primary>"
msgstr " <primary> sem·foros </primary> "

#: book.translate.xml:3752
#, fuzzy
msgid ""
"Semaphore system calls allow processes to synchronize execution by doing a set of "
"operations atomically on a set of semaphores. Basically semaphores provide another "
"way for processes lock resources. However, process waiting on a semaphore, that is "
"being used, will sleep until the resources are relinquished. The following semaphore "
"system calls are blocked inside a <application>jail</application>: "
"<citerefentry><refentrytitle>semget</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>semctl</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> and <citerefentry><refentrytitle>semop</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"Chamadas de sistema de sem·foro permitem que processos sincronizem a execuÁ„o "
"executando um conjunto de operaÁÌµes atomicamente em um conjunto de sem·foros. "
"Basicamente, sem·foros fornecem outra maneira para recursos de bloqueio de "
"processos. No entanto, processo aguardando um sem·foro, que est· sendo usado, ir· "
"dormir atÈ os recursos As seguintes chamadas do sistema de sem·foro est„o bloqueadas "
"dentro <application> cadeia </application> : <citerefentry><refentrytitle> semget </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> semctl </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> e <citerefentry><refentrytitle> semop </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> "

#: book.translate.xml:3761
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_sem.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_sem.c </filename> : "

#: book.translate.xml:3765
#, fuzzy
msgid ""
"<literal>semctl(semid, semnum, cmd, ...)</literal>: <literal>semctl</literal> does "
"the specified <literal>cmd</literal> on the semaphore queue indicated by "
"<literal>semid</literal>."
msgstr ""
" <literal> semctl (semid, semnum, cmd, ...) </literal> : <literal> semctl </literal> "
"faz o especificado <literal> cmd </literal> na fila de sem·foros indicada por "
"<literal> semid </literal> "

#: book.translate.xml:3771
#, fuzzy
msgid ""
"<literal>semget(key, nsems, flag)</literal>: <literal>semget</literal> creates an "
"array of semaphores, corresponding to <literal>key</literal>."
msgstr ""
" <literal> semget (chave, nsems, bandeira) </literal> : <literal> semget </literal> "
"cria uma matriz de sem·foros, correspondente a <literal> chave </literal> "

#: book.translate.xml:3775
#, fuzzy
msgid "<literal>key and flag take on the same meaning as they do in msgget.</literal>"
msgstr " <literal> key e flag assumem o mesmo significado que no msgget. </literal> "

#: book.translate.xml:3778
#, fuzzy
msgid ""
"<literal>semop(semid, array, nops)</literal>: <literal>semop</literal> performs a "
"group of operations indicated by <literal>array</literal>, to the set of semaphores "
"identified by <literal>semid</literal>."
msgstr ""
" <literal> semop (semid, array, nops) </literal> : <literal> semop </literal> "
"executa um grupo de operaÁÌµes indicado por <literal> array </literal> , ao conjunto "
"de sem·foros identificados por <literal> semid </literal> "

#: book.translate.xml:3784
#, fuzzy
msgid "<primary>shared memory</primary>"
msgstr " <primary> memoria compartilhada </primary> "

#: book.translate.xml:3785
#, fuzzy
msgid ""
"System V IPC allows for processes to share memory. Processes can communicate "
"directly with each other by sharing parts of their virtual address space and then "
"reading and writing data stored in the shared memory. These system calls are blocked "
"within a jailed environment: <citerefentry><refentrytitle>shmdt</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>shmat</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>shmctl</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> and <citerefentry><refentrytitle>shmget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"O System V IPC permite que os processos compartilhem memÛria. Os processos podem se "
"comunicar diretamente compartilhando partes de seu espaÁo de endereÁo virtual e "
"depois lendo e gravando dados armazenados na memÛria compartilhada. Essas chamadas "
"de sistema s„o bloqueadas em um ambiente preso: <citerefentry><refentrytitle> shmdt "
"</refentrytitle><manvolnum> 2 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> shmat </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> , <citerefentry><refentrytitle> shmctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> shmget </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:3792
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_shm.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_shm.c </filename> : "

#: book.translate.xml:3795
#, fuzzy
msgid ""
"<literal>shmctl(shmid, cmd, buf)</literal>: <literal>shmctl</literal> does various "
"control operations on the shared memory region identified by <literal>shmid</"
"literal>."
msgstr ""
" <literal> shmctl (shmid, cmd, buf) </literal> : <literal> shmctl </literal> faz "
"v·rias operaÁÌµes de controle na regi„o de memÛria compartilhada identificada por "
"<literal> shmid </literal> "

#: book.translate.xml:3800
#, fuzzy
msgid ""
"<literal>shmget(key, size, flag)</literal>: <literal>shmget</literal> accesses or "
"creates a shared memory region of <literal>size</literal> bytes."
msgstr ""
" <literal> shmget (chave, tamanho, bandeira) </literal> : <literal> shmget </"
"literal> acessa ou cria uma regi„o de memÛria compartilhada <literal> Tamanho </"
"literal> bytes. "

#: book.translate.xml:3804
#, fuzzy
msgid ""
"<literal>shmat(shmid, addr, flag)</literal>: <literal>shmat</literal> attaches a "
"shared memory region identified by <literal>shmid</literal> to the address space of "
"a process."
msgstr ""
" <literal> shmat (shmid, addr, bandeira) </literal> : <literal> shmat </literal> "
"anexa uma regi„o de memÛria compartilhada identificada <literal> shmid </literal> "
"para o espaÁo de endereÁo de um processo \""

#: book.translate.xml:3809
#, fuzzy
msgid ""
"<literal>shmdt(addr)</literal>: <literal>shmdt</literal> detaches the shared memory "
"region previously attached at <literal>addr</literal>."
msgstr ""
" <literal> shmdt (addr) </literal> : <literal> shmdt </literal> separa a regi„o de "
"memÛria compartilhada anteriormente conectada <literal> addr </literal> "

#: book.translate.xml:3817
#, fuzzy
msgid "Sockets"
msgstr "Tomadas"

#: book.translate.xml:3819
#, fuzzy
msgid "<primary>sockets</primary>"
msgstr " <primary> tomadas </primary> "

#: book.translate.xml:3820
#, fuzzy
msgid ""
"<application>Jail</application> treats the <citerefentry><refentrytitle>socket</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call and related lower-"
"level socket functions in a special manner. In order to determine whether a certain "
"socket is allowed to be created, it first checks to see if the sysctl "
"<literal>security.jail.socket_unixiproute_only</literal> is set. If set, sockets are "
"only allowed to be created if the family specified is either <literal>PF_LOCAL</"
"literal>, <literal>PF_INET</literal> or <literal>PF_ROUTE</literal>. Otherwise, it "
"returns an error."
msgstr ""
" <application> Cadeia </application> trata o <citerefentry><refentrytitle> soquete </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema e "
"funÁÌµes de soquete de nÌ≠vel inferior relacionadas de uma maneira especial. Para "
"determinar se um certo socket pode ser criado, ele primeiro verifica se o sysctl "
"<literal> security.jail.socket_unixiproute_only </literal> est· definido. Se "
"definido, os soquetes sÛ poder„o ser criados se a famÌ≠lia especificada for <literal> "
"PF_LOCAL </literal> , <literal> PF_INET </literal> ou <literal> PF_ROUTE </"
"literal> . Caso contr·rio, retorna um erro. "

#: book.translate.xml:3850
#, fuzzy
msgid "Berkeley Packet Filter"
msgstr "Filtro de pacotes de Berkeley"

#: book.translate.xml:3852
#, fuzzy
msgid "<primary>Berkeley Packet Filter</primary>"
msgstr " <primary> Filtro de pacotes de Berkeley </primary> "

#: book.translate.xml:3853
#, fuzzy
msgid "<primary>data link layer</primary>"
msgstr " <primary> camada de enlace de dados </primary> "

#: book.translate.xml:3855
#, fuzzy
msgid ""
"The <application>Berkeley Packet Filter</application> provides a raw interface to "
"data link layers in a protocol independent fashion. <application>BPF</application> "
"is now controlled by the <citerefentry><refentrytitle>devfs</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> whether it can be used in a "
"jailed environment."
msgstr ""
"O <application> Filtro de pacotes de Berkeley </application> fornece uma interface "
"bruta para as camadas de enlace de dados de maneira independente do protocolo. "
"<application> BPF </application> agora È controlado pelo "
"<citerefentry><refentrytitle> devfs </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> se pode ser usado em um ambiente preso \""

#: book.translate.xml:3863
#, fuzzy
msgid "Protocols"
msgstr "Protocolos"

#: book.translate.xml:3865
#, fuzzy
msgid "<primary>protocols</primary>"
msgstr " <primary> protocolos </primary> "

#: book.translate.xml:3867
#, fuzzy
msgid ""
"There are certain protocols which are very common, such as TCP, UDP, IP and ICMP. IP "
"and ICMP are on the same level: the network layer 2. There are certain precautions "
"which are taken in order to prevent a jailed process from binding a protocol to a "
"certain address only if the <literal>nam</literal> parameter is set. <literal>nam</"
"literal> is a pointer to a <literal>sockaddr</literal> structure, which describes "
"the address on which to bind the service. A more exact definition is that "
"<literal>sockaddr</literal> \"may be used as a template for referring to the "
"identifying tag and length of each address\". In the function "
"<literal>in_pcbbind_setup()</literal>, <literal>sin</literal> is a pointer to a "
"<literal>sockaddr_in</literal> structure, which contains the port, address, length "
"and domain family of the socket which is to be bound. Basically, this disallows any "
"processes from <application>jail</application> to be able to specify the address "
"that does not belong to the <application>jail</application> in which the calling "
"process exists."
msgstr ""
"Existem certos protocolos que s„o muito comuns, como TCP, UDP, IP e ICMP. IP e ICMP "
"est„o no mesmo nÌ≠vel: a camada de rede 2. H· certas precauÁÌµes que s„o tomadas para "
"evitar que um processo preso seja vinculado. um protocolo para um determinado "
"endereÁo apenas se o <literal> nam </literal> parÌ¢metro est· definido. <literal> "
"nam </literal> È um ponteiro para um <literal> sockaddr </literal> estrutura, que "
"descreve o endereÁo no qual ligar o serviÁo. Uma definiÁ„o mais exata È que "
"<literal> sockaddr </literal> \\ \"pode ‚Äã‚Äãser usado como um modelo para referir-se "
"Ì† tag de identificaÁ„o e comprimento de cada endereÁo \". Na funÁ„o <literal> "
"in_pcbbind_setup () </literal> , <literal> pecado </literal> È um ponteiro para um "
"<literal> sockaddr_in </literal> estrutura, que contÈm a porta, endereÁo, "
"comprimento e famÌ≠lia de domÌ≠nio do socket que deve ser ligado. Basicamente, isso "
"impede qualquer processo de <application> cadeia </application> para poder "
"especificar o endereÁo que n„o pertence ao <application> cadeia </application> em "
"que o processo de chamada existe. "

#: book.translate.xml:3921
#, fuzzy
msgid ""
"You might be wondering what function <literal>prison_ip()</literal> does. "
"<literal>prison_ip()</literal> is given three arguments, a pointer to the "
"credential(represented by <literal>cred</literal>), any flags, and an IP address. It "
"returns 1 if the IP address does NOT belong to the <application>jail</application> "
"or 0 otherwise. As you can see from the code, if it is indeed an IP address not "
"belonging to the <application>jail</application>, the protocol is not allowed to "
"bind to that address."
msgstr ""
"VocÍ pode estar se perguntando que funÁ„o <literal> prison_ip () </literal> faz. "
"<literal> prison_ip () </literal> È dado trÍs argumentos, um ponteiro para a "
"credencial (representado por <literal> cred </literal> ), qualquer sinalizador e um "
"endereÁo IP. Ele retorna 1 se o endereÁo IP NÌÉO pertencer ao <application> cadeia </"
"application> ou 0 caso contr·rio. Como vocÍ pode ver no cÛdigo, se È realmente um "
"endereÁo IP n„o pertencente ao <application> cadeia </application> , o protocolo n„o "
"tem permiss„o para vincular a esse endereÁo \""

#: book.translate.xml:3964
#, fuzzy
msgid "Filesystem"
msgstr "Sistema de arquivo"

#: book.translate.xml:3966
#, fuzzy
msgid "<primary>filesystem</primary>"
msgstr " <primary> sistema de arquivo </primary> "

#: book.translate.xml:3967
#, fuzzy
msgid ""
"Even <literal>root</literal> users within the <application>jail</application> are "
"not allowed to unset or modify any file flags, such as immutable, append-only, and "
"undeleteable flags, if the securelevel is greater than 0."
msgstr ""
"AtÈ <literal> raiz </literal> usu·rios dentro do <application> cadeia </application> "
"n„o È permitido anular ou modificar qualquer sinalizador de arquivo, como "
"sinalizadores imut·veis, somente de anexaÁ„o e n„o-destac·veis, se o nÌ≠vel de "
"seguranÁa for maior que 0. "

#: book.translate.xml:4027
#, fuzzy
msgid "The SYSINIT Framework"
msgstr "O Framework SYSINIT"

#: book.translate.xml:4029
#, fuzzy
msgid "<primary>SYSINIT</primary>"
msgstr " <primary> SYSINIT </primary> "

#: book.translate.xml:4030
#, fuzzy
msgid "<primary>dynamic initialization</primary>"
msgstr " <primary> inicializaÁ„o dinÌ¢mica </primary> "

#: book.translate.xml:4031
#, fuzzy
msgid "<primary>kernel initialization</primary> <secondary>dynamic</secondary>"
msgstr ""
" <primary> inicializaÁ„o do kernel </primary><secondary> dinÌ¢mico </secondary> "

#: book.translate.xml:15400 book.translate.xml:4033
#, fuzzy
msgid "<primary>kernel modules</primary>"
msgstr " <primary> mÛdulos do kernel </primary> "

#: book.translate.xml:4034
#, fuzzy
msgid "<primary>kernel linker</primary>"
msgstr " <primary> linker de kernel </primary> "

#: book.translate.xml:4036
#, fuzzy
msgid ""
"SYSINIT is the framework for a generic call sort and dispatch mechanism. FreeBSD "
"currently uses it for the dynamic initialization of the kernel. SYSINIT allows "
"FreeBSD's kernel subsystems to be reordered, and added, removed, and replaced at "
"kernel link time when the kernel or one of its modules is loaded without having to "
"edit a statically ordered initialization routing and recompile the kernel. This "
"system also allows kernel modules, currently called <firstterm>KLD's</firstterm>, to "
"be separately compiled, linked, and initialized at boot time and loaded even later "
"while the system is already running. This is accomplished using the <quote>kernel "
"linker</quote> and <quote>linker sets</quote>."
msgstr ""
"SYSINIT È o framework para um mecanismo genÈrico de ordenaÁ„o e envio de chamadas. O "
"FreeBSD atualmente o utiliza para a inicializaÁ„o dinÌ¢mica do kernel. SYSINIT "
"permite que os subsistemas de kernel do FreeBSD sejam reordenados, adicionados, "
"removidos e substituÌ≠dos no momento do link do kernel quando o kernel ou um de seus "
"mÛdulos È carregado sem ter que editar um roteamento de inicializaÁ„o ordenado "
"estaticamente e recompilar o kernel.Este sistema tambÈm permite mÛdulos do kernel, "
"atualmente chamados <firstterm> KLD';s </firstterm> , para ser compilado, vinculado "
"e inicializado separadamente no momento da inicializaÁ„o e carregado ainda mais "
"tarde enquanto o sistema j· est· em execuÁ„o. Isso È feito usando o <quote> linker "
"de kernel </quote> e <quote> conjuntos de linkers </quote> "

#: book.translate.xml:4054
#, fuzzy
msgid "Linker Set"
msgstr "Left Set"

#: book.translate.xml:4056
#, fuzzy
msgid ""
"A linker technique in which the linker gathers statically declared data throughout a "
"program's source files into a single contiguously addressable unit of data."
msgstr ""
"Uma tÈcnica de linker na qual o linker re˙ne dados estaticamente declarados atravÈs "
"dos arquivos de cÛdigo-fonte de um programa em uma ˙nica unidade de dados "
"contiguamente endereÁ·vel."

#: book.translate.xml:4066
#, fuzzy
msgid "SYSINIT Operation"
msgstr "OperaÁ„o SYSINIT"

#: book.translate.xml:4068
#, fuzzy
msgid "<primary>linker sets</primary>"
msgstr " <primary> conjuntos de linkers </primary> "

#: book.translate.xml:4070
#, fuzzy
msgid ""
"SYSINIT relies on the ability of the linker to take static data declared at multiple "
"locations throughout a program's source and group it together as a single contiguous "
"chunk of data. This linker technique is called a <quote>linker set</quote>. SYSINIT "
"uses two linker sets to maintain two data sets containing each consumer's call "
"order, function, and a pointer to the data to pass to that function."
msgstr ""
"O SYSINIT depende da capacidade do vinculador de obter dados est·ticos declarados em "
"v·rios locais ao longo da origem de um programa e agrup·-los como um ˙nico bloco "
"contÌ≠guo de dados. Essa tÈcnica de vinculador È chamada de <quote> conjunto de "
"linker </quote> . O SYSINIT usa dois conjuntos de linkers para manter dois conjuntos "
"de dados contendo cada ordem de chamada do consumidor, funÁ„o e um ponteiro para os "
"dados a serem passados ‚Äã‚Äãpara essa funÁ„o. "

#: book.translate.xml:4078
#, fuzzy
msgid ""
"SYSINIT uses two priorities when ordering the functions for execution. The first "
"priority is a subsystem ID giving an overall order for SYSINIT's dispatch of "
"functions. Current predeclared ID's are in <filename>&lt;sys/kernel.h&gt;</filename> "
"in the enum list <literal>sysinit_sub_id</literal>. The second priority used is an "
"element order within the subsystem. Current predeclared subsystem element orders are "
"in <filename>&lt;sys/kernel.h&gt;</filename> in the enum list "
"<literal>sysinit_elem_order</literal>."
msgstr ""
"O SYSINIT usa duas prioridades ao ordenar as funÁÌµes para execuÁ„o. A primeira "
"prioridade È um ID de subsistema dando uma ordem geral para o despacho de funÁÌµes "
"do SYSINIT. As IDs prÈ-declaradas atuais est„o em <filename> &lt;sys / kernel.h&gt; "
"</filename> na lista enum <literal> sysinit_sub_id </literal> . A segunda prioridade "
"usada È uma ordem de elemento no subsistema. As atuais ordens de elementos do "
"subsistema prÈ-declarado est„o em <filename> &lt;sys / kernel.h&gt; </filename> na "
"lista enum <literal> sysinit_elem_order </literal> "

#: book.translate.xml:4088
#, fuzzy
msgid "<primary>pseudo-devices</primary>"
msgstr " <primary> pseudo-dispositivos </primary> "

#: book.translate.xml:4090
#, fuzzy
msgid ""
"There are currently two uses for SYSINIT. Function dispatch at system startup and "
"kernel module loads, and function dispatch at system shutdown and kernel module "
"unload. Kernel subsystems often use system startup SYSINIT's to initialize data "
"structures, for example the process scheduling subsystem uses a SYSINIT to "
"initialize the run queue data structure. Device drivers should avoid using "
"<literal>SYSINIT()</literal> directly. Instead drivers for real devices that are "
"part of a bus structure should use <literal>DRIVER_MODULE()</literal> to provide a "
"function that detects the device and, if it is present, initializes the device. It "
"will do a few things specific to devices and then call <literal>SYSINIT()</literal> "
"itself. For pseudo-devices, which are not part of a bus structure, use "
"<literal>DEV_MODULE()</literal>."
msgstr ""
"Existem atualmente dois usos para SYSINIT. O despacho de funÁÌµes na inicializaÁ„o "
"do sistema e do mÛdulo kernel e o envio de funÁÌµes no desligamento do sistema e no "
"mÛdulo kernel descarregam. Os subsistemas Kernel geralmente usam SYSINIT';s para "
"inicializar estruturas de dados, por exemplo, o subsistema de agendamento de "
"processos SYSINIT para inicializar a estrutura de dados da fila de execuÁ„o.Os "
"drivers de dispositivo devem evitar o uso <literal> SYSINIT () </literal> "
"diretamente. Em vez disso, os drivers para dispositivos reais que fazem parte de uma "
"estrutura de barramento devem usar <literal> DRIVER_MODULE () </literal> para "
"fornecer uma funÁ„o que detecta o dispositivo e, se estiver presente, inicializa o "
"dispositivo. Ele far· algumas coisas especÌ≠ficas para os dispositivos e, em seguida, "
"chamar· <literal> SYSINIT () </literal> em si. Para pseudo-dispositivos, que n„o "
"fazem parte de uma estrutura de barramento, use <literal> DEV_MODULE () </literal> "

#: book.translate.xml:4108
#, fuzzy
msgid "Using SYSINIT"
msgstr "Usando SYSINIT"

#: book.translate.xml:4128
#, fuzzy
msgid "Startup"
msgstr "Comece"

#: book.translate.xml:4130
#, fuzzy
msgid ""
"The <literal>SYSINIT()</literal> macro creates the necessary SYSINIT data in "
"SYSINIT's startup data set for SYSINIT to sort and dispatch a function at system "
"startup and module load. <literal>SYSINIT()</literal> takes a uniquifier that "
"SYSINIT uses to identify the particular function dispatch data, the subsystem order, "
"the subsystem element order, the function to call, and the data to pass the "
"function. All functions must take a constant pointer argument."
msgstr ""
"O <literal> SYSINIT () </literal> macro cria os dados SYSINIT necess·rios no "
"conjunto de dados de inicializaÁ„o do SYSINIT para SYSINIT para classificar e "
"despachar uma funÁ„o na inicializaÁ„o do sistema e no carregamento do mÛdulo. "
"<literal> SYSINIT () </literal> pega um uniquificador que SYSINIT usa para "
"identificar os dados de despacho da funÁ„o especÌ≠fica, a ordem do subsistema, a "
"ordem do elemento do subsistema, a funÁ„o a ser chamada e os dados para passar a "
"funÁ„o. Todas as funÁÌµes devem ter um argumento de ponteiro constante. "

#: book.translate.xml:4141
#, fuzzy
msgid "Example of a <literal>SYSINIT()</literal>"
msgstr "Exemplo de um <literal> SYSINIT () </literal> "

#: book.translate.xml:4164
#, fuzzy
msgid ""
"Note that <literal>SI_SUB_FOO</literal> and <literal>SI_ORDER_FOO</literal> need to "
"be in the <literal>sysinit_sub_id</literal> and <literal>sysinit_elem_order</"
"literal> enum's as mentioned above. Either use existing ones or add your own to the "
"enum's. You can also use math for fine-tuning the order a SYSINIT will run in. This "
"example shows a SYSINIT that needs to be run just barely before the SYSINIT's that "
"handle tuning kernel parameters."
msgstr ""
"Observe que <literal> SI_SUB_FOO </literal> e <literal> SI_ORDER_FOO </literal> "
"precisa estar no <literal> sysinit_sub_id </literal> e <literal> sysinit_elem_order "
"</literal> enum como mencionado acima. Use os existentes ou adicione os seus aos do "
"enum. VocÍ tambÈm pode usar matem·tica para ajustar a ordem na qual um SYSINIT ser· "
"executado. Este exemplo mostra um SYSINIT que precisa ser executado logo antes do "
"SYSINIT tratar os parÌ¢metros do kernel de ajuste. "

#: book.translate.xml:4175
#, fuzzy
msgid "Example of Adjusting <literal>SYSINIT()</literal> Order"
msgstr "Exemplo de ajuste <literal> SYSINIT () </literal> Ordem"

#: book.translate.xml:4190
#, fuzzy
msgid "Shutdown"
msgstr "Desligar"

#: book.translate.xml:4192
#, fuzzy
msgid ""
"The <literal>SYSUNINIT()</literal> macro behaves similarly to the "
"<literal>SYSINIT()</literal> macro except that it adds the SYSINIT data to SYSINIT's "
"shutdown data set."
msgstr ""
"O <literal> SYSUNINIT () </literal> macro se comporta de forma semelhante ao "
"<literal> SYSINIT () </literal> macro, exceto que adiciona os dados SYSINIT ao "
"conjunto de dados de desligamento do SYSINIT. "

#: book.translate.xml:4197
#, fuzzy
msgid "Example of a <literal>SYSUNINIT()</literal>"
msgstr "Exemplo de um <literal> SYSUNINIT () </literal> "

#: book.translate.xml:4256
#, fuzzy
msgid "The TrustedBSD MAC Framework"
msgstr "O framework MAC TrustedBSD"

#: book.translate.xml:4258
#, fuzzy
msgid ""
"<personname><firstname>Chris</firstname><surname>Costello</surname></"
"personname><affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/> </"
"affiliation>"
msgstr ""
" <personname><firstname> Chris </firstname><surname> Costello </surname></"
"personname><affiliation><orgname> Projeto TrustedBSD </orgname> <_: endereÁo-1 /> </"
"affiliation> "

#: book.translate.xml:4263
#, fuzzy
msgid ""
"<personname><firstname>Robert</firstname><surname>Watson</surname></"
"personname><affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/> </"
"affiliation>"
msgstr ""
" <personname><firstname> Robert </firstname><surname> Watson </surname></"
"personname><affiliation><orgname> Projeto TrustedBSD </orgname> <_: endereÁo-1 /> </"
"affiliation> "

#: book.translate.xml:4273
#, fuzzy
msgid "MAC Documentation Copyright"
msgstr "Direitos autorais da documentaÁ„o do MAC"

#: book.translate.xml:4275
#, fuzzy
msgid ""
"This documentation was developed for the FreeBSD Project by Chris Costello at "
"Safeport Network Services and Network Associates Laboratories, the Security Research "
"Division of Network Associates, Inc. under DARPA/SPAWAR contract N66001-01-C-8035 "
"(<quote>CBOSS</quote>), as part of the DARPA CHATS research program."
msgstr ""
"Esta documentaÁ„o foi desenvolvida para o Projeto FreeBSD por Chris Costello na "
"Safeport Network Services e Network Associates Laboratories, a Divis„o de Pesquisa "
"de SeguranÁa da Network Associates, Inc. sob contrato DARPA / SPAWAR N66001-01-"
"C-8035 ( <quote> CBOSS </quote> ), como parte do programa de pesquisa DARPA CHATS. "

#: book.translate.xml:4282
#, fuzzy
msgid ""
"Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, HTML, "
"PDF, PostScript, RTF and so forth) with or without modification, are permitted "
"provided that the following conditions are met:"
msgstr ""
"RedistribuiÁ„o e uso em formul·rios de origem (SGML DocBook) e ';compilados'; (SGML, "
"HTML, PDF, PostScript, RTF e assim por diante) com ou sem modificaÁ„o, s„o "
"permitidos desde que as seguintes condiÁÌµes sejam atendidas:"

#: book.translate.xml:4289
#, fuzzy
msgid ""
"Redistributions of source code (SGML DocBook) must retain the above copyright "
"notice, this list of conditions and the following disclaimer as the first lines of "
"this file unmodified."
msgstr ""
"As redistribuiÁÌµes do cÛdigo-fonte (SGML DocBook) devem manter o aviso de copyright "
"acima, esta lista de condiÁÌµes e o aviso de isenÁ„o de responsabilidade a seguir, "
"conforme as primeiras linhas deste arquivo n„o sejam modificadas."

#: book.translate.xml:4306
#, fuzzy
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC \"AS IS\" "
"AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED "
"WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. "
"IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, INC BE LIABLE FOR ANY DIRECT, "
"INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT "
"NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR "
"PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, "
"WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF THE "
"POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"ESTA DOCUMENTAÌáÌÉO Ìâ FORNECIDA PELA NETWORKS ASSOCIATES TECHNOLOGY, INC \" COMO ESTÌÅ "
"\"\" E QUALQUER GARANTIA EXPRESSA OU IMPLÌçCITA, INCLUINDO, MAS NÌÉO SE LIMITANDO ÌÄS "
"GARANTIAS IMPLÌçCITAS DE COMERCIALIZAÌáÌÉO E ADEQUAÌáÌÉO A UMA FINALIDADE ESPECÌçFICA, Ìâ "
"REJEITADA. A NETWORKS ASSOCIATES TECHNOLOGY, INC Ìâ RESPONSÌÅVEL POR QUAISQUER DANOS "
"DIRETOS, INDIRETOS, INCIDENTAIS, ESPECIAIS, EXEMPLARES OU CONSEQÌúENCIAIS (INCLUINDO, "
"MAS NÌÉO SE LIMITANDO A, AQUISIÌáÌÉO DE BENS OU SERVIÌáOS SUBSTITUTOS; PERDA DE USO, "
"DADOS OU LUCROS; OU INTERRUPÌáÌÉO DE NEGÌìCIOS) SEMPRE CAUSOU QUALQUER TEORIA DE "
"RESPONSABILIDADE, SEJA EM CONTRATO, RESPONSABILIDADE ESTRITA, OU DELITO (INCLUINDO "
"NEGLIGÌäNCIA OU DE OUTRA FORMA) DECORRENTE DE QUALQUER FORMA DO USO DESTA "
"DOCUMENTAÌáÌÉO, MESMO SE AVISADA DA POSSIBILIDADE DE TAIS DANOS. "

#: book.translate.xml:4325
#, fuzzy
msgid ""
"FreeBSD includes experimental support for several mandatory access control policies, "
"as well as a framework for kernel security extensibility, the TrustedBSD MAC "
"Framework. The MAC Framework is a pluggable access control framework, permitting new "
"security policies to be easily linked into the kernel, loaded at boot, or loaded "
"dynamically at run-time. The framework provides a variety of features to make it "
"easier to implement new security policies, including the ability to easily tag "
"security labels (such as confidentiality information) onto system objects."
msgstr ""
"O FreeBSD inclui suporte experimental para v·rias polÌ≠ticas de controle de acesso, "
"bem como uma estrutura para extensibilidade de seguranÁa do kernel, o TrustedBSD MAC "
"Framework. O MAC Framework È uma estrutura de controle de acesso plug·vel, "
"permitindo que novas polÌ≠ticas de seguranÁa sejam facilmente vinculadas ao kernel na "
"inicializaÁ„o ou carregada dinamicamente em tempo de execuÁ„o. A estrutura fornece "
"uma variedade de recursos para facilitar a implementaÁ„o de novas polÌ≠ticas de "
"seguranÁa, incluindo a capacidade de marcar facilmente rÛtulos de seguranÁa (como "
"informaÁÌµes de confidencialidade) em objetos do sistema. "

#: book.translate.xml:4336
#, fuzzy
msgid ""
"This chapter introduces the MAC policy framework and provides documentation for a "
"sample MAC policy module."
msgstr ""
"Este capÌ≠tulo apresenta a estrutura de polÌ≠tica do MAC e fornece documentaÁ„o para "
"um mÛdulo de polÌ≠tica MAC de amostra."

#: book.translate.xml:22640 book.translate.xml:21588 book.translate.xml:15974
#: book.translate.xml:14804 book.translate.xml:4342
#, fuzzy
msgid "Introduction"
msgstr "IntroduÁ„o"

#: book.translate.xml:4344
#, fuzzy
msgid ""
"The TrustedBSD MAC framework provides a mechanism to allow the compile-time or run-"
"time extension of the kernel access control model. New system policies may be "
"implemented as kernel modules and linked to the kernel; if multiple policy modules "
"are present, their results will be composed. The MAC Framework provides a variety of "
"access control infrastructure services to assist policy writers, including support "
"for transient and persistent policy-agnostic object security labels. This support is "
"currently considered experimental."
msgstr ""
"A estrutura MAC do TrustedBSD fornece um mecanismo para permitir a extens„o em tempo "
"de compilaÁ„o ou de tempo de execuÁ„o do modelo de controle de acesso do kernel. "
"Novas polÌ≠ticas do sistema podem ser implementadas como mÛdulos do kernel e "
"vinculadas ao kernel; se houver v·rios mÛdulos de polÌ≠tica, seus resultados O MAC "
"Framework fornece uma variedade de serviÁos de infra-estrutura de controle de acesso "
"para auxiliar os redatores de polÌ≠ticas, incluindo o suporte a rÛtulos de seguranÁa "
"de objetos agnÛsticos, transitÛrios e persistentes. Esse suporte È atualmente "
"considerado experimental. "

#: book.translate.xml:4354
#, fuzzy
msgid ""
"This chapter provides information appropriate for developers of policy modules, as "
"well as potential consumers of MAC-enabled environments, to learn about how the MAC "
"Framework supports access control extension of the kernel."
msgstr ""
"Este capÌ≠tulo fornece informaÁÌµes apropriadas para desenvolvedores de mÛdulos de "
"polÌ≠ticas, bem como potenciais consumidores de ambientes habilitados para MAC, para "
"aprender sobre como o MAC Framework suporta a extens„o de controle de acesso do "
"kernel."

#: book.translate.xml:4361
#, fuzzy
msgid "Policy Background"
msgstr "HistÛrico da PolÌ≠tica"

#: book.translate.xml:4363
#, fuzzy
msgid ""
"Mandatory Access Control (MAC), refers to a set of access control policies that are "
"mandatorily enforced on users by the operating system. MAC policies may be "
"contrasted with Discretionary Access Control (DAC) protections, by which non-"
"administrative users may (at their discretion) protect objects. In traditional UNIX "
"systems, DAC protections include file permissions and access control lists; MAC "
"protections include process controls preventing inter-user debugging and firewalls. "
"A variety of MAC policies have been formulated by operating system designers and "
"security researches, including the Multi-Level Security (MLS) confidentiality "
"policy, the Biba integrity policy, Role-Based Access Control (RBAC), Domain and Type "
"Enforcement (DTE), and Type Enforcement (TE). Each model bases decisions on a "
"variety of factors, including user identity, role, and security clearance, as well "
"as security labels on objects representing concepts such as data sensitivity and "
"integrity."
msgstr ""
"Mandatory Access Control (MAC), refere-se a um conjunto de polÌ≠ticas de controle de "
"acesso impostas obrigatoriamente aos usu·rios pelo sistema operacional. As polÌ≠ticas "
"MAC podem ser contrastadas com as proteÁÌµes de Controle de Acesso Discricion·rio "
"(DAC), pelas quais usu·rios n„o administrativos podem Em seus sistemas UNIX "
"tradicionais, as proteÁÌµes do DAC incluem permissÌµes de arquivos e listas de "
"controle de acesso, e as proteÁÌµes MAC incluem controles de processo que impedem a "
"depuraÁ„o entre usu·rios e firewalls.Uma variedade de polÌ≠ticas MAC foram formuladas "
"por projetistas de sistemas operacionais e pesquisas de seguranÁa. incluindo a polÌ≠"
"tica de confidencialidade Multi-Level Security (MLS), a polÌ≠tica de integridade "
"Biba, RBAC (Role-Based Access Control), DTE (Domain and Type Enforcement) e TE (Type "
"Enforcement), cada modelo baseia as decisÌµes numa variedade de fatores. , incluindo "
"identidade de usu·rio, funÁ„o e autorizaÁ„o de seguranÁa, bem como etiquetas de "
"seguranÁa em objetos que representam conceitos como integridade e sensibilidade de "
"dados. "

#: book.translate.xml:4381
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework is capable of supporting policy modules that implement "
"all of these policies, as well as a broad class of system hardening policies, which "
"may use existing security attributes, such as user and group IDs, as well as "
"extended attributes on files, and other system properties. In addition, despite the "
"name, the MAC Framework can also be used to implement purely discretionary policies, "
"as policy modules are given substantial flexibility in how they authorize "
"protections."
msgstr ""
"O TrustedBSD MAC Framework È capaz de suportar mÛdulos de polÌ≠ticas que implementam "
"todas essas polÌ≠ticas, bem como uma ampla classe de polÌ≠ticas de proteÁ„o do "
"sistema, que podem usar atributos de seguranÁa existentes, como IDs de usu·rios e "
"grupos, bem como atributos estendidos em arquivos e outras propriedades do sistema "
"AlÈm disso, apesar do nome, o MAC Framework tambÈm pode ser usado para implementar "
"polÌ≠ticas puramente discricion·rias, uma vez que os mÛdulos de polÌ≠ticas recebem uma "
"flexibilidade substancial na forma como autorizam proteÁÌµes \""

#: book.translate.xml:4393
#, fuzzy
msgid "MAC Framework Kernel Architecture"
msgstr "Arquitetura do Kernel do MAC Framework"

#: book.translate.xml:4395
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework permits kernel modules to extend the operating system "
"security policy, as well as providing infrastructure functionality required by many "
"access control modules. If multiple policies are simultaneously loaded, the MAC "
"Framework will usefully (for some definition of useful) compose the results of the "
"policies."
msgstr ""
"O TrustedBSD MAC Framework permite que os mÛdulos do kernel estendam a polÌ≠tica de "
"seguranÁa do sistema operacional, bem como fornecem a funcionalidade de infra-"
"estrutura requerida por muitos mÛdulos de controle de acesso. Se v·rias polÌ≠ticas "
"forem carregadas simultaneamente, o MAC Framework utilizar· (para alguma definiÁ„o "
"˙til) resultados das polÌ≠ticas \""

#: book.translate.xml:4404
#, fuzzy
msgid "Kernel Elements"
msgstr "Elementos do Kernel"

#: book.translate.xml:4406
#, fuzzy
msgid "The MAC Framework contains a number of kernel elements:"
msgstr "O MAC Framework contÈm v·rios elementos do kernel:"

#: book.translate.xml:4409
#, fuzzy
msgid "Framework management interfaces"
msgstr "Interfaces de gerenciamento de estrutura"

#: book.translate.xml:4410
#, fuzzy
msgid "Concurrency and synchronization primitives."
msgstr "Primitivas de sincronizaÁ„o e simultaneidade."

#: book.translate.xml:4412
#, fuzzy
msgid "Policy registration"
msgstr "Registo de polÌ≠tica"

#: book.translate.xml:4413
#, fuzzy
msgid "Extensible security label for kernel objects"
msgstr "Etiqueta de seguranÁa extensÌ≠vel para objetos do kernel"

#: book.translate.xml:4415
#, fuzzy
msgid "Policy entry point composition operators"
msgstr "Operadores de composiÁ„o de ponto de entrada de polÌ≠tica"

#: book.translate.xml:4417
#, fuzzy
msgid "Label management primitives"
msgstr "Primitivos de gerenciamento de rÛtulo"

#: book.translate.xml:4418
#, fuzzy
msgid "Entry point API invoked by kernel services"
msgstr "API do ponto de entrada invocada pelos serviÁos do kernel"

#: book.translate.xml:4420
#, fuzzy
msgid "Entry point API to policy modules"
msgstr "API de ponto de entrada para mÛdulos de polÌ≠tica"

#: book.translate.xml:4421
#, fuzzy
msgid ""
"Entry points implementations (policy life cycle, object life cycle/label management, "
"access control checks)."
msgstr ""
"ImplementaÁÌµes de pontos de entrada (ciclo de vida da polÌ≠tica, ciclo de vida do "
"objeto / gerenciamento de etiquetas, verificaÁÌµes de controle de acesso)."

#: book.translate.xml:4424
#, fuzzy
msgid "Policy-agnostic label-management system calls"
msgstr "Chamadas de sistema de gerenciamento de rÛtulo agnÛstico de polÌ≠ticas"

#: book.translate.xml:4426
#, fuzzy
msgid "<function>mac_syscall()</function> multiplex system call"
msgstr " <function> mac_syscall () </function> chamada do sistema multiplex "

#: book.translate.xml:4428
#, fuzzy
msgid "Various security policies implemented as MAC policy modules"
msgstr "V·rias polÌ≠ticas de seguranÁa implementadas como mÛdulos de polÌ≠tica MAC"

#: book.translate.xml:4434
#, fuzzy
msgid "Framework Management Interfaces"
msgstr "Framework Management Interfaces"

#: book.translate.xml:4436
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework may be directly managed using sysctl's, loader "
"tunables, and system calls."
msgstr ""
"O TrustedBSD MAC Framework pode ser gerenciado diretamente usando sysctl';s, "
"sintetizadores de carregador e chamadas do sistema."

#: book.translate.xml:4439
#, fuzzy
msgid ""
"In most cases, sysctl's and loader tunables of the same name modify the same "
"parameters, and control behavior such as enforcement of protections relating to "
"various kernel subsystems. In addition, if MAC debugging support is compiled into "
"the kernel, several counters will be maintained tracking label allocation. It is "
"generally advisable that per-subsystem enforcement controls not be used to control "
"policy behavior in production environments, as they broadly impact the operation of "
"all active policies. Instead, per-policy controls should be preferred, as they "
"provide greater granularity and greater operational consistency for policy modules."
msgstr ""
"Na maioria dos casos, sysctl';s e loaders sintoniz·veis ‚Äã‚Äãdo mesmo nome modificam os "
"mesmos parÌ¢metros e controlam o comportamento, como a aplicaÁ„o de proteÁÌµes "
"relacionadas a v·rios subsistemas do kernel. AlÈm disso, se o suporte de depuraÁ„o "
"MAC for compilado no kernel, v·rios contadores ser„o mantidos. Ìâ geralmente "
"aconselh·vel que os controles de fiscalizaÁ„o por subsistema n„o sejam usados ‚Äã‚Äãpara "
"controlar o comportamento de polÌ≠ticas em ambientes de produÁ„o, pois eles "
"geralmente afetam a operaÁ„o de todas as polÌ≠ticas ativas. granularidade e maior "
"consistÍncia operacional para mÛdulos de polÌ≠ticas. "

#: book.translate.xml:4452
#, fuzzy
msgid ""
"Loading and unloading of policy modules is performed using the system module "
"management system calls and other system interfaces, including boot loader "
"variables; policy modules will have the opportunity to influence load and unload "
"events, including preventing undesired unloading of the policy."
msgstr ""
"O carregamento e descarregamento de mÛdulos de polÌ≠ticas È realizado usando as "
"chamadas do sistema de gerenciamento de mÛdulos do sistema e outras interfaces do "
"sistema, incluindo vari·veis ‚Äã‚Äãdo carregador de inicializaÁ„o; os mÛdulos de polÌ≠"
"tica ter„o a oportunidade de influenciar a carga e descarga de eventos, incluindo a "
"prevenÁ„o de descarregamento indesejado da polÌ≠tica."

#: book.translate.xml:4460
#, fuzzy
msgid "Policy List Concurrency and Synchronization"
msgstr "ConcorrÍncia e SincronizaÁ„o da Lista de PolÌ≠ticas"

#: book.translate.xml:4462
#, fuzzy
msgid ""
"As the set of active policies may change at run-time, and the invocation of entry "
"points is non-atomic, synchronization is required to prevent loading or unloading of "
"policies while an entry point invocation is in progress, freezing the set of active "
"policies for the duration. This is accomplished by means of a framework busy count: "
"whenever an entry point is entered, the busy count is incremented; whenever it is "
"exited, the busy count is decremented. While the busy count is elevated, policy list "
"changes are not permitted, and threads attempting to modify the policy list will "
"sleep until the list is not busy. The busy count is protected by a mutex, and a "
"condition variable is used to wake up sleepers waiting on policy list modifications. "
"One side effect of this synchronization model is that recursion into the MAC "
"Framework from within a policy module is permitted, although not generally used."
msgstr ""
"Como o conjunto de polÌ≠ticas ativas pode mudar em tempo de execuÁ„o e a invocaÁ„o de "
"pontos de entrada n„o È atÌ¥mica, a sincronizaÁ„o È necess·ria para impedir o "
"carregamento ou descarregamento de polÌ≠ticas enquanto uma chamada de ponto de "
"entrada est· em andamento, congelando o conjunto de polÌ≠ticas ativas Isso ocorre por "
"meio de uma contagem ocupacional de estrutura: sempre que um ponto de entrada È "
"inserido, a contagem de ocupado È incrementada e, quando ela È encerrada, a contagem "
"de ocupado È diminuÌ≠da. n„o permitido, e os segmentos que tentam modificar a lista "
"de polÌ≠ticas ficar„o suspensos atÈ que a lista n„o esteja ocupada.A contagem ocupada "
"È protegida por um mutex e uma vari·vel de condiÁ„o È usada para ativar os travessas "
"aguardando modificaÁÌµes na lista de polÌ≠ticas. O modelo de sincronizaÁ„o È que a "
"recurs„o no MAC Framework de dentro de um mÛdulo de polÌ≠tica È permitida, embora n„o "
"seja geralmente usada. "

#: book.translate.xml:4480
#, fuzzy
msgid ""
"Various optimizations are used to reduce the overhead of the busy count, including "
"avoiding the full cost of incrementing and decrementing if the list is empty or "
"contains only static entries (policies that are loaded before the system starts, and "
"cannot be unloaded). A compile-time option is also provided which prevents any "
"change in the set of loaded policies at run-time, which eliminates the mutex locking "
"costs associated with supporting dynamically loaded and unloaded policies as "
"synchronization is no longer required."
msgstr ""
"V·rias otimizaÁÌµes s„o usadas para reduzir a sobrecarga da contagem de ocupaÁÌµes, "
"evitando o custo total de incrementar e decrementar se a lista estiver vazia ou "
"contiver apenas entradas est·ticas (polÌ≠ticas que s„o carregadas antes do sistema "
"ser iniciado e n„o podem ser descarregadas). opÁ„o de tempo de compilaÁ„o tambÈm È "
"fornecida, o que elimina qualquer alteraÁ„o no conjunto de polÌ≠ticas carregadas em "
"tempo de execuÁ„o, o que elimina os custos de bloqueio mutex associados ao suporte "
"de polÌ≠ticas carregadas e descarregadas dinamicamente, j· que a sincronizaÁ„o n„o È "
"mais necess·ria. "

#: book.translate.xml:4491
#, fuzzy
msgid ""
"As the MAC Framework is not permitted to block in some entry points, a normal sleep "
"lock cannot be used; as a result, it is possible for the load or unload attempt to "
"block for a substantial period of time waiting for the framework to become idle."
msgstr ""
"Como o MAC Framework n„o tem permiss„o para bloquear em alguns pontos de entrada, "
"n„o È possÌ≠vel usar um bloqueio de sono normal; como resultado, È possÌ≠vel que a "
"tentativa de carga ou descarga seja bloqueada por um perÌ≠odo de tempo substancial "
"esperando a estrutura se tornar ocioso \""

#: book.translate.xml:4499
#, fuzzy
msgid "Label Synchronization"
msgstr "Label Synchronization"

#: book.translate.xml:4501
#, fuzzy
msgid ""
"As kernel objects of interest may generally be accessed from more than one thread at "
"a time, and simultaneous entry of more than one thread into the MAC Framework is "
"permitted, security attribute storage maintained by the MAC Framework is carefully "
"synchronized. In general, existing kernel synchronization on kernel object data is "
"used to protect MAC Framework security labels on the object: for example, MAC labels "
"on sockets are protected using the existing socket mutex. Likewise, semantics for "
"concurrent access are generally identical to those of the container objects: for "
"credentials, copy-on-write semantics are maintained for label contents as with the "
"remainder of the credential structure. The MAC Framework asserts necessary locks on "
"objects when invoked with an object reference. Policy authors must be aware of these "
"synchronization semantics, as they will sometimes limit the types of accesses "
"permitted on labels: for example, when a read-only reference to a credential is "
"passed to a policy via an entry point, only read operations are permitted on the "
"label state attached to the credential."
msgstr ""
"Como os objetos de interesse do kernel geralmente podem ser acessados ‚Äã‚Äãde mais de "
"um thread de cada vez, e a entrada simultÌ¢nea de mais de um thread no MAC Framework "
"È permitida, o armazenamento de atributos de seguranÁa mantido pelo MAC Framework È "
"cuidadosamente sincronizado. A sincronizaÁ„o do kernel nos dados do objeto kernel È "
"usada para proteger os rÛtulos de seguranÁa do MAC Framework no objeto: por exemplo, "
"os rÛtulos MAC nos soquetes s„o protegidos usando o mutex de soquete existente Da "
"mesma forma, as semÌ¢nticas para acesso simultÌ¢neo s„o geralmente idÍnticas "
"Ì†quelas dos objetos contÍineres: credenciais, a semÌ¢ntica de copy-on-write È "
"mantida para o conte˙do da etiqueta como no restante da estrutura de credencial.O "
"MAC Framework afirma os bloqueios necess·rios em objetos quando invocado com uma "
"referÍncia de objeto.Os autores da polÌ≠tica devem estar cientes dessas semÌ¢nticas "
"de sincronizaÁ„o, pois elas ÌÄs vezes, limitar os tipos de acessos permitidos nos "
"rÛtulos: por exemplo, quando uma referÍncia somente leitura a uma credencial È "
"passada para uma polÌ≠tica por meio de um ponto de entrada, somente as operaÁÌµes de "
"leitura s„o permitidas no estado da etiqueta anexado Ì† credencial. "

#: book.translate.xml:4524
#, fuzzy
msgid "Policy Synchronization and Concurrency"
msgstr "SincronizaÁ„o e ConcorrÍncia de PolÌ≠ticas"

#: book.translate.xml:4526
#, fuzzy
msgid ""
"Policy modules must be written to assume that many kernel threads may simultaneously "
"enter one more policy entry points due to the parallel and preemptive nature of the "
"FreeBSD kernel. If the policy module makes use of mutable state, this may require "
"the use of synchronization primitives within the policy to prevent inconsistent "
"views on that state resulting in incorrect operation of the policy. Policies will "
"generally be able to make use of existing FreeBSD synchronization primitives for "
"this purpose, including mutexes, sleep locks, condition variables, and counting "
"semaphores. However, policies should be written to employ these primitives "
"carefully, respecting existing kernel lock orders, and recognizing that some entry "
"points are not permitted to sleep, limiting the use of primitives in those entry "
"points to mutexes and wakeup operations."
msgstr ""
"Os mÛdulos de polÌ≠tica devem ser escritos para assumir que muitos encadeamentos do "
"kernel podem inserir simultaneamente mais um ponto de entrada de polÌ≠tica devido Ì† "
"natureza paralela e preventiva do kernel do FreeBSD. Se o mÛdulo de polÌ≠tica faz uso "
"do estado mut·vel, isso pode exigir o uso de primitivas de sincronizaÁ„o dentro da "
"polÌ≠tica para evitar visÌµes inconsistentes sobre aquele estado resultando em "
"operaÁ„o incorreta da polÌ≠tica, geralmente as polÌ≠ticas poder„o fazer uso das "
"primitivas de sincronizaÁ„o existentes do FreeBSD para este propÛsito, incluindo "
"mutexes, travas de sono, vari·veis ‚Äã‚Äãde condiÁ„o e sem·foros de contagem. as polÌ≠"
"ticas devem ser escritas para empregar esses primitivos cuidadosamente, respeitando "
"os pedidos de bloqueio do kernel existentes, e reconhecendo que alguns pontos de "
"entrada n„o tÍm permiss„o para dormir, limitando o uso de primitivos nesses pontos "
"de entrada para mutexes e operaÁÌµes de ativaÁ„o. "

#: book.translate.xml:4543
#, fuzzy
msgid ""
"When policy modules call out to other kernel subsystems, they will generally need to "
"release any in-policy locks in order to avoid violating the kernel lock order or "
"risking lock recursion. This will maintain policy locks as leaf locks in the global "
"lock order, helping to avoid deadlock."
msgstr ""
"Quando os mÛdulos de polÌ≠tica chamam outros subsistemas do kernel, eles geralmente "
"precisam liberar qualquer bloqueio na polÌ≠tica para evitar violar a ordem de "
"bloqueio do kernel ou arriscar a recurs„o do bloqueio. Isso manter· os bloqueios de "
"polÌ≠tica como bloqueios de folha na ordem de bloqueio global. ajudando a evitar o "
"impasse \""

#: book.translate.xml:4551
#, fuzzy
msgid "Policy Registration"
msgstr "Registro de PolÌ≠tica"

#: book.translate.xml:4553
#, fuzzy
msgid ""
"The MAC Framework maintains two lists of active policies: a static list, and a "
"dynamic list. The lists differ only with regards to their locking semantics: an "
"elevated reference count is not required to make use of the static list. When kernel "
"modules containing MAC Framework policies are loaded, the policy module will use "
"<literal>SYSINIT</literal> to invoke a registration function; when a policy module "
"is unloaded, <literal>SYSINIT</literal> will likewise invoke a de-registration "
"function. Registration may fail if a policy module is loaded more than once, if "
"insufficient resources are available for the registration (for example, the policy "
"might require labeling and insufficient labeling state might be available), or other "
"policy prerequisites might not be met (some policies may only be loaded prior to "
"boot). Likewise, de-registration may fail if a policy is flagged as not unloadable."
msgstr ""
"O MAC Framework mantÈm duas listas de polÌ≠ticas ativas: uma lista est·tica e uma "
"lista dinÌ¢mica. As listas diferem apenas em relaÁ„o Ì† semÌ¢ntica de bloqueio: uma "
"contagem de referÍncia elevada n„o È necess·ria para fazer uso da lista est·tica. "
"Quando os mÛdulos do kernel contÍm PolÌ≠ticas do MAC Framework s„o carregadas, o "
"mÛdulo de polÌ≠tica usar· <literal> SYSINIT </literal> invocar uma funÁ„o de "
"registro; quando um mÛdulo de polÌ≠tica È descarregado, <literal> SYSINIT </literal> "
"Da mesma forma, invocar· uma funÁ„o de cancelamento de registro. O registro pode "
"falhar se um mÛdulo de polÌ≠tica for carregado mais de uma vez, se recursos "
"insuficientes estiverem disponÌ≠veis para o registro (por exemplo, a polÌ≠tica exigir "
"rotulagem e estado de rotulagem insuficiente estiver disponÌ≠vel) ou se outros prÈ-"
"requisitos de diretiva n„o forem atendidos sÛ pode ser carregado antes da "
"inicializaÁ„o). Da mesma forma, o cancelamento de registro poder· falhar se uma polÌ≠"
"tica for sinalizada como n„o descarreg·vel. "

#: book.translate.xml:4574
#, fuzzy
msgid "Entry Points"
msgstr "Pontos de entrada"

#: book.translate.xml:4576
#, fuzzy
msgid ""
"Kernel services interact with the MAC Framework in two ways: they invoke a series of "
"APIs to notify the framework of relevant events, and they provide a policy-agnostic "
"label structure pointer in security-relevant objects. The label pointer is "
"maintained by the MAC Framework via label management entry points, and permits the "
"Framework to offer a labeling service to policy modules through relatively non-"
"invasive changes to the kernel subsystem maintaining the object. For example, label "
"pointers have been added to processes, process credentials, sockets, pipes, vnodes, "
"Mbufs, network interfaces, IP reassembly queues, and a variety of other security-"
"relevant structures. Kernel services also invoke the MAC Framework when they perform "
"important security decisions, permitting policy modules to augment those decisions "
"based on their own criteria (possibly including data stored in security labels). "
"Most of these security critical decisions will be explicit access control checks; "
"however, some affect more general decision functions such as packet matching for "
"sockets and label transition at program execution."
msgstr ""
"Os serviÁos do kernel interagem com o MAC Framework de duas maneiras: eles invocam "
"uma sÈrie de APIs para notificar a estrutura de eventos relevantes e fornecem um "
"ponteiro de estrutura de rÛtulos agnÛsticos para polÌ≠ticas em objetos relevantes "
"para a seguranÁa. O ponteiro de rÛtulo È mantido pelo MAC Framework via pontos de "
"entrada de gerenciamento de rÛtulos e permite que o Framework ofereÁa um serviÁo de "
"rotulagem aos mÛdulos de polÌ≠tica atravÈs de alteraÁÌµes relativamente n„o invasivas "
"ao subsistema do kernel mantendo os objetos. Por exemplo, ponteiros de rÛtulo foram "
"adicionados a processos, credenciais de processo, soquetes vnodes, Mbufs, interfaces "
"de rede, filas de reagrupamento IP e uma variedade de outras estruturas relevantes "
"para seguranÁa.Os serviÁos de kernel tambÈm invocam o MAC Framework quando executam "
"importantes decisÌµes de seguranÁa, permitindo que os mÛdulos de polÌ≠ticas aumentem "
"essas decisÌµes com base em seus prÛprios critÈrios (possivelmente incluindo os "
"dados armazenados nos rÛtulos de seguranÁa.) A maioria dessas decisÌµes crÌ≠ticas de "
"seguranÁa ser„o verificaÁÌµes explÌ≠citas de controle de acesso; afetam funÁÌµes de "
"decis„o mais gerais, como correspondÍncia de pacotes para soquetes e transiÁ„o de "
"rÛtulo na execuÁ„o do programa. "

#: book.translate.xml:4598
#, fuzzy
msgid "Policy Composition"
msgstr "ComposiÁ„o da PolÌ≠tica"

#: book.translate.xml:4600
#, fuzzy
msgid ""
"When more than one policy module is loaded into the kernel at a time, the results of "
"the policy modules will be composed by the framework using a composition operator. "
"This operator is currently hard-coded, and requires that all active policies must "
"approve a request for it to return success. As policies may return a variety of "
"error conditions (success, access denied, object does not exist, ...), a precedence "
"operator selects the resulting error from the set of errors returned by policies. In "
"general, errors indicating that an object does not exist will be preferred to errors "
"indicating that access to an object is denied. While it is not guaranteed that the "
"resulting composition will be useful or secure, we have found that it is for many "
"useful selections of policies. For example, traditional trusted systems often ship "
"with two or more policies using a similar composition."
msgstr ""
"Quando mais de um mÛdulo de polÌ≠tica È carregado no kernel de cada vez, os "
"resultados dos mÛdulos de polÌ≠tica ser„o compostos pela estrutura usando um operador "
"de composiÁ„o. Esse operador est· atualmente embutido em cÛdigo e requer que todas "
"as polÌ≠ticas ativas aprovem uma pedido para que ele retorne sucesso.Como as polÌ≠"
"ticas podem retornar uma variedade de condiÁÌµes de erro (sucesso, acesso negado, "
"objeto n„o existe, ...), um operador de precedÍncia seleciona o erro resultante do "
"conjunto de erros retornados pelas polÌ≠ticas. , erros indicando que um objeto n„o "
"existe ser„o preferidos a erros indicando que o acesso a um objeto È negado.Enquanto "
"n„o È garantido que a composiÁ„o resultante ser· ˙til ou segura, descobrimos que È "
"para muitas seleÁÌµes ˙teis de polÌ≠ticas Por exemplo, sistemas confi·veis "
"‚Äã‚Äãtradicionais geralmente vÍm com duas ou mais polÌ≠ticas usando uma composiÁ„o "
"similar. "

#: book.translate.xml:4619
#, fuzzy
msgid "Labeling Support"
msgstr "Suporte de rotulagem"

#: book.translate.xml:4621
#, fuzzy
msgid ""
"As many interesting access control extensions rely on security labels on objects, "
"the MAC Framework provides a set of policy-agnostic label management system calls "
"covering a variety of user-exposed objects. Common label types include partition "
"identifiers, sensitivity labels, integrity labels, compartments, domains, roles, and "
"types. By policy agnostic, we mean that policy modules are able to completely define "
"the semantics of meta-data associated with an object. Policy modules participate in "
"the internalization and externalization of string-based labels provides by user "
"applications, and can expose multiple label elements to applications if desired."
msgstr ""
"Como muitas extensÌµes de controle de acesso interessantes dependem de rÛtulos de "
"seguranÁa em objetos, o MAC Framework fornece um conjunto de chamadas de sistema de "
"gerenciamento de rÛtulos agnÛsticos que cobrem uma variedade de objetos expostos "
"pelo usu·rio. Os tipos de rÛtulos comuns incluem identificadores de partiÁ„o, "
"rÛtulos de sensibilidade e rÛtulos de integridade. compartimentos, domÌ≠nios, "
"funÁÌµes e tipos. Por polÌ≠tica agnÛstica, queremos dizer que os mÛdulos de polÌ≠tica "
"s„o capazes de definir completamente a semÌ¢ntica de metadados associados a um "
"objeto. MÛdulos de polÌ≠ticas participam da internalizaÁ„o e externalizaÁ„o de "
"rÛtulos baseados em strings fornecidas pelo usu·rio aplicativos e pode expor v·rios "
"elementos de rÛtulo para aplicativos, se desejado. "

#: book.translate.xml:4634
#, fuzzy
msgid ""
"In-memory labels are stored in slab-allocated <varname remap=\"structname\">struct "
"label</varname>, which consists of a fixed-length array of unions, each holding a "
"<literal>void *</literal> pointer and a <literal>long</literal>. Policies "
"registering for label storage will be assigned a \"slot\" identifier, which may be "
"used to dereference the label storage. The semantics of the storage are left "
"entirely up to the policy module: modules are provided with a variety of entry "
"points associated with the kernel object life cycle, including initialization, "
"association/creation, and destruction. Using these interfaces, it is possible to "
"implement reference counting and other storage models. Direct access to the object "
"structure is generally not required by policy modules to retrieve a label, as the "
"MAC Framework generally passes both a pointer to the object and a direct pointer to "
"the object's label into entry points. The primary exception to this rule is the "
"process credential, which must be manually dereferenced to access the credential "
"label. This may change in future revisions of the MAC Framework."
msgstr ""
"Etiquetas na memÛria s„o armazenadas em alocaÁ„o de placas <varname remap="
"\"structname\"> rÛtulo struct </varname> , que consiste em uma matriz de uniÌµes de "
"comprimento fixo, cada uma segurando uma <literal> void * </literal> ponteiro e um "
"<literal> longo </literal> . As polÌ≠ticas que se registram para o armazenamento de "
"rÛtulo receber„o um identificador \\ \"slot \", que pode ser usado para excluir a "
"referÍncia do armazenamento de rÛtulo. A semÌ¢ntica do armazenamento È deixada "
"inteiramente para o mÛdulo de polÌ≠tica: os mÛdulos s„o fornecidos com uma variedade "
"de pontos de entrada associados ao ciclo de vida do objeto do kernel, incluindo "
"inicializaÁ„o, associaÁ„o / criaÁ„o e destruiÁ„o. Usando essas interfaces, È possÌ≠"
"vel implementar a contagem de referÍncia e outros modelos de armazenamento. O acesso "
"direto Ì† estrutura do objeto geralmente n„o È exigido pelos mÛdulos de polÌ≠tica "
"para recuperar um rÛtulo, j· que o MAC Framework geralmente passa um ponteiro para o "
"objeto e um ponteiro direto para o rÛtulo do objeto nos pontos de entrada. A "
"principal exceÁ„o a essa regra È a credencial do processo, que deve ser manualmente "
"referenciada para acessar o rÛtulo da credencial. Isso pode mudar em futuras "
"revisÌµes do MAC Framework. "

#: book.translate.xml:4654
#, fuzzy
msgid ""
"Initialization entry points frequently include a sleeping disposition flag "
"indicating whether or not an initialization is permitted to sleep; if sleeping is "
"not permitted, a failure may be returned to cancel allocation of the label (and "
"hence object). This may occur, for example, in the network stack during interrupt "
"handling, where sleeping is not permitted, or while the caller holds a mutex. Due to "
"the performance cost of maintaining labels on in-flight network packets (Mbufs), "
"policies must specifically declare a requirement that Mbuf labels be allocated. "
"Dynamically loaded policies making use of labels must be able to handle the case "
"where their init function has not been called on an object, as objects may already "
"exist when the policy is loaded. The MAC Framework guarantees that uninitialized "
"label slots will hold a 0 or NULL value, which policies may use to detect "
"uninitialized values. However, as allocation of Mbuf labels is conditional, policies "
"must also be able to handle a NULL label pointer for Mbufs if they have been loaded "
"dynamically."
msgstr ""
"Os pontos de entrada de inicializaÁ„o freqÌºentemente incluem um sinalizador de "
"disposiÁ„o de sono indicando se uma inicializaÁ„o È permitida ou n„o; se dormir n„o "
"for permitido, uma falha pode ser retornada para cancelar a alocaÁ„o do rÛtulo (e, "
"portanto, objeto). Isso pode ocorrer, por exemplo , na pilha de rede durante o "
"manuseio de interrupÁ„o, onde dormir n„o È permitido ou enquanto o chamador possui "
"um mutex.Devido ao custo de desempenho de manutenÁ„o de rÛtulos em pacotes de rede "
"em trÌ¢nsito (Mbufs), diretivas devem declarar especificamente um requisito que "
"rÛtulos Mbuf PolÌ≠ticas carregadas dinamicamente que usam rÛtulos devem ser capazes "
"de lidar com o caso em que sua funÁ„o init n„o foi chamada em um objeto, j· que "
"objetos j· podem existir quando a polÌ≠tica È carregada. O MAC Framework garante que "
"os slots de rÛtulo n„o inicializados um valor 0 ou NULL, que as polÌ≠ticas podem usar "
"para detectar valores n„o inicializados.No entanto, como a alocaÁ„o de rÛtulos Mbuf "
"È condicional, as polÌ≠ticas tambÈm devem ser capazes de manipular Ponteiro de rÛtulo "
"NULL para Mbufs se eles foram carregados dinamicamente. "

#: book.translate.xml:4675
#, fuzzy
msgid ""
"In the case of file system labels, special support is provided for the persistent "
"storage of security labels in extended attributes. Where available, extended "
"attribute transactions are used to permit consistent compound updates of security "
"labels on vnodes--currently this support is present only in the UFS2 file system. "
"Policy authors may choose to implement multilabel file system object labels using "
"one (or more) extended attributes. For efficiency reasons, the vnode label "
"(<literal>v_label</literal>) is a cache of any on-disk label; policies are able to "
"load values into the cache when the vnode is instantiated, and update the cache as "
"needed. As a result, the extended attribute need not be directly accessed with every "
"access control check."
msgstr ""
"No caso de rÛtulos de sistema de arquivos, È fornecido suporte especial para o "
"armazenamento persistente de rÛtulos de seguranÁa em atributos estendidos. Quando "
"disponÌ≠veis, transaÁÌµes de atributos estendidas s„o usadas para permitir "
"atualizaÁÌµes consistentes de rÛtulos de seguranÁa em vnodes - atualmente este "
"suporte est· presente apenas No sistema de arquivos UFS2, os autores de polÌ≠ticas "
"podem optar por implementar rÛtulos de objeto de sistema de arquivos multilabel "
"usando um (ou mais) atributos estendidos.Por razÌµes de eficiÍncia, o rÛtulo vnode "
"( <literal> v_label </literal> ) È um cache de qualquer rÛtulo no disco; as polÌ≠"
"ticas podem carregar valores no cache quando o vnode È instanciado e atualizar o "
"cache conforme necess·rio. Como resultado, o atributo estendido n„o precisa ser "
"acessado diretamente com todas as verificaÁÌµes de controle de acesso. "

#: book.translate.xml:4689
#, fuzzy
msgid ""
"Currently, if a labeled policy permits dynamic unloading, its state slot cannot be "
"reclaimed, which places a strict (and relatively low) bound on the number of unload-"
"reload operations for labeled policies."
msgstr ""
"Atualmente, se uma polÌ≠tica rotulada permite descarregamento dinÌ¢mico, seu slot de "
"estado n„o pode ser recuperado, o que coloca um limite estrito (e relativamente "
"baixo) no n˙mero de operaÁÌµes de descarregamento para polÌ≠ticas rotuladas."

#: book.translate.xml:4696
#, fuzzy
msgid "System Calls"
msgstr "Chamadas do sistema"

#: book.translate.xml:4698
#, fuzzy
msgid ""
"The MAC Framework implements a number of system calls: most of these calls support "
"the policy-agnostic label retrieval and manipulation APIs exposed to user "
"applications."
msgstr ""
"O MAC Framework implementa v·rias chamadas de sistema: a maioria dessas chamadas "
"suporta APIs de recuperaÁ„o e manipulaÁ„o de etiquetas agnÛsticas de polÌ≠ticas "
"expostas a aplicativos de usu·rios."

#: book.translate.xml:4703
#, fuzzy
msgid ""
"The label management calls accept a label description structure, <varname remap="
"\"structname\">struct mac</varname>, which contains a series of MAC label elements. "
"Each element contains a character string name, and character string value. Each "
"policy will be given the chance to claim a particular element name, permitting "
"policies to expose multiple independent elements if desired. Policy modules perform "
"the internalization and externalization between kernel labels and user-provided "
"labels via entry points, permitting a variety of semantics. Label management system "
"calls are generally wrapped by user library functions to perform memory allocation "
"and error handling, simplifying user applications that must manage labels."
msgstr ""
"As chamadas de gerenciamento de etiquetas aceitam uma estrutura de descriÁ„o de "
"rÛtulo, <varname remap=\"structname\"> struct mac </varname> , que contÈm uma sÈrie "
"de elementos de rÛtulo MAC. Cada elemento contÈm um nome de cadeia de caracteres e "
"um valor de cadeia de caracteres. Cada polÌ≠tica ter· a chance de reivindicar um "
"determinado nome de elemento, permitindo que as polÌ≠ticas exponham v·rios elementos "
"independentes, se desejado. Os mÛdulos de polÌ≠tica executam a internalizaÁ„o e a "
"externalizaÁ„o entre os rÛtulos do kernel e os rÛtulos fornecidos pelo usu·rio por "
"meio de pontos de entrada, permitindo uma variedade de semÌ¢nticas. As chamadas do "
"sistema de gerenciamento de rÛtulos geralmente s„o agrupadas por funÁÌµes da "
"biblioteca do usu·rio para executar alocaÁ„o de memÛria e tratamento de erros, "
"simplificando os aplicativos do usu·rio que devem gerenciar rÛtulos. "

#: book.translate.xml:4717
#, fuzzy
msgid "The following MAC-related system calls are present in the FreeBSD kernel:"
msgstr ""
"As seguintes chamadas do sistema relacionadas ao MAC est„o presentes no kernel do "
"FreeBSD:"

#: book.translate.xml:4722
#, fuzzy
msgid ""
"<function>mac_get_proc()</function> may be used to retrieve the label of the current "
"process."
msgstr ""
" <function> mac_get_proc () </function> pode ser usado para recuperar o rÛtulo do "
"processo atual. "

#: book.translate.xml:4727
#, fuzzy
msgid ""
"<function>mac_set_proc()</function> may be used to request a change in the label of "
"the current process."
msgstr ""
" <function> mac_set_proc () </function> pode ser usado para solicitar uma alteraÁ„o "
"no rÛtulo do processo atual. "

#: book.translate.xml:4732
#, fuzzy
msgid ""
"<function>mac_get_fd()</function> may be used to retrieve the label of an object "
"(file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
" <function> mac_get_fd () </function> pode ser usado para recuperar o rÛtulo de um "
"objeto (arquivo, socket, pipe, ...) referenciado por um descritor de arquivo. "

#: book.translate.xml:4738
#, fuzzy
msgid ""
"<function>mac_get_file()</function> may be used to retrieve the label of an object "
"referenced by a file system path."
msgstr ""
" <function> mac_get_file () </function> pode ser usado para recuperar o rÛtulo de um "
"objeto referenciado por um caminho do sistema de arquivos. "

#: book.translate.xml:4743
#, fuzzy
msgid ""
"<function>mac_set_fd()</function> may be used to request a change in the label of an "
"object (file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
" <function> mac_set_fd () </function> pode ser usado para solicitar uma alteraÁ„o no "
"rÛtulo de um objeto (arquivo, socket, pipe, ...) referenciado por um descritor de "
"arquivo. "

#: book.translate.xml:4749
#, fuzzy
msgid ""
"<function>mac_set_file()</function> may be used to request a change in the label of "
"an object referenced by a file system path."
msgstr ""
" <function> mac_set_file () </function> pode ser usado para solicitar uma alteraÁ„o "
"no rÛtulo de um objeto referenciado por um caminho do sistema de arquivos. "

#: book.translate.xml:4755
#, fuzzy
msgid ""
"<function>mac_syscall()</function> permits policy modules to create new system calls "
"without modifying the system call table; it accepts a target policy name, operation "
"number, and opaque argument for use by the policy."
msgstr ""
" <function> mac_syscall () </function> permite que os mÛdulos de polÌ≠tica criem "
"novas chamadas do sistema sem modificar a tabela de chamadas do sistema; aceita um "
"nome de polÌ≠tica de destino, n˙mero de operaÁ„o e argumento opaco para uso pela polÌ≠"
"tica. "

#: book.translate.xml:4762
#, fuzzy
msgid ""
"<function>mac_get_pid()</function> may be used to request the label of another "
"process by process id."
msgstr ""
" <function> mac_get_pid () </function> pode ser usado para solicitar o rÛtulo de "
"outro processo pelo id do processo. "

#: book.translate.xml:4767
#, fuzzy
msgid ""
"<function>mac_get_link()</function> is identical to <function>mac_get_file()</"
"function>, only it will not follow a symbolic link if it is the final entry in the "
"path, so may be used to retrieve the label on a symlink."
msgstr ""
" <function> mac_get_link () </function> È idÍntico a <function> mac_get_file () </"
"function> , sÛ n„o seguir· um link simbÛlico se for a entrada final no caminho, "
"ent„o pode ser usado para recuperar o rÛtulo em um symlink. "

#: book.translate.xml:4774
#, fuzzy
msgid ""
"<function>mac_set_link()</function> is identical to <function>mac_set_file()</"
"function>, only it will not follow a symbolic link if it is the final entry in a "
"path, so may be used to manipulate the label on a symlink."
msgstr ""
" <function> mac_set_link () </function> È idÍntico a <function> mac_set_file () </"
"function> , sÛ n„o seguir· um link simbÛlico se for a entrada final em um caminho, "
"ent„o pode ser usado para manipular o rÛtulo em um symlink \""

#: book.translate.xml:4781
#, fuzzy
msgid ""
"<function>mac_execve()</function> is identical to the <function>execve()</function> "
"system call, only it also accepts a requested label to set the process label to when "
"beginning execution of a new program. This change in label on execution is referred "
"to as a \"transition\"."
msgstr ""
" <function> mac_execve () </function> È idÍntico ao <function> execve () </function> "
"chamada de sistema, sÛ que tambÈm aceita um rÛtulo solicitado para definir o rÛtulo "
"do processo ao iniciar a execuÁ„o de um novo programa. Esta mudanÁa na etiqueta na "
"execuÁ„o È referida como \\ \"transiÁ„o \". "

#: book.translate.xml:4789
#, fuzzy
msgid ""
"<function>mac_get_peer()</function>, actually implemented via a socket option, "
"retrieves the label of a remote peer on a socket, if available."
msgstr ""
" <function> mac_get_peer () </function> , na verdade, implementado por meio de uma "
"opÁ„o de soquete, recupera o rÛtulo de um ponto remoto em um soquete, se disponÌ≠vel. "

#: book.translate.xml:4795
#, fuzzy
msgid ""
"In addition to these system calls, the <literal>SIOCSIGMAC</literal> and "
"<literal>SIOCSIFMAC</literal> network interface ioctls permit the labels on network "
"interfaces to be retrieved and set."
msgstr ""
"AlÈm dessas chamadas de sistema, o <literal> SIOCSIGMAC </literal> e <literal> "
"SIOCSIFMAC </literal> Os ioctls da interface de rede permitem que os rÛtulos nas "
"interfaces de rede sejam recuperados e definidos. "

#: book.translate.xml:4803
#, fuzzy
msgid "MAC Policy Architecture"
msgstr "Arquitetura de polÌ≠ticas MAC"

#: book.translate.xml:4805
#, fuzzy
msgid ""
"Security policies are either linked directly into the kernel, or compiled into "
"loadable kernel modules that may be loaded at boot, or dynamically using the module "
"loading system calls at runtime. Policy modules interact with the system through a "
"set of declared entry points, providing access to a stream of system events and "
"permitting the policy to influence access control decisions. Each policy contains a "
"number of elements:"
msgstr ""
"As polÌ≠ticas de seguranÁa s„o ligadas diretamente ao kernel ou compiladas em mÛdulos "
"do kernel carreg·veis ‚Äã‚Äãque podem ser carregados na inicializaÁ„o ou dinamicamente "
"usando o mÛdulo carregando chamadas do sistema em tempo de execuÁ„o. MÛdulos de polÌ≠"
"ticas interagem com o sistema atravÈs de um conjunto de pontos de entrada "
"declarados, fornecendo acesso a um fluxo de eventos do sistema e permitindo que a "
"polÌ≠tica influencie as decisÌµes de controle de acesso. Cada polÌ≠tica contÈm v·rios "
"elementos: "

#: book.translate.xml:4814
#, fuzzy
msgid "Optional configuration parameters for policy."
msgstr "ParÌ¢metros de configuraÁ„o opcionais para polÌ≠tica."

#: book.translate.xml:4816
#, fuzzy
msgid "Centralized implementation of the policy logic and parameters."
msgstr "ImplementaÁ„o centralizada da lÛgica e parÌ¢metros da polÌ≠tica."

#: book.translate.xml:4818
#, fuzzy
msgid ""
"Optional implementation of policy life cycle events, such as initialization and "
"destruction."
msgstr ""
"ImplementaÁ„o opcional de eventos do ciclo de vida da polÌ≠tica, como inicializaÁ„o e "
"destruiÁ„o."

#: book.translate.xml:4820
#, fuzzy
msgid ""
"Optional support for initializing, maintaining, and destroying labels on selected "
"kernel objects."
msgstr ""
"Suporte opcional para inicializar, manter e destruir rÛtulos em objetos de kernel "
"selecionados."

#: book.translate.xml:4822
#, fuzzy
msgid ""
"Optional support for user process inspection and modification of labels on selected "
"objects."
msgstr ""
"Suporte opcional para inspeÁ„o de processo do usu·rio e modificaÁ„o de rÛtulos em "
"objetos selecionados."

#: book.translate.xml:4824
#, fuzzy
msgid ""
"Implementation of selected access control entry points that are of interest to the "
"policy."
msgstr ""
"ImplementaÁ„o de pontos de entrada de controle de acesso selecionados que s„o de "
"interesse para a polÌ≠tica."

#: book.translate.xml:4826
#, fuzzy
msgid "Declaration of policy identity, module entry points, and policy properties."
msgstr ""
"DeclaraÁ„o de identidade de polÌ≠tica, pontos de entrada de mÛdulo e propriedades de "
"polÌ≠tica."

#: book.translate.xml:4831
#, fuzzy
msgid "Policy Declaration"
msgstr "DeclaraÁ„o de polÌ≠tica"

#: book.translate.xml:4833
#, fuzzy
msgid ""
"Modules may be declared using the <function>MAC_POLICY_SET()</function> macro, which "
"names the policy, provides a reference to the MAC entry point vector, provides load-"
"time flags determining how the policy framework should handle the policy, and "
"optionally requests the allocation of label state by the framework."
msgstr ""
"Os mÛdulos podem ser declarados usando o <function> MAC_POLICY_SET () </function> "
"macro, que nomeia a polÌ≠tica, fornece uma referÍncia ao vetor de ponto de entrada "
"MAC, fornece sinalizadores de tempo de carregamento determinando como a estrutura de "
"polÌ≠tica deve manipular a polÌ≠tica e, opcionalmente, solicita a alocaÁ„o do estado "
"do rÛtulo pela estrutura. "

#: book.translate.xml:4852
#, fuzzy
msgid ""
"The MAC policy entry point vector, <varname>mac_<replaceable>policy</"
"replaceable>_ops</varname> in this example, associates functions defined in the "
"module with specific entry points. A complete listing of available entry points and "
"their prototypes may be found in the MAC entry point reference section. Of specific "
"interest during module registration are the <symbol>.mpo_destroy</symbol> and "
"<symbol>.mpo_init</symbol> entry points. <symbol>.mpo_init</symbol> will be invoked "
"once a policy is successfully registered with the module framework but prior to any "
"other entry points becoming active. This permits the policy to perform any policy-"
"specific allocation and initialization, such as initialization of any data or locks. "
"<symbol>.mpo_destroy</symbol> will be invoked when a policy module is unloaded to "
"permit releasing of any allocated memory and destruction of locks. Currently, these "
"two entry points are invoked with the MAC policy list mutex held to prevent any "
"other entry points from being invoked: this will be changed, but in the mean time, "
"policies should be careful about what kernel primitives they invoke so as to avoid "
"lock ordering or sleeping problems."
msgstr ""
"O vetor do ponto de entrada da polÌ≠tica MAC, <varname> Mac_ <replaceable> polÌ≠tica </"
"replaceable> _ops </varname> neste exemplo, associa funÁÌµes definidas no mÛdulo com "
"pontos de entrada especÌ≠ficos. Uma lista completa dos pontos de entrada disponÌ≠veis "
"e seus protÛtipos podem ser encontrados na seÁ„o de referÍncia do ponto de entrada "
"MAC. De interesse especÌ≠fico durante o registro do mÛdulo s„o os <symbol> ."
"mpo_destroy </symbol> e <symbol> .mpo_init </symbol> pontos de entrada. <symbol> ."
"mpo_init </symbol> ser· invocado assim que uma polÌ≠tica for registrada com sucesso "
"na estrutura do mÛdulo, mas antes de qualquer outro ponto de entrada se tornar "
"ativo. Isso permite que a polÌ≠tica execute qualquer alocaÁ„o e inicializaÁ„o especÌ≠"
"ficas da polÌ≠tica, como a inicializaÁ„o de quaisquer dados ou bloqueios. <symbol> ."
"mpo_destroy </symbol> ser· invocado quando um mÛdulo de polÌ≠tica for descarregado "
"para permitir a liberaÁ„o de qualquer memÛria alocada e destruiÁ„o de bloqueios. "
"Atualmente, esses dois pontos de entrada s„o invocados com o mutex da lista de polÌ≠"
"ticas MAC mantido para evitar que outros pontos de entrada sejam invocados: isso "
"ser· alterado, mas nesse meio tempo, as polÌ≠ticas devem ter cuidado com as "
"primitivas de kernel que invocam para evitar bloquear pedidos ou problemas de sono. "

#: book.translate.xml:4873
#, fuzzy
msgid ""
"The policy declaration's module name field exists so that the module may be uniquely "
"identified for the purposes of module dependencies. An appropriate string should be "
"selected. The full string name of the policy is displayed to the user via the kernel "
"log during load and unload events, and also exported when providing status "
"information to userland processes."
msgstr ""
"O campo de nome do mÛdulo da declaraÁ„o de polÌ≠tica existe para que o mÛdulo possa "
"ser identificado exclusivamente para fins de dependÍncias do mÛdulo. Uma sequÍncia "
"apropriada deve ser selecionada. O nome completo da cadeia da polÌ≠tica È exibido ao "
"usu·rio atravÈs do log do kernel durante o carregamento e descarregamento eventos e "
"tambÈm exportados ao fornecer informaÁÌµes de status para os processos do usu·rio. "

#: book.translate.xml:4883
#, fuzzy
msgid "Policy Flags"
msgstr "Bandeiras de PolÌ≠ticas"

#: book.translate.xml:4885
#, fuzzy
msgid ""
"The policy declaration flags field permits the module to provide the framework with "
"information about its capabilities at the time the module is loaded. Currently, "
"three flags are defined:"
msgstr ""
"O campo flags de declaraÁ„o de polÌ≠tica permite que o mÛdulo forneÁa Ì† estrutura "
"informaÁÌµes sobre suas capacidades no momento em que o mÛdulo È carregado. "
"Atualmente, trÍs sinalizadores s„o definidos:"

#: book.translate.xml:4892
#, fuzzy
msgid "MPC_LOADTIME_FLAG_UNLOADOK"
msgstr "MPC_LOADTIME_FLAG_UNLOADOK"

#: book.translate.xml:4895
#, fuzzy
msgid ""
"This flag indicates that the policy module may be unloaded. If this flag is not "
"provided, then the policy framework will reject requests to unload the module. This "
"flag might be used by modules that allocate label state and are unable to free that "
"state at runtime."
msgstr ""
"Esse sinalizador indica que o mÛdulo de polÌ≠tica pode ser descarregado. Se esse "
"sinalizador n„o for fornecido, a estrutura de polÌ≠tica rejeitar· solicitaÁÌµes para "
"descarregar o mÛdulo. Esse sinalizador pode ser usado por mÛdulos que alocam o "
"estado de rÛtulo e n„o conseguem liberar esse estado em tempo de execuÁ„o."

#: book.translate.xml:4905
#, fuzzy
msgid "MPC_LOADTIME_FLAG_NOTLATE"
msgstr "MPC_LOADTIME_FLAG_NOTLATE"

#: book.translate.xml:4908
#, fuzzy
msgid ""
"This flag indicates that the policy module must be loaded and initialized early in "
"the boot process. If the flag is specified, attempts to register the module "
"following boot will be rejected. The flag may be used by policies that require "
"pervasive labeling of all system objects, and cannot handle objects that have not "
"been properly initialized by the policy."
msgstr ""
"Este sinalizador indica que o mÛdulo de polÌ≠tica deve ser carregado e inicializado "
"no inÌ≠cio do processo de inicializaÁ„o. Se o sinalizador for especificado, "
"tentativas de registrar o mÛdulo apÛs a inicializaÁ„o ser„o rejeitadas. O "
"sinalizador pode ser usado por polÌ≠ticas que exigem rotulagem abrangente de todo o "
"sistema objetos e n„o podem manipular objetos que n„o foram inicializados "
"corretamente pela polÌ≠tica. "

#: book.translate.xml:4919
#, fuzzy
msgid "MPC_LOADTIME_FLAG_LABELMBUFS"
msgstr "MPC_LOADTIME_FLAG_LABELMBUFS"

#: book.translate.xml:4922
#, fuzzy
msgid ""
"This flag indicates that the policy module requires labeling of Mbufs, and that "
"memory should always be allocated for the storage of Mbuf labels. By default, the "
"MAC Framework will not allocate label storage for Mbufs unless at least one loaded "
"policy has this flag set. This measurably improves network performance when policies "
"do not require Mbuf labeling. A kernel option, <literal>MAC_ALWAYS_LABEL_MBUF</"
"literal>, exists to force the MAC Framework to allocate Mbuf label storage "
"regardless of the setting of this flag, and may be useful in some environments."
msgstr ""
"Este sinalizador indica que o mÛdulo de polÌ≠tica requer rotulagem de Mbufs, e essa "
"memÛria sempre deve ser alocada para o armazenamento de rÛtulos Mbuf. Por padr„o, o "
"MAC Framework n„o alocar· armazenamento de rÛtulo para Mbufs a menos que pelo menos "
"uma diretiva carregada tenha este sinalizador definido Isso aumenta "
"consideravelmente o desempenho da rede quando as polÌ≠ticas n„o exigem rotulagem "
"Mbuf. <literal> MAC_ALWAYS_LABEL_MBUF </literal> existe para forÁar o MAC Framework "
"a alocar o armazenamento de rÛtulos Mbuf, independentemente da configuraÁ„o desse "
"sinalizador, e pode ser ˙til em alguns ambientes. "

#: book.translate.xml:4937
#, fuzzy
msgid ""
"Policies using the <literal>MPC_LOADTIME_FLAG_LABELMBUFS</literal> without the "
"<literal>MPC_LOADTIME_FLAG_NOTLATE</literal> flag set must be able to correctly "
"handle <literal>NULL</literal> Mbuf label pointers passed into entry points. This is "
"necessary as in-flight Mbufs without label storage may persist after a policy "
"enabling Mbuf labeling has been loaded. If a policy is loaded before the network "
"subsystem is active (i.e., the policy is not being loaded late), then all Mbufs are "
"guaranteed to have label storage."
msgstr ""
"PolÌ≠ticas usando o <literal> MPC_LOADTIME_FLAG_LABELMBUFS </literal> sem o <literal> "
"MPC_LOADTIME_FLAG_NOTLATE </literal> conjunto de sinalizadores deve ser capaz de "
"manipular corretamente <literal> NULO </literal> Ponteiros de rÛtulos Mbuf passados "
"‚Äã‚Äãpara pontos de entrada. Isso È necess·rio, pois o Mbufs em andamento sem "
"armazenamento de rÛtulo pode persistir apÛs uma polÌ≠tica que permite que o rÛtulo "
"Mbuf seja carregado. Se uma polÌ≠tica for carregada antes que o subsistema de rede "
"esteja ativo (ou seja, a polÌ≠tica n„o esteja sendo carregada com atraso), todos os "
"Mbufs ter„o garantia de armazenamento de rÛtulo. "

#: book.translate.xml:4950
#, fuzzy
msgid "Policy Entry Points"
msgstr "Pontos de Entrada de PolÌ≠ticas"

#: book.translate.xml:4952
#, fuzzy
msgid ""
"Four classes of entry points are offered to policies registered with the framework: "
"entry points associated with the registration and management of policies, entry "
"points denoting initialization, creation, destruction, and other life cycle events "
"for kernel objects, events associated with access control decisions that the policy "
"module may influence, and calls associated with the management of labels on objects. "
"In addition, a <function>mac_syscall()</function> entry point is provided so that "
"policies may extend the kernel interface without registering new system calls."
msgstr ""
"Quatro classes de pontos de entrada s„o oferecidas a polÌ≠ticas registradas no "
"framework: pontos de entrada associados ao registro e gerenciamento de polÌ≠ticas, "
"pontos de entrada denotando inicializaÁ„o, criaÁ„o, destruiÁ„o e outros eventos de "
"ciclo de vida para objetos do kernel, eventos associados a decisÌµes de controle de "
"acesso que o mÛdulo de polÌ≠tica pode influenciar e as chamadas associadas ao "
"gerenciamento de rÛtulos em objetos. <function> mac_syscall () </function> ponto de "
"entrada È fornecido para que as polÌ≠ticas possam estender a interface do kernel sem "
"registrar novas chamadas do sistema. "

#: book.translate.xml:4963 book.translate.xml:4975
#, fuzzy
msgid ""
"Policy entry points will pass a reference to the object label along with the object "
"itself. This permits labeled policies to be unaware of the internals of the object "
"yet still make decisions based on the label. The exception to this is the process "
"credential, which is assumed to be understood by policies as a first class security "
"object in the kernel."
msgstr ""
"Os pontos de entrada da polÌ≠tica passar„o uma referÍncia ao rÛtulo do objeto junto "
"com o prÛprio objeto. Isso permite que as polÌ≠ticas rotuladas n„o estejam cientes "
"dos componentes internos do objeto e ainda tomem decisÌµes com base no rÛtulo. A "
"exceÁ„o a isso È a credencial do processo, que È assumido como sendo entendido pelas "
"polÌ≠ticas como um objeto de seguranÁa de primeira classe no kernel. "

#: book.translate.xml:4985
#, fuzzy
msgid "MAC Policy Entry Point Reference"
msgstr "ReferÍncia do Ponto de Entrada da PolÌ≠tica MAC"

#: book.translate.xml:4988
#, fuzzy
msgid "General-Purpose Module Entry Points"
msgstr "Pontos de Entrada do MÛdulo de Finalidade Geral"

#: book.translate.xml:4991
#, fuzzy
msgid "<function>mpo_init</function>"
msgstr " <function> mpo_init </function> "

#: book.translate.xml:4994
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init </function></funcdef><paramdef> struct "
"mac_policy_conf * <parameter> conf </parameter></paramdef> "

#: book.translate.xml:14312 book.translate.xml:14251 book.translate.xml:14205
#: book.translate.xml:14157 book.translate.xml:14114 book.translate.xml:14060
#: book.translate.xml:13995 book.translate.xml:13922 book.translate.xml:13846
#: book.translate.xml:13778 book.translate.xml:13717 book.translate.xml:13660
#: book.translate.xml:13590 book.translate.xml:13514 book.translate.xml:13446
#: book.translate.xml:13378 book.translate.xml:13293 book.translate.xml:13215
#: book.translate.xml:13149 book.translate.xml:13083 book.translate.xml:13021
#: book.translate.xml:12955 book.translate.xml:12886 book.translate.xml:12823
#: book.translate.xml:12740 book.translate.xml:12658 book.translate.xml:12589
#: book.translate.xml:12530 book.translate.xml:12469 book.translate.xml:12405
#: book.translate.xml:12330 book.translate.xml:12244 book.translate.xml:12171
#: book.translate.xml:12106 book.translate.xml:12037 book.translate.xml:11954
#: book.translate.xml:11872 book.translate.xml:11810 book.translate.xml:11748
#: book.translate.xml:11678 book.translate.xml:11617 book.translate.xml:11553
#: book.translate.xml:11489 book.translate.xml:11434 book.translate.xml:11373
#: book.translate.xml:11308 book.translate.xml:11251 book.translate.xml:11190
#: book.translate.xml:11134 book.translate.xml:11076 book.translate.xml:11007
#: book.translate.xml:10943 book.translate.xml:10884 book.translate.xml:10826
#: book.translate.xml:10763 book.translate.xml:10704 book.translate.xml:10647
#: book.translate.xml:10580 book.translate.xml:10531 book.translate.xml:10488
#: book.translate.xml:10435 book.translate.xml:10384 book.translate.xml:10336
#: book.translate.xml:10287 book.translate.xml:10244 book.translate.xml:10180
#: book.translate.xml:10069 book.translate.xml:10025 book.translate.xml:9983
#: book.translate.xml:9920 book.translate.xml:9842 book.translate.xml:9786
#: book.translate.xml:9719 book.translate.xml:9652 book.translate.xml:9576
#: book.translate.xml:9508 book.translate.xml:9428 book.translate.xml:9359
#: book.translate.xml:9292 book.translate.xml:9224 book.translate.xml:9157
#: book.translate.xml:9091 book.translate.xml:9025 book.translate.xml:8959
#: book.translate.xml:8903 book.translate.xml:8845 book.translate.xml:8775
#: book.translate.xml:8709 book.translate.xml:8643 book.translate.xml:8578
#: book.translate.xml:8512 book.translate.xml:8451 book.translate.xml:8393
#: book.translate.xml:8327 book.translate.xml:8250 book.translate.xml:8184
#: book.translate.xml:8119 book.translate.xml:8070 book.translate.xml:8004
#: book.translate.xml:7915 book.translate.xml:7832 book.translate.xml:7765
#: book.translate.xml:7705 book.translate.xml:7641 book.translate.xml:7570
#: book.translate.xml:7491 book.translate.xml:7335 book.translate.xml:7260
#: book.translate.xml:7185 book.translate.xml:7110 book.translate.xml:7035
#: book.translate.xml:6958 book.translate.xml:6881 book.translate.xml:6804
#: book.translate.xml:6727 book.translate.xml:6650 book.translate.xml:6573
#: book.translate.xml:6521 book.translate.xml:6471 book.translate.xml:6421
#: book.translate.xml:6375 book.translate.xml:6332 book.translate.xml:6289
#: book.translate.xml:6245 book.translate.xml:6200 book.translate.xml:6149
#: book.translate.xml:6103 book.translate.xml:6059 book.translate.xml:6015
#: book.translate.xml:5971 book.translate.xml:5927 book.translate.xml:5882
#: book.translate.xml:5838 book.translate.xml:5797 book.translate.xml:5754
#: book.translate.xml:5704 book.translate.xml:5653 book.translate.xml:5610
#: book.translate.xml:5568 book.translate.xml:5519 book.translate.xml:5459
#: book.translate.xml:5402 book.translate.xml:5359 book.translate.xml:5317
#: book.translate.xml:5275 book.translate.xml:5233 book.translate.xml:5168
#: book.translate.xml:5102 book.translate.xml:5058 book.translate.xml:5012
#, fuzzy
msgid "Parameter"
msgstr "ParÌ¢metro"

#: book.translate.xml:14313 book.translate.xml:14252 book.translate.xml:14206
#: book.translate.xml:14158 book.translate.xml:14115 book.translate.xml:14061
#: book.translate.xml:13996 book.translate.xml:13923 book.translate.xml:13847
#: book.translate.xml:13779 book.translate.xml:13718 book.translate.xml:13661
#: book.translate.xml:13591 book.translate.xml:13515 book.translate.xml:13447
#: book.translate.xml:13379 book.translate.xml:13294 book.translate.xml:13216
#: book.translate.xml:13150 book.translate.xml:13084 book.translate.xml:13022
#: book.translate.xml:12956 book.translate.xml:12887 book.translate.xml:12824
#: book.translate.xml:12741 book.translate.xml:12659 book.translate.xml:12590
#: book.translate.xml:12531 book.translate.xml:12470 book.translate.xml:12406
#: book.translate.xml:12331 book.translate.xml:12245 book.translate.xml:12172
#: book.translate.xml:12107 book.translate.xml:12038 book.translate.xml:11955
#: book.translate.xml:11873 book.translate.xml:11811 book.translate.xml:11749
#: book.translate.xml:11679 book.translate.xml:11618 book.translate.xml:11554
#: book.translate.xml:11490 book.translate.xml:11435 book.translate.xml:11374
#: book.translate.xml:11309 book.translate.xml:11252 book.translate.xml:11191
#: book.translate.xml:11135 book.translate.xml:11077 book.translate.xml:11008
#: book.translate.xml:10944 book.translate.xml:10885 book.translate.xml:10827
#: book.translate.xml:10764 book.translate.xml:10705 book.translate.xml:10648
#: book.translate.xml:10581 book.translate.xml:10532 book.translate.xml:10489
#: book.translate.xml:10436 book.translate.xml:10385 book.translate.xml:10337
#: book.translate.xml:10288 book.translate.xml:10245 book.translate.xml:10181
#: book.translate.xml:10070 book.translate.xml:10026 book.translate.xml:9984
#: book.translate.xml:9921 book.translate.xml:9843 book.translate.xml:9787
#: book.translate.xml:9720 book.translate.xml:9653 book.translate.xml:9577
#: book.translate.xml:9509 book.translate.xml:9429 book.translate.xml:9360
#: book.translate.xml:9293 book.translate.xml:9225 book.translate.xml:9158
#: book.translate.xml:9092 book.translate.xml:9026 book.translate.xml:8960
#: book.translate.xml:8904 book.translate.xml:8846 book.translate.xml:8776
#: book.translate.xml:8710 book.translate.xml:8644 book.translate.xml:8579
#: book.translate.xml:8513 book.translate.xml:8452 book.translate.xml:8394
#: book.translate.xml:8328 book.translate.xml:8251 book.translate.xml:8185
#: book.translate.xml:8120 book.translate.xml:8071 book.translate.xml:8005
#: book.translate.xml:7916 book.translate.xml:7833 book.translate.xml:7766
#: book.translate.xml:7706 book.translate.xml:7642 book.translate.xml:7571
#: book.translate.xml:7492 book.translate.xml:7336 book.translate.xml:7261
#: book.translate.xml:7186 book.translate.xml:7111 book.translate.xml:7036
#: book.translate.xml:6959 book.translate.xml:6882 book.translate.xml:6805
#: book.translate.xml:6728 book.translate.xml:6651 book.translate.xml:6574
#: book.translate.xml:6522 book.translate.xml:6472 book.translate.xml:6422
#: book.translate.xml:6376 book.translate.xml:6333 book.translate.xml:6290
#: book.translate.xml:6246 book.translate.xml:6201 book.translate.xml:6150
#: book.translate.xml:6104 book.translate.xml:6060 book.translate.xml:6016
#: book.translate.xml:5972 book.translate.xml:5928 book.translate.xml:5883
#: book.translate.xml:5839 book.translate.xml:5798 book.translate.xml:5755
#: book.translate.xml:5705 book.translate.xml:5654 book.translate.xml:5611
#: book.translate.xml:5569 book.translate.xml:5520 book.translate.xml:5460
#: book.translate.xml:5403 book.translate.xml:5360 book.translate.xml:5318
#: book.translate.xml:5276 book.translate.xml:5234 book.translate.xml:5169
#: book.translate.xml:5103 book.translate.xml:5059 book.translate.xml:5013
#, fuzzy
msgid "Description"
msgstr "DescriÁ„o"

#: book.translate.xml:14314 book.translate.xml:14253 book.translate.xml:14207
#: book.translate.xml:14159 book.translate.xml:14116 book.translate.xml:14062
#: book.translate.xml:13997 book.translate.xml:13924 book.translate.xml:13848
#: book.translate.xml:13780 book.translate.xml:13719 book.translate.xml:13662
#: book.translate.xml:13592 book.translate.xml:13516 book.translate.xml:13448
#: book.translate.xml:13380 book.translate.xml:13295 book.translate.xml:13217
#: book.translate.xml:13151 book.translate.xml:13085 book.translate.xml:13023
#: book.translate.xml:12957 book.translate.xml:12888 book.translate.xml:12825
#: book.translate.xml:12742 book.translate.xml:12660 book.translate.xml:12591
#: book.translate.xml:12532 book.translate.xml:12471 book.translate.xml:12407
#: book.translate.xml:12332 book.translate.xml:12246 book.translate.xml:12173
#: book.translate.xml:12108 book.translate.xml:12039 book.translate.xml:11956
#: book.translate.xml:11874 book.translate.xml:11812 book.translate.xml:11750
#: book.translate.xml:11680 book.translate.xml:11619 book.translate.xml:11555
#: book.translate.xml:11491 book.translate.xml:11436 book.translate.xml:11375
#: book.translate.xml:11310 book.translate.xml:11253 book.translate.xml:11192
#: book.translate.xml:11136 book.translate.xml:11078 book.translate.xml:11009
#: book.translate.xml:10945 book.translate.xml:10886 book.translate.xml:10828
#: book.translate.xml:10765 book.translate.xml:10706 book.translate.xml:10649
#: book.translate.xml:10582 book.translate.xml:10533 book.translate.xml:10490
#: book.translate.xml:10437 book.translate.xml:10386 book.translate.xml:10338
#: book.translate.xml:10289 book.translate.xml:10246 book.translate.xml:10182
#: book.translate.xml:10071 book.translate.xml:10027 book.translate.xml:9985
#: book.translate.xml:9922 book.translate.xml:9844 book.translate.xml:9788
#: book.translate.xml:9721 book.translate.xml:9654 book.translate.xml:9578
#: book.translate.xml:9510 book.translate.xml:9430 book.translate.xml:9361
#: book.translate.xml:9294 book.translate.xml:9226 book.translate.xml:9159
#: book.translate.xml:9093 book.translate.xml:9027 book.translate.xml:8961
#: book.translate.xml:8905 book.translate.xml:8847 book.translate.xml:8777
#: book.translate.xml:8711 book.translate.xml:8645 book.translate.xml:8580
#: book.translate.xml:8514 book.translate.xml:8453 book.translate.xml:8395
#: book.translate.xml:8329 book.translate.xml:8252 book.translate.xml:8186
#: book.translate.xml:8121 book.translate.xml:8072 book.translate.xml:8006
#: book.translate.xml:7917 book.translate.xml:7834 book.translate.xml:7767
#: book.translate.xml:7707 book.translate.xml:7643 book.translate.xml:7572
#: book.translate.xml:7493 book.translate.xml:7337 book.translate.xml:7262
#: book.translate.xml:7187 book.translate.xml:7112 book.translate.xml:7037
#: book.translate.xml:6960 book.translate.xml:6883 book.translate.xml:6806
#: book.translate.xml:6729 book.translate.xml:6652 book.translate.xml:6575
#: book.translate.xml:6523 book.translate.xml:6473 book.translate.xml:6423
#: book.translate.xml:6377 book.translate.xml:6334 book.translate.xml:6291
#: book.translate.xml:6247 book.translate.xml:6202 book.translate.xml:6151
#: book.translate.xml:6105 book.translate.xml:6061 book.translate.xml:6017
#: book.translate.xml:5973 book.translate.xml:5929 book.translate.xml:5884
#: book.translate.xml:5840 book.translate.xml:5799 book.translate.xml:5756
#: book.translate.xml:5706 book.translate.xml:5655 book.translate.xml:5612
#: book.translate.xml:5570 book.translate.xml:5521 book.translate.xml:5461
#: book.translate.xml:5404 book.translate.xml:5361 book.translate.xml:5319
#: book.translate.xml:5277 book.translate.xml:5235 book.translate.xml:5170
#: book.translate.xml:5104 book.translate.xml:5060 book.translate.xml:5014
#, fuzzy
msgid "Locking"
msgstr "Bloqueio"

#: book.translate.xml:5067 book.translate.xml:5021
#, fuzzy
msgid "<parameter>conf</parameter>"
msgstr " <parameter> conf </parameter> "

#: book.translate.xml:5068 book.translate.xml:5022
#, fuzzy
msgid "MAC policy definition"
msgstr "DefiniÁ„o de polÌ≠tica MAC"

#: book.translate.xml:5028
#, fuzzy
msgid ""
"Policy load event. The policy list mutex is held, so sleep operations cannot be "
"performed, and calls out to other kernel subsystems must be made with caution. If "
"potentially sleeping memory allocations are required during policy initialization, "
"they should be made using a separate module SYSINIT()."
msgstr ""
"Evento de carregamento da polÌ≠tica. O mutex da lista de polÌ≠ticas È retido, portanto "
"operaÁÌµes de suspens„o n„o podem ser executadas e chamadas para outros subsistemas "
"do kernel devem ser feitas com cautela. Se alocaÁÌµes de memÛria potencialmente "
"suspensas forem necess·rias durante a inicializaÁ„o da polÌ≠tica, elas devem ser "
"feitas usando mÛdulo SYSINIT (). "

#: book.translate.xml:5037
#, fuzzy
msgid "<function>mpo_destroy</function>"
msgstr " <function> mpo_destroy </function> "

#: book.translate.xml:5040
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy </function></funcdef><paramdef> struct "
"mac_policy_conf * <parameter> conf </parameter></paramdef> "

#: book.translate.xml:5074
#, fuzzy
msgid "Policy load event. The policy list mutex is held, so caution should be applied."
msgstr ""
"Evento de carregamento da polÌ≠tica. O mutex da lista de polÌ≠ticas È mantido, "
"portanto, cuidado deve ser aplicado."

#: book.translate.xml:5079
#, fuzzy
msgid "<function>mpo_syscall</function>"
msgstr " <function> mpo_syscall </function> "

#: book.translate.xml:5082
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_syscall</function></funcdef> <paramdef>struct thread "
"*<parameter>td</parameter></paramdef> <paramdef>int <parameter>call</parameter></"
"paramdef> <paramdef>void *<parameter>arg</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_syscall </function></funcdef><paramdef> thread de "
"estrutura * <parameter> td </parameter></paramdef><paramdef> int <parameter> ligar </"
"parameter></paramdef><paramdef> void * <parameter> arg </parameter></paramdef> "

#: book.translate.xml:5177 book.translate.xml:5111
#, fuzzy
msgid "<parameter>td</parameter>"
msgstr " <parameter> por exemplo, </parameter> "

#: book.translate.xml:5112
#, fuzzy
msgid "Calling thread"
msgstr "Chamada de discuss„o"

#: book.translate.xml:5116
#, fuzzy
msgid "<parameter>call</parameter>"
msgstr " <parameter> ligar </parameter> "

#: book.translate.xml:5117
#, fuzzy
msgid "Policy-specific syscall number"
msgstr "N˙mero de syscall especÌ≠fico da polÌ≠tica"

#: book.translate.xml:5121
#, fuzzy
msgid "<parameter>arg</parameter>"
msgstr " <parameter> arg </parameter> "

#: book.translate.xml:5122
#, fuzzy
msgid "Pointer to syscall arguments"
msgstr "Ponteiro para argumentos syscall"

#: book.translate.xml:5128
#, fuzzy
msgid ""
"This entry point provides a policy-multiplexed system call so that policies may "
"provide additional services to user processes without registering specific system "
"calls. The policy name provided during registration is used to demux calls from "
"userland, and the arguments will be forwarded to this entry point. When implementing "
"new services, security modules should be sure to invoke appropriate access control "
"checks from the MAC framework as needed. For example, if a policy implements an "
"augmented signal functionality, it should call the necessary signal access control "
"checks to invoke the MAC framework and other registered policies."
msgstr ""
"Esse ponto de entrada fornece uma chamada de sistema multiplexada por polÌ≠tica para "
"que as polÌ≠ticas possam fornecer serviÁos adicionais aos processos do usu·rio sem "
"registrar chamadas especÌ≠ficas do sistema. O nome da polÌ≠tica fornecido durante o "
"registro È usado para desmobilizar chamadas de usu·rios e os argumentos ser„o "
"encaminhados para essa entrada. Ao implementar novos serviÁos, os mÛdulos de "
"seguranÁa devem invocar as verificaÁÌµes de controle de acesso apropriadas da "
"estrutura do MAC, conforme necess·rio.Por exemplo, se uma polÌ≠tica implementa uma "
"funcionalidade de sinal aumentada, ela deve chamar as verificaÁÌµes de controle de "
"acesso de sinal necess·rias para invocar o MAC. estrutura e outras polÌ≠ticas "
"registradas. "

#: book.translate.xml:5141
#, fuzzy
msgid ""
"Modules must currently perform the <function>copyin()</function> of the syscall data "
"on their own."
msgstr ""
"Os mÛdulos devem atualmente executar o <function> copyin () </function> dos dados "
"syscall por conta prÛpria. "

#: book.translate.xml:5147
#, fuzzy
msgid "<function>mpo_thread_userret</function>"
msgstr " <function> mpo_thread_userret </function> "

#: book.translate.xml:5150
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_thread_userret</function></funcdef> <paramdef>struct "
"thread *<parameter>td</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_thread_userret </function></funcdef><paramdef> "
"thread de estrutura * <parameter> td </parameter></paramdef> "

#: book.translate.xml:5178
#, fuzzy
msgid "Returning thread"
msgstr "TÛpico de retorno"

#: book.translate.xml:5185
#, fuzzy
msgid ""
"This entry point permits policy modules to perform MAC-related events when a thread "
"returns to user space, via a system call return, trap return, or otherwise. This is "
"required for policies that have floating process labels, as it is not always "
"possible to acquire the process lock at arbitrary points in the stack during system "
"call processing; process labels might represent traditional authentication data, "
"process history information, or other data. To employ this mechanism, intended "
"changes to the process credential label may be stored in the <literal>p_label</"
"literal> protected by a per-policy spin lock, and then set the per-thread "
"<literal>TDF_ASTPENDING</literal> flag and per-process <literal>PS_MACPENDM</"
"literal> flag to schedule a call to the userret entry point. From this entry point, "
"the policy may create a replacement credential with less concern about the locking "
"context. Policy writers are cautioned that event ordering relating to scheduling an "
"AST and the AST being performed may be complex and interlaced in multithreaded "
"applications."
msgstr ""
"Esse ponto de entrada permite que os mÛdulos de polÌ≠tica executem eventos "
"relacionados ao MAC quando um encadeamento retorna ao espaÁo do usu·rio, por meio de "
"um retorno de chamada do sistema, retorno de interceptaÁ„o ou outro. Isso È "
"necess·rio para polÌ≠ticas que possuem rÛtulos de processo flutuantes, pois nem "
"sempre È possÌ≠vel para adquirir o bloqueio de processo em pontos arbitr·rios na "
"pilha durante o processamento da chamada do sistema, os rÛtulos de processo podem "
"representar dados de autenticaÁ„o tradicionais, informaÁÌµes do histÛrico de "
"processos ou outros dados. <literal> p_label </literal> protegido por um bloqueio "
"por rotaÁ„o por polÌ≠tica e, em seguida, defina o <literal> TDF_ASTPENDING </literal> "
"bandeira e por processo <literal> PS_MACPENDM </literal> flag para agendar uma "
"chamada para o ponto de entrada userret. A partir desse ponto de entrada, a polÌ≠tica "
"pode criar uma credencial de substituiÁ„o com menos preocupaÁ„o sobre o contexto de "
"bloqueio. Escritores de polÌ≠ticas s„o alertados que a ordenaÁ„o de eventos "
"relacionados ao planejamento de um AST e do AST sendo executado pode ser complexa e "
"entrelaÁada em aplicativos multithread. "

#: book.translate.xml:5209
#, fuzzy
msgid "Label Operations"
msgstr "OperaÁÌµes de etiqueta"

#: book.translate.xml:5212
#, fuzzy
msgid "<function>mpo_init_bpfdesc_label</function>"
msgstr " <function> mpo_init_bpfdesc_label </function> "

#: book.translate.xml:5215
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_bpfdesc_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_bpfdesc_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:13797 book.translate.xml:13609 book.translate.xml:13533
#: book.translate.xml:13465 book.translate.xml:13397 book.translate.xml:13312
#: book.translate.xml:13234 book.translate.xml:13168 book.translate.xml:13102
#: book.translate.xml:12974 book.translate.xml:12770 book.translate.xml:12688
#: book.translate.xml:12614 book.translate.xml:12488 book.translate.xml:12424
#: book.translate.xml:12360 book.translate.xml:12263 book.translate.xml:12190
#: book.translate.xml:12125 book.translate.xml:12058 book.translate.xml:11984
#: book.translate.xml:11697 book.translate.xml:7934 book.translate.xml:7725
#: book.translate.xml:7345 book.translate.xml:7270 book.translate.xml:7195
#: book.translate.xml:7120 book.translate.xml:7045 book.translate.xml:6968
#: book.translate.xml:6891 book.translate.xml:6814 book.translate.xml:6737
#: book.translate.xml:6660 book.translate.xml:6583 book.translate.xml:6384
#: book.translate.xml:6341 book.translate.xml:6298 book.translate.xml:6209
#: book.translate.xml:6112 book.translate.xml:6068 book.translate.xml:6024
#: book.translate.xml:5980 book.translate.xml:5936 book.translate.xml:5891
#: book.translate.xml:5847 book.translate.xml:5806 book.translate.xml:5763
#: book.translate.xml:5713 book.translate.xml:5662 book.translate.xml:5619
#: book.translate.xml:5577 book.translate.xml:5474 book.translate.xml:5411
#: book.translate.xml:5368 book.translate.xml:5326 book.translate.xml:5284
#: book.translate.xml:5242
#, fuzzy
msgid "<parameter>label</parameter>"
msgstr " <parameter> rÛtulo </parameter> "

#: book.translate.xml:5412 book.translate.xml:5369 book.translate.xml:5327
#: book.translate.xml:5243
#, fuzzy
msgid "New label to apply"
msgstr "Novo rÛtulo para aplicar"

#: book.translate.xml:5249
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated bpfdesc (BPF descriptor). Sleeping is "
"permitted."
msgstr ""
"Inicialize o rÛtulo em um bpfdesc recÈm-instanciado (descritor BPF). Dormir È "
"permitido."

#: book.translate.xml:5254
#, fuzzy
msgid "<function>mpo_init_cred_label</function>"
msgstr " <function> mpo_init_cred_label </function> "

#: book.translate.xml:5257
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_cred_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_cred_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5807 book.translate.xml:5764 book.translate.xml:5714
#: book.translate.xml:5663 book.translate.xml:5285
#, fuzzy
msgid "New label to initialize"
msgstr "Novo rÛtulo para inicializar"

#: book.translate.xml:5291
#, fuzzy
msgid ""
"Initialize the label for a newly instantiated user credential. Sleeping is permitted."
msgstr ""
"Inicialize o rÛtulo para uma credencial de usu·rio recÈm-instanciada. A suspens„o È "
"permitida."

#: book.translate.xml:5296
#, fuzzy
msgid "<function>mpo_init_devfsdirent_label</function>"
msgstr " <function> mpo_init_devfsdirent_label </function> "

#: book.translate.xml:5299
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_devfsdirent_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5333
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated devfs entry. Sleeping is permitted."
msgstr ""
"Inicialize o rÛtulo em uma entrada recentemente instanciada devfs. Dormir È "
"permitido."

#: book.translate.xml:5338
#, fuzzy
msgid "<function>mpo_init_ifnet_label</function>"
msgstr " <function> mpo_init_ifnet_label </function> "

#: book.translate.xml:5341
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_ifnet_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_ifnet_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5375
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated network interface. Sleeping is "
"permitted."
msgstr ""
"Inicialize o rÛtulo em uma interface de rede recÈm-instanciada. Ìâ permitido dormir."

#: book.translate.xml:5380
#, fuzzy
msgid "<function>mpo_init_ipq_label</function>"
msgstr " <function> mpo_init_ipq_label </function> "

#: book.translate.xml:5383
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_ipq_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef> <paramdef>int <parameter>flag</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_ipq_label </function></funcdef><paramdef> label "
"struct * <parameter> rÛtulo </parameter></paramdef><paramdef> int <parameter> "
"bandeira </parameter></paramdef> "

#: book.translate.xml:5718 book.translate.xml:5667 book.translate.xml:5468
#: book.translate.xml:5416
#, fuzzy
msgid "<parameter>flag</parameter>"
msgstr " <parameter> bandeira </parameter> "

#: book.translate.xml:5469 book.translate.xml:5417
#, fuzzy
msgid ""
"Sleeping/non-sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>; see below"
msgstr ""
"Dormir / n„o dormir <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> "
"9 </manvolnum></citerefentry> ; ver abaixo"

#: book.translate.xml:5424
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated IP fragment reassembly queue. The "
"<parameter>flag</parameter> field may be one of <symbol>M_WAITOK</symbol> and "
"<symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a sleeping "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> during this initialization call. IP fragment reassembly queue "
"allocation frequently occurs in performance sensitive environments, and the "
"implementation should be careful to avoid sleeping or long-lived operations. This "
"entry point is permitted to fail resulting in the failure to allocate the IP "
"fragment reassembly queue."
msgstr ""
"Inicialize o rÛtulo em uma fila de remontagem de fragmento IP recÈm-instanciada. "
"<parameter> bandeira </parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> "
"e <symbol> M_NOWAIT </symbol> , e deve ser empregado para evitar a realizaÁ„o de um "
"sono <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> durante esta chamada de inicializaÁ„o. A alocaÁ„o de fila "
"de remontagem de fragmento de IP ocorre com frequÍncia em ambientes sensÌ≠veis ao "
"desempenho, e a implementaÁ„o deve ter cuidado para evitar operaÁÌµes de longa "
"duraÁ„o ou de suspens„o. Este ponto de entrada tem permiss„o para falhar, resultando "
"na falha de alocar a fila de remontagem de fragmento de IP. "

#: book.translate.xml:5437
#, fuzzy
msgid "<function>mpo_init_mbuf_label</function>"
msgstr " <function> mpo_init_mbuf_label </function> "

#: book.translate.xml:5440
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mbuf_label</function></funcdef> <paramdef>int "
"<parameter>flag</parameter></paramdef> <paramdef>struct label *<parameter>label</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mbuf_label </function></funcdef><paramdef> int "
"<parameter> bandeira </parameter></paramdef><paramdef> label struct * <parameter> "
"rÛtulo </parameter></paramdef> "

#: book.translate.xml:5475
#, fuzzy
msgid "Policy label to initialize"
msgstr "RÛtulo de PolÌ≠tica para Inicializar"

#: book.translate.xml:5481
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated mbuf packet header (<parameter>mbuf</"
"parameter>). The <parameter>flag</parameter> field may be one of <symbol>M_WAITOK</"
"symbol> and <symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call. Mbuf allocation "
"frequently occurs in performance sensitive environments, and the implementation "
"should be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the mbuf header."
msgstr ""
"Inicialize o rÛtulo em um cabeÁalho de pacote mbuf recÈm-instanciado ( <parameter> "
"mbuf </parameter> ). o <parameter> bandeira </parameter> campo pode ser um dos "
"<symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </symbol> , e deve ser empregado "
"para evitar a realizaÁ„o de um sono <citerefentry><refentrytitle> malloc </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> durante esta chamada de "
"inicializaÁ„o. A alocaÁ„o de Mbuf ocorre com freqÌºÍncia em ambientes sensÌ≠veis ao "
"desempenho, e a implementaÁ„o deve ser cuidadosa para evitar operaÁÌµes de longa "
"duraÁ„o ou suspensas. Este ponto de entrada tem permiss„o para falhar, resultando na "
"falha de alocar o cabeÁalho mbuf. "

#: book.translate.xml:5495
#, fuzzy
msgid "<function>mpo_init_mount_label</function>"
msgstr " <function> mpo_init_mount_label </function> "

#: book.translate.xml:5498
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mount_label</function></funcdef> <paramdef>struct "
"label *<parameter>mntlabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mount_label </function></funcdef><paramdef> "
"label struct * <parameter> mntlabel </parameter></paramdef><paramdef> label struct * "
"<parameter> fslabel </parameter></paramdef> "

#: book.translate.xml:8023 book.translate.xml:6158 book.translate.xml:5528
#, fuzzy
msgid "<parameter>mntlabel</parameter>"
msgstr " <parameter> mntlabel </parameter> "

#: book.translate.xml:5529
#, fuzzy
msgid "Policy label to be initialized for the mount itself"
msgstr "Etiqueta de polÌ≠tica a ser inicializada para a montagem em si"

#: book.translate.xml:8029 book.translate.xml:7655 book.translate.xml:7584
#: book.translate.xml:7505 book.translate.xml:6163 book.translate.xml:5534
#, fuzzy
msgid "<parameter>fslabel</parameter>"
msgstr " <parameter> fslabel </parameter> "

#: book.translate.xml:5535
#, fuzzy
msgid "Policy label to be initialized for the file system"
msgstr "RÛtulo de PolÌ≠tica a Ser Inicializado para o Sistema de Arquivos"

#: book.translate.xml:5542
#, fuzzy
msgid ""
"Initialize the labels on a newly instantiated mount point. Sleeping is permitted."
msgstr ""
"Inicialize os rÛtulos em um ponto de montagem recÈm-instanciado. Ìâ permitido dormir."

#: book.translate.xml:5547
#, fuzzy
msgid "<function>mpo_init_mount_fs_label</function>"
msgstr " <function> mpo_init_mount_fs_label </function> "

#: book.translate.xml:5550
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mount_fs_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mount_fs_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5578
#, fuzzy
msgid "Label to be initialized"
msgstr "RÛtulo a ser inicializado"

#: book.translate.xml:5584
#, fuzzy
msgid "Initialize the label on a newly mounted file system. Sleeping is permitted"
msgstr ""
"Inicialize o rÛtulo em um sistema de arquivos recÈm montado. Ìâ permitido dormir"

#: book.translate.xml:5589
#, fuzzy
msgid "<function>mpo_init_pipe_label</function>"
msgstr " <function> mpo_init_pipe_label </function> "

#: book.translate.xml:5592
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_pipe_label</function></funcdef> <paramdef>struct "
"label*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_pipe_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:7346 book.translate.xml:7271 book.translate.xml:7196
#: book.translate.xml:7121 book.translate.xml:7046 book.translate.xml:5620
#, fuzzy
msgid "Label to be filled in"
msgstr "Etiqueta a ser preenchida"

#: book.translate.xml:5626
#, fuzzy
msgid "Initialize a label for a newly instantiated pipe. Sleeping is permitted."
msgstr "Inicialize um rÛtulo para um pipe recÈm-instanciado. Ìâ permitido dormir."

#: book.translate.xml:5631
#, fuzzy
msgid "<function>mpo_init_socket_label</function>"
msgstr " <function> mpo_init_socket_label </function> "

#: book.translate.xml:5634
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_socket_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef> <paramdef>int <parameter>flag</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_socket_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef><paramdef> int <parameter> "
"bandeira </parameter></paramdef> "

#: book.translate.xml:5719 book.translate.xml:5668
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> flags"
msgstr ""
" <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> bandeiras"

#: book.translate.xml:5674
#, fuzzy
msgid ""
"Initialize a label for a newly instantiated socket. The <parameter>flag</parameter> "
"field may be one of <symbol>M_WAITOK</symbol> and <symbol>M_NOWAIT</symbol>, and "
"should be employed to avoid performing a sleeping "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> during this initialization call."
msgstr ""
"Inicialize um rÛtulo para um soquete recÈm-instanciado. <parameter> bandeira </"
"parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </"
"symbol> , e deve ser empregado para evitar a realizaÁ„o de um sono "
"<citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> durante esta chamada de inicializaÁ„o. "

#: book.translate.xml:5682
#, fuzzy
msgid "<function>mpo_init_socket_peer_label</function>"
msgstr " <function> mpo_init_socket_peer_label </function> "

#: book.translate.xml:5685
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>int "
"<parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#: book.translate.xml:5725
#, fuzzy
msgid ""
"Initialize the peer label for a newly instantiated socket. The <parameter>flag</"
"parameter> field may be one of <symbol>M_WAITOK</symbol> and <symbol>M_NOWAIT</"
"symbol>, and should be employed to avoid performing a sleeping "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> during this initialization call."
msgstr ""
"Inicialize o rÛtulo peer para um soquete recÈm-instanciado. <parameter> bandeira </"
"parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </"
"symbol> , e deve ser empregado para evitar a realizaÁ„o de um sono "
"<citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> durante esta chamada de inicializaÁ„o. "

#: book.translate.xml:5733
#, fuzzy
msgid "<function>mpo_init_proc_label</function>"
msgstr " <function> mpo_init_proc_label </function> "

#: book.translate.xml:5736
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_proc_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_proc_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5770
#, fuzzy
msgid "Initialize the label for a newly instantiated process. Sleeping is permitted."
msgstr "Inicialize o rÛtulo para um processo recÈm-instanciado. Ìâ permitido dormir."

#: book.translate.xml:5776
#, fuzzy
msgid "<function>mpo_init_vnode_label</function>"
msgstr " <function> mpo_init_vnode_label </function> "

#: book.translate.xml:5779
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_vnode_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_vnode_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5813
#, fuzzy
msgid "Initialize the label on a newly instantiated vnode. Sleeping is permitted."
msgstr "Inicialize o rÛtulo em um vnode recÈm-instanciado. Dormir È permitido."

#: book.translate.xml:5817
#, fuzzy
msgid "<function>mpo_destroy_bpfdesc_label</function>"
msgstr " <function> mpo_destroy_bpfdesc_label </function> "

#: book.translate.xml:5820
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_bpfdesc_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5848
#, fuzzy
msgid "bpfdesc label"
msgstr "rÛtulo bpfdesc"

#: book.translate.xml:5854
#, fuzzy
msgid ""
"Destroy the label on a BPF descriptor. In this entry point a policy should free any "
"internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em um descritor BPF. Neste ponto de entrada, uma polÌ≠tica deve "
"liberar qualquer armazenamento interno associado a <parameter> rÛtulo </parameter> "
"para que possa ser destruÌ≠do \""

#: book.translate.xml:5861
#, fuzzy
msgid "<function>mpo_destroy_cred_label</function>"
msgstr " <function> mpo_destroy_cred_label </function> "

#: book.translate.xml:5864
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_cred_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_cred_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6069 book.translate.xml:6025 book.translate.xml:5981
#: book.translate.xml:5937 book.translate.xml:5892
#, fuzzy
msgid "Label being destroyed"
msgstr "Etiqueta sendo destruÌ≠da"

#: book.translate.xml:5898
#, fuzzy
msgid ""
"Destroy the label on a credential. In this entry point, a policy module should free "
"any internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em uma credencial. Nesse ponto de entrada, um mÛdulo de polÌ≠tica "
"deve liberar qualquer armazenamento interno associado a <parameter> rÛtulo </"
"parameter> para que possa ser destruÌ≠do \""

#: book.translate.xml:5906
#, fuzzy
msgid "<function>mpo_destroy_devfsdirent_label</function>"
msgstr " <function> mpo_destroy_devfsdirent_label </function> "

#: book.translate.xml:5909
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_devfsdirent_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5943
#, fuzzy
msgid ""
"Destroy the label on a devfs entry. In this entry point, a policy module should free "
"any internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em uma entrada devfs. Nesse ponto de entrada, um mÛdulo de polÌ≠tica "
"deve liberar qualquer armazenamento interno associado <parameter> rÛtulo </"
"parameter> para que possa ser destruÌ≠do \""

#: book.translate.xml:5950
#, fuzzy
msgid "<function>mpo_destroy_ifnet_label</function>"
msgstr " <function> mpo_destroy_ifnet_label </function> "

#: book.translate.xml:5953
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_ifnet_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:5987
#, fuzzy
msgid ""
"Destroy the label on a removed interface. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o rÛtulo em uma interface removida. Nesse ponto de entrada, um mÛdulo de polÌ≠"
"tica deve liberar qualquer armazenamento interno associado a <parameter> rÛtulo </"
"parameter> para que possa ser destruÌ≠do \""

#: book.translate.xml:5994
#, fuzzy
msgid "<function>mpo_destroy_ipq_label</function>"
msgstr " <function> mpo_destroy_ipq_label </function> "

#: book.translate.xml:5997
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_ipq_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_ipq_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6031
#, fuzzy
msgid ""
"Destroy the label on an IP fragment queue. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o rÛtulo em uma fila de fragmentos de IP. Nesse ponto de entrada, um mÛdulo "
"de polÌ≠tica deve liberar qualquer armazenamento interno associado a <parameter> "
"rÛtulo </parameter> para que possa ser destruÌ≠do \""

#: book.translate.xml:6038
#, fuzzy
msgid "<function>mpo_destroy_mbuf_label</function>"
msgstr " <function> mpo_destroy_mbuf_label </function> "

#: book.translate.xml:6041
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mbuf_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mbuf_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6075
#, fuzzy
msgid ""
"Destroy the label on an mbuf header. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so that it "
"may be destroyed."
msgstr ""
"Destrua o rÛtulo em um cabeÁalho mbuf. Nesse ponto de entrada, um mÛdulo de polÌ≠tica "
"deve liberar qualquer armazenamento interno associado a <parameter> rÛtulo </"
"parameter> para que possa ser destruÌ≠do \""

#: book.translate.xml:6126 book.translate.xml:6082
#, fuzzy
msgid "<function>mpo_destroy_mount_label</function>"
msgstr " <function> mpo_destroy_mount_label </function> "

#: book.translate.xml:6085
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mount_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6159 book.translate.xml:6113
#, fuzzy
msgid "Mount point label being destroyed"
msgstr "Etiqueta de ponto de montagem sendo destruÌ≠da"

#: book.translate.xml:6119
#, fuzzy
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module should "
"free the internal storage associated with <parameter>mntlabel</parameter> so that "
"they may be destroyed."
msgstr ""
"Destrua os rÛtulos em um ponto de montagem. Nesse ponto de entrada, um mÛdulo de polÌ≠"
"tica deve liberar o armazenamento interno associado <parameter> mntlabel </"
"parameter> para que eles sejam destruÌ≠dos \""

#: book.translate.xml:6129
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> <paramdef>struct "
"label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mount_label </function></funcdef><paramdef> "
"label struct * <parameter> mntlabel </parameter></paramdef><paramdef> label struct * "
"<parameter> fslabel </parameter></paramdef> "

#: book.translate.xml:6164
#, fuzzy
msgid "File system label being destroyed&gt;"
msgstr "RÛtulo do sistema de arquivos sendo destruÌ≠do&gt;"

#: book.translate.xml:6170
#, fuzzy
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module should "
"free the internal storage associated with <parameter>mntlabel</parameter> and "
"<parameter>fslabel</parameter> so that they may be destroyed."
msgstr ""
"Destrua os rÛtulos em um ponto de montagem. Nesse ponto de entrada, um mÛdulo de polÌ≠"
"tica deve liberar o armazenamento interno associado <parameter> mntlabel </"
"parameter> e <parameter> fslabel </parameter> para que eles sejam destruÌ≠dos \""

#: book.translate.xml:6178
#, fuzzy
msgid "<function>mpo_destroy_socket_label</function>"
msgstr " <function> mpo_destroy_socket_label </function> "

#: book.translate.xml:6181
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_socket_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6210
#, fuzzy
msgid "Socket label being destroyed"
msgstr "Etiqueta de soquete sendo destruÌ≠da"

#: book.translate.xml:6217
#, fuzzy
msgid ""
"Destroy the label on a socket. In this entry point, a policy module should free any "
"internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em um soquete. Nesse ponto de entrada, um mÛdulo de polÌ≠tica deve "
"liberar qualquer armazenamento interno associado <parameter> rÛtulo </parameter> "
"para que possa ser destruÌ≠do \""

#: book.translate.xml:6224
#, fuzzy
msgid "<function>mpo_destroy_socket_peer_label</function>"
msgstr " <function> mpo_destroy_socket_peer_label </function> "

#: book.translate.xml:6227
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>peerlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> peerlabel </parameter></paramdef> "

#: book.translate.xml:6254
#, fuzzy
msgid "<parameter>peerlabel</parameter>"
msgstr " <parameter> peerlabel </parameter> "

#: book.translate.xml:6255
#, fuzzy
msgid "Socket peer label being destroyed"
msgstr "RÛtulo do par de soquetes sendo destruÌ≠do"

#: book.translate.xml:6261
#, fuzzy
msgid ""
"Destroy the peer label on a socket. In this entry point, a policy module should free "
"any internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo peer em um soquete. Neste ponto de entrada, um mÛdulo de polÌ≠tica "
"deve liberar qualquer armazenamento interno associado <parameter> rÛtulo </"
"parameter> para que possa ser destruÌ≠do \""

#: book.translate.xml:6268
#, fuzzy
msgid "<function>mpo_destroy_pipe_label</function>"
msgstr " <function> mpo_destroy_pipe_label </function> "

#: book.translate.xml:6271
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_pipe_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_pipe_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6299
#, fuzzy
msgid "Pipe label"
msgstr "RÛtulo de tubo"

#: book.translate.xml:6305
#, fuzzy
msgid ""
"Destroy the label on a pipe. In this entry point, a policy module should free any "
"internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em um pipe. Nesse ponto de entrada, um mÛdulo de polÌ≠tica deve "
"liberar qualquer armazenamento interno associado <parameter> rÛtulo </parameter> "
"para que possa ser destruÌ≠do \""

#: book.translate.xml:6312
#, fuzzy
msgid "<function>mpo_destroy_proc_label</function>"
msgstr " <function> mpo_destroy_proc_label </function> "

#: book.translate.xml:6315
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_proc_label</function></funcdef> <paramdef>struct "
"label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_proc_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6385 book.translate.xml:6342
#, fuzzy
msgid "Process label"
msgstr "RÛtulo do processo"

#: book.translate.xml:6348
#, fuzzy
msgid ""
"Destroy the label on a process. In this entry point, a policy module should free any "
"internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em um processo. Nesse ponto de entrada, um mÛdulo de polÌ≠tica deve "
"liberar qualquer armazenamento interno associado <parameter> rÛtulo </parameter> "
"para que possa ser destruÌ≠do \""

#: book.translate.xml:6355
#, fuzzy
msgid "<function>mpo_destroy_vnode_label</function>"
msgstr " <function> mpo_destroy_vnode_label </function> "

#: book.translate.xml:6358
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_vnode_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:6391
#, fuzzy
msgid ""
"Destroy the label on a vnode. In this entry point, a policy module should free any "
"internal storage associated with <parameter>label</parameter> so that it may be "
"destroyed."
msgstr ""
"Destrua o rÛtulo em um vnode. Nesse ponto de entrada, um mÛdulo de polÌ≠tica deve "
"liberar qualquer armazenamento interno associado <parameter> rÛtulo </parameter> "
"para que possa ser destruÌ≠do \""

#: book.translate.xml:6398
#, fuzzy
msgid "<function>mpo_copy_mbuf_label</function>"
msgstr " <function> mpo_copy_mbuf_label </function> "

#: book.translate.xml:6401
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_mbuf_label</function></funcdef> <paramdef>struct "
"label *<parameter>src</parameter></paramdef> <paramdef>struct label "
"*<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_mbuf_label </function></funcdef><paramdef> "
"label struct * <parameter> src </parameter></paramdef><paramdef> label struct * "
"<parameter> dest </parameter></paramdef> "

#: book.translate.xml:6530 book.translate.xml:6480 book.translate.xml:6430
#, fuzzy
msgid "<parameter>src</parameter>"
msgstr " <parameter> src </parameter> "

#: book.translate.xml:6531 book.translate.xml:6481 book.translate.xml:6431
#, fuzzy
msgid "Source label"
msgstr "RÛtulo da fonte"

#: book.translate.xml:6535 book.translate.xml:6485 book.translate.xml:6435
#, fuzzy
msgid "<parameter>dest</parameter>"
msgstr " <parameter> comeÁou </parameter> "

#: book.translate.xml:6536 book.translate.xml:6486 book.translate.xml:6436
#, fuzzy
msgid "Destination label"
msgstr "Etiqueta de destino"

#: book.translate.xml:6542 book.translate.xml:6492 book.translate.xml:6442
#, fuzzy
msgid ""
"Copy the label information in <parameter>src</parameter> into <parameter>dest</"
"parameter>."
msgstr ""
"Copie as informaÁÌµes da etiqueta em <parameter> src </parameter> para dentro "
"<parameter> dest </parameter> "

#: book.translate.xml:6448
#, fuzzy
msgid "<function>mpo_copy_pipe_label</function>"
msgstr " <function> mpo_copy_pipe_label </function> "

#: book.translate.xml:6451
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_pipe_label</function></funcdef> <paramdef>struct "
"label *<parameter>src</parameter></paramdef> <paramdef>struct label "
"*<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_pipe_label </function></funcdef><paramdef> "
"label struct * <parameter> src </parameter></paramdef><paramdef> label struct * "
"<parameter> comeÁou </parameter></paramdef> "

#: book.translate.xml:6498
#, fuzzy
msgid "<function>mpo_copy_vnode_label</function>"
msgstr " <function> mpo_copy_vnode_label </function> "

#: book.translate.xml:6501
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_vnode_label</function></funcdef> <paramdef>struct "
"label *<parameter>src</parameter></paramdef> <paramdef>struct label "
"*<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_vnode_label </function></funcdef><paramdef> "
"label struct * <parameter> src </parameter></paramdef><paramdef> label struct * "
"<parameter> dest </parameter></paramdef> "

#: book.translate.xml:6548
#, fuzzy
msgid "<function>mpo_externalize_cred_label</function>"
msgstr " <function> mpo_externalize_cred_label </function> "

#: book.translate.xml:6551
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>struct sbuf "
"*<parameter>sb</parameter></paramdef> <paramdef>int <parameter>*claimed</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_cred_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef><paramdef> Caracteres * "
"<parameter> element_name </parameter></paramdef><paramdef> struct sbuf * <parameter> "
"sb </parameter></paramdef><paramdef> int <parameter> * reivindicado </parameter></"
"paramdef> "

#: book.translate.xml:6969 book.translate.xml:6892 book.translate.xml:6815
#: book.translate.xml:6738 book.translate.xml:6661 book.translate.xml:6584
#, fuzzy
msgid "Label to be externalized"
msgstr "Etiqueta a ser externalizada"

#: book.translate.xml:7350 book.translate.xml:7275 book.translate.xml:7200
#: book.translate.xml:7125 book.translate.xml:7050 book.translate.xml:6973
#: book.translate.xml:6896 book.translate.xml:6819 book.translate.xml:6742
#: book.translate.xml:6665 book.translate.xml:6588
#, fuzzy
msgid "<parameter>element_name</parameter>"
msgstr " <parameter> element_name </parameter> "

#: book.translate.xml:6974 book.translate.xml:6897 book.translate.xml:6820
#: book.translate.xml:6743 book.translate.xml:6666 book.translate.xml:6589
#, fuzzy
msgid "Name of the policy whose label should be externalized"
msgstr "Nome da polÌ≠tica cujo rÛtulo deve ser externalizado"

#: book.translate.xml:6978 book.translate.xml:6901 book.translate.xml:6824
#: book.translate.xml:6747 book.translate.xml:6670 book.translate.xml:6593
#, fuzzy
msgid "<parameter>sb</parameter>"
msgstr " <parameter> sb </parameter> "

#: book.translate.xml:6979 book.translate.xml:6902 book.translate.xml:6825
#: book.translate.xml:6748 book.translate.xml:6671 book.translate.xml:6594
#, fuzzy
msgid "String buffer to be filled with a text representation of label"
msgstr "Buffer de cadeia a ser preenchido com uma representaÁ„o de texto de rÛtulo"

#: book.translate.xml:7360 book.translate.xml:7285 book.translate.xml:7210
#: book.translate.xml:7135 book.translate.xml:7060 book.translate.xml:6984
#: book.translate.xml:6907 book.translate.xml:6830 book.translate.xml:6753
#: book.translate.xml:6676 book.translate.xml:6599
#, fuzzy
msgid "<parameter>claimed</parameter>"
msgstr " <parameter> reivindicado </parameter> "

#: book.translate.xml:6985 book.translate.xml:6908 book.translate.xml:6831
#: book.translate.xml:6754 book.translate.xml:6677 book.translate.xml:6600
#, fuzzy
msgid ""
"Should be incremented when <parameter>element_data</parameter> can be filled in."
msgstr ""
"Deve ser incrementado quando <parameter> element_data </parameter> pode ser "
"preenchido. "

#: book.translate.xml:6994 book.translate.xml:6917 book.translate.xml:6840
#: book.translate.xml:6763 book.translate.xml:6686 book.translate.xml:6609
#, fuzzy
msgid ""
"Produce an externalized label based on the label structure passed. An externalized "
"label consists of a text representation of the label contents that can be used with "
"userland applications and read by the user. Currently, all policies' "
"<function>externalize</function> entry points will be called, so the implementation "
"should check the contents of <parameter>element_name</parameter> before attempting "
"to fill in <parameter>sb</parameter>. If <parameter>element_name</parameter> does "
"not match the name of your policy, simply return <returnvalue>0</returnvalue>. Only "
"return nonzero if an error occurs while externalizing the label data. Once the "
"policy fills in <parameter>element_data</parameter>, <varname>*claimed</varname> "
"should be incremented."
msgstr ""
"Produza um rÛtulo externalizado com base na estrutura de rÛtulo passada. Um rÛtulo "
"externalizado consiste em uma representaÁ„o de texto do conte˙do do rÛtulo que pode "
"ser usado com aplicativos de usu·rio final e lido pelo usu·rio. Atualmente, todas as "
"polÌ≠ticas '; <function> externalizar </function> pontos de entrada ser„o chamados, "
"ent„o a implementaÁ„o deve verificar o conte˙do de <parameter> element_name </"
"parameter> antes de tentar preencher <parameter> sb </parameter> . E se <parameter> "
"element_name </parameter> n„o corresponde ao nome da sua polÌ≠tica, basta retornar "
"<returnvalue> 0 </returnvalue> . SÛ retornar· diferente de zero se ocorrer um erro "
"ao externalizar os dados da etiqueta. Quando a polÌ≠tica preencher <parameter> "
"element_data </parameter> , <varname> * reivindicado </varname> deve ser "
"incrementado \""

#: book.translate.xml:6625
#, fuzzy
msgid "<function>mpo_externalize_ifnet_label</function>"
msgstr " <function> mpo_externalize_ifnet_label </function> "

#: book.translate.xml:6628
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>struct sbuf "
"*<parameter>sb</parameter></paramdef> <paramdef>int <parameter>*claimed</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></paramdef><paramdef> "
"int <parameter> * reivindicado </parameter></paramdef> "

#: book.translate.xml:6702
#, fuzzy
msgid "<function>mpo_externalize_pipe_label</function>"
msgstr " <function> mpo_externalize_pipe_label </function> "

#: book.translate.xml:6705
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>struct sbuf "
"*<parameter>sb</parameter></paramdef> <paramdef>int <parameter>*claimed</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_pipe_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef><paramdef> Caracteres * "
"<parameter> element_name </parameter></paramdef><paramdef> struct sbuf * <parameter> "
"sb </parameter></paramdef><paramdef> int <parameter> * reivindicado </parameter></"
"paramdef> "

#: book.translate.xml:6779
#, fuzzy
msgid "<function>mpo_externalize_socket_label</function>"
msgstr " <function> mpo_externalize_socket_label </function> "

#: book.translate.xml:6782
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>struct sbuf "
"*<parameter>sb</parameter></paramdef> <paramdef>int <parameter>*claimed</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></paramdef><paramdef> "
"int <parameter> * reivindicado </parameter></paramdef> "

#: book.translate.xml:6856
#, fuzzy
msgid "<function>mpo_externalize_socket_peer_label</function>"
msgstr " <function> mpo_externalize_socket_peer_label </function> "

#: book.translate.xml:6859
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>struct sbuf "
"*<parameter>sb</parameter></paramdef> <paramdef>int <parameter>*claimed</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></paramdef><paramdef> "
"int <parameter> * reivindicado </parameter></paramdef> "

#: book.translate.xml:6933
#, fuzzy
msgid "<function>mpo_externalize_vnode_label</function>"
msgstr " <function> mpo_externalize_vnode_label </function> "

#: book.translate.xml:6936
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>struct sbuf "
"*<parameter>sb</parameter></paramdef> <paramdef>int <parameter>*claimed</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></paramdef><paramdef> "
"int <parameter> * reivindicado </parameter></paramdef> "

#: book.translate.xml:7010
#, fuzzy
msgid "<function>mpo_internalize_cred_label</function>"
msgstr " <function> mpo_internalize_cred_label </function> "

#: book.translate.xml:7013
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>char "
"*<parameter>element_data</parameter></paramdef> <paramdef>int *<parameter>claimed</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_cred_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef><paramdef> Caracteres * "
"<parameter> element_name </parameter></paramdef><paramdef> Caracteres * <parameter> "
"element_data </parameter></paramdef><paramdef> int * <parameter> reivindicado </"
"parameter></paramdef> "

#: book.translate.xml:7351 book.translate.xml:7276 book.translate.xml:7201
#: book.translate.xml:7126 book.translate.xml:7051
#, fuzzy
msgid "Name of the policy whose label should be internalized"
msgstr "Nome da polÌ≠tica cujo rÛtulo deve ser internalizado"

#: book.translate.xml:7355 book.translate.xml:7280 book.translate.xml:7205
#: book.translate.xml:7130 book.translate.xml:7055
#, fuzzy
msgid "<parameter>element_data</parameter>"
msgstr " <parameter> element_data </parameter> "

#: book.translate.xml:7356 book.translate.xml:7281 book.translate.xml:7206
#: book.translate.xml:7131 book.translate.xml:7056
#, fuzzy
msgid "Text data to be internalized"
msgstr "Dados de texto a serem internalizados"

#: book.translate.xml:7361 book.translate.xml:7286 book.translate.xml:7211
#: book.translate.xml:7136 book.translate.xml:7061
#, fuzzy
msgid "Should be incremented when data can be successfully internalized."
msgstr "Deve ser incrementado quando os dados podem ser internalizados com sucesso."

#: book.translate.xml:7370 book.translate.xml:7295 book.translate.xml:7220
#: book.translate.xml:7145 book.translate.xml:7070
#, fuzzy
msgid ""
"Produce an internal label structure based on externalized label data in text format. "
"Currently, all policies' <function>internalize</function> entry points are called "
"when internalization is requested, so the implementation should compare the contents "
"of <parameter>element_name</parameter> to its own name in order to be sure it should "
"be internalizing the data in <parameter>element_data</parameter>. Just as in the "
"<function>externalize</function> entry points, the entry point should return "
"<returnvalue>0</returnvalue> if <parameter>element_name</parameter> does not match "
"its own name, or when data can successfully be internalized, in which case "
"<varname>*claimed</varname> should be incremented."
msgstr ""
"Produzir uma estrutura de rÛtulo interno com base em dados de rÛtulo externalizados "
"em formato de texto. Atualmente, todas as polÌ≠ticas '; <function> internalizar </"
"function> os pontos de entrada s„o chamados quando a internalizaÁ„o È solicitada, "
"ent„o a implementaÁ„o deve comparar o conte˙do de <parameter> element_name </"
"parameter> para o seu prÛprio nome, a fim de ter certeza de que deveria estar "
"internalizando os dados em <parameter> element_data </parameter> . Assim como no "
"<function> externalizar </function> pontos de entrada, o ponto de entrada deve "
"retornar <returnvalue> 0 </returnvalue> E se <parameter> element_name </parameter> "
"n„o corresponde ao seu prÛprio nome, ou quando os dados podem ser internalizados com "
"Íxito, em cujo caso <varname> * reivindicado </varname> deve ser incrementado \""

#: book.translate.xml:7085
#, fuzzy
msgid "<function>mpo_internalize_ifnet_label</function>"
msgstr " <function> mpo_internalize_ifnet_label </function> "

#: book.translate.xml:7088
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>char "
"*<parameter>element_data</parameter></paramdef> <paramdef>int *<parameter>claimed</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#: book.translate.xml:7160
#, fuzzy
msgid "<function>mpo_internalize_pipe_label</function>"
msgstr " <function> mpo_internalize_pipe_label </function> "

#: book.translate.xml:7163
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>char "
"*<parameter>element_data</parameter></paramdef> <paramdef>int *<parameter>claimed</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_pipe_label </function></funcdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef><paramdef> Caracteres * "
"<parameter> element_name </parameter></paramdef><paramdef> Caracteres * <parameter> "
"element_data </parameter></paramdef><paramdef> int * <parameter> reivindicado </"
"parameter></paramdef> "

#: book.translate.xml:7235
#, fuzzy
msgid "<function>mpo_internalize_socket_label</function>"
msgstr " <function> mpo_internalize_socket_label </function> "

#: book.translate.xml:7238
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>char "
"*<parameter>element_data</parameter></paramdef> <paramdef>int *<parameter>claimed</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#: book.translate.xml:7310
#, fuzzy
msgid "<function>mpo_internalize_vnode_label</function>"
msgstr " <function> mpo_internalize_vnode_label </function> "

#: book.translate.xml:7313
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>char "
"*<parameter>element_name</parameter></paramdef> <paramdef>char "
"*<parameter>element_data</parameter></paramdef> <paramdef>int *<parameter>claimed</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#: book.translate.xml:7386
#, fuzzy
msgid "Label Events"
msgstr "Eventos de etiqueta"

#: book.translate.xml:7388
#, fuzzy
msgid ""
"This class of entry points is used by the MAC framework to permit policies to "
"maintain label information on kernel objects. For each labeled kernel object of "
"interest to a MAC policy, entry points may be registered for relevant life cycle "
"events. All objects implement initialization, creation, and destruction hooks. Some "
"objects will also implement relabeling, allowing user processes to change the labels "
"on objects. Some objects will also implement object-specific events, such as label "
"events associated with IP reassembly. A typical labeled object will have the "
"following life cycle of entry points:"
msgstr ""
"Essa classe de pontos de entrada È usada pela estrutura MAC para permitir que as polÌ≠"
"ticas mantenham informaÁÌµes de rÛtulos nos objetos do kernel. Para cada objeto "
"rotulado do kernel de interesse de uma polÌ≠tica MAC, os pontos de entrada podem ser "
"registrados para eventos de ciclo de vida relevantes. AlÈm disso, alguns objetos "
"tambÈm implementar„o a remarcaÁ„o, permitindo que os processos do usu·rio alterem os "
"rÛtulos dos objetos.Alguns objetos tambÈm implementar„o eventos especÌ≠ficos do "
"objeto, como eventos de rÛtulo associados Ì† remontagem do IP.Um objeto rotulado tÌ≠"
"pico seguinte ciclo de vida dos pontos de entrada: "

#: book.translate.xml:7410
#, fuzzy
msgid ""
"Label initialization permits policies to allocate memory and set initial values for "
"labels without context for the use of the object. The label slot allocated to a "
"policy will be zeroed by default, so some policies may not need to perform "
"initialization."
msgstr ""
"A inicializaÁ„o do rÛtulo permite que polÌ≠ticas aloquem memÛria e definam valores "
"iniciais para rÛtulos sem contexto para o uso do objeto. O slot de rÛtulo alocado a "
"uma polÌ≠tica ser· zerado por padr„o, portanto, algumas polÌ≠ticas podem n„o precisar "
"executar a inicializaÁ„o."

#: book.translate.xml:7416
#, fuzzy
msgid ""
"Label creation occurs when the kernel structure is associated with an actual kernel "
"object. For example, Mbufs may be allocated and remain unused in a pool until they "
"are required. mbuf allocation causes label initialization on the mbuf to take place, "
"but mbuf creation occurs when the mbuf is associated with a datagram. Typically, "
"context will be provided for a creation event, including the circumstances of the "
"creation, and labels of other relevant objects in the creation process. For example, "
"when an mbuf is created from a socket, the socket and its label will be presented to "
"registered policies in addition to the new mbuf and its label. Memory allocation in "
"creation events is discouraged, as it may occur in performance sensitive ports of "
"the kernel; in addition, creation calls are not permitted to fail so a failure to "
"allocate memory cannot be reported."
msgstr ""
"A criaÁ„o de rÛtulos ocorre quando a estrutura do kernel È associada a um objeto de "
"kernel real. Por exemplo, Mbufs podem ser alocados e permanecer sem uso em um "
"conjunto atÈ que sejam necess·rios. A alocaÁ„o de mbuf faz com que a inicializaÁ„o "
"de rÛtulo ocorra, mas a criaÁ„o de mbuf ocorre Quando o mbuf È associado a um "
"datagrama.Normalmente, o contexto ser· fornecido para um evento de criaÁ„o, "
"incluindo as circunstÌ¢ncias da criaÁ„o, e rÛtulos de outros objetos relevantes no "
"processo de criaÁ„o.Por exemplo, quando um mbuf È criado a partir de um soquete, o "
"soquete e seu rÛtulo ser„o apresentados a polÌ≠ticas registradas, alÈm do novo mbuf e "
"seu rÛtulo.A alocaÁ„o de memÛria em eventos de criaÁ„o È desencorajada, pois pode "
"ocorrer em portas sensÌ≠veis ao desempenho do kernel, alÈm disso, as chamadas de "
"criaÁ„o n„o tÍm permiss„o para falhar, portanto, uma falha na alocaÁ„o de memÛria "
"n„o pode ser reportada. "

#: book.translate.xml:7432
#, fuzzy
msgid ""
"Object specific events do not generally fall into the other broad classes of label "
"events, but will generally provide an opportunity to modify or update the label on "
"an object based on additional context. For example, the label on an IP fragment "
"reassembly queue may be updated during the <symbol>MAC_UPDATE_IPQ</symbol> entry "
"point as a result of the acceptance of an additional mbuf to that queue."
msgstr ""
"Eventos especÌ≠ficos de objeto geralmente n„o se enquadram em outras classes de "
"eventos de rÛtulo, mas geralmente fornecem uma oportunidade para modificar ou "
"atualizar o rÛtulo em um objeto com base em contexto adicional. Por exemplo, o "
"rÛtulo em uma fila de reagrupamento de fragmento IP pode ser atualizado durante o "
"<symbol> MAC_UPDATE_IPQ </symbol> ponto de entrada como resultado da aceitaÁ„o de um "
"mbuf adicional para essa fila. "

#: book.translate.xml:7440
#, fuzzy
msgid "Access control events are discussed in detail in the following section."
msgstr "Os eventos de controle de acesso s„o discutidos em detalhes na seÁ„o a seguir."

#: book.translate.xml:7443
#, fuzzy
msgid ""
"Label destruction permits policies to release storage or state associated with a "
"label during its association with an object so that the kernel data structures "
"supporting the object may be reused or released."
msgstr ""
"A destruiÁ„o de etiqueta permite que polÌ≠ticas liberem armazenamento ou estado "
"associado a um rÛtulo durante sua associaÁ„o com um objeto, de forma que as "
"estruturas de dados do kernel que suportam o objeto possam ser reutilizadas ou "
"liberadas."

#: book.translate.xml:7448
#, fuzzy
msgid ""
"In addition to labels associated with specific kernel objects, an additional class "
"of labels exists: temporary labels. These labels are used to store update "
"information submitted by user processes. These labels are initialized and destroyed "
"as with other label types, but the creation event is <symbol>MAC_INTERNALIZE</"
"symbol>, which accepts a user label to be converted to an in-kernel representation."
msgstr ""
"AlÈm de rÛtulos associados a objetos de kernel especÌ≠ficos, existe uma classe "
"adicional de rÛtulos: rÛtulos tempor·rios. Esses rÛtulos s„o usados ‚Äã‚Äãpara armazenar "
"informaÁÌµes de atualizaÁ„o enviadas pelos processos do usu·rio. Esses rÛtulos s„o "
"inicializados e destruÌ≠dos como com outros tipos de rÛtulo, mas o evento de criaÁ„o "
"È <symbol> MAC_INTERNALIZE </symbol> , que aceita um rÛtulo de usu·rio para ser "
"convertido em uma representaÁ„o no kernel. "

#: book.translate.xml:7457
#, fuzzy
msgid "File System Object Labeling Event Operations"
msgstr "OperaÁÌµes de eventos de rotulagem de objeto de sistema de arquivos"

#: book.translate.xml:7460
#, fuzzy
msgid "<function>mpo_associate_vnode_devfs</function>"
msgstr " <function> mpo_associate_vnode_devfs </function> "

#: book.translate.xml:7463
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_associate_vnode_devfs</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> <paramdef>struct label "
"*<parameter>fslabel</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>de</parameter></paramdef> <paramdef>struct label *<parameter>delabel</"
"parameter></paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_associate_vnode_devfs </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> de </parameter></"
"paramdef><paramdef> label struct * <parameter> delabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></paramdef><paramdef> "
"label struct * <parameter> vlabel </parameter></paramdef> "

#: book.translate.xml:11567 book.translate.xml:8018 book.translate.xml:7846
#: book.translate.xml:7650 book.translate.xml:7579 book.translate.xml:7500
#, fuzzy
msgid "<parameter>mp</parameter>"
msgstr " <parameter> pf </parameter> "

#: book.translate.xml:7847 book.translate.xml:7501
#, fuzzy
msgid "Devfs mount point"
msgstr "Devfs mount point"

#: book.translate.xml:7506
#, fuzzy
msgid "Devfs file system label (<varname>mp-&gt;mnt_fslabel</varname>)"
msgstr ""
"RÛtulo do sistema de arquivos Devfs ( <varname> mp-&gt; mnt_fslabel </varname> ) "

#: book.translate.xml:7862 book.translate.xml:7511
#, fuzzy
msgid "<parameter>de</parameter>"
msgstr " <parameter> de </parameter> "

#: book.translate.xml:7512
#, fuzzy
msgid "Devfs directory entry"
msgstr "Entrada do diretÛrio Devfs"

#: book.translate.xml:7867 book.translate.xml:7516
#, fuzzy
msgid "<parameter>delabel</parameter>"
msgstr " <parameter> delabel </parameter> "

#: book.translate.xml:7517
#, fuzzy
msgid "Policy label associated with <parameter>de</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> de </parameter> "

#: book.translate.xml:14265 book.translate.xml:14074 book.translate.xml:13792
#: book.translate.xml:13604 book.translate.xml:13528 book.translate.xml:13460
#: book.translate.xml:13392 book.translate.xml:13307 book.translate.xml:13229
#: book.translate.xml:13163 book.translate.xml:13097 book.translate.xml:12969
#: book.translate.xml:12765 book.translate.xml:12683 book.translate.xml:12609
#: book.translate.xml:12544 book.translate.xml:12484 book.translate.xml:12419
#: book.translate.xml:12355 book.translate.xml:12258 book.translate.xml:12185
#: book.translate.xml:12120 book.translate.xml:12052 book.translate.xml:11979
#: book.translate.xml:11692 book.translate.xml:11504 book.translate.xml:10449
#: book.translate.xml:9936 book.translate.xml:9862 book.translate.xml:8271
#: book.translate.xml:8198 book.translate.xml:8133 book.translate.xml:7950
#: book.translate.xml:7660 book.translate.xml:7589 book.translate.xml:7522
#, fuzzy
msgid "<parameter>vp</parameter>"
msgstr " <parameter> vp </parameter> "

#: book.translate.xml:7523
#, fuzzy
msgid "vnode associated with <parameter>de</parameter>"
msgstr "vnode associado com <parameter> de </parameter> "

#: book.translate.xml:14270 book.translate.xml:14079 book.translate.xml:10454
#: book.translate.xml:8204 book.translate.xml:7955 book.translate.xml:7665
#: book.translate.xml:7594 book.translate.xml:7528
#, fuzzy
msgid "<parameter>vlabel</parameter>"
msgstr " <parameter> vlabel </parameter> "

#: book.translate.xml:12771 book.translate.xml:12689 book.translate.xml:12615
#: book.translate.xml:12425 book.translate.xml:12361 book.translate.xml:8205
#: book.translate.xml:7956 book.translate.xml:7666 book.translate.xml:7595
#: book.translate.xml:7529
#, fuzzy
msgid "Policy label associated with <parameter>vp</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> vp </parameter> "

#: book.translate.xml:7536
#, fuzzy
msgid ""
"Fill in the label (<parameter>vlabel</parameter>) for a newly created devfs vnode "
"based on the devfs directory entry passed in <parameter>de</parameter> and its label."
msgstr ""
"Preencha o rÛtulo ( <parameter> vlabel </parameter> ) para um vnode devfs recÈm-"
"criado com base na entrada de diretÛrio devfs passada <parameter> de </parameter> e "
"seu rÛtulo \""

#: book.translate.xml:7543
#, fuzzy
msgid "<function>mpo_associate_vnode_extattr</function>"
msgstr " <function> mpo_associate_vnode_extattr </function> "

#: book.translate.xml:7546
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_associate_vnode_extattr</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> <paramdef>struct label "
"*<parameter>fslabel</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>vlabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_associate_vnode_extattr </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></paramdef><paramdef> "
"label struct * <parameter> vlabel </parameter></paramdef> "

#: book.translate.xml:7930 book.translate.xml:7651 book.translate.xml:7580
#, fuzzy
msgid "File system mount point"
msgstr "Ponto de montagem do sistema de arquivos"

#: book.translate.xml:7935 book.translate.xml:7656 book.translate.xml:7585
#, fuzzy
msgid "File system label"
msgstr "RÛtulo do sistema de arquivos"

#: book.translate.xml:7661 book.translate.xml:7590
#, fuzzy
msgid "Vnode to label"
msgstr "Vnode para rotular"

#: book.translate.xml:7602
#, fuzzy
msgid ""
"Attempt to retrieve the label for <parameter>vp</parameter> from the file system "
"extended attributes. Upon success, the value <literal>0</literal> is returned. "
"Should extended attribute retrieval not be supported, an accepted fallback is to "
"copy <parameter>fslabel</parameter> into <parameter>vlabel</parameter>. In the event "
"of an error, an appropriate value for <varname>errno</varname> should be returned."
msgstr ""
"Tentativa de recuperar o rÛtulo para <parameter> vp </parameter> dos atributos "
"estendidos do sistema de arquivos. ApÛs o sucesso, o valor <literal> 0 </literal> È "
"retornado. Caso a recuperaÁ„o de atributos estendidos n„o seja suportada, um "
"substituto aceito È copiar <parameter> fslabel </parameter> para dentro <parameter> "
"vlabel </parameter> . Em caso de erro, um valor apropriado para <varname> errno </"
"varname> deve ser devolvido \""

#: book.translate.xml:7614
#, fuzzy
msgid "<function>mpo_associate_vnode_singlelabel</function>"
msgstr " <function> mpo_associate_vnode_singlelabel </function> "

#: book.translate.xml:7617
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_associate_vnode_singlelabel</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> <paramdef>struct label "
"*<parameter>fslabel</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>vlabel</parameter></"
"paramdef>"
msgstr ""
"<funcdef> vazio <function> mpo_associate_vnode_singlelabel </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></paramdef><paramdef> "
"label struct * <parameter> vlabel </parameter></paramdef>"

#: book.translate.xml:7673
#, fuzzy
msgid ""
"On non-multilabel file systems, this entry point is called to set the policy label "
"for <parameter>vp</parameter> based on the file system label, <parameter>fslabel</"
"parameter>."
msgstr ""
"Em sistemas de arquivos n„o multilabel, este ponto de entrada È chamado para definir "
"o rÛtulo de polÌ≠tica para <parameter> vp </parameter> com base no rÛtulo do sistema "
"de arquivos, <parameter> fslabel </parameter> "

#: book.translate.xml:7681
#, fuzzy
msgid "<function>mpo_create_devfs_device</function>"
msgstr " <function> mpo_create_devfs_device </function> "

#: book.translate.xml:7684
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_device</function></funcdef> <paramdef>dev_t "
"<parameter>dev</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_device </function></funcdef><paramdef> "
"dev_t <parameter> dev </parameter></paramdef><paramdef> struct devfs_dirent * "
"<parameter> devfs_dirent </parameter></paramdef><paramdef> label struct * "
"<parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:7714
#, fuzzy
msgid "<parameter>dev</parameter>"
msgstr " <parameter> dev </parameter> "

#: book.translate.xml:7715
#, fuzzy
msgid "Device corresponding with <parameter>devfs_dirent</parameter>"
msgstr "Dispositivo correspondente com <parameter> devfs_dirent </parameter> "

#: book.translate.xml:8259 book.translate.xml:7785 book.translate.xml:7720
#, fuzzy
msgid "<parameter>devfs_dirent</parameter>"
msgstr " <parameter> devfs_dirent </parameter> "

#: book.translate.xml:7721
#, fuzzy
msgid "Devfs directory entry to be labeled."
msgstr "Devfs entrada do diretÛrio a ser rotulado."

#: book.translate.xml:7726
#, fuzzy
msgid "Label for <parameter>devfs_dirent</parameter> to be filled in."
msgstr "RÛtulo para <parameter> devfs_dirent </parameter> para ser preenchido. "

#: book.translate.xml:7733
#, fuzzy
msgid ""
"Fill out the label on a devfs_dirent being created for the passed device. This call "
"will be made when the device file system is mounted, regenerated, or a new device is "
"made available."
msgstr ""
"Preencha o rÛtulo em um devfs_dirent sendo criado para o dispositivo passado. Essa "
"chamada ser· feita quando o sistema de arquivos do dispositivo for montado, "
"regenerado ou um novo dispositivo for disponibilizado."

#: book.translate.xml:7740
#, fuzzy
msgid "<function>mpo_create_devfs_directory</function>"
msgstr " <function> mpo_create_devfs_directory </function> "

#: book.translate.xml:7743
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_directory</function></funcdef> "
"<paramdef>char *<parameter>dirname</parameter></paramdef> <paramdef>int "
"<parameter>dirnamelen</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_directory </function></"
"funcdef><paramdef> Caracteres * <parameter> dirname </parameter></"
"paramdef><paramdef> int <parameter> dirnamelen </parameter></paramdef><paramdef> "
"struct devfs_dirent * <parameter> devfs_dirent </parameter></paramdef><paramdef> "
"label struct * <parameter> rÛtulo </parameter></paramdef> "

#: book.translate.xml:7774
#, fuzzy
msgid "<parameter>dirname</parameter>"
msgstr " <parameter> dirname </parameter> "

#: book.translate.xml:7775
#, fuzzy
msgid "Name of directory being created"
msgstr "Nome do diretÛrio sendo criado"

#: book.translate.xml:14331 book.translate.xml:7779
#, fuzzy
msgid "<parameter>namelen</parameter>"
msgstr " <parameter> namelen </parameter> "

#: book.translate.xml:7780
#, fuzzy
msgid "Length of string <parameter>dirname</parameter>"
msgstr "Comprimento da corda <parameter> dirname </parameter> "

#: book.translate.xml:7786
#, fuzzy
msgid "Devfs directory entry for directory being created."
msgstr "Entrada do diretÛrio Devfs para o diretÛrio que est· sendo criado."

#: book.translate.xml:7793
#, fuzzy
msgid ""
"Fill out the label on a devfs_dirent being created for the passed directory. This "
"call will be made when the device file system is mounted, regenerated, or a new "
"device requiring a specific directory hierarchy is made available."
msgstr ""
"Preencha o rÛtulo em um devfs_dirent que est· sendo criado para o diretÛrio passado. "
"Essa chamada ser· feita quando o sistema de arquivos do dispositivo for montado, "
"regenerado ou um novo dispositivo que exija uma hierarquia de diretÛrio especÌ≠fica "
"seja disponibilizado."

#: book.translate.xml:7801
#, fuzzy
msgid "<function>mpo_create_devfs_symlink</function>"
msgstr " <function> mpo_create_devfs_symlink </function> "

#: book.translate.xml:7804
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_symlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"mount *<parameter>mp</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>dd</parameter></paramdef> <paramdef>struct label *<parameter>ddlabel</"
"parameter></paramdef> <paramdef>struct devfs_dirent *<parameter>de</parameter></"
"paramdef> <paramdef>struct label *<parameter>delabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_symlink </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> montagem struct * "
"<parameter> mp </parameter></paramdef><paramdef> struct devfs_dirent * <parameter> "
"dd </parameter></paramdef><paramdef> label struct * <parameter> ddlabel </"
"parameter></paramdef><paramdef> struct devfs_dirent * <parameter> de </parameter></"
"paramdef><paramdef> label struct * <parameter> delabel </parameter></paramdef> "

#: book.translate.xml:14321 book.translate.xml:14260 book.translate.xml:14214
#: book.translate.xml:14166 book.translate.xml:14123 book.translate.xml:14004
#: book.translate.xml:13931 book.translate.xml:13855 book.translate.xml:13787
#: book.translate.xml:13726 book.translate.xml:13669 book.translate.xml:13599
#: book.translate.xml:13523 book.translate.xml:13455 book.translate.xml:13387
#: book.translate.xml:13302 book.translate.xml:13224 book.translate.xml:13158
#: book.translate.xml:13092 book.translate.xml:13030 book.translate.xml:12964
#: book.translate.xml:12895 book.translate.xml:12832 book.translate.xml:12749
#: book.translate.xml:12667 book.translate.xml:12539 book.translate.xml:12478
#: book.translate.xml:12414 book.translate.xml:12339 book.translate.xml:12253
#: book.translate.xml:12180 book.translate.xml:12115 book.translate.xml:12046
#: book.translate.xml:11963 book.translate.xml:11881 book.translate.xml:11819
#: book.translate.xml:11757 book.translate.xml:11687 book.translate.xml:11626
#: book.translate.xml:11562 book.translate.xml:11498 book.translate.xml:11443
#: book.translate.xml:11382 book.translate.xml:11317 book.translate.xml:11260
#: book.translate.xml:11143 book.translate.xml:11085 book.translate.xml:11016
#: book.translate.xml:10952 book.translate.xml:10893 book.translate.xml:10835
#: book.translate.xml:10772 book.translate.xml:10713 book.translate.xml:10656
#: book.translate.xml:10589 book.translate.xml:10540 book.translate.xml:10497
#: book.translate.xml:10444 book.translate.xml:10393 book.translate.xml:10345
#: book.translate.xml:10296 book.translate.xml:10253 book.translate.xml:10078
#: book.translate.xml:10034 book.translate.xml:9992 book.translate.xml:9661
#: book.translate.xml:8854 book.translate.xml:8652 book.translate.xml:8587
#: book.translate.xml:8460 book.translate.xml:8402 book.translate.xml:8193
#: book.translate.xml:8128 book.translate.xml:8013 book.translate.xml:7924
#: book.translate.xml:7841
#, fuzzy
msgid "<parameter>cred</parameter>"
msgstr " <parameter> Eu </parameter> "

#: book.translate.xml:14322 book.translate.xml:14261 book.translate.xml:14215
#: book.translate.xml:14167 book.translate.xml:14124 book.translate.xml:14070
#: book.translate.xml:14005 book.translate.xml:13932 book.translate.xml:13856
#: book.translate.xml:13788 book.translate.xml:13727 book.translate.xml:13670
#: book.translate.xml:13600 book.translate.xml:13524 book.translate.xml:13456
#: book.translate.xml:13388 book.translate.xml:13303 book.translate.xml:13225
#: book.translate.xml:13159 book.translate.xml:13093 book.translate.xml:13031
#: book.translate.xml:12965 book.translate.xml:12896 book.translate.xml:12833
#: book.translate.xml:12750 book.translate.xml:12668 book.translate.xml:12599
#: book.translate.xml:12540 book.translate.xml:12415 book.translate.xml:12340
#: book.translate.xml:12254 book.translate.xml:12181 book.translate.xml:12116
#: book.translate.xml:12047 book.translate.xml:11964 book.translate.xml:11882
#: book.translate.xml:11820 book.translate.xml:11758 book.translate.xml:11688
#: book.translate.xml:11627 book.translate.xml:11563 book.translate.xml:11499
#: book.translate.xml:11444 book.translate.xml:11383 book.translate.xml:11318
#: book.translate.xml:11261 book.translate.xml:11200 book.translate.xml:11144
#: book.translate.xml:11086 book.translate.xml:11017 book.translate.xml:10953
#: book.translate.xml:10894 book.translate.xml:10836 book.translate.xml:10773
#: book.translate.xml:10714 book.translate.xml:10657 book.translate.xml:10590
#: book.translate.xml:10541 book.translate.xml:10498 book.translate.xml:10445
#: book.translate.xml:10394 book.translate.xml:10346 book.translate.xml:10297
#: book.translate.xml:10254 book.translate.xml:10079 book.translate.xml:9662
#: book.translate.xml:8855 book.translate.xml:8653 book.translate.xml:8588
#: book.translate.xml:8461 book.translate.xml:8403 book.translate.xml:8194
#: book.translate.xml:8129 book.translate.xml:8014 book.translate.xml:7925
#: book.translate.xml:7842
#, fuzzy
msgid "Subject credential"
msgstr "Sujeito credencial"

#: book.translate.xml:7851
#, fuzzy
msgid "<parameter>dd</parameter>"
msgstr " <parameter> dd </parameter> "

#: book.translate.xml:7852
#, fuzzy
msgid "Link destination"
msgstr "Destino do link"

#: book.translate.xml:7856
#, fuzzy
msgid "<parameter>ddlabel</parameter>"
msgstr " <parameter> ddlabel </parameter> "

#: book.translate.xml:7857
#, fuzzy
msgid "Label associated with <parameter>dd</parameter>"
msgstr "Etiqueta associada a <parameter> dd </parameter> "

#: book.translate.xml:7863
#, fuzzy
msgid "Symlink entry"
msgstr "Entrada no Symlink"

#: book.translate.xml:7868
#, fuzzy
msgid "Label associated with <parameter>de</parameter>"
msgstr "Etiqueta associada a <parameter> de </parameter> "

#: book.translate.xml:7875
#, fuzzy
msgid ""
"Fill in the label (<parameter>delabel</parameter>) for a newly created <citerefentry "
"vendor=\"current\"><refentrytitle>devfs</refentrytitle><manvolnum>5</manvolnum></"
"citerefentry> symbolic link entry."
msgstr ""
"Preencha o rÛtulo ( <parameter> delabel </parameter> ) para um recÈm criado "
"<citerefentry vendor=\"current\"><refentrytitle> devfs </refentrytitle><manvolnum> 5 "
"</manvolnum></citerefentry> entrada de link simbÛlico \""

#: book.translate.xml:7880
#, fuzzy
msgid "<function>mpo_create_vnode_extattr</function>"
msgstr " <function> mpo_create_vnode_extattr </function> "

#: book.translate.xml:7883
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_create_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"mount *<parameter>mp</parameter></paramdef> <paramdef>struct label "
"*<parameter>fslabel</parameter></paramdef> <paramdef>struct vnode *<parameter>dvp</"
"parameter></paramdef> <paramdef>struct label *<parameter>dlabel</parameter></"
"paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_create_vnode_extattr </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> montagem struct * "
"<parameter> mp </parameter></paramdef><paramdef> label struct * <parameter> fslabel "
"</parameter></paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></paramdef><paramdef> "
"label struct * <parameter> vlabel </parameter></paramdef><paramdef> struct "
"componentname * <parameter> cnp </parameter></paramdef> "

#: book.translate.xml:7929
#, fuzzy
msgid "<parameter>mount</parameter>"
msgstr " <parameter> montar </parameter> "

#: book.translate.xml:13035 book.translate.xml:12900 book.translate.xml:12754
#: book.translate.xml:12672 book.translate.xml:12344 book.translate.xml:11968
#: book.translate.xml:11886 book.translate.xml:11824 book.translate.xml:11762
#: book.translate.xml:7939
#, fuzzy
msgid "<parameter>dvp</parameter>"
msgstr " <parameter> dvp </parameter> "

#: book.translate.xml:11969 book.translate.xml:7940
#, fuzzy
msgid "Parent directory vnode"
msgstr "DiretÛrio pai vnode"

#: book.translate.xml:13040 book.translate.xml:12905 book.translate.xml:12759
#: book.translate.xml:12677 book.translate.xml:12349 book.translate.xml:11973
#: book.translate.xml:11891 book.translate.xml:11829 book.translate.xml:11767
#: book.translate.xml:7944
#, fuzzy
msgid "<parameter>dlabel</parameter>"
msgstr " <parameter> dlabel </parameter> "

#: book.translate.xml:7945
#, fuzzy
msgid "Label associated with <parameter>dvp</parameter>"
msgstr "Etiqueta associada a <parameter> dvp </parameter> "

#: book.translate.xml:7951
#, fuzzy
msgid "Newly created vnode"
msgstr "Vnode recentemente criado"

#: book.translate.xml:12911 book.translate.xml:12782 book.translate.xml:12694
#: book.translate.xml:12366 book.translate.xml:11990 book.translate.xml:11897
#: book.translate.xml:7961
#, fuzzy
msgid "<parameter>cnp</parameter>"
msgstr " <parameter> CNP </parameter> "

#: book.translate.xml:12695 book.translate.xml:11991 book.translate.xml:7962
#, fuzzy
msgid "Component name for <parameter>vp</parameter>"
msgstr "Nome do componente para <parameter> vp </parameter> "

#: book.translate.xml:7969
#, fuzzy
msgid ""
"Write out the label for <parameter>vp</parameter> to the appropriate extended "
"attribute. If the write succeeds, fill in <parameter>vlabel</parameter> with the "
"label, and return <returnvalue>0</returnvalue>. Otherwise, return an appropriate "
"error."
msgstr ""
"Escreva o rÛtulo para <parameter> vp </parameter> para o atributo estendido "
"apropriado. Se a gravaÁ„o for bem-sucedida, preencha <parameter> vlabel </parameter> "
"com o rÛtulo e retornar <returnvalue> 0 </returnvalue> . Caso contr·rio, retorne um "
"erro apropriado. "

#: book.translate.xml:7977
#, fuzzy
msgid "<function>mpo_create_mount</function>"
msgstr " <function> mpo_create_mount </function> "

#: book.translate.xml:7980
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mount</function></funcdef> <paramdef>struct ucred "
"*<parameter>cred</parameter></paramdef> <paramdef>struct mount *<parameter>mp</"
"parameter></paramdef> <paramdef>struct label *<parameter>mnt</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mount </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> montagem struct * "
"<parameter> mp </parameter></paramdef><paramdef> label struct * <parameter> mnt </"
"parameter></paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#: book.translate.xml:8019
#, fuzzy
msgid "Object; file system being mounted"
msgstr "Objeto; sistema de arquivos sendo montado"

#: book.translate.xml:8024
#, fuzzy
msgid "Policy label to be filled in for <parameter>mp</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para <parameter> mp </parameter> "

#: book.translate.xml:8030
#, fuzzy
msgid "Policy label for the file system <parameter>mp</parameter> mounts."
msgstr ""
"RÛtulo de PolÌ≠tica para o Sistema de Arquivos <parameter> mp </parameter> montagens. "

#: book.translate.xml:8037
#, fuzzy
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when a new file system is mounted."
msgstr ""
"Preencha os rÛtulos no ponto de montagem que est· sendo criado pela credencial de "
"assunto passada. Essa chamada ser· feita quando um novo sistema de arquivos for "
"montado."

#: book.translate.xml:8043
#, fuzzy
msgid "<function>mpo_create_root_mount</function>"
msgstr " <function> mpo_create_root_mount </function> "

#: book.translate.xml:8046
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_root_mount</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct mount *<parameter>mp</"
"parameter></paramdef> <paramdef>struct label *<parameter>mntlabel</parameter></"
"paramdef> <paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_root_mount </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> montagem struct * "
"<parameter> mp </parameter></paramdef><paramdef> label struct * <parameter> mntlabel "
"</parameter></paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#: book.translate.xml:8079
#, fuzzy
msgid "See <xref linkend=\"mac-mpo-create-mount\"/>."
msgstr "Vejo <xref linkend=\"mac-mpo-create-mount\"/> "

#: book.translate.xml:8085
#, fuzzy
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when the root file system is mounted, after "
"mpo_create_mount;."
msgstr ""
"Preencha os rÛtulos no ponto de montagem que est· sendo criado pela credencial de "
"assunto passada. Essa chamada ser· feita quando o sistema de arquivos raiz for "
"montado, apÛs mpo_create_mount ;."

#: book.translate.xml:8092
#, fuzzy
msgid "<function>mpo_relabel_vnode</function>"
msgstr " <function> mpo_relabel_vnode </function> "

#: book.translate.xml:8095
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_vnode</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>vnodelabel</parameter></"
"paramdef> <paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_vnode </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> "
"vnodelabel </parameter></paramdef><paramdef> label struct * <parameter> newlabel </"
"parameter></paramdef> "

#: book.translate.xml:8134
#, fuzzy
msgid "vnode to relabel"
msgstr "vnode para reclassificar"

#: book.translate.xml:11510 book.translate.xml:9941 book.translate.xml:9868
#: book.translate.xml:8277 book.translate.xml:8138
#, fuzzy
msgid "<parameter>vnodelabel</parameter>"
msgstr " <parameter> vnodelabel </parameter> "

#: book.translate.xml:11511 book.translate.xml:8139
#, fuzzy
msgid "Existing policy label for <parameter>vp</parameter>"
msgstr "Etiqueta de polÌ≠tica existente para <parameter> vp </parameter> "

#: book.translate.xml:11516 book.translate.xml:11448 book.translate.xml:11398
#: book.translate.xml:11333 book.translate.xml:10788 book.translate.xml:10083
#: book.translate.xml:9677 book.translate.xml:8733 book.translate.xml:8669
#: book.translate.xml:8603 book.translate.xml:8144
#, fuzzy
msgid "<parameter>newlabel</parameter>"
msgstr " <parameter> newlabel </parameter> "

#: book.translate.xml:8145
#, fuzzy
msgid "New, possibly partial label to replace <parameter>vnodelabel</parameter>"
msgstr ""
"Etiqueta nova, possivelmente parcial, para substituir <parameter> vnodelabel </"
"parameter> "

#: book.translate.xml:8152
#, fuzzy
msgid ""
"Update the label on the passed vnode given the passed update vnode label and the "
"passed subject credential."
msgstr ""
"Atualize o rÛtulo no vnode passado, dado o rÛtulo vnode da atualizaÁ„o passada e a "
"credencial de assunto passada."

#: book.translate.xml:8157
#, fuzzy
msgid "<function>mpo_setlabel_vnode_extattr</function>"
msgstr " <function> mpo_setlabel_vnode_extattr </function> "

#: book.translate.xml:8160
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_setlabel_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>vlabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>intlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_setlabel_vnode_extattr </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> vlabel </"
"parameter></paramdef><paramdef> label struct * <parameter> intlabel </parameter></"
"paramdef> "

#: book.translate.xml:8199
#, fuzzy
msgid "Vnode for which the label is being written"
msgstr "Vnode para o qual o rÛtulo est· sendo gravado"

#: book.translate.xml:8210
#, fuzzy
msgid "<parameter>intlabel</parameter>"
msgstr " <parameter> louco </parameter> "

#: book.translate.xml:8211
#, fuzzy
msgid "Label to write out"
msgstr "Etiqueta para escrever"

#: book.translate.xml:8217
#, fuzzy
msgid ""
"Write out the policy from <parameter>intlabel</parameter> to an extended attribute. "
"This is called from <function>vop_stdcreatevnode_ea</function>."
msgstr ""
"Escreva a polÌ≠tica de <parameter> intlabel </parameter> para um atributo estendido. "
"Isso È chamado de <function> vop_stdcreatevnode_ea </function> "

#: book.translate.xml:8224
#, fuzzy
msgid "<function>mpo_update_devfsdirent</function>"
msgstr " <function> mpo_update_devfsdirent </function> "

#: book.translate.xml:8226
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_update_devfsdirent</function></funcdef> <paramdef>struct "
"devfs_dirent *<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>direntlabel</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>vp</parameter></paramdef> <paramdef>struct label *<parameter>vnodelabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_update_devfsdirent </function></funcdef><paramdef> "
"struct devfs_dirent * <parameter> devfs_dirent </parameter></paramdef><paramdef> "
"label struct * <parameter> direntlabel </parameter></paramdef><paramdef> struct "
"vnode * <parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> "
"vnodelabel </parameter></paramdef> "

#: book.translate.xml:8260
#, fuzzy
msgid "Object; devfs directory entry"
msgstr "Objeto; entrada do diretÛrio devfs"

#: book.translate.xml:8264
#, fuzzy
msgid "<parameter>direntlabel</parameter>"
msgstr " <parameter> direntlabel </parameter> "

#: book.translate.xml:8265
#, fuzzy
msgid "Policy label for <parameter>devfs_dirent</parameter> to be updated."
msgstr ""
"Etiqueta de polÌ≠tica para <parameter> devfs_dirent </parameter> ser atualizado."

#: book.translate.xml:8272
#, fuzzy
msgid "Parent vnode"
msgstr "Parent vnode"

#: book.translate.xml:12054 book.translate.xml:11506 book.translate.xml:9864
#: book.translate.xml:8273
#, fuzzy
msgid "Locked"
msgstr "Bloqueado"

#: book.translate.xml:13798 book.translate.xml:13610 book.translate.xml:13534
#: book.translate.xml:13466 book.translate.xml:13398 book.translate.xml:13313
#: book.translate.xml:13235 book.translate.xml:13169 book.translate.xml:13103
#: book.translate.xml:12975 book.translate.xml:12264 book.translate.xml:12191
#: book.translate.xml:12126 book.translate.xml:12059 book.translate.xml:11985
#: book.translate.xml:11698 book.translate.xml:9942 book.translate.xml:9869
#: book.translate.xml:8278
#, fuzzy
msgid "Policy label for <parameter>vp</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> vp </parameter> "

#: book.translate.xml:8285
#, fuzzy
msgid ""
"Update the <parameter>devfs_dirent</parameter> label from the passed devfs vnode "
"label. This call will be made when a devfs vnode has been successfully relabeled to "
"commit the label change such that it lasts even if the vnode is recycled. It will "
"also be made when a symlink is created in devfs, following a call to "
"<function>mac_vnode_create_from_vnode</function> to initialize the vnode label."
msgstr ""
"Atualizar o <parameter> devfs_dirent </parameter> label do rÛtulo vnode devfs "
"passado. Essa chamada ser· feita quando um devfs vnode tiver sido renomeado com "
"sucesso para confirmar a mudanÁa de rÛtulo, de modo que ele dure mesmo que o vnode "
"seja reciclado. TambÈm ser· feito quando um link simbÛlico È criado no devfs, apÛs "
"uma chamada para <function> mac_vnode_create_from_vnode </function> para inicializar "
"o rÛtulo vnode. "

#: book.translate.xml:8297
#, fuzzy
msgid "IPC Object Labeling Event Operations"
msgstr "OperaÁÌµes de evento de rotulagem de objeto IPC"

#: book.translate.xml:8301
#, fuzzy
msgid "<function>mpo_create_mbuf_from_socket</function>"
msgstr " <function> mpo_create_mbuf_from_socket </function> "

#: book.translate.xml:8304
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef> <paramdef>struct mbuf *<parameter>m</"
"parameter></paramdef> <paramdef>struct label *<parameter>mbuflabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> m </parameter></paramdef><paramdef> "
"label struct * <parameter> mbuflabel </parameter></paramdef> "

#: book.translate.xml:12837 book.translate.xml:11387 book.translate.xml:11265
#: book.translate.xml:11021 book.translate.xml:10957 book.translate.xml:8336
#, fuzzy
msgid "<parameter>socket</parameter>"
msgstr " <parameter> soquete </parameter> "

#: book.translate.xml:11149 book.translate.xml:11091 book.translate.xml:8337
#, fuzzy
msgid "Socket"
msgstr "Soquete"

#: book.translate.xml:8338
#, fuzzy
msgid "Socket locking WIP"
msgstr "Socket locking WIP"

#: book.translate.xml:14015 book.translate.xml:12842 book.translate.xml:11392
#: book.translate.xml:11270 book.translate.xml:11153 book.translate.xml:11095
#: book.translate.xml:11026 book.translate.xml:10962 book.translate.xml:8471
#: book.translate.xml:8342
#, fuzzy
msgid "<parameter>socketlabel</parameter>"
msgstr " <parameter> socketlabel </parameter> "

#: book.translate.xml:12843 book.translate.xml:11271 book.translate.xml:11027
#: book.translate.xml:10963 book.translate.xml:8343
#, fuzzy
msgid "Policy label for <parameter>socket</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> soquete </parameter> "

#: book.translate.xml:8348
#, fuzzy
msgid "<parameter>m</parameter>"
msgstr " <parameter> m </parameter> "

#: book.translate.xml:8349
#, fuzzy
msgid "Object; mbuf"
msgstr "Objeto; mbuf"

#: book.translate.xml:13952 book.translate.xml:13876 book.translate.xml:9733
#: book.translate.xml:9384 book.translate.xml:9317 book.translate.xml:9249
#: book.translate.xml:8723 book.translate.xml:8353
#, fuzzy
msgid "<parameter>mbuflabel</parameter>"
msgstr " <parameter> mbuflabel </parameter> "

#: book.translate.xml:8354
#, fuzzy
msgid "Policy label to fill in for <parameter>m</parameter>"
msgstr "Etiqueta de polÌ≠tica a preencher para <parameter> m </parameter> "

#: book.translate.xml:8361
#, fuzzy
msgid ""
"Set the label on a newly created mbuf header from the passed socket label. This call "
"is made when a new datagram or message is generated by the socket and stored in the "
"passed mbuf."
msgstr ""
"Configure o rÛtulo em um cabeÁalho mbuf recÈm-criado a partir do rÛtulo do soquete "
"passado. Essa chamada È feita quando um novo datagrama ou mensagem È gerado pelo "
"soquete e armazenado no mbuf passado."

#: book.translate.xml:8368
#, fuzzy
msgid "<function>mpo_create_pipe</function>"
msgstr " <function> mpo_create_pipe </function> "

#: book.translate.xml:8371
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_pipe</function></funcdef> <paramdef>struct ucred "
"*<parameter>cred</parameter></paramdef> <paramdef>struct pipe *<parameter>pipe</"
"parameter></paramdef> <paramdef>struct label *<parameter>pipelabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_pipe </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura * "
"<parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef> "

#: book.translate.xml:10898 book.translate.xml:10840 book.translate.xml:10777
#: book.translate.xml:10718 book.translate.xml:10661 book.translate.xml:10594
#: book.translate.xml:8592 book.translate.xml:8407
#, fuzzy
msgid "<parameter>pipe</parameter>"
msgstr " <parameter> tubo </parameter> "

#: book.translate.xml:10899 book.translate.xml:10841 book.translate.xml:10778
#: book.translate.xml:10719 book.translate.xml:10662 book.translate.xml:10595
#: book.translate.xml:8593 book.translate.xml:8408
#, fuzzy
msgid "Pipe"
msgstr "Tubo"

#: book.translate.xml:10903 book.translate.xml:10845 book.translate.xml:10782
#: book.translate.xml:10723 book.translate.xml:10666 book.translate.xml:10599
#: book.translate.xml:8412
#, fuzzy
msgid "<parameter>pipelabel</parameter>"
msgstr " <parameter> pipelabel </parameter> "

#: book.translate.xml:10904 book.translate.xml:10846 book.translate.xml:10724
#: book.translate.xml:10667 book.translate.xml:10600 book.translate.xml:8413
#, fuzzy
msgid "Policy label associated with <parameter>pipe</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> tubo </parameter> "

#: book.translate.xml:8420
#, fuzzy
msgid ""
"Set the label on a newly created pipe from the passed subject credential. This call "
"is made when a new pipe is created."
msgstr ""
"Configure o rÛtulo em um pipe recÈm-criado a partir da credencial de assunto "
"passada. Essa chamada È feita quando um novo canal È criado."

#: book.translate.xml:8426
#, fuzzy
msgid "<function>mpo_create_socket</function>"
msgstr " <function> mpo_create_socket </function> "

#: book.translate.xml:8429
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_socket</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct socket "
"*<parameter>so</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_socket </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de estrutura * "
"<parameter> assim </parameter></paramdef><paramdef> label struct * <parameter> "
"socketlabel </parameter></paramdef> "

#: book.translate.xml:14006 book.translate.xml:12048 book.translate.xml:11628
#: book.translate.xml:11500 book.translate.xml:9932 book.translate.xml:9853
#: book.translate.xml:8856 book.translate.xml:8654 book.translate.xml:8462
#, fuzzy
msgid "Immutable"
msgstr "Imut·vel"

#: book.translate.xml:14010 book.translate.xml:11148 book.translate.xml:11090
#: book.translate.xml:8658 book.translate.xml:8466
#, fuzzy
msgid "<parameter>so</parameter>"
msgstr " <parameter> assim </parameter> "

#: book.translate.xml:8467
#, fuzzy
msgid "Object; socket to label"
msgstr "Objeto; soquete para rotular"

#: book.translate.xml:8472
#, fuzzy
msgid "Label to fill in for <parameter>so</parameter>"
msgstr "RÛtulo para preencher para <parameter> assim </parameter> "

#: book.translate.xml:8479
#, fuzzy
msgid ""
"Set the label on a newly created socket from the passed subject credential. This "
"call is made when a socket is created."
msgstr ""
"Configure o rÛtulo em um soquete recÈm-criado a partir da credencial de assunto "
"passada. Essa chamada È feita quando um soquete È criado."

#: book.translate.xml:8485
#, fuzzy
msgid "<function>mpo_create_socket_from_socket</function>"
msgstr " <function> mpo_create_socket_from_socket </function> "

#: book.translate.xml:8488
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_socket_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_socket_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> oldsocket </parameter></"
"paramdef><paramdef> label struct * <parameter> oldsocketlabel </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> boletim de notÌ≠cias </"
"parameter></paramdef><paramdef> label struct * <parameter> newsocketlabel </"
"parameter></paramdef> "

#: book.translate.xml:8784 book.translate.xml:8521
#, fuzzy
msgid "<parameter>oldsocket</parameter>"
msgstr " <parameter> oldsocket </parameter> "

#: book.translate.xml:8522
#, fuzzy
msgid "Listening socket"
msgstr "Tomada de escuta"

#: book.translate.xml:8789 book.translate.xml:8526
#, fuzzy
msgid "<parameter>oldsocketlabel</parameter>"
msgstr " <parameter> oldsocketlabel </parameter> "

#: book.translate.xml:8527
#, fuzzy
msgid "Policy label associated with <parameter>oldsocket</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> oldsocket </parameter> "

#: book.translate.xml:8795 book.translate.xml:8532
#, fuzzy
msgid "<parameter>newsocket</parameter>"
msgstr " <parameter> newsocket </parameter> "

#: book.translate.xml:8533
#, fuzzy
msgid "New socket"
msgstr "Novo soquete"

#: book.translate.xml:8537
#, fuzzy
msgid "<parameter>newsocketlabel</parameter>"
msgstr " <parameter> newsocketlabel </parameter> "

#: book.translate.xml:8538
#, fuzzy
msgid "Policy label associated with <parameter>newsocketlabel</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> newsocketlabel </parameter> "

#: book.translate.xml:8545
#, fuzzy
msgid ""
"Label a socket, <parameter>newsocket</parameter>, newly "
"<citerefentry><refentrytitle>accept</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>ed, based on the <citerefentry><refentrytitle>listen</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> socket, <parameter>oldsocket</"
"parameter>."
msgstr ""
"Etiquetar um soquete, <parameter> boletim de notÌ≠cias </parameter> recentemente "
"<citerefentry><refentrytitle> aceitar </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> ed, com base no <citerefentry><refentrytitle> ouÁo </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> soquete <parameter> "
"oldsocket </parameter> "

#: book.translate.xml:8551
#, fuzzy
msgid "<function>mpo_relabel_pipe</function>"
msgstr " <function> mpo_relabel_pipe </function> "

#: book.translate.xml:8554
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_pipe</function></funcdef> <paramdef>struct ucred "
"*<parameter>cred</parameter></paramdef> <paramdef>struct pipe *<parameter>pipe</"
"parameter></paramdef> <paramdef>struct label *<parameter>oldlabel</parameter></"
"paramdef> <paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_pipe </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura * "
"<parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"oldlabel </parameter></paramdef><paramdef> label struct * <parameter> newlabel </"
"parameter></paramdef> "

#: book.translate.xml:8728 book.translate.xml:8663 book.translate.xml:8597
#, fuzzy
msgid "<parameter>oldlabel</parameter>"
msgstr " <parameter> oldlabel </parameter> "

#: book.translate.xml:10783 book.translate.xml:8598
#, fuzzy
msgid "Current policy label associated with <parameter>pipe</parameter>"
msgstr "Etiqueta de polÌ≠tica atual associada a <parameter> tubo </parameter> "

#: book.translate.xml:8604
#, fuzzy
msgid "Policy label update to apply to <parameter>pipe</parameter>"
msgstr ""
"AtualizaÁ„o de rÛtulo de polÌ≠tica a ser aplicada a <parameter> tubo </parameter> "

#: book.translate.xml:8611
#, fuzzy
msgid ""
"Apply a new label, <parameter>newlabel</parameter>, to <parameter>pipe</parameter>."
msgstr ""
"Aplique um novo rÛtulo, <parameter> newlabel </parameter> , para <parameter> tubo </"
"parameter> "

#: book.translate.xml:8616
#, fuzzy
msgid "<function>mpo_relabel_socket</function>"
msgstr " <function> mpo_relabel_socket </function> "

#: book.translate.xml:8619
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_socket</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct socket "
"*<parameter>so</parameter></paramdef> <paramdef>struct label *<parameter>oldlabel</"
"parameter></paramdef> <paramdef>struct label *<parameter>newlabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_socket </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> assim </parameter></paramdef><paramdef> label struct * "
"<parameter> oldlabel </parameter></paramdef><paramdef> label struct * <parameter> "
"newlabel </parameter></paramdef> "

#: book.translate.xml:14011 book.translate.xml:12838 book.translate.xml:11388
#: book.translate.xml:11266 book.translate.xml:8659
#, fuzzy
msgid "Object; socket"
msgstr "Objeto; soquete"

#: book.translate.xml:8664
#, fuzzy
msgid "Current label for <parameter>so</parameter>"
msgstr "Etiqueta atual para <parameter> assim </parameter> "

#: book.translate.xml:8670
#, fuzzy
msgid "Label update for <parameter>so</parameter>"
msgstr "AtualizaÁ„o de etiqueta para <parameter> assim </parameter> "

#: book.translate.xml:8677
#, fuzzy
msgid "Update the label on a socket from the passed socket label update."
msgstr "Atualize o rÛtulo em um soquete da atualizaÁ„o do rÛtulo do soquete passado."

#: book.translate.xml:8682
#, fuzzy
msgid "<function>mpo_set_socket_peer_from_mbuf</function>"
msgstr " <function> mpo_set_socket_peer_from_mbuf </function> "

#: book.translate.xml:8685
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>mbuflabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>oldlabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_set_socket_peer_from_mbuf </function></"
"funcdef><paramdef> struct mbuf * <parameter> mbuf </parameter></paramdef><paramdef> "
"label struct * <parameter> mbuflabel </parameter></paramdef><paramdef> label struct "
"* <parameter> oldlabel </parameter></paramdef><paramdef> label struct * <parameter> "
"newlabel </parameter></paramdef> "

#: book.translate.xml:13947 book.translate.xml:13871 book.translate.xml:9728
#: book.translate.xml:9379 book.translate.xml:9312 book.translate.xml:9244
#: book.translate.xml:8718
#, fuzzy
msgid "<parameter>mbuf</parameter>"
msgstr " <parameter> mbuf </parameter> "

#: book.translate.xml:8719
#, fuzzy
msgid "First datagram received over socket"
msgstr "Primeiro datagrama recebido por soquete"

#: book.translate.xml:8724
#, fuzzy
msgid "Label for <parameter>mbuf</parameter>"
msgstr "RÛtulo para <parameter> mbuf </parameter> "

#: book.translate.xml:8729
#, fuzzy
msgid "Current label for the socket"
msgstr "Etiqueta atual para o soquete"

#: book.translate.xml:8734
#, fuzzy
msgid "Policy label to be filled out for the socket"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para o socket"

#: book.translate.xml:8741
#, fuzzy
msgid ""
"Set the peer label on a stream socket from the passed mbuf label. This call will be "
"made when the first datagram is received by the stream socket, with the exception of "
"Unix domain sockets."
msgstr ""
"Configure o rÛtulo peer em um soquete de fluxo a partir do rÛtulo mbuf passado. Essa "
"chamada ser· feita quando o primeiro datagrama for recebido pelo soquete de fluxo, "
"com a exceÁ„o dos soquetes de domÌ≠nio Unix."

#: book.translate.xml:8748
#, fuzzy
msgid "<function>mpo_set_socket_peer_from_socket</function>"
msgstr " <function> mpo_set_socket_peer_from_socket </function> "

#: book.translate.xml:8751
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketpeerlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_set_socket_peer_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> oldsocket </parameter></"
"paramdef><paramdef> label struct * <parameter> oldsocketlabel </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> boletim de notÌ≠cias </"
"parameter></paramdef><paramdef> label struct * <parameter> newsocketpeerlabel </"
"parameter></paramdef> "

#: book.translate.xml:8785
#, fuzzy
msgid "Local socket"
msgstr "Soquete local"

#: book.translate.xml:8790
#, fuzzy
msgid "Policy label for <parameter>oldsocket</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> oldsocket </parameter> "

#: book.translate.xml:8796
#, fuzzy
msgid "Peer socket"
msgstr "Soquete do par"

#: book.translate.xml:8800
#, fuzzy
msgid "<parameter>newsocketpeerlabel</parameter>"
msgstr " <parameter> newsocketpeerlabel </parameter> "

#: book.translate.xml:8801
#, fuzzy
msgid "Policy label to fill in for <parameter>newsocket</parameter>"
msgstr ""
"Etiqueta de polÌ≠tica a preencher para <parameter> boletim de notÌ≠cias </parameter> "

#: book.translate.xml:8809
#, fuzzy
msgid ""
"Set the peer label on a stream UNIX domain socket from the passed remote socket "
"endpoint. This call will be made when the socket pair is connected, and will be made "
"for both endpoints."
msgstr ""
"Configure o rÛtulo peer em um soquete de domÌ≠nio UNIX de fluxo a partir do terminal "
"de soquete remoto passado. Essa chamada ser· feita quando o par de soquetes estiver "
"conectado e ser· feita para os dois terminais."

#: book.translate.xml:8817
#, fuzzy
msgid "Network Object Labeling Event Operations"
msgstr "OperaÁÌµes de evento de rotulagem de objeto de rede"

#: book.translate.xml:8820
#, fuzzy
msgid "<function>mpo_create_bpfdesc</function>"
msgstr " <function> mpo_create_bpfdesc </function> "

#: book.translate.xml:8823
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_bpfdesc</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct bpf_d "
"*<parameter>bpf_d</parameter></paramdef> <paramdef>struct label "
"*<parameter>bpflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_bpfdesc </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct bpf_d * "
"<parameter> bpf_d </parameter></paramdef><paramdef> label struct * <parameter> "
"bpflabel </parameter></paramdef> "

#: book.translate.xml:10189 book.translate.xml:9301 book.translate.xml:8860
#, fuzzy
msgid "<parameter>bpf_d</parameter>"
msgstr " <parameter> bpf_d </parameter> "

#: book.translate.xml:8861
#, fuzzy
msgid "Object; bpf descriptor"
msgstr "Objeto; descritor bpf"

#: book.translate.xml:8865
#, fuzzy
msgid "<parameter>bpf</parameter>"
msgstr " <parameter> bpf </parameter> "

#: book.translate.xml:8866
#, fuzzy
msgid "Policy label to be filled in for <parameter>bpf_d</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para <parameter> bpf_d </parameter> "

#: book.translate.xml:8873
#, fuzzy
msgid ""
"Set the label on a newly created BPF descriptor from the passed subject credential. "
"This call will be made when a BPF device node is opened by a process with the passed "
"subject credential."
msgstr ""
"Configure o rÛtulo em um descritor BPF recÈm-criado a partir da credencial de "
"assunto passada. Essa chamada ser· feita quando um nÛ de dispositivo BPF for aberto "
"por um processo com a credencial de assunto passada."

#: book.translate.xml:8880
#, fuzzy
msgid "<function>mpo_create_ifnet</function>"
msgstr " <function> mpo_create_ifnet </function> "

#: book.translate.xml:8883
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_ifnet</function></funcdef> <paramdef>struct ifnet "
"*<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_ifnet </function></funcdef><paramdef> struct "
"ifnet * <parameter> ifnet </parameter></paramdef><paramdef> label struct * "
"<parameter> ifnetlabel </parameter></paramdef> "

#: book.translate.xml:13936 book.translate.xml:13860 book.translate.xml:11322
#: book.translate.xml:10200 book.translate.xml:9666 book.translate.xml:9448
#: book.translate.xml:9368 book.translate.xml:9233 book.translate.xml:8912
#, fuzzy
msgid "<parameter>ifnet</parameter>"
msgstr " <parameter> ifnet </parameter> "

#: book.translate.xml:13937 book.translate.xml:13861 book.translate.xml:9449
#: book.translate.xml:9369 book.translate.xml:9234 book.translate.xml:8913
#, fuzzy
msgid "Network interface"
msgstr "Interface de rede"

#: book.translate.xml:13941 book.translate.xml:13865 book.translate.xml:11327
#: book.translate.xml:10205 book.translate.xml:9671 book.translate.xml:9453
#: book.translate.xml:9373 book.translate.xml:9238 book.translate.xml:8917
#, fuzzy
msgid "<parameter>ifnetlabel</parameter>"
msgstr " <parameter> ifnetlabel </parameter> "

#: book.translate.xml:8918
#, fuzzy
msgid "Policy label to fill in for <parameter>ifnet</parameter>"
msgstr "Etiqueta de polÌ≠tica a preencher para <parameter> ifnet </parameter> "

#: book.translate.xml:8925
#, fuzzy
msgid ""
"Set the label on a newly created interface. This call may be made when a new "
"physical interface becomes available to the system, or when a pseudo-interface is "
"instantiated during the boot or as a result of a user action."
msgstr ""
"Configure o rÛtulo em uma interface recÈm-criada. Essa chamada pode ser feita quando "
"uma nova interface fÌ≠sica se torna disponÌ≠vel para o sistema ou quando uma pseudo-"
"interface È instanciada durante a inicializaÁ„o ou como resultado de uma aÁ„o do "
"usu·rio."

#: book.translate.xml:8932
#, fuzzy
msgid "<function>mpo_create_ipq</function>"
msgstr " <function> mpo_create_ipq </function> "

#: book.translate.xml:8935
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_ipq</function></funcdef> <paramdef>struct mbuf "
"*<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label *<parameter>ipqlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_ipq </function></funcdef><paramdef> struct "
"mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label struct * "
"<parameter> fragmento </parameter></paramdef><paramdef> struct ipq * <parameter> ipq "
"</parameter></paramdef><paramdef> label struct * <parameter> ipqlabel </parameter></"
"paramdef> "

#: book.translate.xml:9585 book.translate.xml:9111 book.translate.xml:8968
#, fuzzy
msgid "<parameter>fragment</parameter>"
msgstr " <parameter> fragmento </parameter> "

#: book.translate.xml:8969
#, fuzzy
msgid "First received IP fragment"
msgstr "Primeiro fragmento IP recebido"

#: book.translate.xml:9590 book.translate.xml:9116 book.translate.xml:8973
#, fuzzy
msgid "<parameter>fragmentlabel</parameter>"
msgstr " <parameter> fragmento </parameter> "

#: book.translate.xml:9591 book.translate.xml:8974
#, fuzzy
msgid "Policy label for <parameter>fragment</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> fragmento </parameter> "

#: book.translate.xml:9739 book.translate.xml:9596 book.translate.xml:9034
#: book.translate.xml:8979
#, fuzzy
msgid "<parameter>ipq</parameter>"
msgstr " <parameter> ipq </parameter> "

#: book.translate.xml:8980
#, fuzzy
msgid "IP reassembly queue to be labeled"
msgstr "Fila de remontagem de IP a ser rotulada"

#: book.translate.xml:9744 book.translate.xml:9601 book.translate.xml:9039
#: book.translate.xml:8984
#, fuzzy
msgid "<parameter>ipqlabel</parameter>"
msgstr " <parameter> ipglabel </parameter> "

#: book.translate.xml:8985
#, fuzzy
msgid "Policy label to be filled in for <parameter>ipq</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para <parameter> ipq </parameter> "

#: book.translate.xml:8992
#, fuzzy
msgid ""
"Set the label on a newly created IP fragment reassembly queue from the mbuf header "
"of the first received fragment."
msgstr ""
"Configure o rÛtulo em uma fila de remontagem de fragmento IP recÈm-criada a partir "
"do cabeÁalho mbuf do primeiro fragmento recebido."

#: book.translate.xml:8998
#, fuzzy
msgid "<function>mpo_create_datagram_from_ipq</function>"
msgstr " <function> mpo_create_datagram_from_ipq </function> "

#: book.translate.xml:9001
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_create_datagram_from_ipq</function></funcdef> "
"<paramdef>struct ipq *<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>datagram</parameter></paramdef> <paramdef>struct label "
"*<parameter>datagramlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_create_datagram_from_ipq </function></"
"funcdef><paramdef> struct ipq * <parameter> ipq </parameter></paramdef><paramdef> "
"label struct * <parameter> ipqlabel </parameter></paramdef><paramdef> struct mbuf * "
"<parameter> datagrama </parameter></paramdef><paramdef> label struct * <parameter> "
"datagramlabel </parameter></paramdef> "

#: book.translate.xml:9035
#, fuzzy
msgid "IP reassembly queue"
msgstr "Fila de remontagem de IP"

#: book.translate.xml:9602 book.translate.xml:9040
#, fuzzy
msgid "Policy label for <parameter>ipq</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> ipq </parameter> "

#: book.translate.xml:9100 book.translate.xml:9045
#, fuzzy
msgid "<parameter>datagram</parameter>"
msgstr " <parameter> datagrama </parameter> "

#: book.translate.xml:9046
#, fuzzy
msgid "Datagram to be labeled"
msgstr "Datagrama a ser rotulado"

#: book.translate.xml:9105 book.translate.xml:9050
#, fuzzy
msgid "<parameter>datagramlabel</parameter>"
msgstr " <parameter> etiqueta datagrama </parameter> "

#: book.translate.xml:9051
#, fuzzy
msgid "Policy label to be filled in for <parameter>datagramlabel</parameter>"
msgstr ""
"Etiqueta de polÌ≠tica a ser preenchida para <parameter> datagramlabel </parameter> "

#: book.translate.xml:9058
#, fuzzy
msgid ""
"Set the label on a newly reassembled IP datagram from the IP fragment reassembly "
"queue from which it was generated."
msgstr ""
"Configure o rÛtulo em um datagrama IP recÈm remontado da fila de remontagem de "
"fragmento IP a partir da qual ele foi gerado."

#: book.translate.xml:9064
#, fuzzy
msgid "<function>mpo_create_fragment</function>"
msgstr " <function> mpo_create_fragment </function> "

#: book.translate.xml:9067
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_fragment</function></funcdef> <paramdef>struct "
"mbuf *<parameter>datagram</parameter></paramdef> <paramdef>struct label "
"*<parameter>datagramlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_fragment </function></funcdef><paramdef> "
"struct mbuf * <parameter> datagrama </parameter></paramdef><paramdef> label struct * "
"<parameter> datagramlabel </parameter></paramdef><paramdef> struct mbuf * "
"<parameter> fragmento </parameter></paramdef><paramdef> label struct * <parameter> "
"fragmento </parameter></paramdef> "

#: book.translate.xml:9101
#, fuzzy
msgid "Datagram"
msgstr "Datagrama"

#: book.translate.xml:9106
#, fuzzy
msgid "Policy label for <parameter>datagram</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> datagrama </parameter> "

#: book.translate.xml:9112
#, fuzzy
msgid "Fragment to be labeled"
msgstr "Fragmento a ser rotulado"

#: book.translate.xml:9117
#, fuzzy
msgid "Policy label to be filled in for <parameter>datagram</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para <parameter> datagrama </parameter> "

#: book.translate.xml:9124
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created IP fragment from the label on "
"the mbuf header of the datagram it was generate from."
msgstr ""
"Configure o rÛtulo no cabeÁalho mbuf de um fragmento IP recÈm-criado a partir do "
"rÛtulo no cabeÁalho mbuf do datagrama do qual ele foi gerado."

#: book.translate.xml:9130
#, fuzzy
msgid "<function>mpo_create_mbuf_from_mbuf</function>"
msgstr " <function> mpo_create_mbuf_from_mbuf </function> "

#: book.translate.xml:9133
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> <paramdef>struct "
"label *<parameter>oldmbuflabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>newmbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_mbuf </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></paramdef> "

#: book.translate.xml:9517 book.translate.xml:9437 book.translate.xml:9166
#, fuzzy
msgid "<parameter>oldmbuf</parameter>"
msgstr " <parameter> oldmbuf </parameter> "

#: book.translate.xml:9167
#, fuzzy
msgid "Existing (source) mbuf"
msgstr "Existente (fonte) mbuf"

#: book.translate.xml:9522 book.translate.xml:9442 book.translate.xml:9171
#, fuzzy
msgid "<parameter>oldmbuflabel</parameter>"
msgstr " <parameter> oldmbuflabel </parameter> "

#: book.translate.xml:9523 book.translate.xml:9443 book.translate.xml:9172
#, fuzzy
msgid "Policy label for <parameter>oldmbuf</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> oldmbuf </parameter> "

#: book.translate.xml:9528 book.translate.xml:9459 book.translate.xml:9177
#, fuzzy
msgid "<parameter>newmbuf</parameter>"
msgstr " <parameter> newmbuf </parameter> "

#: book.translate.xml:9313 book.translate.xml:9178
#, fuzzy
msgid "New mbuf to be labeled"
msgstr "Novo mbuf a ser rotulado"

#: book.translate.xml:9533 book.translate.xml:9465 book.translate.xml:9182
#, fuzzy
msgid "<parameter>newmbuflabel</parameter>"
msgstr " <parameter> newmbuflabel </parameter> "

#: book.translate.xml:9466 book.translate.xml:9183
#, fuzzy
msgid "Policy label to be filled in for <parameter>newmbuf</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para <parameter> newmbuf </parameter> "

#: book.translate.xml:9190
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram from the mbuf header of "
"an existing datagram. This call may be made in a number of situations, including "
"when an mbuf is re-allocated for alignment purposes."
msgstr ""
"Configure o rÛtulo no cabeÁalho mbuf de um datagrama recÈm-criado a partir do "
"cabeÁalho mbuf de um datagrama existente. Essa chamada pode ser feita em v·rias "
"situaÁÌµes, inclusive quando um mbuf È realocado para fins de alinhamento."

#: book.translate.xml:9197
#, fuzzy
msgid "<function>mpo_create_mbuf_linklayer</function>"
msgstr " <function> mpo_create_mbuf_linklayer </function> "

#: book.translate.xml:9200
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_linklayer</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> <paramdef>struct "
"label *<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>mbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_linklayer </function></"
"funcdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></paramdef><paramdef> "
"label struct * <parameter> mbuflabel </parameter></paramdef> "

#: book.translate.xml:13942 book.translate.xml:13866 book.translate.xml:10206
#: book.translate.xml:9672 book.translate.xml:9454 book.translate.xml:9239
#, fuzzy
msgid "Policy label for <parameter>ifnet</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> ifnet </parameter> "

#: book.translate.xml:9380 book.translate.xml:9245
#, fuzzy
msgid "mbuf header for new datagram"
msgstr "cabeÁalho mbuf para novo datagrama"

#: book.translate.xml:9385 book.translate.xml:9250
#, fuzzy
msgid "Policy label to be filled in for <parameter>mbuf</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser preenchida para <parameter> mbuf </parameter> "

#: book.translate.xml:9257
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated for the "
"purposes of a link layer response for the passed interface. This call may be made in "
"a number of situations, including for ARP or ND6 responses in the IPv4 and IPv6 "
"stacks."
msgstr ""
"Defina o rÛtulo no cabeÁalho mbuf de um datagrama recÈm-criado gerado para fins de "
"uma resposta de camada de link para a interface passada. Essa chamada pode ser feita "
"em v·rias situaÁÌµes, incluindo respostas ARP ou ND6 nas pilhas IPv4 e IPv6 "

#: book.translate.xml:9265
#, fuzzy
msgid "<function>mpo_create_mbuf_from_bpfdesc</function>"
msgstr " <function> mpo_create_mbuf_from_bpfdesc </function> "

#: book.translate.xml:9268
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_bpfdesc</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> <paramdef>struct "
"label *<parameter>bpflabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>mbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_bpfdesc </function></"
"funcdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></paramdef><paramdef> "
"label struct * <parameter> mbuflabel </parameter></paramdef> "

#: book.translate.xml:9302
#, fuzzy
msgid "BPF descriptor"
msgstr "Descritor BPF"

#: book.translate.xml:10194 book.translate.xml:9306
#, fuzzy
msgid "<parameter>bpflabel</parameter>"
msgstr " <parameter> bpflabel </parameter> "

#: book.translate.xml:9307
#, fuzzy
msgid "Policy label for <parameter>bpflabel</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> bpflabel </parameter> "

#: book.translate.xml:9318
#, fuzzy
msgid "Policy label to fill in for <parameter>mbuf</parameter>"
msgstr "Etiqueta de polÌ≠tica a preencher para <parameter> mbuf </parameter> "

#: book.translate.xml:9325
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated using the "
"passed BPF descriptor. This call is made when a write is performed to the BPF device "
"associated with the passed BPF descriptor."
msgstr ""
"Definir o rÛtulo no cabeÁalho mbuf de um datagrama recÈm-criado gerado usando o "
"descritor BPF passado. Essa chamada È feita quando uma gravaÁ„o È executada para o "
"dispositivo BPF associado ao descritor BPF passado."

#: book.translate.xml:9332
#, fuzzy
msgid "<function>mpo_create_mbuf_from_ifnet</function>"
msgstr " <function> mpo_create_mbuf_from_ifnet </function> "

#: book.translate.xml:9335
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> <paramdef>struct "
"label *<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>mbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_ifnet </function></"
"funcdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></paramdef><paramdef> "
"label struct * <parameter> mbuflabel </parameter></paramdef> "

#: book.translate.xml:9374
#, fuzzy
msgid "Policy label for <parameter>ifnetlabel</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> ifnetlabel </parameter> "

#: book.translate.xml:9392
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from the "
"passed network interface."
msgstr ""
"Configure o rÛtulo no cabeÁalho mbuf de um datagrama recÈm-criado gerado a partir da "
"interface de rede passada."

#: book.translate.xml:9397
#, fuzzy
msgid "<function>mpo_create_mbuf_multicast_encap</function>"
msgstr " <function> mpo_create_mbuf_multicast_encap </function> "

#: book.translate.xml:9400
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_multicast_encap</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> <paramdef>struct "
"label *<parameter>oldmbuflabel</parameter></paramdef> <paramdef>struct ifnet "
"*<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>newmbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_multicast_encap </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></paramdef> "

#: book.translate.xml:9438
#, fuzzy
msgid "mbuf header for existing datagram"
msgstr "cabeÁalho mbuf para datagrama existente"

#: book.translate.xml:9460
#, fuzzy
msgid "mbuf header to be labeled for new datagram"
msgstr "cabeÁalho mbuf a ser rotulado para novo datagrama"

#: book.translate.xml:9473
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from the "
"existing passed datagram when it is processed by the passed multicast encapsulation "
"interface. This call is made when an mbuf is to be delivered using the virtual "
"interface."
msgstr ""
"Configure o rÛtulo no cabeÁalho mbuf de um datagrama recÈm-criado gerado a partir do "
"datagrama passado existente quando ele È processado pela interface de encapsulamento "
"de difus„o m˙ltipla passada. Essa chamada È feita quando um mbuf deve ser entregue "
"usando a interface virtual."

#: book.translate.xml:9481
#, fuzzy
msgid "<function>mpo_create_mbuf_netlayer</function>"
msgstr " <function> mpo_create_mbuf_netlayer </function> "

#: book.translate.xml:9484
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_netlayer</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> <paramdef>struct "
"label *<parameter>oldmbuflabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>newmbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_netlayer </function></funcdef><paramdef> "
"struct mbuf * <parameter> oldmbuf </parameter></paramdef><paramdef> label struct * "
"<parameter> oldmbuflabel </parameter></paramdef><paramdef> struct mbuf * <parameter> "
"newmbuf </parameter></paramdef><paramdef> label struct * <parameter> newmbuflabel </"
"parameter></paramdef> "

#: book.translate.xml:9518
#, fuzzy
msgid "Received datagram"
msgstr "Recebido datagrama"

#: book.translate.xml:9529
#, fuzzy
msgid "Newly created datagram"
msgstr "Datagrama recÈm-criado"

#: book.translate.xml:9534
#, fuzzy
msgid "Policy label for <parameter>newmbuf</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> newmbuf </parameter> "

#: book.translate.xml:9541
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated by the IP "
"stack in response to an existing received datagram (<parameter>oldmbuf</parameter>). "
"This call may be made in a number of situations, including when responding to ICMP "
"request datagrams."
msgstr ""
"Definir o rÛtulo no cabeÁalho mbuf de um datagrama recÈm-criado gerado pela pilha IP "
"em resposta a um datagrama recebido existente ( <parameter> oldmbuf </parameter> ). "
"Essa chamada pode ser feita em v·rias situaÁÌµes, inclusive ao responder datagramas "
"de solicitaÁ„o do ICMP. "

#: book.translate.xml:9549
#, fuzzy
msgid "<function>mpo_fragment_match</function>"
msgstr " <function> mpo_fragment_match </function> "

#: book.translate.xml:9552
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_fragment_match</function></funcdef> <paramdef>struct mbuf "
"*<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label *<parameter>ipqlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_fragment_match </function></funcdef><paramdef> struct "
"mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label struct * "
"<parameter> fragmento </parameter></paramdef><paramdef> struct ipq * <parameter> ipq "
"</parameter></paramdef><paramdef> label struct * <parameter> ipqlabel </parameter></"
"paramdef> "

#: book.translate.xml:9586
#, fuzzy
msgid "IP datagram fragment"
msgstr "Fragmento de datagrama IP"

#: book.translate.xml:9740 book.translate.xml:9597
#, fuzzy
msgid "IP fragment reassembly queue"
msgstr "Fila de remontagem de fragmento de IP"

#: book.translate.xml:9609
#, fuzzy
msgid ""
"Determine whether an mbuf header containing an IP datagram (<parameter>fragment</"
"parameter>) fragment matches the label of the passed IP fragment reassembly queue "
"(<parameter>ipq</parameter>). Return (<returnvalue>1</returnvalue>) for a successful "
"match, or (<returnvalue>0</returnvalue>) for no match. This call is made when the IP "
"stack attempts to find an existing fragment reassembly queue for a newly received "
"fragment; if this fails, a new fragment reassembly queue may be instantiated for the "
"fragment. Policies may use this entry point to prevent the reassembly of otherwise "
"matching IP fragments if policy does not permit them to be reassembled based on the "
"label or other information."
msgstr ""
"Determina se um cabeÁalho mbuf contendo um datagrama IP ( <parameter> fragmento </"
"parameter> ) fragment corresponde ao rÛtulo da fila de remontagem de fragmentos IP "
"passada ( <parameter> ipq </parameter> ). Retorna ( <returnvalue> 1 </returnvalue> ) "
"para um jogo bem sucedido, ou ( <returnvalue> 0 </returnvalue> ) sem "
"correspondÍncia. Essa chamada È feita quando a pilha de IP tenta localizar uma fila "
"de remontagem de fragmento existente para um fragmento recÈm-recebido; se isso "
"falhar, uma nova fila de remontagem de fragmento pode ser instanciada para o "
"fragmento. As polÌ≠ticas podem usar este ponto de entrada para impedir a remontagem "
"de fragmentos IP correspondentes, caso a polÌ≠tica n„o permita que eles sejam "
"remontados com base no rÛtulo ou em outras informaÁÌµes. "

#: book.translate.xml:9625
#, fuzzy
msgid "<function>mpo_relabel_ifnet</function>"
msgstr " <function> mpo_relabel_ifnet </function> "

#: book.translate.xml:9628
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_ifnet</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct ifnet "
"*<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_ifnet </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> struct ifnet * "
"<parameter> ifnet </parameter></paramdef><paramdef> label struct * <parameter> "
"ifnetlabel </parameter></paramdef><paramdef> label struct * <parameter> newlabel </"
"parameter></paramdef> "

#: book.translate.xml:9667
#, fuzzy
msgid "Object; Network interface"
msgstr "Objeto; interface de rede"

#: book.translate.xml:9678
#, fuzzy
msgid "Label update to apply to <parameter>ifnet</parameter>"
msgstr "AtualizaÁ„o de etiqueta para aplicar a <parameter> ifnet </parameter> "

#: book.translate.xml:9685
#, fuzzy
msgid ""
"Update the label of network interface, <parameter>ifnet</parameter>, based on the "
"passed update label, <parameter>newlabel</parameter>, and the passed subject "
"credential, <parameter>cred</parameter>."
msgstr ""
"Atualizar o rÛtulo da interface de rede, <parameter> ifnet </parameter> , com base "
"na etiqueta de atualizaÁ„o aprovada, <parameter> newlabel </parameter> e a "
"credencial de assunto passada <parameter> cred </parameter> "

#: book.translate.xml:9692
#, fuzzy
msgid "<function>mpo_update_ipq</function>"
msgstr " <function> mpo_update_ipq </function> "

#: book.translate.xml:9695
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_update_ipq</function></funcdef> <paramdef>struct mbuf "
"*<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label *<parameter>ipqlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_update_ipq </function></funcdef><paramdef> struct "
"mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label struct * "
"<parameter> fragmento </parameter></paramdef><paramdef> struct ipq * <parameter> ipq "
"</parameter></paramdef><paramdef> label struct * <parameter> ipqlabel </parameter></"
"paramdef> "

#: book.translate.xml:9729
#, fuzzy
msgid "IP fragment"
msgstr "Fragmento de IP"

#: book.translate.xml:13953 book.translate.xml:13877 book.translate.xml:9734
#, fuzzy
msgid "Policy label for <parameter>mbuf</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> mbuf </parameter> "

#: book.translate.xml:9745
#, fuzzy
msgid "Policy label to be updated for <parameter>ipq</parameter>"
msgstr "Etiqueta de polÌ≠tica a ser atualizada para <parameter> ipq </parameter> "

#: book.translate.xml:9752
#, fuzzy
msgid ""
"Update the label on an IP fragment reassembly queue (<parameter>ipq</parameter>) "
"based on the acceptance of the passed IP fragment mbuf header (<parameter>mbuf</"
"parameter>)."
msgstr ""
"Atualize o rÛtulo em uma fila de remontagem de fragmento IP ( <parameter> ipq </"
"parameter> ) com base na aceitaÁ„o do cabeÁalho mbuf do fragmento IP transmitido "
"( <parameter> mbuf </parameter> ) "

#: book.translate.xml:9760
#, fuzzy
msgid "Process Labeling Event Operations"
msgstr "OperaÁÌµes de eventos de rotulagem de processos"

#: book.translate.xml:9763
#, fuzzy
msgid "<function>mpo_create_cred</function>"
msgstr " <function> mpo_create_cred </function> "

#: book.translate.xml:9766
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_cred</function></funcdef> <paramdef>struct ucred "
"*<parameter>parent_cred</parameter></paramdef> <paramdef>struct ucred "
"*<parameter>child_cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_cred </function></funcdef><paramdef> struct "
"ucred * <parameter> parent_cred </parameter></paramdef><paramdef> struct ucred * "
"<parameter> child_cred </parameter></paramdef> "

#: book.translate.xml:9795
#, fuzzy
msgid "<parameter>parent_cred</parameter>"
msgstr " <parameter> parent_cred </parameter> "

#: book.translate.xml:9796
#, fuzzy
msgid "Parent subject credential"
msgstr "Parent subject credential"

#: book.translate.xml:9800
#, fuzzy
msgid "<parameter>child_cred</parameter>"
msgstr " <parameter> child_cred </parameter> "

#: book.translate.xml:9801
#, fuzzy
msgid "Child subject credential"
msgstr "Credencial do sujeito da crianÁa"

#: book.translate.xml:9807
#, fuzzy
msgid ""
"Set the label of a newly created subject credential from the passed subject "
"credential. This call will be made when <citerefentry><refentrytitle>crcopy</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> is invoked on a newly created "
"<type>struct ucred</type>. This call should not be confused with a process forking "
"or creation event."
msgstr ""
"Definir o rÛtulo de uma credencial de assunto recÈm-criada a partir da credencial de "
"assunto passada. Essa chamada ser· feita quando <citerefentry><refentrytitle> crcopy "
"</refentrytitle><manvolnum> 9 </manvolnum></citerefentry> È invocado em um recÈm-"
"criado <type> structurred </type> . Esta chamada n„o deve ser confundida com um "
"processo de bifurcaÁ„o ou evento de criaÁ„o. "

#: book.translate.xml:9815
#, fuzzy
msgid "<function>mpo_execve_transition</function>"
msgstr " <function> mpo_execve_transition </function> "

#: book.translate.xml:9818
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_execve_transition</function></funcdef> <paramdef>struct "
"ucred *<parameter>old</parameter></paramdef> <paramdef>struct ucred *<parameter>new</"
"parameter></paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_execve_transition </function></funcdef><paramdef> "
"struct ucred * <parameter> velho </parameter></paramdef><paramdef> struct ucred * "
"<parameter> Novo </parameter></paramdef><paramdef> struct vnode * <parameter> vp </"
"parameter></paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#: book.translate.xml:14335 book.translate.xml:9929 book.translate.xml:9851
#, fuzzy
msgid "<parameter>old</parameter>"
msgstr " <parameter> velho </parameter> "

#: book.translate.xml:9852
#, fuzzy
msgid "Existing subject credential"
msgstr "Credencial de assunto existente"

#: book.translate.xml:14349 book.translate.xml:9857
#, fuzzy
msgid "<parameter>new</parameter>"
msgstr " <parameter> Novo </parameter> "

#: book.translate.xml:9858
#, fuzzy
msgid "New subject credential to be labeled"
msgstr "Nova credencial de sujeito a ser rotulada"

#: book.translate.xml:9937 book.translate.xml:9863
#, fuzzy
msgid "File to execute"
msgstr "Arquivo para executar"

#: book.translate.xml:9876
#, fuzzy
msgid ""
"Update the label of a newly created subject credential (<parameter>new</parameter>) "
"from the passed existing subject credential (<parameter>old</parameter>) based on a "
"label transition caused by executing the passed vnode (<parameter>vp</parameter>). "
"This call occurs when a process executes the passed vnode and one of the policies "
"returns a success from the <function>mpo_execve_will_transition</function> entry "
"point. Policies may choose to implement this call simply by invoking "
"<function>mpo_create_cred</function> and passing the two subject credentials so as "
"not to implement a transitioning event. Policies should not leave this entry point "
"unimplemented if they implement <function>mpo_create_cred</function>, even if they "
"do not implement <function>mpo_execve_will_transition</function>."
msgstr ""
"Atualizar o rÛtulo de uma credencial de assunto recÈm-criada ( <parameter> Novo </"
"parameter> ) da credencial de sujeito j· existente ( <parameter> velho </"
"parameter> ) baseado em uma transiÁ„o de rÛtulo causada pela execuÁ„o do vnode "
"passado ( <parameter> vp </parameter> ). Essa chamada ocorre quando um processo "
"executa o vnode passado e uma das polÌ≠ticas retorna um sucesso do <function> "
"mpo_execve_will_transition </function> ponto de entrada. As polÌ≠ticas podem optar "
"por implementar essa chamada simplesmente invocando <function> mpo_create_cred </"
"function> e passando as duas credenciais de assunto para n„o implementar um evento "
"de transiÁ„o. As polÌ≠ticas n„o devem deixar este ponto de entrada n„o implementado "
"se implementarem <function> mpo_create_cred </function> , mesmo que eles n„o "
"implementem <function> mpo_execve_will_transition </function> "

#: book.translate.xml:9895
#, fuzzy
msgid "<function>mpo_execve_will_transition</function>"
msgstr " <function> mpo_execve_will_transition </function> "

#: book.translate.xml:9898
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_execve_will_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>vp</parameter></paramdef> <paramdef>struct label *<parameter>vnodelabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_execve_will_transition </function></funcdef><paramdef> "
"struct ucred * <parameter> velho </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> "
"vnodelabel </parameter></paramdef> "

#: book.translate.xml:9930
#, fuzzy
msgid ""
"Subject credential prior to <citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Credencial do sujeito antes de <citerefentry><refentrytitle> execve </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:9949
#, fuzzy
msgid ""
"Determine whether the policy will want to perform a transition event as a result of "
"the execution of the passed vnode by the passed subject credential. Return "
"<returnvalue>1</returnvalue> if a transition is required, <returnvalue>0</"
"returnvalue> if not. Even if a policy returns <returnvalue>0</returnvalue>, it "
"should behave correctly in the presence of an unexpected invocation of "
"<function>mpo_execve_transition</function>, as that call may happen as a result of "
"another policy requesting a transition."
msgstr ""
"Determine se a polÌ≠tica desejar· executar um evento de transiÁ„o como resultado da "
"execuÁ„o do vnode transmitido pela credencial de assunto passada. <returnvalue> 1 </"
"returnvalue> se uma transiÁ„o for necess·ria, <returnvalue> 0 </returnvalue> se n„o. "
"Mesmo que uma polÌ≠tica retorne <returnvalue> 0 </returnvalue> , deve comportar-se "
"corretamente na presenÁa de uma invocaÁ„o inesperada de <function> "
"mpo_execve_transition </function> , como essa chamada pode acontecer como resultado "
"de outra polÌ≠tica solicitando uma transiÁ„o \""

#: book.translate.xml:9962
#, fuzzy
msgid "<function>mpo_create_proc0</function>"
msgstr " <function> mpo_create_proc0 </function> "

#: book.translate.xml:9965
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_proc0</function></funcdef> <paramdef>struct ucred "
"*<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_proc0 </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:10035 book.translate.xml:9993
#, fuzzy
msgid "Subject credential to be filled in"
msgstr "Assunto credencial a ser preenchido"

#: book.translate.xml:9999
#, fuzzy
msgid "Create the subject credential of process 0, the parent of all kernel processes."
msgstr ""
"Crie a credencial do assunto do processo 0, o pai de todos os processos do kernel."

#: book.translate.xml:10004
#, fuzzy
msgid "<function>mpo_create_proc1</function>"
msgstr " <function> mpo_create_proc1 </function> "

#: book.translate.xml:10007
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_proc1</function></funcdef> <paramdef>struct ucred "
"*<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_proc1 </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:10041
#, fuzzy
msgid "Create the subject credential of process 1, the parent of all user processes."
msgstr ""
"Crie a credencial do assunto do processo 1, o pai de todos os processos do usu·rio."

#: book.translate.xml:10046
#, fuzzy
msgid "<function>mpo_relabel_cred</function>"
msgstr " <function> mpo_relabel_cred </function> "

#: book.translate.xml:10049
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_cred</function></funcdef> <paramdef>struct ucred "
"*<parameter>cred</parameter></paramdef> <paramdef>struct label *<parameter>newlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_cred </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> label struct * "
"<parameter> newlabel </parameter></paramdef> "

#: book.translate.xml:10084
#, fuzzy
msgid "Label update to apply to <parameter>cred</parameter>"
msgstr "AtualizaÁ„o de etiqueta para aplicar a <parameter> cred </parameter> "

#: book.translate.xml:10091
#, fuzzy
msgid "Update the label on a subject credential from the passed update label."
msgstr ""
"Atualize o rÛtulo de uma credencial de assunto da etiqueta de atualizaÁ„o passada."

#: book.translate.xml:10099
#, fuzzy
msgid "Access Control Checks"
msgstr "VerificaÁÌµes de controle de acesso"

#: book.translate.xml:10101
#, fuzzy
msgid ""
"Access control entry points permit policy modules to influence access control "
"decisions made by the kernel. Generally, although not always, arguments to an access "
"control entry point will include one or more authorizing credentials, information "
"(possibly including a label) for any other objects involved in the operation. An "
"access control entry point may return 0 to permit the operation, or an "
"<citerefentry><refentrytitle>errno</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> error value. The results of invoking the entry point across various "
"registered policy modules will be composed as follows: if all modules permit the "
"operation to succeed, success will be returned. If one or modules returns a failure, "
"a failure will be returned. If more than one module returns a failure, the errno "
"value to return to the user will be selected using the following precedence, "
"implemented by the <function>error_select()</function> function in "
"<filename>kern_mac.c</filename>:"
msgstr ""
"Pontos de entrada de controle de acesso permitem que mÛdulos de polÌ≠tica influenciem "
"decisÌµes de controle de acesso feitas pelo kernel. Geralmente, embora nem sempre, "
"argumentos para um ponto de entrada de controle de acesso incluir„o uma ou mais "
"credenciais de autorizaÁ„o, informaÁÌµes (possivelmente incluindo um rÛtulo) para "
"quaisquer outros objetos O ponto de entrada de controle de acesso pode retornar 0 "
"para permitir a operaÁ„o ou <citerefentry><refentrytitle> errno </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> valor de erro. Os resultados "
"de invocar o ponto de entrada em v·rios mÛdulos de polÌ≠tica registrados ser„o "
"compostos da seguinte maneira: se todos os mÛdulos permitirem que a operaÁ„o seja "
"bem-sucedida, o sucesso ser· retornado. Se um ou os mÛdulos retornarem uma falha, "
"uma falha ser· retornada. Se mais de um mÛdulo retornar uma falha, o valor de errno "
"a ser retornado ao usu·rio ser· selecionado usando a seguinte precedÍncia, "
"implementada pelo <function> error_select () </function> funÁ„o em <filename> "
"kern_mac.c </filename> : "

#: book.translate.xml:10122
#, fuzzy
msgid "Most precedence"
msgstr "Maior precedÍncia"

#: book.translate.xml:10123
#, fuzzy
msgid "<errorcode>EDEADLK</errorcode>"
msgstr " <errorcode> EDEADLK </errorcode> "

#: book.translate.xml:10127
#, fuzzy
msgid "<errorcode>EINVAL</errorcode>"
msgstr " <errorcode> escolhido </errorcode> "

#: book.translate.xml:10131
#, fuzzy
msgid "<errorcode>ESRCH</errorcode>"
msgstr " <errorcode> ESRCH </errorcode> "

#: book.translate.xml:10135
#, fuzzy
msgid "EACCES"
msgstr "EACCES"

#: book.translate.xml:10138
#, fuzzy
msgid "Least precedence"
msgstr "Menos precedÍncia"

#: book.translate.xml:10139
#, fuzzy
msgid "EPERM"
msgstr "EPERM"

#: book.translate.xml:10145
#, fuzzy
msgid ""
"If none of the error values returned by all modules are listed in the precedence "
"chart then an arbitrarily selected value from the set will be returned. In general, "
"the rules provide precedence to errors in the following order: kernel failures, "
"invalid arguments, object not present, access not permitted, other."
msgstr ""
"Se nenhum dos valores de erro retornados por todos os mÛdulos estiverem listados no "
"gr·fico de precedÍncia, um valor selecionado arbitrariamente do conjunto ser· "
"retornado. Em geral, as regras fornecem precedÍncia a erros na seguinte ordem: "
"falhas de kernel, argumentos inv·lidos, objeto n„o presente, acesso n„o permitido, "
"outro \""

#: book.translate.xml:10153
#, fuzzy
msgid "<function>mpo_check_bpfdesc_receive</function>"
msgstr " <function> mpo_check_bpfdesc_receive </function> "

#: book.translate.xml:10156
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_bpfdesc_receive</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> <paramdef>struct "
"label *<parameter>bpflabel</parameter></paramdef> <paramdef>struct ifnet "
"*<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_bpfdesc_receive </function></funcdef><paramdef> "
"struct bpf_d * <parameter> bpf_d </parameter></paramdef><paramdef> label struct * "
"<parameter> bpflabel </parameter></paramdef><paramdef> struct ifnet * <parameter> "
"ifnet </parameter></paramdef><paramdef> label struct * <parameter> ifnetlabel </"
"parameter></paramdef> "

#: book.translate.xml:10190
#, fuzzy
msgid "Subject; BPF descriptor"
msgstr "Assunto; descritor BPF"

#: book.translate.xml:10195
#, fuzzy
msgid "Policy label for <parameter>bpf_d</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> bpf_d </parameter> "

#: book.translate.xml:11323 book.translate.xml:10201
#, fuzzy
msgid "Object; network interface"
msgstr "Objeto; interface de rede"

#: book.translate.xml:10213
#, fuzzy
msgid ""
"Determine whether the MAC framework should permit datagrams from the passed "
"interface to be delivered to the buffers of the passed BPF descriptor. Return "
"(<returnvalue>0</returnvalue>) for success, or an <varname>errno</varname> value for "
"failure Suggested failure: <errorcode>EACCES</errorcode> for label mismatches, "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se o framework MAC deve permitir que os datagramas da interface passada "
"sejam entregues aos buffers do descritor BPF passado. Return ( <returnvalue> 0 </"
"returnvalue> ) para o sucesso, ou um <varname> errno </varname> valor para falha "
"Falha sugerida: <errorcode> EACCES </errorcode> para incompatibilidades de rÛtulo, "
"<errorcode> EPERM </errorcode> por falta de privilÈgio \""

#: book.translate.xml:10223
#, fuzzy
msgid "<function>mpo_check_kenv_dump</function>"
msgstr " <function> mpo_check_kenv_dump </function> "

#: book.translate.xml:10226
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_dump</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_dump </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:10260
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve the kernel environment "
"(see <citerefentry><refentrytitle>kenv</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>)."
msgstr ""
"Determine se o assunto deve ter permiss„o para recuperar o ambiente do kernel (veja "
"<citerefentry><refentrytitle> kenv </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> ) "

#: book.translate.xml:10265
#, fuzzy
msgid "<function>mpo_check_kenv_get</function>"
msgstr " <function> mpo_check_kenv_get </function> "

#: book.translate.xml:10268
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_get</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>char *<parameter>name</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_get </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres * <parameter> "
"nome </parameter></paramdef> "

#: book.translate.xml:14326 book.translate.xml:13322 book.translate.xml:12274
#: book.translate.xml:10398 book.translate.xml:10350 book.translate.xml:10301
#, fuzzy
msgid "<parameter>name</parameter>"
msgstr " <parameter> nome </parameter> "

#: book.translate.xml:10399 book.translate.xml:10351 book.translate.xml:10302
#, fuzzy
msgid "Kernel environment variable name"
msgstr "Nome da vari·vel de ambiente do kernel"

#: book.translate.xml:10308
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve the value of the "
"specified kernel environment variable."
msgstr ""
"Determine se o assunto deve ter permiss„o para recuperar o valor da vari·vel de "
"ambiente do kernel especificada."

#: book.translate.xml:10314
#, fuzzy
msgid "<function>mpo_check_kenv_set</function>"
msgstr " <function> mpo_check_kenv_set </function> "

#: book.translate.xml:10317
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_set</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>char *<parameter>name</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_set </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres * <parameter> "
"nome </parameter></paramdef> "

#: book.translate.xml:10357
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to set the specified kernel "
"environment variable."
msgstr ""
"Determine se o assunto deve ter permiss„o para definir a vari·vel de ambiente do "
"kernel especificada."

#: book.translate.xml:10362
#, fuzzy
msgid "<function>mpo_check_kenv_unset</function>"
msgstr " <function> mpo_check_kenv_unset </function> "

#: book.translate.xml:10365
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_unset</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>char *<parameter>name</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_unset </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres * "
"<parameter> nome </parameter></paramdef> "

#: book.translate.xml:10405
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to unset the specified kernel "
"environment variable."
msgstr ""
"Determine se o assunto deve ter permiss„o para desfazer a vari·vel de ambiente do "
"kernel especificada."

#: book.translate.xml:10410
#, fuzzy
msgid "<function>mpo_check_kld_load</function>"
msgstr " <function> mpo_check_kld_load </function> "

#: book.translate.xml:10413
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_load</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>vlabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_load </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> vlabel </"
"parameter></paramdef> "

#: book.translate.xml:10450
#, fuzzy
msgid "Kernel module vnode"
msgstr "MÛdulo do kernel vnode"

#: book.translate.xml:14271 book.translate.xml:14080 book.translate.xml:10455
#, fuzzy
msgid "Label associated with <parameter>vp</parameter>"
msgstr "Etiqueta associada a <parameter> vp </parameter> "

#: book.translate.xml:10462
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to load the specified module file."
msgstr ""
"Determine se o assunto deve ter permiss„o para carregar o arquivo do mÛdulo "
"especificado."

#: book.translate.xml:10467
#, fuzzy
msgid "<function>mpo_check_kld_stat</function>"
msgstr " <function> mpo_check_kld_stat </function> "

#: book.translate.xml:10470
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_stat</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_stat </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:10504
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve a list of loaded kernel "
"module files and associated statistics."
msgstr ""
"Determine se o assunto deve ter permiss„o para recuperar uma lista de arquivos do "
"mÛdulo do kernel carregados e estatÌ≠sticas associadas."

#: book.translate.xml:10510
#, fuzzy
msgid "<function>mpo_check_kld_unload</function>"
msgstr " <function> mpo_check_kld_unload </function> "

#: book.translate.xml:10513
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_unload</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_unload </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:10547
#, fuzzy
msgid "Determine whether the subject should be allowed to unload a kernel module."
msgstr ""
"Determine se o assunto deve ter permiss„o para descarregar um mÛdulo do kernel."

#: book.translate.xml:10552
#, fuzzy
msgid "<function>mpo_check_pipe_ioctl</function>"
msgstr " <function> mpo_check_pipe_ioctl </function> "

#: book.translate.xml:10555
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_ioctl</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct pipe "
"*<parameter>pipe</parameter></paramdef> <paramdef>struct label "
"*<parameter>pipelabel</parameter></paramdef> <paramdef>unsigned long <parameter>cmd</"
"parameter></paramdef> <paramdef>void *<parameter>data</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_ioctl </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura "
"* <parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef><paramdef> sem assinatura longa <parameter> cmd </"
"parameter></paramdef><paramdef> void * <parameter> dados </parameter></paramdef> "

#: book.translate.xml:10605
#, fuzzy
msgid "<parameter>cmd</parameter>"
msgstr " <parameter> cmd </parameter> "

#: book.translate.xml:10606
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> command"
msgstr ""
" <citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> comando"

#: book.translate.xml:10610
#, fuzzy
msgid "<parameter>data</parameter>"
msgstr " <parameter> dados </parameter> "

#: book.translate.xml:10611
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> data"
msgstr ""
" <citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> dados"

#: book.translate.xml:10617
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> call."
msgstr ""
"Determinar se o assunto deve ter permiss„o para fazer o especificado "
"<citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> ligar."

#: book.translate.xml:10622
#, fuzzy
msgid "<function>mpo_check_pipe_poll</function>"
msgstr " <function> mpo_check_pipe_poll </function> "

#: book.translate.xml:10625
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_poll</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct pipe "
"*<parameter>pipe</parameter></paramdef> <paramdef>struct label "
"*<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_poll </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura * "
"<parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef> "

#: book.translate.xml:10674
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to poll <parameter>pipe</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para pesquisar <parameter> tubo </"
"parameter> "

#: book.translate.xml:10679
#, fuzzy
msgid "<function>mpo_check_pipe_read</function>"
msgstr " <function> mpo_check_pipe_read </function> "

#: book.translate.xml:10682
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_read</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct pipe "
"*<parameter>pipe</parameter></paramdef> <paramdef>struct label "
"*<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_read </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura * "
"<parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef> "

#: book.translate.xml:10731
#, fuzzy
msgid ""
"Determine whether the subject should be allowed read access to <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o de acesso de leitura a <parameter> tubo </"
"parameter> "

#: book.translate.xml:10736
#, fuzzy
msgid "<function>mpo_check_pipe_relabel</function>"
msgstr " <function> mpo_check_pipe_relabel </function> "

#: book.translate.xml:10739
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_relabel</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct pipe "
"*<parameter>pipe</parameter></paramdef> <paramdef>struct label "
"*<parameter>pipelabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_relabel </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura "
"* <parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef><paramdef> label struct * <parameter> newlabel </"
"parameter></paramdef> "

#: book.translate.xml:10789
#, fuzzy
msgid "Label update to <parameter>pipelabel</parameter>"
msgstr "AtualizaÁ„o de etiqueta para <parameter> pipelabel </parameter> "

#: book.translate.xml:10796
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to relabel <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ser autorizado a reclassificar <parameter> tubo </"
"parameter> "

#: book.translate.xml:10801
#, fuzzy
msgid "<function>mpo_check_pipe_stat</function>"
msgstr " <function> mpo_check_pipe_stat </function> "

#: book.translate.xml:10804
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_stat</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct pipe "
"*<parameter>pipe</parameter></paramdef> <paramdef>struct label "
"*<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_stat </function></funcdef><paramdef> struct "
"ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura * "
"<parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef> "

#: book.translate.xml:10853
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve statistics related to "
"<parameter>pipe</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para recuperar estatÌ≠sticas relacionadas a "
"<parameter> tubo </parameter> "

#: book.translate.xml:10859
#, fuzzy
msgid "<function>mpo_check_pipe_write</function>"
msgstr " <function> mpo_check_pipe_write </function> "

#: book.translate.xml:10862
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_write</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct pipe "
"*<parameter>pipe</parameter></paramdef> <paramdef>struct label "
"*<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_write </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de estrutura "
"* <parameter> tubo </parameter></paramdef><paramdef> label struct * <parameter> "
"pipelabel </parameter></paramdef> "

#: book.translate.xml:10911
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to write to <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para escrever <parameter> tubo </"
"parameter> "

#: book.translate.xml:10916
#, fuzzy
msgid "<function>mpo_check_socket_bind</function>"
msgstr " <function> mpo_check_socket_bind </function> "

#: book.translate.xml:10919
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_bind</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct socket "
"*<parameter>socket</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef> <paramdef>struct sockaddr "
"*<parameter>sockaddr</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_bind </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> soquete </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef><paramdef> struct sockaddr * "
"<parameter> sockaddr </parameter></paramdef> "

#: book.translate.xml:10958
#, fuzzy
msgid "Socket to be bound"
msgstr "Soquete a ser ligado"

#: book.translate.xml:11032 book.translate.xml:10968
#, fuzzy
msgid "<parameter>sockaddr</parameter>"
msgstr " <parameter> sockaddr </parameter> "

#: book.translate.xml:11033 book.translate.xml:10969
#, fuzzy
msgid "Address of <parameter>socket</parameter>"
msgstr "EndereÁo de <parameter> soquete </parameter> "

#: book.translate.xml:10980
#, fuzzy
msgid "<function>mpo_check_socket_connect</function>"
msgstr " <function> mpo_check_socket_connect </function> "

#: book.translate.xml:10983
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_connect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"socket *<parameter>socket</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef> <paramdef>struct sockaddr "
"*<parameter>sockaddr</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_connect </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> soquete </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef><paramdef> struct sockaddr * "
"<parameter> sockaddr </parameter></paramdef> "

#: book.translate.xml:11022
#, fuzzy
msgid "Socket to be connected"
msgstr "Soquete para ser conectado"

#: book.translate.xml:11040
#, fuzzy
msgid ""
"Determine whether the subject credential (<parameter>cred</parameter>) can connect "
"the passed socket (<parameter>socket</parameter>) to the passed socket address "
"(<parameter>sockaddr</parameter>). Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</errorcode> for "
"lack of privilege."
msgstr ""
"Determine se a credencial do sujeito ( <parameter> cred </parameter> ) pode conectar "
"o soquete passado ( <parameter> soquete </parameter> ) para o endereÁo de socket "
"passado ( <parameter> sockaddr </parameter> ). Retorna <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para falha. "
"Falha sugerida: <errorcode> EACCES </errorcode> para incompatibilidades de rÛtulo, "
"<errorcode> EPERM </errorcode> por falta de privilÈgio \""

#: book.translate.xml:11051
#, fuzzy
msgid "<function>mpo_check_socket_receive</function>"
msgstr " <function> mpo_check_socket_receive </function> "

#: book.translate.xml:11054
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_receive</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"socket *<parameter>so</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_receive </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> assim </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef> "

#: book.translate.xml:11154 book.translate.xml:11096
#, fuzzy
msgid "Policy label associated with <parameter>so</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> assim </parameter> "

#: book.translate.xml:11103
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to receive information from the "
"socket <parameter>so</parameter>."
msgstr ""
"Determinar se o assunto deve receber permiss„o de receber informaÁÌµes do soquete "
"<parameter> assim </parameter> "

#: book.translate.xml:11109
#, fuzzy
msgid "<function>mpo_check_socket_send</function>"
msgstr " <function> mpo_check_socket_send </function> "

#: book.translate.xml:11112
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_send</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct socket "
"*<parameter>so</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_send </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> assim </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef> "

#: book.translate.xml:11161
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to send information across the "
"socket <parameter>so</parameter>."
msgstr ""
"Determinar se o assunto deve ter permiss„o para enviar informaÁÌµes atravÈs do "
"soquete <parameter> assim </parameter> "

#: book.translate.xml:11167
#, fuzzy
msgid "<function>mpo_check_cred_visible</function>"
msgstr " <function> mpo_check_cred_visible </function> "

#: book.translate.xml:11170
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_cred_visible</function></funcdef> <paramdef>struct "
"ucred *<parameter>u1</parameter></paramdef> <paramdef>struct ucred *<parameter>u2</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_cred_visible </function></funcdef><paramdef> "
"struct ucred * <parameter> u1 </parameter></paramdef><paramdef> struct ucred * "
"<parameter> u2 </parameter></paramdef> "

#: book.translate.xml:11199
#, fuzzy
msgid "<parameter>u1</parameter>"
msgstr " <parameter> u1 </parameter> "

#: book.translate.xml:11204
#, fuzzy
msgid "<parameter>u2</parameter>"
msgstr " <parameter> u2 </parameter> "

#: book.translate.xml:11205
#, fuzzy
msgid "Object credential"
msgstr "Credencial do objeto"

#: book.translate.xml:11211
#, fuzzy
msgid ""
"Determine whether the subject credential <parameter>u1</parameter> can <quote>see</"
"quote> other subjects with the passed subject credential <parameter>u2</parameter>. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for label "
"mismatches, <errorcode>EPERM</errorcode> for lack of privilege, or <errorcode>ESRCH</"
"errorcode> to hide visibility. This call may be made in a number of situations, "
"including inter-process status sysctl's used by <command>ps</command>, and in procfs "
"lookups."
msgstr ""
"Determinar se a credencial do sujeito <parameter> u1 </parameter> posso <quote> Vejo "
"</quote> outros assuntos com a credencial do sujeito passado <parameter> u2 </"
"parameter> . Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidades de rÛtulo, <errorcode> EPERM </errorcode> por falta de "
"privilÈgio, ou <errorcode> ESRCH </errorcode> para esconder a visibilidade. Essa "
"chamada pode ser feita em v·rias situaÁÌµes, incluindo sysctl de status entre "
"processos usado por <command> ps </command> e em pesquisas procfs \""

#: book.translate.xml:13970 book.translate.xml:11226
#, fuzzy
msgid "<function>mpo_check_socket_visible</function>"
msgstr " <function> mpo_check_socket_visible </function> "

#: book.translate.xml:11229
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"socket *<parameter>socket</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_visible </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> soquete </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef> "

#: book.translate.xml:11281
#, fuzzy
msgid "<function>mpo_check_ifnet_relabel</function>"
msgstr " <function> mpo_check_ifnet_relabel </function> "

#: book.translate.xml:11284
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_ifnet_relabel</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct ifnet "
"*<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_ifnet_relabel </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct ifnet * "
"<parameter> ifnet </parameter></paramdef><paramdef> label struct * <parameter> "
"ifnetlabel </parameter></paramdef><paramdef> label struct * <parameter> newlabel </"
"parameter></paramdef> "

#: book.translate.xml:11328
#, fuzzy
msgid "Existing policy label for <parameter>ifnet</parameter>"
msgstr "Etiqueta de polÌ≠tica existente para <parameter> ifnet </parameter> "

#: book.translate.xml:11334
#, fuzzy
msgid "Policy label update to later be applied to <parameter>ifnet</parameter>"
msgstr ""
"AtualizaÁ„o de rÛtulo de polÌ≠tica para depois ser aplicada a <parameter> ifnet </"
"parameter> "

#: book.translate.xml:11341
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed network interface to "
"the passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar a interface de rede passada "
"para a atualizaÁ„o de rÛtulo passada."

#: book.translate.xml:11346
#, fuzzy
msgid "<function>mpo_check_socket_relabel</function>"
msgstr " <function> mpo_check_socket_relabel </function> "

#: book.translate.xml:11349
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"socket *<parameter>socket</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef> <paramdef>struct label "
"*<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_relabel </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> soquete </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef><paramdef> label struct * <parameter> "
"newlabel </parameter></paramdef> "

#: book.translate.xml:11393
#, fuzzy
msgid "Existing policy label for <parameter>socket</parameter>"
msgstr "Etiqueta de polÌ≠tica existente para <parameter> soquete </parameter> "

#: book.translate.xml:11399
#, fuzzy
msgid "Label update to later be applied to <parameter>socketlabel</parameter>"
msgstr ""
"AtualizaÁ„o de etiqueta para depois ser aplicada a <parameter> socketlabel </"
"parameter> "

#: book.translate.xml:11406
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed socket to the passed "
"label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar o soquete transmitido para a "
"atualizaÁ„o de rÛtulo transmitida."

#: book.translate.xml:11411
#, fuzzy
msgid "<function>mpo_check_cred_relabel</function>"
msgstr " <function> mpo_check_cred_relabel </function> "

#: book.translate.xml:11414
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_cred_relabel</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct label "
"*<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_cred_relabel </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> label struct * "
"<parameter> newlabel </parameter></paramdef> "

#: book.translate.xml:11449
#, fuzzy
msgid "Label update to later be applied to <parameter>cred</parameter>"
msgstr ""
"AtualizaÁ„o de etiqueta para depois ser aplicada a <parameter> cred </parameter> "

#: book.translate.xml:11456
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel itself to the passed label "
"update."
msgstr ""
"Determine se a credencial do assunto pode se renomear para a atualizaÁ„o de rÛtulo "
"passada."

#: book.translate.xml:11462
#, fuzzy
msgid "<function>mpo_check_vnode_relabel</function>"
msgstr " <function> mpo_check_vnode_relabel </function> "

#: book.translate.xml:11465
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_relabel</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>vnodelabel</parameter></"
"paramdef> <paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_relabel </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> "
"vnodelabel </parameter></paramdef><paramdef> label struct * <parameter> newlabel </"
"parameter></paramdef> "

#: book.translate.xml:13793 book.translate.xml:13529 book.translate.xml:13461
#: book.translate.xml:13393 book.translate.xml:13308 book.translate.xml:13230
#: book.translate.xml:13164 book.translate.xml:13098 book.translate.xml:12970
#: book.translate.xml:12901 book.translate.xml:12259 book.translate.xml:12186
#: book.translate.xml:12053 book.translate.xml:11887 book.translate.xml:11693
#: book.translate.xml:11505
#, fuzzy
msgid "Object; vnode"
msgstr "Objeto; vnode"

#: book.translate.xml:11517
#, fuzzy
msgid "Policy label update to later be applied to <parameter>vp</parameter>"
msgstr ""
"AtualizaÁ„o de rÛtulo de polÌ≠tica para depois ser aplicada a <parameter> vp </"
"parameter> "

#: book.translate.xml:11524
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed vnode to the passed "
"label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar o vnode transmitido para a "
"atualizaÁ„o de rÛtulo transmitida."

#: book.translate.xml:11529
#, fuzzy
msgid "<function>mpo_check_mount_stat</function>"
msgstr " <function> mpo_check_mount_stat </function> "

#: book.translate.xml:11532
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_mount_stat</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct mount *<parameter>mp</"
"parameter></paramdef> <paramdef>struct label *<parameter>mountlabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_mount_stat </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> montagem struct * "
"<parameter> mp </parameter></paramdef><paramdef> label struct * <parameter> "
"mountlabel </parameter></paramdef> "

#: book.translate.xml:11568
#, fuzzy
msgid "Object; file system mount"
msgstr "Objeto; montagem do sistema de arquivos"

#: book.translate.xml:11572
#, fuzzy
msgid "<parameter>mountlabel</parameter>"
msgstr " <parameter> mountlabel </parameter> "

#: book.translate.xml:11573
#, fuzzy
msgid "Policy label for <parameter>mp</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> mp </parameter> "

#: book.translate.xml:11581
#, fuzzy
msgid ""
"Determine whether the subject credential can see the results of a statfs performed "
"on the file system. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatches or <errorcode>EPERM</errorcode> for lack of "
"privilege. This call may be made in a number of situations, including during "
"invocations of <citerefentry><refentrytitle>statfs</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> and related calls, as well as to determine what file "
"systems to exclude from listings of file systems, such as when "
"<citerefentry><refentrytitle>getfsstat</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> is invoked."
msgstr ""
"Determine se a credencial do assunto pode ver os resultados de um statfs executado "
"no sistema de arquivos. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidades de rÛtulo ou <errorcode> EPERM </errorcode> por "
"falta de privilÈgio. Essa chamada pode ser feita em v·rias situaÁÌµes, inclusive "
"durante invocaÁÌµes de <citerefentry><refentrytitle> statfs </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e chamadas relacionadas, bem "
"como para determinar quais sistemas de arquivos devem ser excluÌ≠dos das listagens de "
"sistemas de arquivos, como quando <citerefentry><refentrytitle> getfsstat </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> È invocado. "

#: book.translate.xml:11594
#, fuzzy
msgid "<function>mpo_check_proc_debug</function>"
msgstr " <function> mpo_check_proc_debug </function> "

#: book.translate.xml:11597
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_debug</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct proc "
"*<parameter>proc</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_debug </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct proc * "
"<parameter> proc </parameter></paramdef> "

#: book.translate.xml:13731 book.translate.xml:13674 book.translate.xml:11632
#, fuzzy
msgid "<parameter>proc</parameter>"
msgstr " <parameter> por cento </parameter> "

#: book.translate.xml:13732 book.translate.xml:13675 book.translate.xml:11633
#, fuzzy
msgid "Object; process"
msgstr "Objeto; processo"

#: book.translate.xml:11639
#, fuzzy
msgid ""
"Determine whether the subject credential can debug the passed process. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> value for "
"failure. Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, "
"<errorcode>EPERM</errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> "
"to hide visibility of the target. This call may be made in a number of situations, "
"including use of the <citerefentry><refentrytitle>ptrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>ktrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> APIs, as well as for some types of procfs operations."
msgstr ""
"Determine se a credencial do assunto pode depurar o processo passado. Retornar "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, <errorcode> EPERM </errorcode> por falta de "
"privilÈgio, ou <errorcode> ESRCH </errorcode> para ocultar a visibilidade do alvo. "
"Esta chamada pode ser feita em v·rias situaÁÌµes, incluindo o uso do "
"<citerefentry><refentrytitle> ptrace </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> e <citerefentry><refentrytitle> ktrace </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> APIs, bem como para alguns tipos de operaÁÌµes procfs \""

#: book.translate.xml:11652
#, fuzzy
msgid "<function>mpo_check_vnode_access</function>"
msgstr " <function> mpo_check_vnode_access </function> "

#: book.translate.xml:11655
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_access</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>int <parameter>flags</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_access </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> int <parameter> bandeiras </parameter></paramdef> "

#: book.translate.xml:13403 book.translate.xml:11703
#, fuzzy
msgid "<parameter>flags</parameter>"
msgstr " <parameter> bandeiras </parameter> "

#: book.translate.xml:11704
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>access</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> flags"
msgstr ""
" <citerefentry><refentrytitle> Acesso </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> bandeiras"

#: book.translate.xml:11710
#, fuzzy
msgid ""
"Determine how invocations of <citerefentry><refentrytitle>access</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and related calls by the "
"subject credential should return when performed on the passed vnode using the passed "
"access flags. This should generally be implemented using the same semantics used in "
"<function>mpo_check_vnode_open</function>. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches or <errorcode>EPERM</errorcode> "
"for lack of privilege."
msgstr ""
"Determinar como invocaÁÌµes de <citerefentry><refentrytitle> Acesso </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e chamadas relacionadas pela "
"credencial de assunto devem retornar quando executadas no vnode passado usando os "
"sinalizadores de acesso passado. Isso geralmente deve ser implementado usando a "
"mesma semÌ¢ntica usada <function> mpo_check_vnode_open </function> . Retorna "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidades de rÛtulo ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:11723
#, fuzzy
msgid "<function>mpo_check_vnode_chdir</function>"
msgstr " <function> mpo_check_vnode_chdir </function> "

#: book.translate.xml:11726
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_chdir</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>dvp</parameter></paramdef> <paramdef>struct label *<parameter>dlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_chdir </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef> "

#: book.translate.xml:11763
#, fuzzy
msgid ""
"Object; vnode to <citerefentry><refentrytitle>chdir</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> into"
msgstr ""
"Objeto; vnode para <citerefentry><refentrytitle> chdir </refentrytitle><manvolnum> 2 "
"</manvolnum></citerefentry> para dentro"

#: book.translate.xml:13041 book.translate.xml:12906 book.translate.xml:11974
#: book.translate.xml:11892 book.translate.xml:11768
#, fuzzy
msgid "Policy label for <parameter>dvp</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> dvp </parameter> "

#: book.translate.xml:11775
#, fuzzy
msgid ""
"Determine whether the subject credential can change the process working directory to "
"the passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode alterar o diretÛrio de trabalho do "
"processo para o vnode passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privilÈgio \""

#: book.translate.xml:11785
#, fuzzy
msgid "<function>mpo_check_vnode_chroot</function>"
msgstr " <function> mpo_check_vnode_chroot </function> "

#: book.translate.xml:11788
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_chroot</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>dvp</parameter></paramdef> <paramdef>struct label *<parameter>dlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_chroot </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef> "

#: book.translate.xml:12755 book.translate.xml:12673 book.translate.xml:12345
#: book.translate.xml:11825
#, fuzzy
msgid "Directory vnode"
msgstr "DiretÛrio vnode"

#: book.translate.xml:12760 book.translate.xml:12678 book.translate.xml:12350
#: book.translate.xml:11830
#, fuzzy
msgid "Policy label associated with <parameter>dvp</parameter>"
msgstr "Etiqueta de polÌ≠tica associada a <parameter> dvp </parameter> "

#: book.translate.xml:11837
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to "
"<citerefentry><refentrytitle>chroot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> into the specified directory (<parameter>dvp</parameter>)."
msgstr ""
"Determinar se o assunto deve ser permitido <citerefentry><refentrytitle> chroot </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> no diretÛrio especificado "
"( <parameter> dvp </parameter> ) "

#: book.translate.xml:11843
#, fuzzy
msgid "<function>mpo_check_vnode_create</function>"
msgstr " <function> mpo_check_vnode_create </function> "

#: book.translate.xml:11846
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_create</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>dvp</parameter></paramdef> <paramdef>struct label *<parameter>dlabel</"
"parameter></paramdef> <paramdef>struct componentname *<parameter>cnp</parameter></"
"paramdef> <paramdef>struct vattr *<parameter>vap</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_create </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef><paramdef> struct componentname * <parameter> cnp </"
"parameter></paramdef><paramdef> struct vattr * <parameter> vap </parameter></"
"paramdef> "

#: book.translate.xml:11898
#, fuzzy
msgid "Component name for <parameter>dvp</parameter>"
msgstr "Nome do componente para <parameter> dvp </parameter> "

#: book.translate.xml:11903
#, fuzzy
msgid "<parameter>vap</parameter>"
msgstr " <parameter> vap </parameter> "

#: book.translate.xml:11904
#, fuzzy
msgid "vnode attributes for <parameter>vap</parameter>"
msgstr "atributos vnode para <parameter> vap </parameter> "

#: book.translate.xml:11910
#, fuzzy
msgid ""
"Determine whether the subject credential can create a vnode with the passed parent "
"directory, passed name information, and passed attribute information. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> value for "
"failure. Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in a "
"number of situations, including as a result of calls to "
"<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> with <symbol>O_CREAT</symbol>, <citerefentry><refentrytitle>mkfifo</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, and others."
msgstr ""
"Determine se a credencial de assunto pode criar um vnode com o diretÛrio pai "
"passado, informaÁÌµes de nome passadas e informaÁÌµes de atributo transmitidas. "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio. Esta chamada pode ser feita em v·rias situaÁÌµes, inclusive como "
"resultado de chamadas para <citerefentry><refentrytitle> aberto </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> com <symbol> O_CREAT </"
"symbol> , <citerefentry><refentrytitle> mkfifo </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , e outros."

#: book.translate.xml:11924
#, fuzzy
msgid "<function>mpo_check_vnode_delete</function>"
msgstr " <function> mpo_check_vnode_delete </function> "

#: book.translate.xml:11927
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_delete</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>dvp</parameter></paramdef> <paramdef>struct label *<parameter>dlabel</"
"parameter></paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>void *<parameter>label</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_delete </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> void * <parameter> rÛtulo </parameter></paramdef><paramdef> "
"struct componentname * <parameter> cnp </parameter></paramdef> "

#: book.translate.xml:11980
#, fuzzy
msgid "Object; vnode to delete"
msgstr "Objeto; vnode para excluir"

#: book.translate.xml:11998
#, fuzzy
msgid ""
"Determine whether the subject credential can delete a vnode from the passed parent "
"directory and passed name information. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</errorcode> "
"for lack of privilege. This call may be made in a number of situations, including as "
"a result of calls to <citerefentry><refentrytitle>unlink</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>rmdir</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>. Policies implementing this entry point should also implement "
"<function>mpo_check_rename_to</function> to authorize deletion of objects as a "
"result of being the target of a rename."
msgstr ""
"Determine se a credencial do assunto pode excluir um vnode do diretÛrio pai passado "
"e passou as informaÁÌµes de nome. <returnvalue> 0 </returnvalue> para o sucesso, ou "
"um <varname> errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privilÈgio. Esta chamada pode ser feita em v·rias situaÁÌµes, inclusive "
"como resultado de chamadas para <citerefentry><refentrytitle> desvincular </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> rmdir </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> . PolÌ≠ticas que implementam este ponto de entrada tambÈm devem "
"implementar <function> mpo_check_rename_to </function> para autorizar a exclus„o de "
"objetos como resultado de ser o alvo de uma renomeaÁ„o. "

#: book.translate.xml:12014
#, fuzzy
msgid "<function>mpo_check_vnode_deleteacl</function>"
msgstr " <function> mpo_check_vnode_deleteacl </function> "

#: book.translate.xml:12017
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_deleteacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>acl_type_t <parameter>type</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_deleteacl </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> acl_type_t <parameter> tipo </parameter></paramdef> "

#: book.translate.xml:13240 book.translate.xml:12196 book.translate.xml:12064
#, fuzzy
msgid "<parameter>type</parameter>"
msgstr " <parameter> tipo </parameter> "

#: book.translate.xml:13241 book.translate.xml:12197 book.translate.xml:12065
#, fuzzy
msgid "ACL type"
msgstr "Tipo de ACL"

#: book.translate.xml:12071
#, fuzzy
msgid ""
"Determine whether the subject credential can delete the ACL of passed type from the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode excluir a ACL do tipo passado do vnode "
"passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:12081
#, fuzzy
msgid "<function>mpo_check_vnode_exec</function>"
msgstr " <function> mpo_check_vnode_exec </function> "

#: book.translate.xml:12084
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_exec</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_exec </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef> "

#: book.translate.xml:12121
#, fuzzy
msgid "Object; vnode to execute"
msgstr "Objeto; vnode para executar"

#: book.translate.xml:12133
#, fuzzy
msgid ""
"Determine whether the subject credential can execute the passed vnode. Determination "
"of execute privilege is made separately from decisions about any transitioning "
"event. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar o vnode passado. A determinaÁ„o "
"do privilÈgio de execuÁ„o È feita separadamente das decisÌµes sobre qualquer evento "
"de transiÁ„o. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:12144
#, fuzzy
msgid "<function>mpo_check_vnode_getacl</function>"
msgstr " <function> mpo_check_vnode_getacl </function> "

#: book.translate.xml:12147
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_getacl</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_getacl </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> acl_type_t <parameter> tipo </parameter></paramdef> "

#: book.translate.xml:12203
#, fuzzy
msgid ""
"Determine whether the subject credential can retrieve the ACL of passed type from "
"the passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode recuperar a ACL do tipo passado do vnode "
"passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:12213
#, fuzzy
msgid "<function>mpo_check_vnode_getextattr</function>"
msgstr " <function> mpo_check_vnode_getextattr </function> "

#: book.translate.xml:12216
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_getextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>int <parameter>attrnamespace</"
"parameter></paramdef> <paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_getextattr </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> int <parameter> attrnamespace </parameter></"
"paramdef><paramdef> const char * <parameter> nome </parameter></paramdef><paramdef> "
"struct uio * <parameter> uio </parameter></paramdef> "

#: book.translate.xml:13317 book.translate.xml:12269
#, fuzzy
msgid "<parameter>attrnamespace</parameter>"
msgstr " <parameter> attrnamespace </parameter> "

#: book.translate.xml:13318 book.translate.xml:12270
#, fuzzy
msgid "Extended attribute namespace"
msgstr "Namespace de atributo estendido"

#: book.translate.xml:13323 book.translate.xml:12275
#, fuzzy
msgid "Extended attribute name"
msgstr "Nome do atributo estendido"

#: book.translate.xml:13327 book.translate.xml:12279
#, fuzzy
msgid "<parameter>uio</parameter>"
msgstr " <parameter> uio </parameter> "

#: book.translate.xml:13328 book.translate.xml:12280
#, fuzzy
msgid ""
"I/O structure pointer; see <citerefentry><refentrytitle>uio</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"Ponteiro de estrutura de E / S; consulte <citerefentry><refentrytitle> uio </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#: book.translate.xml:12286
#, fuzzy
msgid ""
"Determine whether the subject credential can retrieve the extended attribute with "
"the passed namespace and name from the passed vnode. Policies implementing labeling "
"using extended attributes may be interested in special handling of operations on "
"those extended attributes. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode recuperar o atributo estendido com o "
"namespace passado e o nome do vnode transmitido. As polÌ≠ticas que implementam a "
"rotulagem usando atributos estendidos podem estar interessadas no tratamento "
"especial de operaÁÌµes nesses atributos estendidos. Voltar para o inÌ≠cio "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:12299
#, fuzzy
msgid "<function>mpo_check_vnode_link</function>"
msgstr " <function> mpo_check_vnode_link </function> "

#: book.translate.xml:12302
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_link</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>dvp</parameter></paramdef> <paramdef>struct label *<parameter>dlabel</"
"parameter></paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_link </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></paramdef> "

#: book.translate.xml:12356
#, fuzzy
msgid "Link destination vnode"
msgstr "Link destino vnode"

#: book.translate.xml:12367
#, fuzzy
msgid "Component name for the link being created"
msgstr "Nome do componente para o link que est· sendo criado"

#: book.translate.xml:12373
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to create a link to the vnode "
"<parameter>vp</parameter> with the name specified by <parameter>cnp</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para criar um link para o vnode "
"<parameter> vp </parameter> com o nome especificado por <parameter> cnp </parameter> "

#: book.translate.xml:12379
#, fuzzy
msgid "<function>mpo_check_vnode_mmap</function>"
msgstr " <function> mpo_check_vnode_mmap </function> "

#: book.translate.xml:12382
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_mmap</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_mmap </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> int <parameter> prot </parameter></paramdef> "

#: book.translate.xml:12420
#, fuzzy
msgid "Vnode to map"
msgstr "Vnode para mapear"

#: book.translate.xml:12549 book.translate.xml:12492 book.translate.xml:12430
#, fuzzy
msgid "<parameter>prot</parameter>"
msgstr " <parameter> prot </parameter> "

#: book.translate.xml:12431
#, fuzzy
msgid ""
"Mmap protections (see <citerefentry><refentrytitle>mmap</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>)"
msgstr ""
"ProteÁÌµes Mmap (veja <citerefentry><refentrytitle> mmap </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> ) "

#: book.translate.xml:12437
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to map the vnode <parameter>vp</"
"parameter> with the protections specified in <parameter>prot</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para mapear o vnode <parameter> vp </"
"parameter> com as proteÁÌµes especificadas em <parameter> prot </parameter> "

#: book.translate.xml:12443
#, fuzzy
msgid "<function>mpo_check_vnode_mmap_downgrade</function>"
msgstr " <function> mpo_check_vnode_mmap_downgrade </function> "

#: book.translate.xml:12446
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_check_vnode_mmap_downgrade</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>int *<parameter>prot</parameter></"
"paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_check_vnode_mmap_downgrade </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef><paramdef> "
"struct vnode * <parameter> vp </parameter></paramdef><paramdef> label struct * "
"<parameter> rÛtulo </parameter></paramdef><paramdef> int * <parameter> prot </"
"parameter></paramdef> "

#: book.translate.xml:12479
#, fuzzy
msgid "See <xref linkend=\"mac-mpo-check-vnode-mmap\"/>."
msgstr "Vejo <xref linkend=\"mac-mpo-check-vnode-mmap\"/> "

#: book.translate.xml:12493
#, fuzzy
msgid "Mmap protections to be downgraded"
msgstr "ProteÁÌµes Mmap a serem desatualizadas"

#: book.translate.xml:12499
#, fuzzy
msgid "Downgrade the mmap protections based on the subject and object labels."
msgstr "FaÁa o downgrade das proteÁÌµes mmap com base nos rÛtulos de assunto e objeto."

#: book.translate.xml:12504
#, fuzzy
msgid "<function>mpo_check_vnode_mprotect</function>"
msgstr " <function> mpo_check_vnode_mprotect </function> "

#: book.translate.xml:12507
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_mprotect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>int <parameter>prot</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_mprotect </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> int <parameter> prot </parameter></paramdef> "

#: book.translate.xml:12545
#, fuzzy
msgid "Mapped vnode"
msgstr "Vnode mapeado"

#: book.translate.xml:12550
#, fuzzy
msgid "Memory protections"
msgstr "ProteÁÌµes de memÛria"

#: book.translate.xml:12556
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to set the specified memory "
"protections on memory mapped from the vnode <parameter>vp</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para definir as proteÁÌµes de memÛria "
"especificadas na memÛria mapeada a partir do vnode <parameter> vp </parameter> "

#: book.translate.xml:12562
#, fuzzy
msgid "<function>mpo_check_vnode_poll</function>"
msgstr " <function> mpo_check_vnode_poll </function> "

#: book.translate.xml:12565
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_poll</function></funcdef> <paramdef>struct "
"ucred *<parameter>active_cred</parameter></paramdef> <paramdef>struct ucred "
"*<parameter>file_cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_poll </function></funcdef><paramdef> "
"struct ucred * <parameter> active_cred </parameter></paramdef><paramdef> struct "
"ucred * <parameter> file_cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef> "

#: book.translate.xml:12598
#, fuzzy
msgid "<parameter>active_cred</parameter>"
msgstr " <parameter> active_cred </parameter> "

#: book.translate.xml:12603
#, fuzzy
msgid "<parameter>file_cred</parameter>"
msgstr " <parameter> file_cred </parameter> "

#: book.translate.xml:12604
#, fuzzy
msgid "Credential associated with the <type>struct file</type>"
msgstr "Credencial associado ao <type> arquivo struct </type> "

#: book.translate.xml:12610
#, fuzzy
msgid "Polled vnode"
msgstr "Polled vnode"

#: book.translate.xml:12622
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to poll the vnode <parameter>vp</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss„o para pesquisar o vnode <parameter> vp </"
"parameter> "

#: book.translate.xml:12627
#, fuzzy
msgid "<function>mpo_check_vnode_rename_from</function>"
msgstr " <function> mpo_check_vnode_rename_from </function> "

#: book.translate.xml:12630
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_vnode_rename_from</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>dvp</parameter></paramdef> <paramdef>struct label *<parameter>dlabel</"
"parameter></paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_vnode_rename_from </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></paramdef> "

#: book.translate.xml:12684
#, fuzzy
msgid "Vnode to be renamed"
msgstr "Vnode a ser renomeado"

#: book.translate.xml:12702
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to rename the vnode <parameter>vp</"
"parameter> to something else."
msgstr ""
"Determinar se o assunto deve ter permiss„o para renomear o vnode <parameter> vp </"
"parameter> para outra coisa \""

#: book.translate.xml:12708
#, fuzzy
msgid "<function>mpo_check_vnode_rename_to</function>"
msgstr " <function> mpo_check_vnode_rename_to </function> "

#: book.translate.xml:12711
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_rename_to</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>dvp</parameter></paramdef> <paramdef>struct label "
"*<parameter>dlabel</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>int <parameter>samedir</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_rename_to </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> dvp </parameter></paramdef><paramdef> label struct * <parameter> dlabel "
"</parameter></paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> rÛtulo </parameter></"
"paramdef><paramdef> int <parameter> samedir </parameter></paramdef><paramdef> struct "
"componentname * <parameter> cnp </parameter></paramdef> "

#: book.translate.xml:12766
#, fuzzy
msgid "Overwritten vnode"
msgstr "Vnode sobrescrito"

#: book.translate.xml:12776
#, fuzzy
msgid "<parameter>samedir</parameter>"
msgstr " <parameter> samedir </parameter> "

#: book.translate.xml:12777
#, fuzzy
msgid ""
"Boolean; <literal>1</literal> if the source and destination directories are the same"
msgstr ""
"Boleano; <literal> 1 </literal> se os diretÛrios de origem e destino forem os mesmos "

#: book.translate.xml:12783
#, fuzzy
msgid "Destination component name"
msgstr "Nome do componente de destino"

#: book.translate.xml:12789
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to rename to the vnode "
"<parameter>vp</parameter>, into the directory <parameter>dvp</parameter>, or to the "
"name represented by <parameter>cnp</parameter>. If there is no existing file to "
"overwrite, <parameter>vp</parameter> and <parameter>label</parameter> will be NULL."
msgstr ""
"Determinar se o assunto deve ter permiss„o para renomear para o vnode <parameter> vp "
"</parameter> , no diretÛrio <parameter> dvp </parameter> , ou para o nome "
"representado por <parameter> cnp </parameter> . Se n„o houver nenhum arquivo "
"existente para substituir, <parameter> vp </parameter> e <parameter> rÛtulo </"
"parameter> ser· NULL. "

#: book.translate.xml:12798
#, fuzzy
msgid "<function>mpo_check_socket_listen</function>"
msgstr " <function> mpo_check_socket_listen </function> "

#: book.translate.xml:12801
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_listen</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct socket "
"*<parameter>socket</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_listen </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> soquete </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef> "

#: book.translate.xml:12850
#, fuzzy
msgid ""
"Determine whether the subject credential can listen on the passed socket. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> value for "
"failure. Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode escutar no soquete passado. Retornar "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:12859
#, fuzzy
msgid "<function>mpo_check_vnode_lookup</function>"
msgstr " <function> mpo_check_vnode_lookup </function> "

#: book.translate.xml:12862
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_lookup</function></funcdef> <paramdef>struct "
"ucred *<parameter/>cred</paramdef> <paramdef>struct vnode *<parameter/>dvp</"
"paramdef> <paramdef>struct label *<parameter/>dlabel</paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_lookup </function></funcdef><paramdef> "
"struct ucred * <parameter/> cred </paramdef><paramdef> struct vnode * <parameter/> "
"dvp </paramdef><paramdef> label struct * <parameter/> dlabel </paramdef><paramdef> "
"struct componentname * <parameter> cnp </parameter></paramdef> "

#: book.translate.xml:12912
#, fuzzy
msgid "Component name being looked up"
msgstr "Nome do componente sendo pesquisado"

#: book.translate.xml:12918
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a lookup in the passed "
"directory vnode for the passed name. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</errorcode> "
"for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma pesquisa no diretÛrio passado "
"vnode para o nome passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privilÈgio \""

#: book.translate.xml:12928
#, fuzzy
msgid "<function>mpo_check_vnode_open</function>"
msgstr " <function> mpo_check_vnode_open </function> "

#: book.translate.xml:12931
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_open</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>int <parameter>acc_mode</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_open </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> int <parameter> acc_mode </parameter></paramdef> "

#: book.translate.xml:12980
#, fuzzy
msgid "<parameter>acc_mode</parameter>"
msgstr " <parameter> acc_mode </parameter> "

#: book.translate.xml:12981
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> access mode"
msgstr ""
" <citerefentry><refentrytitle> aberto </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> modo de acesso"

#: book.translate.xml:12987
#, fuzzy
msgid ""
"Determine whether the subject credential can perform an open operation on the passed "
"vnode with the passed access mode. Return <returnvalue>0</returnvalue> for success, "
"or an errno value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma operaÁ„o aberta no vnode "
"passado com o modo de acesso passado. <returnvalue> 0 </returnvalue> para o sucesso, "
"ou um valor errno para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:12996
#, fuzzy
msgid "<function>mpo_check_vnode_readdir</function>"
msgstr " <function> mpo_check_vnode_readdir </function> "

#: book.translate.xml:12999
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_readdir</function></funcdef> <paramdef>struct "
"ucred *<parameter/>cred</paramdef> <paramdef>struct vnode *<parameter/>dvp</"
"paramdef> <paramdef>struct label *<parameter/>dlabel</paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_readdir </function></funcdef><paramdef> "
"struct ucred * <parameter/> cred </paramdef><paramdef> struct vnode * <parameter/> "
"dvp </paramdef><paramdef> label struct * <parameter/> dlabel </paramdef> "

#: book.translate.xml:13036
#, fuzzy
msgid "Object; directory vnode"
msgstr "Objeto; diretÛrio vnode"

#: book.translate.xml:13048
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a <function>readdir</function> "
"operation on the passed directory vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</errorcode> "
"for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma <function> readdir </"
"function> operaÁ„o no diretÛrio passado vnode. Retorna <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para falha. "
"Falha sugerida: <errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, "
"ou <errorcode> EPERM </errorcode> por falta de privilÈgio \""

#: book.translate.xml:13058
#, fuzzy
msgid "<function>mpo_check_vnode_readlink</function>"
msgstr " <function> mpo_check_vnode_readlink </function> "

#: book.translate.xml:13061
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_readlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_readlink </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef> "

#: book.translate.xml:13110
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a <function>readlink</function> "
"operation on the passed symlink vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</errorcode> "
"for lack of privilege. This call may be made in a number of situations, including an "
"explicit <function>readlink</function> call by the user process, or as a result of "
"an implicit <function>readlink</function> during a name lookup by the process."
msgstr ""
"Determine se a credencial do assunto pode executar uma <function> readlink </"
"function> operaÁ„o no vnode symlink passado. Retorna <returnvalue> 0 </returnvalue> "
"para o sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> "
"EPERM </errorcode> por falta de privilÈgio. Esta chamada pode ser feita em v·rias "
"situaÁÌµes, incluindo uma <function> readlink </function> chamada pelo processo do "
"usu·rio ou como resultado de um <function> readlink </function> durante uma pesquisa "
"de nome pelo processo \""

#: book.translate.xml:13124
#, fuzzy
msgid "<function>mpo_check_vnode_revoke</function>"
msgstr " <function> mpo_check_vnode_revoke </function> "

#: book.translate.xml:13127
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_revoke</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_revoke </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef> "

#: book.translate.xml:13176
#, fuzzy
msgid ""
"Determine whether the subject credential can revoke access to the passed vnode. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for label "
"mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode revogar o acesso ao vnode passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:13186
#, fuzzy
msgid "<function>mpo_check_vnode_setacl</function>"
msgstr " <function> mpo_check_vnode_setacl </function> "

#: book.translate.xml:13189
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setacl</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>acl_type_t <parameter>type</parameter></paramdef> "
"<paramdef>struct acl *<parameter>acl</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setacl </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> acl_type_t <parameter> tipo </parameter></"
"paramdef><paramdef> struct acl * <parameter> acl </parameter></paramdef> "

#: book.translate.xml:13245
#, fuzzy
msgid "<parameter>acl</parameter>"
msgstr " <parameter> acl </parameter> "

#: book.translate.xml:13246
#, fuzzy
msgid "ACL"
msgstr "ACL"

#: book.translate.xml:13252
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed ACL of passed type on "
"the passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode definir a ACL transmitida do tipo passado "
"no vnode passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:13262
#, fuzzy
msgid "<function>mpo_check_vnode_setextattr</function>"
msgstr " <function> mpo_check_vnode_setextattr </function> "

#: book.translate.xml:13265
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>int <parameter>attrnamespace</"
"parameter></paramdef> <paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setextattr </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> int <parameter> attrnamespace </parameter></"
"paramdef><paramdef> const char * <parameter> nome </parameter></paramdef><paramdef> "
"struct uio * <parameter> uio </parameter></paramdef> "

#: book.translate.xml:13334
#, fuzzy
msgid ""
"Determine whether the subject credential can set the extended attribute of passed "
"name and passed namespace on the passed vnode. Policies implementing security labels "
"backed into extended attributes may want to provide additional protections for those "
"attributes. Additionally, policies should avoid making decisions based on the data "
"referenced from <parameter>uio</parameter>, as there is a potential race condition "
"between this check and the actual operation. The <parameter>uio</parameter> may also "
"be <literal>NULL</literal> if a delete operation is being performed. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> value for "
"failure. Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determinar se a credencial de assunto pode definir o atributo estendido do nome "
"passado e o espaÁo de nomes passado no vnode passado. As polÌ≠ticas que implementam "
"rÛtulos de seguranÁa com backup em atributos estendidos podem fornecer proteÁÌµes "
"adicionais para esses atributos. AlÈm disso, as polÌ≠ticas devem evitar tomar "
"decisÌµes com base no dados referenciados de <parameter> uio </parameter> , como h· "
"uma condiÁ„o de corrida em potencial entre essa verificaÁ„o e a operaÁ„o real. o "
"<parameter> uio </parameter> TambÈm pode ser <literal> NULO </literal> se uma "
"operaÁ„o de exclus„o estiver sendo executada. Retorna <returnvalue> 0 </returnvalue> "
"para o sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> "
"EPERM </errorcode> por falta de privilÈgio \""

#: book.translate.xml:13352
#, fuzzy
msgid "<function>mpo_check_vnode_setflags</function>"
msgstr " <function> mpo_check_vnode_setflags </function> "

#: book.translate.xml:13355
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setflags</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>u_long <parameter>flags</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setflags </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> u_long <parameter> bandeiras </parameter></paramdef> "

#: book.translate.xml:13404
#, fuzzy
msgid ""
"File flags; see <citerefentry><refentrytitle>chflags</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"Sinalizadores de arquivo; consulte <citerefentry><refentrytitle> chflags </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:13410
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed flags on the passed "
"vnode. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir os sinalizadores passados ‚Äã‚Äãno "
"vnode passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privilÈgio \""

#: book.translate.xml:13420
#, fuzzy
msgid "<function>mpo_check_vnode_setmode</function>"
msgstr " <function> mpo_check_vnode_setmode </function> "

#: book.translate.xml:13423
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setmode</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></"
"paramdef> <paramdef>mode_t <parameter>mode</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setmode </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> mode_t <parameter> modo </parameter></paramdef> "

#: book.translate.xml:13470
#, fuzzy
msgid "<parameter>mode</parameter>"
msgstr " <parameter> modo </parameter> "

#: book.translate.xml:13471
#, fuzzy
msgid ""
"File mode; see <citerefentry><refentrytitle>chmod</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"Modo de arquivo; consulte <citerefentry><refentrytitle> chmod </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:13477
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed mode on the passed "
"vnode. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir o modo passado no vnode passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:13487
#, fuzzy
msgid "<function>mpo_check_vnode_setowner</function>"
msgstr " <function> mpo_check_vnode_setowner </function> "

#: book.translate.xml:13490
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setowner</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"vnode *<parameter>vp</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef> <paramdef>uid_t <parameter>uid</parameter></"
"paramdef> <paramdef>gid_t <parameter>gid</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setowner </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef><paramdef> uid_t <parameter> uido </parameter></"
"paramdef><paramdef> gid_t <parameter> gid </parameter></paramdef> "

#: book.translate.xml:13538
#, fuzzy
msgid "<parameter>uid</parameter>"
msgstr " <parameter> uido </parameter> "

#: book.translate.xml:13539
#, fuzzy
msgid "User ID"
msgstr "ID do usu·rio"

#: book.translate.xml:13543
#, fuzzy
msgid "<parameter>gid</parameter>"
msgstr " <parameter> guia </parameter> "

#: book.translate.xml:13544
#, fuzzy
msgid "Group ID"
msgstr "ID do grupo"

#: book.translate.xml:13550
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed uid and passed gid as "
"file uid and file gid on the passed vnode. The IDs may be set to (<literal>-1</"
"literal>) to request no update. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir o uid passado e o gid passado como "
"arquivo uid e gid do arquivo no vnode transmitido. Os IDs podem ser definidos como "
"( <literal> -1 </literal> ) para solicitar nenhuma atualizaÁ„o. Retorna "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:13561
#, fuzzy
msgid "<function>mpo_check_vnode_setutimes</function>"
msgstr " <function> mpo_check_vnode_setutimes </function> "

#: book.translate.xml:13564
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setutimes</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>vp</paramdef> <paramdef>struct label *<parameter/>label</paramdef> "
"<paramdef>struct timespec <parameter/>atime</paramdef> <paramdef>struct timespec "
"<parameter/>mtime</paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setutimes </function></funcdef><paramdef> "
"struct ucred * <parameter/> cred </paramdef><paramdef> struct vnode * <parameter/> "
"vp </paramdef><paramdef> label struct * <parameter/> rÛtulo </paramdef><paramdef> "
"struct timespec <parameter/> um tempo </paramdef><paramdef> struct timespec "
"<parameter/> mtime </paramdef> "

#: book.translate.xml:13605
#, fuzzy
msgid "Object; vp"
msgstr "Objeto; vp"

#: book.translate.xml:13615
#, fuzzy
msgid "<parameter>atime</parameter>"
msgstr " <parameter> um tempo </parameter> "

#: book.translate.xml:13616
#, fuzzy
msgid ""
"Access time; see <citerefentry><refentrytitle>utimes</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"Tempo de acesso; consulte <citerefentry><refentrytitle> utimes </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:13620
#, fuzzy
msgid "<parameter>mtime</parameter>"
msgstr " <parameter> mtime </parameter> "

#: book.translate.xml:13621
#, fuzzy
msgid ""
"Modification time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Tempo de modificaÁ„o; ver <citerefentry><refentrytitle> utimes </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:13627
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed access timestamps on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode definir os registros de data e hora de "
"acesso transmitidos no vnode transmitido. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> "
"EPERM </errorcode> por falta de privilÈgio \""

#: book.translate.xml:13637
#, fuzzy
msgid "<function>mpo_check_proc_sched</function>"
msgstr " <function> mpo_check_proc_sched </function> "

#: book.translate.xml:13640
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_sched</function></funcdef> <paramdef>struct "
"ucred *<parameter>ucred</parameter></paramdef> <paramdef>struct proc "
"*<parameter>proc</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_sched </function></funcdef><paramdef> "
"struct ucred * <parameter> ucred </parameter></paramdef><paramdef> struct proc * "
"<parameter> proc </parameter></paramdef> "

#: book.translate.xml:13681
#, fuzzy
msgid ""
"Determine whether the subject credential can change the scheduling parameters of the "
"passed process. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: <errorcode>EACCES</"
"errorcode> for label mismatch, <errorcode>EPERM</errorcode> for lack of privilege, "
"or <errorcode>ESRCH</errorcode> to limit visibility."
msgstr ""
"Determine se a credencial do assunto pode alterar os parÌ¢metros de agendamento do "
"processo passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, <errorcode> EPERM </errorcode> por falta de "
"privilÈgio, ou <errorcode> ESRCH </errorcode> para limitar a visibilidade \""

#: book.translate.xml:13689
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>setpriority</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"Vejo <citerefentry><refentrytitle> definir prioridades </refentrytitle><manvolnum> 2 "
"</manvolnum></citerefentry> Para maiores informaÁÌµes."

#: book.translate.xml:13693
#, fuzzy
msgid "<function>mpo_check_proc_signal</function>"
msgstr " <function> mpo_check_proc_signal </function> "

#: book.translate.xml:13696
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_signal</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct proc "
"*<parameter>proc</parameter></paramdef> <paramdef>int <parameter>signal</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_signal </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct proc * "
"<parameter> proc </parameter></paramdef><paramdef> int <parameter> sinal </"
"parameter></paramdef> "

#: book.translate.xml:13736
#, fuzzy
msgid "<parameter>signal</parameter>"
msgstr " <parameter> sinal </parameter> "

#: book.translate.xml:13737
#, fuzzy
msgid ""
"Signal; see <citerefentry><refentrytitle>kill</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"Signal; ver <citerefentry><refentrytitle> matar </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> "

#: book.translate.xml:13743
#, fuzzy
msgid ""
"Determine whether the subject credential can deliver the passed signal to the passed "
"process. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, <errorcode>EPERM</errorcode> for lack of privilege, or "
"<errorcode>ESRCH</errorcode> to limit visibility."
msgstr ""
"Determine se a credencial do participante pode entregar o sinal passado ao processo "
"passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, <errorcode> EPERM </errorcode> por falta de "
"privilÈgio, ou <errorcode> ESRCH </errorcode> para limitar a visibilidade \""

#: book.translate.xml:13753
#, fuzzy
msgid "<function>mpo_check_vnode_stat</function>"
msgstr " <function> mpo_check_vnode_stat </function> "

#: book.translate.xml:13756
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_stat</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_stat </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> rÛtulo </"
"parameter></paramdef> "

#: book.translate.xml:13805
#, fuzzy
msgid ""
"Determine whether the subject credential can <function>stat</function> the passed "
"vnode. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do sujeito pode <function> stat </function> o vnode "
"passado. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:13813
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>stat</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> for more information."
msgstr ""
"Vejo <citerefentry><refentrytitle> stat </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> Para maiores informaÁÌµes."

#: book.translate.xml:13817
#, fuzzy
msgid "<function>mpo_check_ifnet_transmit</function>"
msgstr " <function> mpo_check_ifnet_transmit </function> "

#: book.translate.xml:13820
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_ifnet_transmit</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"ifnet *<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>mbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_ifnet_transmit </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct ifnet * "
"<parameter> ifnet </parameter></paramdef><paramdef> label struct * <parameter> "
"ifnetlabel </parameter></paramdef><paramdef> struct mbuf * <parameter> mbuf </"
"parameter></paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#: book.translate.xml:13872
#, fuzzy
msgid "Object; mbuf to be sent"
msgstr "Objeto; mbuf a ser enviado"

#: book.translate.xml:13884
#, fuzzy
msgid ""
"Determine whether the network interface can transmit the passed mbuf. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> value for "
"failure. Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a interface de rede pode transmitir o mbuf passado. <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para falha. "
"Falha sugerida: <errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, "
"ou <errorcode> EPERM </errorcode> por falta de privilÈgio \""

#: book.translate.xml:13893
#, fuzzy
msgid "<function>mpo_check_socket_deliver</function>"
msgstr " <function> mpo_check_socket_deliver </function> "

#: book.translate.xml:13896
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_deliver</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"ifnet *<parameter>ifnet</parameter></paramdef> <paramdef>struct label "
"*<parameter>ifnetlabel</parameter></paramdef> <paramdef>struct mbuf "
"*<parameter>mbuf</parameter></paramdef> <paramdef>struct label "
"*<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_deliver </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct ifnet * "
"<parameter> ifnet </parameter></paramdef><paramdef> label struct * <parameter> "
"ifnetlabel </parameter></paramdef><paramdef> struct mbuf * <parameter> mbuf </"
"parameter></paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#: book.translate.xml:13948
#, fuzzy
msgid "Object; mbuf to be delivered"
msgstr "Objeto; mbuf a ser entregue"

#: book.translate.xml:13960
#, fuzzy
msgid ""
"Determine whether the socket may receive the datagram stored in the passed mbuf "
"header. Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failures: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determina se o socket pode receber o datagrama armazenado no cabeÁalho mbuf passado. "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </varname> "
"valor para falha. Falhas sugeridas: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta de "
"privilÈgio \""

#: book.translate.xml:13973
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>struct "
"socket *<parameter>so</parameter></paramdef> <paramdef>struct label "
"*<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_visible </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> soquete de "
"estrutura * <parameter> assim </parameter></paramdef><paramdef> label struct * "
"<parameter> socketlabel </parameter></paramdef> "

#: book.translate.xml:14016
#, fuzzy
msgid "Policy label for <parameter>so</parameter>"
msgstr "Etiqueta de polÌ≠tica para <parameter> assim </parameter> "

#: book.translate.xml:14023
#, fuzzy
msgid ""
"Determine whether the subject credential cred can \"see\" the passed socket "
"(<parameter>socket</parameter>) using system monitoring functions, such as those "
"employed by <citerefentry><refentrytitle>netstat</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry> and <citerefentry><refentrytitle>sockstat</"
"refentrytitle><manvolnum>1</manvolnum></citerefentry>. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatches, "
"<errorcode>EPERM</errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> "
"to hide visibility."
msgstr ""
"Determine se o credencial da pessoa em quest„o pode\" ver \"o soquete passado "
"( <parameter> soquete </parameter> ) usando funÁÌµes de monitoramento do sistema, "
"como aquelas empregadas <citerefentry><refentrytitle> netstat </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> sockstat </refentrytitle><manvolnum> 1 </manvolnum></"
"citerefentry> . Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidades de rÛtulo, <errorcode> EPERM </errorcode> por "
"falta de privilÈgio, ou <errorcode> ESRCH </errorcode> para esconder visibilidade \""

#: book.translate.xml:14035
#, fuzzy
msgid "<function>mpo_check_system_acct</function>"
msgstr " <function> mpo_check_system_acct </function> "

#: book.translate.xml:14038
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_acct</function></funcdef> <paramdef>struct "
"ucred *<parameter>ucred</parameter></paramdef> <paramdef>struct vnode "
"*<parameter>vp</parameter></paramdef> <paramdef>struct label *<parameter>vlabel</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_acct </function></funcdef><paramdef> "
"struct ucred * <parameter> ucred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> vlabel </"
"parameter></paramdef> "

#: book.translate.xml:14069
#, fuzzy
msgid "<parameter>ucred</parameter>"
msgstr " <parameter> ucred </parameter> "

#: book.translate.xml:14075
#, fuzzy
msgid ""
"Accounting file; <citerefentry><refentrytitle>acct</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry>"
msgstr ""
"Arquivo cont·bil; <citerefentry><refentrytitle> acct </refentrytitle><manvolnum> 5 </"
"manvolnum></citerefentry> "

#: book.translate.xml:14087
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to enable accounting, based on its "
"label and the label of the accounting log file."
msgstr ""
"Determine se o assunto deve ter permiss„o para ativar a contabilidade, com base em "
"seu rÛtulo e no rÛtulo do arquivo de registro cont·bil."

#: book.translate.xml:14093
#, fuzzy
msgid "<function>mpo_check_system_nfsd</function>"
msgstr " <function> mpo_check_system_nfsd </function> "

#: book.translate.xml:14096
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_nfsd</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_nfsd </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:14130
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to call "
"<citerefentry><refentrytitle>nfssvc</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>."
msgstr ""
"Determinar se o assunto deve ter permiss„o para ligar <citerefentry><refentrytitle> "
"nfssvc </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:14135
#, fuzzy
msgid "<function>mpo_check_system_reboot</function>"
msgstr " <function> mpo_check_system_reboot </function> "

#: book.translate.xml:14138
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_reboot</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>int <parameter>howto</"
"parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_reboot </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> int <parameter> "
"como </parameter></paramdef> "

#: book.translate.xml:14171
#, fuzzy
msgid "<parameter>howto</parameter>"
msgstr " <parameter> como </parameter> "

#: book.translate.xml:14172
#, fuzzy
msgid ""
"<parameter>howto</parameter> parameter from <citerefentry><refentrytitle>reboot</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
" <parameter> como </parameter> parÌ¢metro de <citerefentry><refentrytitle> reiniciar "
"</refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#: book.translate.xml:14179
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to reboot the system in the "
"specified manner."
msgstr ""
"Determine se o assunto deve ter permiss„o para reinicializar o sistema da maneira "
"especificada."

#: book.translate.xml:14184
#, fuzzy
msgid "<function>mpo_check_system_settime</function>"
msgstr " <function> mpo_check_system_settime </function> "

#: book.translate.xml:14187
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_settime</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_settime </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#: book.translate.xml:14221
#, fuzzy
msgid "Determine whether the user should be allowed to set the system clock."
msgstr "Determine se o usu·rio deve ter permiss„o para definir o relÛgio do sistema."

#: book.translate.xml:14226
#, fuzzy
msgid "<function>mpo_check_system_swapon</function>"
msgstr " <function> mpo_check_system_swapon </function> "

#: book.translate.xml:14229
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_swapon</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>struct vnode *<parameter>vp</"
"parameter></paramdef> <paramdef>struct label *<parameter>vlabel</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_swapon </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct vnode * "
"<parameter> vp </parameter></paramdef><paramdef> label struct * <parameter> vlabel </"
"parameter></paramdef> "

#: book.translate.xml:14266
#, fuzzy
msgid "Swap device"
msgstr "Dispositivo de troca"

#: book.translate.xml:14278
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to add <parameter>vp</parameter> as "
"a swap device."
msgstr ""
"Determine se o assunto deve ter permiss„o para adicionar <parameter> vp </parameter> "
"como um dispositivo de troca \""

#: book.translate.xml:14283
#, fuzzy
msgid "<function>mpo_check_system_sysctl</function>"
msgstr " <function> mpo_check_system_sysctl </function> "

#: book.translate.xml:14286
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_sysctl</function></funcdef> <paramdef>struct "
"ucred *<parameter>cred</parameter></paramdef> <paramdef>int *<parameter>name</"
"parameter></paramdef> <paramdef>u_int *<parameter>namelen</parameter></paramdef> "
"<paramdef>void *<parameter>old</parameter></paramdef> <paramdef>size_t "
"*<parameter>oldlenp</parameter></paramdef> <paramdef>int <parameter>inkernel</"
"parameter></paramdef> <paramdef>void *<parameter>new</parameter></paramdef> "
"<paramdef>size_t <parameter>newlen</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_sysctl </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> int * <parameter> "
"nome </parameter></paramdef><paramdef> u_int * <parameter> namelen </parameter></"
"paramdef><paramdef> void * <parameter> velho </parameter></paramdef><paramdef> "
"size_t * <parameter> oldlenp </parameter></paramdef><paramdef> int <parameter> "
"t˙nica </parameter></paramdef><paramdef> void * <parameter> Novo </parameter></"
"paramdef><paramdef> size_t <parameter> Newlen </parameter></paramdef> "

#: book.translate.xml:14350 book.translate.xml:14327
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>"
msgstr ""
"Vejo <citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> "

#: book.translate.xml:14339
#, fuzzy
msgid "<parameter>oldlenp</parameter>"
msgstr " <parameter> oldlenp </parameter> "

#: book.translate.xml:14343
#, fuzzy
msgid "<parameter>inkernel</parameter>"
msgstr " <parameter> inkernel </parameter> "

#: book.translate.xml:14344
#, fuzzy
msgid "Boolean; <literal>1</literal> if called from kernel"
msgstr "Boleano; <literal> 1 </literal> se chamado do kernel "

#: book.translate.xml:14354
#, fuzzy
msgid "<parameter>newlen</parameter>"
msgstr " <parameter> newlen </parameter> "

#: book.translate.xml:14360
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> transaction."
msgstr ""
"Determinar se o assunto deve ter permiss„o para fazer o especificado "
"<citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 3 </manvolnum></"
"citerefentry> transaÁ„o."

#: book.translate.xml:14366
#, fuzzy
msgid "Label Management Calls"
msgstr "Chamadas de Gerenciamento de Etiqueta"

#: book.translate.xml:14368
#, fuzzy
msgid ""
"Relabel events occur when a user process has requested that the label on an object "
"be modified. A two-phase update occurs: first, an access control check will be "
"performed to determine if the update is both valid and permitted, and then the "
"update itself is performed via a separate entry point. Relabel entry points "
"typically accept the object, object label reference, and an update label submitted "
"by the process. Memory allocation during relabel is discouraged, as relabel calls "
"are not permitted to fail (failure should be reported earlier in the relabel check)."
msgstr ""
"Os eventos de reclassificaÁ„o ocorrem quando um processo do usu·rio solicita que o "
"rÛtulo de um objeto seja modificado. Uma atualizaÁ„o de duas fases ocorre: primeiro, "
"uma verificaÁ„o de controle de acesso ser· executada para determinar se a "
"atualizaÁ„o È v·lida e permitida e, em seguida, a atualizaÁ„o O ponto de entrada de "
"reclassificaÁ„o normalmente aceita o objeto, a referÍncia de rÛtulo de objeto e um "
"rÛtulo de atualizaÁ„o enviado pelo processo.A alocaÁ„o de memÛria durante a "
"reclassificaÁ„o n„o È recomendada, pois as chamadas de reclassificaÁ„o n„o tÍm "
"permiss„o para falhar mais cedo na verificaÁ„o de reclassificaÁ„o). "

#: book.translate.xml:14383
#, fuzzy
msgid "Userland Architecture"
msgstr "Arquitetura Userland"

#: book.translate.xml:14385
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework includes a number of policy-agnostic elements, "
"including MAC library interfaces for abstractly managing labels, modifications to "
"the system credential management and login libraries to support the assignment of "
"MAC labels to users, and a set of tools to monitor and modify labels on processes, "
"files, and network interfaces. More details on the user architecture will be added "
"to this section in the near future."
msgstr ""
"O TrustedBSD MAC Framework inclui v·rios elementos agnÛsticos de polÌ≠ticas, "
"incluindo interfaces de biblioteca MAC para gerenciar rÛtulos, modificaÁÌµes no "
"gerenciamento de credenciais do sistema e bibliotecas de login para suportar a "
"atribuiÁ„o de rÛtulos MAC aos usu·rios e um conjunto de ferramentas para monitorar e "
"modificar rÛtulos em processos, arquivos e interfaces de rede. Mais detalhes sobre a "
"arquitetura do usu·rio ser„o adicionados a esta seÁ„o em um futuro prÛximo. "

#: book.translate.xml:14395
#, fuzzy
msgid "APIs for Policy-Agnostic Label Management"
msgstr "APIs para gerenciamento de rÛtulos agnÛsticos em polÌ≠ticas"

#: book.translate.xml:14397
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework provides a number of library and system calls "
"permitting applications to manage MAC labels on objects using a policy-agnostic "
"interface. This permits applications to manipulate labels for a variety of policies "
"without being written to support specific policies. These interfaces are used by "
"general-purpose tools such as <citerefentry><refentrytitle>ifconfig</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>ls</refentrytitle><manvolnum>1</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>ps</refentrytitle><manvolnum>1</"
"manvolnum></citerefentry> to view labels on network interfaces, files, and "
"processes. The APIs also support MAC management tools including "
"<citerefentry><refentrytitle>getfmac</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>getpmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>setfmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>setfsmac</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry>, and <citerefentry><refentrytitle>setpmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>. The MAC APIs are documented in "
"<citerefentry><refentrytitle>mac</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."
msgstr ""
"O TrustedBSD MAC Framework fornece v·rias chamadas de biblioteca e de sistema, "
"permitindo que aplicativos gerenciem rÛtulos MAC em objetos usando uma interface "
"independente de polÌ≠ticas. Isso permite que os aplicativos manipulem rÛtulos para "
"uma variedade de polÌ≠ticas sem serem escritos para suportar polÌ≠ticas especÌ≠ficas. "
"Essas interfaces s„o usado por ferramentas de uso geral, como "
"<citerefentry><refentrytitle> ifconfig </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> , <citerefentry><refentrytitle> ls </refentrytitle><manvolnum> 1 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> ps </"
"refentrytitle><manvolnum> 1 </manvolnum></citerefentry> para exibir rÛtulos em "
"interfaces de rede, arquivos e processos. As APIs tambÈm suportam ferramentas de "
"gerenciamento MAC, incluindo <citerefentry><refentrytitle> getfmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> getpmac </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> , <citerefentry><refentrytitle> setfmac </refentrytitle><manvolnum> 8 "
"</manvolnum></citerefentry> , <citerefentry><refentrytitle> setfsmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> setpmac </refentrytitle><manvolnum> 8 </manvolnum></"
"citerefentry> . As APIs do MAC est„o documentadas em <citerefentry><refentrytitle> "
"Mac </refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#: book.translate.xml:14411
#, fuzzy
msgid ""
"Applications handle MAC labels in two forms: an internalized form used to return and "
"set labels on processes and objects (<literal>mac_t</literal>), and externalized "
"form based on C strings appropriate for storage in configuration files, display to "
"the user, or input from the user. Each MAC label contains a number of elements, each "
"consisting of a name and value pair. Policy modules in the kernel bind to specific "
"names and interpret the values in policy-specific ways. In the externalized string "
"form, labels are represented by a comma-delimited list of name and value pairs "
"separated by the <literal>/</literal> character. Labels may be directly converted to "
"and from text using provided APIs; when retrieving labels from the kernel, "
"internalized label storage must first be prepared for the desired label element set. "
"Typically, this is done in one of two ways: using "
"<citerefentry><refentrytitle>mac_prepare</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> and an arbitrary list of desired label elements, or one of the "
"variants of the call that loads a default element set from the "
"<citerefentry><refentrytitle>mac.conf</refentrytitle><manvolnum>5</manvolnum></"
"citerefentry> configuration file. Per-object defaults permit application writers to "
"usefully display labels associated with objects without being aware of the policies "
"present in the system."
msgstr ""
"Os aplicativos manipulam rÛtulos MAC de duas formas: um formul·rio internalizado "
"usado para retornar e definir rÛtulos em processos e objetos ( <literal> mac_t </"
"literal> ) e formul·rio externalizado baseado em sequÍncias C apropriadas para "
"armazenamento em arquivos de configuraÁ„o, exibiÁ„o para o usu·rio ou entrada do "
"usu·rio. Cada rÛtulo MAC contÈm v·rios elementos, cada um consistindo em um par de "
"nome e valor. Os mÛdulos de polÌ≠tica no kernel s„o vinculados a nomes especÌ≠ficos e "
"interpretam os valores de maneiras especÌ≠ficas da polÌ≠tica. No formul·rio de string "
"exteriorizado, os rÛtulos s„o representados por uma lista delimitada por vÌ≠rgulas de "
"pares de nome e valor separados por <literal> / </literal> personagem. Os rÛtulos "
"podem ser convertidos diretamente para e a partir do texto usando as APIs "
"fornecidas; Ao recuperar rÛtulos do kernel, o armazenamento de rÛtulos internalizado "
"deve primeiro ser preparado para o conjunto de elementos de rÛtulo desejado. "
"Normalmente, isso È feito de duas maneiras: usando <citerefentry><refentrytitle> "
"mac_prepare </refentrytitle><manvolnum> 3 </manvolnum></citerefentry> e uma lista "
"arbitr·ria de elementos de rÛtulo desejados, ou uma das variantes da chamada que "
"carrega um conjunto de elementos padr„o do <citerefentry><refentrytitle> mac.conf </"
"refentrytitle><manvolnum> 5 </manvolnum></citerefentry> arquivo de configuraÁ„o. "
"PadrÌµes por objeto permitem que escritores de aplicativos exibam rÛtulos associados "
"a objetos sem estarem cientes das polÌ≠ticas presentes no sistema. "

#: book.translate.xml:14435
#, fuzzy
msgid ""
"Currently, direct manipulation of label elements other than by conversion to a text "
"string, string editing, and conversion back to an internalized label is not "
"supported by the MAC library. Such interfaces may be added in the future if they "
"prove necessary for application writers."
msgstr ""
"Atualmente, a manipulaÁ„o direta de elementos de rÛtulo diferentes da convers„o para "
"uma string de texto, ediÁ„o de string e convers„o de volta para um rÛtulo "
"internalizado n„o È suportada pela biblioteca MAC. Tais interfaces podem ser "
"adicionadas no futuro se forem necess·rias para escritores de aplicativos "

#: book.translate.xml:14444
#, fuzzy
msgid "Binding of Labels to Users"
msgstr "LigaÁ„o de etiquetas aos usu·rios"

#: book.translate.xml:14446
#, fuzzy
msgid ""
"The standard user context management interface, "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>, has been modified to retrieve MAC labels associated with a user's "
"class from <citerefentry><refentrytitle>login.conf</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry>. These labels are then set along with other user context "
"when either <literal>LOGIN_SETALL</literal> is specified, or when "
"<literal>LOGIN_SETMAC</literal> is explicitly specified."
msgstr ""
"A interface padr„o de gerenciamento de contexto do usu·rio, "
"<citerefentry><refentrytitle> setusercontext </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> , foi modificado para recuperar rÛtulos MAC associados a "
"uma classe de usu·rio de <citerefentry><refentrytitle> login.conf </"
"refentrytitle><manvolnum> 5 </manvolnum></citerefentry> . Esses rÛtulos s„o ent„o "
"definidos junto com outro contexto de usu·rio quando <literal> LOGIN_SETALL </"
"literal> È especificado, ou quando <literal> LOGIN_SETMAC </literal> È "
"explicitamente especificado. "

#: book.translate.xml:14455
#, fuzzy
msgid ""
"It is expected that, in a future version of FreeBSD, the MAC label database will be "
"separated from the <filename>login.conf</filename> user class abstraction, and be "
"maintained in a separate database. However, the "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> API should remain the same following such a change."
msgstr ""
"Espera-se que, em uma vers„o futura do FreeBSD, o banco de dados de rÛtulos MAC seja "
"separado do <filename> login.conf </filename> abstraÁ„o de classe de usu·rio, e ser "
"mantido em um banco de dados separado. No entanto, o <citerefentry><refentrytitle> "
"setusercontext </refentrytitle><manvolnum> 3 </manvolnum></citerefentry> A API deve "
"permanecer a mesma apÛs essa mudanÁa. "

#: book.translate.xml:14465
#, fuzzy
msgid "Conclusion"
msgstr "Conclus„o"

#: book.translate.xml:14467
#, fuzzy
msgid ""
"The TrustedBSD MAC framework permits kernel modules to augment the system security "
"policy in a highly integrated manner. They may do this based on existing object "
"properties, or based on label data that is maintained with the assistance of the MAC "
"framework. The framework is sufficiently flexible to implement a variety of policy "
"types, including information flow security policies such as MLS and Biba, as well as "
"policies based on existing BSD credentials or file protections. Policy authors may "
"wish to consult this documentation as well as existing security modules when "
"implementing a new security service."
msgstr ""
"A estrutura do TrustedBSD MAC permite que os mÛdulos do kernel aumentem a polÌ≠tica "
"de seguranÁa do sistema de uma maneira altamente integrada. Eles podem fazer isso "
"com base nas propriedades de objetos existentes ou com base nos dados de rÛtulo que "
"s„o mantidos com a assistÍncia da estrutura MAC. flexÌ≠veis para implementar uma "
"variedade de tipos de polÌ≠ticas, incluindo polÌ≠ticas de seguranÁa de fluxo de "
"informaÁÌµes como MLS e Biba, bem como polÌ≠ticas baseadas em credenciais BSD "
"existentes ou proteÁÌµes de arquivos.Autoriais de polÌ≠ticas podem desejar consultar "
"esta documentaÁ„o assim como mÛdulos de seguranÁa existentes ao implementar novo "
"serviÁo de seguranÁa. "

#: book.translate.xml:14490
#, fuzzy
msgid "Virtual Memory System"
msgstr "Sistema de MemÛria Virtual"

#: book.translate.xml:14493
#, fuzzy
msgid ""
"<personname> <firstname>Matthew</firstname> <surname>Dillon</surname> </personname> "
"<contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Mateus </firstname><surname> Dillon </surname></"
"personname><contrib> ContribuÌ≠ram por </contrib> "

#: book.translate.xml:14504
#, fuzzy
msgid "Management of Physical Memory‚Äî<literal>vm_page_t</literal>"
msgstr "Gerenciamento de memÛria fÌ≠sica‚Äî <literal> vm_page_t </literal> "

#: book.translate.xml:14507
#, fuzzy
msgid "<primary>virtual memory</primary>"
msgstr " <primary> memÛria virtual </primary> "

#: book.translate.xml:14508
#, fuzzy
msgid "<primary>physical memory</primary>"
msgstr " <primary> memÛria fÌ≠sica </primary> "

#: book.translate.xml:14509
#, fuzzy
msgid "<primary><literal>vm_page_t</literal> structure</primary>"
msgstr " <primary><literal> vm_page_t </literal> estrutura </primary> "

#: book.translate.xml:14513
#, fuzzy
msgid ""
"Physical memory is managed on a page-by-page basis through the <literal>vm_page_t</"
"literal> structure. Pages of physical memory are categorized through the placement "
"of their respective <literal>vm_page_t</literal> structures on one of several paging "
"queues."
msgstr ""
"A memÛria fÌ≠sica È gerenciada p·gina por p·gina atravÈs do <literal> vm_page_t </"
"literal> estrutura. As p·ginas da memÛria fÌ≠sica s„o categorizadas atravÈs da "
"colocaÁ„o de seus respectivos <literal> vm_page_t </literal> estruturas em uma das "
"v·rias filas de paginaÁ„o. "

#: book.translate.xml:14519
#, fuzzy
msgid ""
"A page can be in a wired, active, inactive, cache, or free state. Except for the "
"wired state, the page is typically placed in a doubly link list queue representing "
"the state that it is in. Wired pages are not placed on any queue."
msgstr ""
"Uma p·gina pode estar em um estado com fio, ativo, inativo, em cache ou livre. "
"Exceto pelo estado com fio, a p·gina normalmente È colocada em uma fila de lista de "
"links duplamente representando o estado em que est·. As p·ginas com fio n„o s„o "
"colocadas em qualquer fila. "

#: book.translate.xml:14524
#, fuzzy
msgid ""
"FreeBSD implements a more involved paging queue for cached and free pages in order "
"to implement page coloring. Each of these states involves multiple queues arranged "
"according to the size of the processor's L1 and L2 caches. When a new page needs to "
"be allocated, FreeBSD attempts to obtain one that is reasonably well aligned from "
"the point of view of the L1 and L2 caches relative to the VM object the page is "
"being allocated for."
msgstr ""
"O FreeBSD implementa uma fila de paginaÁ„o mais envolvida para p·ginas em cache e "
"livres, a fim de implementar coloraÁ„o de p·gina. Cada um desses estados envolve "
"v·rias filas organizadas de acordo com o tamanho dos caches L1 e L2 do processador. "
"Quando uma nova p·gina precisa ser alocada, o FreeBSD tenta obter um que esteja "
"razoavelmente bem alinhado do ponto de vista dos caches L1 e L2 em relaÁ„o ao objeto "
"de VM para o qual a p·gina est· sendo alocada. "

#: book.translate.xml:14533
#, fuzzy
msgid ""
"Additionally, a page may be held with a reference count or locked with a busy count. "
"The VM system also implements an <quote>ultimate locked</quote> state for a page "
"using the PG_BUSY bit in the page's flags."
msgstr ""
"AlÈm disso, uma p·gina pode ser mantida com uma contagem de referÍncia ou bloqueada "
"com uma contagem ocupada. O sistema VM tambÈm implementa uma <quote> ultimate "
"bloqueado </quote> estado para uma p·gina usando o bit PG_BUSY nos flags da p·gina. "

#: book.translate.xml:14538
#, fuzzy
msgid ""
"In general terms, each of the paging queues operates in a LRU fashion. A page is "
"typically placed in a wired or active state initially. When wired, the page is "
"usually associated with a page table somewhere. The VM system ages the page by "
"scanning pages in a more active paging queue (LRU) in order to move them to a less-"
"active paging queue. Pages that get moved into the cache are still associated with a "
"VM object but are candidates for immediate reuse. Pages in the free queue are truly "
"free. FreeBSD attempts to minimize the number of pages in the free queue, but a "
"certain minimum number of truly free pages must be maintained in order to "
"accommodate page allocation at interrupt time."
msgstr ""
"Em termos gerais, cada uma das filas de paginaÁ„o opera de forma LRU. Uma p·gina È "
"normalmente colocada em um estado com fio ou ativo inicialmente. Quando ligada, a "
"p·gina È geralmente associada a uma tabela de p·ginas em algum lugar. O sistema VM "
"envelhece a p·gina por varrendo p·ginas em uma fila de paginaÁ„o mais ativa (LRU) "
"para movÍ-las para uma fila de paginaÁ„o menos ativa As p·ginas que s„o movidas para "
"o cache ainda s„o associadas a um objeto VM, mas s„o candidatas a reutilizaÁ„o "
"imediata. O FreeBSD tenta minimizar o n˙mero de p·ginas na fila livre, mas um certo "
"n˙mero mÌ≠nimo de p·ginas realmente livres deve ser mantido para acomodar a alocaÁ„o "
"de p·ginas no momento da interrupÁ„o. "

#: book.translate.xml:14551
#, fuzzy
msgid ""
"If a process attempts to access a page that does not exist in its page table but "
"does exist in one of the paging queues (such as the inactive or cache queues), a "
"relatively inexpensive page reactivation fault occurs which causes the page to be "
"reactivated. If the page does not exist in system memory at all, the process must "
"block while the page is brought in from disk."
msgstr ""
"Se um processo tentar acessar uma p·gina que n„o existe em sua tabela de p·ginas mas "
"existir em uma das filas de paginaÁ„o (como as filas inativas ou de cache), ocorrer· "
"uma falha de reativaÁ„o de p·gina relativamente barata que faz com que a p·gina seja "
"reativada Se a p·gina n„o existir na memÛria do sistema, o processo deve ser "
"bloqueado enquanto a p·gina È trazida do disco. "

#: book.translate.xml:14559
#, fuzzy
msgid "<primary>paging queues</primary>"
msgstr " <primary> filas de paginaÁ„o </primary> "

#: book.translate.xml:14561
#, fuzzy
msgid ""
"FreeBSD dynamically tunes its paging queues and attempts to maintain reasonable "
"ratios of pages in the various queues as well as attempts to maintain a reasonable "
"breakdown of clean versus dirty pages. The amount of rebalancing that occurs depends "
"on the system's memory load. This rebalancing is implemented by the pageout daemon "
"and involves laundering dirty pages (syncing them with their backing store), "
"noticing when pages are activity referenced (resetting their position in the LRU "
"queues or moving them between queues), migrating pages between queues when the "
"queues are out of balance, and so forth. FreeBSD's VM system is willing to take a "
"reasonable number of reactivation page faults to determine how active or how idle a "
"page actually is. This leads to better decisions being made as to when to launder or "
"swap-out a page."
msgstr ""
"O FreeBSD ajusta dinamicamente suas filas de paginaÁ„o e tenta manter Ì≠ndices "
"razo·veis ‚Äã‚Äãde p·ginas nas v·rias filas, bem como tentativas de manter um "
"detalhamento razo·vel de p·ginas limpas versus p·ginas sujas. A quantidade de "
"rebalanceamento que ocorre depende da carga de memÛria do sistema. implementado pelo "
"daemon de pageout e envolve a lavagem de p·ginas sujas (sincronizando-as com seu "
"armazenamento de backup), observando quando as p·ginas s„o referenciadas Ì† "
"atividade (redefinindo sua posiÁ„o nas filas de LRU ou movendo-as entre filas), "
"migrando p·ginas entre filas quando as filas est„o fora O sistema VM do FreeBSD est· "
"disposto a aceitar um n˙mero razo·vel de falhas de p·gina de reativaÁ„o para "
"determinar o qu„o ativo ou ocioso È uma p·gina. Isso leva a melhores decisÌµes sobre "
"quando lavar ou trocar uma p·gina. "

#: book.translate.xml:14578
#, fuzzy
msgid "The Unified Buffer Cache‚Äî<literal>vm_object_t</literal>"
msgstr "O Unified Buffer Cache‚Äî <literal> vm_object_t </literal> "

#: book.translate.xml:14581
#, fuzzy
msgid "<primary>unified buffer cache</primary>"
msgstr " <primary> cache de buffer unificado </primary> "

#: book.translate.xml:14582
#, fuzzy
msgid "<primary><literal>vm_object_t</literal> structure</primary>"
msgstr " <primary><literal> vm_object_t </literal> estrutura </primary> "

#: book.translate.xml:14586
#, fuzzy
msgid ""
"FreeBSD implements the idea of a generic <quote>VM object</quote>. VM objects can be "
"associated with backing store of various types‚Äîunbacked, swap-backed, physical "
"device-backed, or file-backed storage. Since the filesystem uses the same VM objects "
"to manage in-core data relating to files, the result is a unified buffer cache."
msgstr ""
"O FreeBSD implementa a idÈia de um genÈrico <quote> Objeto da VM </quote> . Os "
"objetos da VM podem ser associados ao armazenamento de suporte de v·rios tipos - "
"armazenamento n„o suportado, com suporte a permuta, com suporte para dispositivos fÌ≠"
"sicos ou com suporte a arquivos. Como o sistema de arquivos usa os mesmos objetos de "
"VM para gerenciar dados internos relacionados aos arquivos, o resultado È um cache "
"de buffer unificado. "

#: book.translate.xml:14593
#, fuzzy
msgid ""
"VM objects can be <emphasis>shadowed</emphasis>. That is, they can be stacked on top "
"of each other. For example, you might have a swap-backed VM object stacked on top of "
"a file-backed VM object in order to implement a MAP_PRIVATE mmap()ing. This stacking "
"is also used to implement various sharing properties, including copy-on-write, for "
"forked address spaces."
msgstr ""
"Objetos VM podem ser <emphasis> sombreado </emphasis> . Ou seja, eles podem ser "
"empilhados uns sobre os outros. Por exemplo, vocÍ pode ter um objeto de VM com "
"suporte a permuta empilhado sobre um objeto de VM com backup de arquivo para "
"implementar um MAP_PRIVATE mmap (). Esse empilhamento tambÈm È usado para "
"implementar v·rias propriedades de compartilhamento, incluindo copy-on-write, para "
"espaÁos de endereÁamento bifurcados. "

#: book.translate.xml:14601
#, fuzzy
msgid ""
"It should be noted that a <literal>vm_page_t</literal> can only be associated with "
"one VM object at a time. The VM object shadowing implements the perceived sharing of "
"the same page across multiple instances."
msgstr ""
"Deve-se notar que um <literal> vm_page_t </literal> sÛ pode ser associado a um "
"objeto de VM por vez. O sombreamento de objeto da VM implementa o compartilhamento "
"percebido da mesma p·gina em v·rias instÌ¢ncias. "

#: book.translate.xml:14608
#, fuzzy
msgid "Filesystem I/O‚Äî<literal>struct buf</literal>"
msgstr "Sistema de arquivos I / O‚Äî <literal> struct buf </literal> "

#: book.translate.xml:14610
#, fuzzy
msgid "<primary>vnode</primary>"
msgstr " <primary> vnode </primary> "

#: book.translate.xml:14611
#, fuzzy
msgid ""
"vnode-backed VM objects, such as file-backed objects, generally need to maintain "
"their own clean/dirty info independent from the VM system's idea of clean/dirty. For "
"example, when the VM system decides to synchronize a physical page to its backing "
"store, the VM system needs to mark the page clean before the page is actually "
"written to its backing store. Additionally, filesystems need to be able to map "
"portions of a file or file metadata into KVM in order to operate on it."
msgstr ""
"Objetos VM com backup de vnode, como objetos com backup de arquivos, geralmente "
"precisam manter suas prÛprias informaÁÌµes limpas / sujas independentemente da idÈia "
"de limpeza / sujeira do sistema VM. Por exemplo, quando o sistema VM decide "
"sincronizar uma p·gina fÌ≠sica com No backing store, o sistema VM precisa marcar a "
"p·gina limpa antes que a p·gina seja realmente gravada em seu armazenamento de "
"backup. AlÈm disso, os sistemas de arquivos precisam poder mapear partes de um "
"arquivo ou metadados de arquivo para o KVM para oper·-lo. "

#: book.translate.xml:14620
#, fuzzy
msgid ""
"The entities used to manage this are known as filesystem buffers, <literal>struct "
"buf</literal>'s, or <literal>bp</literal>'s. When a filesystem needs to operate on a "
"portion of a VM object, it typically maps part of the object into a struct buf and "
"then maps the pages in the struct buf into KVM. In the same manner, disk I/O is "
"typically issued by mapping portions of objects into buffer structures and then "
"issuing the I/O on the buffer structures. The underlying vm_page_t's are typically "
"busied for the duration of the I/O. Filesystem buffers also have their own notion of "
"being busy, which is useful to filesystem driver code which would rather operate on "
"filesystem buffers instead of hard VM pages."
msgstr ""
"As entidades usadas para gerenciar isso s„o conhecidas como buffers de sistema de "
"arquivos, <literal> struct buf </literal> È ou <literal> pb </literal> . Quando um "
"sistema de arquivos precisa operar em uma parte de um objeto VM, ele normalmente "
"mapeia parte do objeto em um struct buf e, em seguida, mapeia as p·ginas no struct "
"buf para o KVM. Da mesma maneira, a E / S de disco normalmente È emitida por partes "
"de mapeamento de objetos em estruturas de buffer e, em seguida, emitindo a E / S nas "
"estruturas de buffer. As vm_page_t subjacentes geralmente s„o ocupadas pela duraÁ„o "
"da E / S. Os buffers do sistema de arquivos tambÈm tÍm sua prÛpria noÁ„o de estar "
"ocupado, o que È ˙til para o cÛdigo do driver do sistema de arquivos, que preferia "
"operar em buffers do sistema de arquivos em vez de p·ginas da VM. "

#: book.translate.xml:14633
#, fuzzy
msgid ""
"FreeBSD reserves a limited amount of KVM to hold mappings from struct bufs, but it "
"should be made clear that this KVM is used solely to hold mappings and does not "
"limit the ability to cache data. Physical data caching is strictly a function of "
"<literal>vm_page_t</literal>'s, not filesystem buffers. However, since filesystem "
"buffers are used to placehold I/O, they do inherently limit the amount of concurrent "
"I/O possible. However, as there are usually a few thousand filesystem buffers "
"available, this is not usually a problem."
msgstr ""
"O FreeBSD reserva uma quantidade limitada de KVM para conter os mapeamentos de "
"struct bufs, mas deve ficar claro que este KVM È usado apenas para manter "
"mapeamentos e n„o limita a capacidade de armazenar dados em cache. O cache de dados "
"fÌ≠sicos È estritamente uma funÁ„o de <literal> vm_page_t </literal> n„o s„o buffers "
"de sistema de arquivos. No entanto, como os buffers do sistema de arquivos s„o "
"usados ‚Äã‚Äãpara posicionar E / S, eles limitam inerentemente a quantidade de E / S "
"simultÌ¢nea possÌ≠vel. No entanto, como geralmente h· alguns milhares de buffers de "
"sistema de arquivos disponÌ≠veis, isso geralmente n„o È um problema. "

#: book.translate.xml:14645
#, fuzzy
msgid "Mapping Page Tables‚Äî<literal>vm_map_t, vm_entry_t</literal>"
msgstr "Mapping Page Tables‚Äî <literal> vm_map_t, vm_entry_t </literal> "

#: book.translate.xml:14648
#, fuzzy
msgid "<primary>page tables</primary>"
msgstr " <primary> tabelas de p·ginas </primary> "

#: book.translate.xml:14649
#, fuzzy
msgid ""
"FreeBSD separates the physical page table topology from the VM system. All hard per-"
"process page tables can be reconstructed on the fly and are usually considered "
"throwaway. Special page tables such as those managing KVM are typically permanently "
"preallocated. These page tables are not throwaway."
msgstr ""
"O FreeBSD separa a topologia da tabela de p·ginas fÌ≠sicas do sistema VM. Todas as "
"tabelas de p·ginas difÌ≠ceis por processo podem ser reconstruÌ≠das rapidamente e s„o "
"geralmente consideradas descart·veis. Tabelas de p·ginas especiais como aquelas que "
"gerenciam KVM s„o tipicamente prÈ-alocadas permanentemente. jogar fora."

#: book.translate.xml:14656
#, fuzzy
msgid ""
"FreeBSD associates portions of vm_objects with address ranges in virtual memory "
"through <literal>vm_map_t</literal> and <literal>vm_entry_t</literal> structures. "
"Page tables are directly synthesized from the <literal>vm_map_t</literal>/"
"<literal>vm_entry_t</literal>/ <literal>vm_object_t</literal> hierarchy. Recall that "
"I mentioned that physical pages are only directly associated with a "
"<literal>vm_object</literal>; that is not quite true. <literal>vm_page_t</literal>'s "
"are also linked into page tables that they are actively associated with. One "
"<literal>vm_page_t</literal> can be linked into several <emphasis>pmaps</emphasis>, "
"as page tables are called. However, the hierarchical association holds, so all "
"references to the same page in the same object reference the same "
"<literal>vm_page_t</literal> and thus give us buffer cache unification across the "
"board."
msgstr ""
"O FreeBSD associa porÁÌµes de vm_objects com intervalos de endereÁo na memÛria "
"virtual atravÈs de <literal> vm_map_t </literal> e <literal> vm_entry_t </literal> "
"estruturas. Tabelas de p·gina s„o diretamente sintetizadas a partir do <literal> "
"vm_map_t </literal> / <literal> vm_entry_t </literal> / <literal> vm_object_t </"
"literal> hierarquia. Lembre-se de que mencionei que as p·ginas fÌ≠sicas s„o "
"associadas diretamente a <literal> vm_object </literal> ; isso n„o È bem verdade. "
"<literal> vm_page_t </literal> tambÈm est„o ligados a tabelas de p·ginas com as "
"quais est„o ativamente associados. 1 <literal> vm_page_t </literal> pode ser ligado "
"em v·rios <emphasis> pmaps </emphasis> , como as tabelas de p·ginas s„o chamadas. No "
"entanto, a associaÁ„o hier·rquica È v·lida, portanto, todas as referÍncias Ì† mesma "
"p·gina no mesmo objeto fazem referÍncia ao mesmo <literal> vm_page_t </literal> e "
"assim nos dar a unificaÁ„o do cache de buffer atravÈs da placa. "

#: book.translate.xml:14675
#, fuzzy
msgid "KVM Memory Mapping"
msgstr "Mapeamento de memÛria KVM"

#: book.translate.xml:14677
#, fuzzy
msgid ""
"FreeBSD uses KVM to hold various kernel structures. The single largest entity held "
"in KVM is the filesystem buffer cache. That is, mappings relating to <literal>struct "
"buf</literal> entities."
msgstr ""
"O FreeBSD usa o KVM para armazenar v·rias estruturas de kernel. A maior entidade "
"individual mantida no KVM È o cache de buffer do sistema de arquivos. Ou seja, "
"mapeamentos relacionados a <literal> struct buf </literal> entidades."

#: book.translate.xml:14682
#, fuzzy
msgid ""
"Unlike Linux, FreeBSD does <emphasis>not</emphasis> map all of physical memory into "
"KVM. This means that FreeBSD can handle memory configurations up to 4G on 32 bit "
"platforms. In fact, if the mmu were capable of it, FreeBSD could theoretically "
"handle memory configurations up to 8TB on a 32 bit platform. However, since most 32 "
"bit platforms are only capable of mapping 4GB of ram, this is a moot point."
msgstr ""
"Ao contr·rio do Linux, o FreeBSD faz <emphasis> n„o </emphasis> mapear toda a "
"memÛria fÌ≠sica para o KVM. Isso significa que o FreeBSD pode manipular "
"configuraÁÌµes de memÛria de atÈ 4G em plataformas de 32 bits. De fato, se o mmu "
"fosse capaz disso, o FreeBSD teoricamente poderia manipular configuraÁÌµes de "
"memÛria de atÈ 8 TB em uma plataforma de 32 bits. No entanto, como a maioria das "
"plataformas de 32 bits sÛ È capaz de mapear 4 GB de RAM, isso È um ponto discutÌ≠vel. "

#: book.translate.xml:14690
#, fuzzy
msgid ""
"KVM is managed through several mechanisms. The main mechanism used to manage KVM is "
"the <emphasis>zone allocator</emphasis>. The zone allocator takes a chunk of KVM and "
"splits it up into constant-sized blocks of memory in order to allocate a specific "
"type of structure. You can use <command>vmstat -m</command> to get an overview of "
"current KVM utilization broken down by zone."
msgstr ""
"O KVM È gerenciado atravÈs de v·rios mecanismos. O principal mecanismo usado para "
"gerenciar o KVM È o <emphasis> alocador de zona </emphasis> . O alocador de zona "
"pega um pedaÁo do KVM e o divide em blocos de memÛria de tamanho constante para "
"alocar um tipo especÌ≠fico de estrutura. VocÍ pode usar <command> vmstat -m </"
"command> para obter uma vis„o geral da utilizaÁ„o atual da KVM dividida por zona. "

#: book.translate.xml:14700
#, fuzzy
msgid "Tuning the FreeBSD VM System"
msgstr "Ajustando o sistema VM do FreeBSD"

#: book.translate.xml:14702
#, fuzzy
msgid ""
"A concerted effort has been made to make the FreeBSD kernel dynamically tune itself. "
"Typically you do not need to mess with anything beyond the <option>maxusers</option> "
"and <option>NMBCLUSTERS</option> kernel config options. That is, kernel compilation "
"options specified in (typically) <filename>/usr/src/sys/i386/conf/"
"<replaceable>CONFIG_FILE</replaceable></filename>. A description of all available "
"kernel configuration options can be found in <filename>/usr/src/sys/i386/conf/LINT</"
"filename>."
msgstr ""
"Um esforÁo concentrado foi feito para fazer o kernel do FreeBSD se ajustar "
"dinamicamente. Normalmente vocÍ n„o precisa mexer com nada alÈm do <option "
"value=maxusers> maxusers </option> e <option value=NMBCLUSTERS> NMBCLUSTERS </"
"option> opÁÌµes de configuraÁ„o do kernel. Isto È, opÁÌµes de compilaÁ„o do kernel "
"especificadas em (tipicamente) <filename> / usr / src / sys / i386 / conf / "
"<replaceable> CONFIG_FILE </replaceable></filename> . Uma descriÁ„o de todas as "
"opÁÌµes de configuraÁ„o do kernel disponÌ≠veis pode ser encontrada em <filename> / "
"usr / src / sys / i386 / conf / LINT </filename> "

#: book.translate.xml:14712
#, fuzzy
msgid ""
"In a large system configuration you may wish to increase <option>maxusers</option>. "
"Values typically range from 10 to 128. Note that raising <option>maxusers</option> "
"too high can cause the system to overflow available KVM resulting in unpredictable "
"operation. It is better to leave <option>maxusers</option> at some reasonable number "
"and add other options, such as <option>NMBCLUSTERS</option>, to increase specific "
"resources."
msgstr ""
"Em uma grande configuraÁ„o do sistema, vocÍ pode querer aumentar <option "
"value=maxusers> maxusers </option> . Os valores geralmente variam de 10 a 128. "
"Observe que aumentar <option value=maxusers> maxusers </option> muito alto pode "
"fazer com que o sistema transborde KVM disponÌ≠vel, resultando em operaÁ„o imprevisÌ≠"
"vel. Ìâ melhor deixar <option value=maxusers> maxusers </option> em algum n˙mero "
"razo·vel e adicionar outras opÁÌµes, como <option value=NMBCLUSTERS> NMBCLUSTERS </"
"option> , para aumentar recursos especÌ≠ficos \""

#: book.translate.xml:14721
#, fuzzy
msgid ""
"If your system is going to use the network heavily, you may want to increase "
"<option>NMBCLUSTERS</option>. Typical values range from 1024 to 4096."
msgstr ""
"Se o seu sistema vai usar a rede pesadamente, vocÍ pode querer aumentar <option "
"value=NMBCLUSTERS> NMBCLUSTERS </option> . Valores tÌ≠picos variam de 1024 a 4096. "

#: book.translate.xml:14725
#, fuzzy
msgid ""
"The <literal>NBUF</literal> parameter is also traditionally used to scale the "
"system. This parameter determines the amount of KVA the system can use to map "
"filesystem buffers for I/O. Note that this parameter has nothing whatsoever to do "
"with the unified buffer cache! This parameter is dynamically tuned in 3.0-CURRENT "
"and later kernels and should generally not be adjusted manually. We recommend that "
"you <emphasis>not</emphasis> try to specify an <literal>NBUF</literal> parameter. "
"Let the system pick it. Too small a value can result in extremely inefficient "
"filesystem operation while too large a value can starve the page queues by causing "
"too many pages to become wired down."
msgstr ""
"O <literal> NBUF </literal> parÌ¢metro tambÈm È tradicionalmente usado para "
"dimensionar o sistema. Esse parÌ¢metro determina a quantidade de KVA que o sistema "
"pode usar para mapear buffers de sistema de arquivos para E / S. Note que este parÌ"
"¢metro n„o tem nada a ver com o cache de buffer unificado! Este parÌ¢metro È "
"dinamicamente ajustado nos kernels 3.0-CURRENT e posteriores e geralmente n„o deve "
"ser ajustado manualmente. Recomendamos que vocÍ <emphasis> n„o </emphasis> tente "
"especificar um <literal> NBUF </literal> parÌ¢metro. Deixe o sistema selecion·-lo. "
"Um valor muito pequeno pode resultar em operaÁ„o do sistema de arquivos extremamente "
"ineficiente, enquanto um valor muito grande pode prejudicar as filas de p·ginas, "
"fazendo com que muitas p·ginas fiquem inativas. "

#: book.translate.xml:14738
#, fuzzy
msgid ""
"By default, FreeBSD kernels are not optimized. You can set debugging and "
"optimization flags with the <literal>makeoptions</literal> directive in the kernel "
"configuration. Note that you should not use <option>-g</option> unless you can "
"accommodate the large (typically 7 MB+) kernels that result."
msgstr ""
"Por padr„o, os kernels do FreeBSD n„o s„o otimizados. VocÍ pode definir "
"sinalizadores de depuraÁ„o e otimizaÁ„o com o <literal> makeoptions </literal> "
"diretiva na configuraÁ„o do kernel. Note que vocÍ n„o deve usar <option value=-g> -g "
"</option> a menos que vocÍ possa acomodar os kernels grandes (normalmente de 7 MB +) "
"resultantes. "

#: book.translate.xml:14748
#, fuzzy
msgid ""
"Sysctl provides a way to tune kernel parameters at run-time. You typically do not "
"need to mess with any of the sysctl variables, especially the VM related ones."
msgstr ""
"O Sysctl fornece uma maneira de ajustar os parÌ¢metros do kernel em tempo de "
"execuÁ„o. VocÍ normalmente n„o precisa mexer em nenhuma das vari·veis ‚Äã‚Äãdo sysctl, "
"especialmente aquelas relacionadas Ì† VM."

#: book.translate.xml:14752
#, fuzzy
msgid ""
"Run time VM and system tuning is relatively straightforward. First, use Soft Updates "
"on your UFS/FFS filesystems whenever possible. <filename>/usr/src/sys/ufs/ffs/README."
"softupdates</filename> contains instructions (and restrictions) on how to configure "
"it."
msgstr ""
"A VM de tempo de execuÁ„o e o ajuste do sistema s„o relativamente diretos. Primeiro, "
"use as Soft Updates nos seus sistemas de arquivos UFS / FFS sempre que possÌ≠vel. "
"<filename> /usr/src/sys/ufs/ffs/README.softupdates </filename> contÈm instruÁÌµes (e "
"restriÁÌµes) sobre como configur·-lo. "

#: book.translate.xml:14759
#, fuzzy
msgid "<primary>swap partition</primary>"
msgstr " <primary> partiÁ„o swap </primary> "

#: book.translate.xml:14760
#, fuzzy
msgid ""
"Second, configure sufficient swap. You should have a swap partition configured on "
"each physical disk, up to four, even on your <quote>work</quote> disks. You should "
"have at least 2x the swap space as you have main memory, and possibly even more if "
"you do not have a lot of memory. You should also size your swap partition based on "
"the maximum memory configuration you ever intend to put on the machine so you do not "
"have to repartition your disks later on. If you want to be able to accommodate a "
"crash dump, your first swap partition must be at least as large as main memory and "
"<filename>/var/crash</filename> must have sufficient free space to hold the dump."
msgstr ""
"Segundo, configure uma troca suficiente. VocÍ deve ter uma partiÁ„o swap configurada "
"em cada disco fÌ≠sico, atÈ quatro, mesmo no seu <quote> trabalhos </quote> discos. "
"VocÍ deve ter pelo menos 2x o espaÁo de troca como vocÍ tem memÛria principal, e "
"possivelmente ainda mais se vocÍ n„o tiver muita memÛria. VocÍ tambÈm deve "
"dimensionar sua partiÁ„o de troca com base na configuraÁ„o m·xima de memÛria que "
"vocÍ pretende colocar na m·quina para que n„o seja necess·rio reparticionar seus "
"discos posteriormente. Se vocÍ quiser ser capaz de acomodar um despejo de memÛria, "
"sua primeira partiÁ„o de troca deve ser pelo menos t„o grande quanto a memÛria "
"principal e <filename> / var / crash </filename> deve ter espaÁo livre suficiente "
"para guardar o lixo. "

#: book.translate.xml:14772
#, fuzzy
msgid ""
"NFS-based swap is perfectly acceptable on 4.X or later systems, but you must be "
"aware that the NFS server will take the brunt of the paging load."
msgstr ""
"A troca baseada em NFS È perfeitamente aceit·vel em sistemas 4.X ou posteriores, mas "
"vocÍ deve estar ciente de que o servidor NFS ir· receber o peso da carga de "
"paginaÁ„o."

#: book.translate.xml:14786
#, fuzzy
msgid "SMPng Design Document"
msgstr "Documento de Projeto SMPng"

#: book.translate.xml:14788
#, fuzzy
msgid ""
"<personname><firstname>John</firstname><surname>Baldwin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> John </firstname><surname> Baldwin </surname></"
"personname><contrib> Escrito por </contrib> "

#: book.translate.xml:14789
#, fuzzy
msgid "<personname><firstname>Robert</firstname><surname>Watson</surname></personname>"
msgstr ""
" <personname><firstname> Robert </firstname><surname> Watson </surname></personname> "

#: book.translate.xml:14792
#, fuzzy
msgid ""
"<year>2002</year> <year>2004</year> <year>2005</year> <holder>John Baldwin</holder> "
"<holder>Robert Watson</holder>"
msgstr ""
" <year> 2002 </year><year> 2004 </year><year> 2005 </year><holder> John Baldwin </"
"holder><holder> Robert Watson </holder> "

#: book.translate.xml:14806
#, fuzzy
msgid "<primary>SMP Next Generation</primary>"
msgstr " <primary> SMP Next Generation </primary> "

#: book.translate.xml:14807
#, fuzzy
msgid "<primary>kernel synchronization</primary>"
msgstr " <primary> sincronizaÁ„o do kernel </primary> "

#: book.translate.xml:14809
#, fuzzy
msgid ""
"This document presents the current design and implementation of the SMPng "
"Architecture. First, the basic primitives and tools are introduced. Next, a general "
"architecture for the FreeBSD kernel's synchronization and execution model is laid "
"out. Then, locking strategies for specific subsystems are discussed, documenting the "
"approaches taken to introduce fine-grained synchronization and parallelism for each "
"subsystem. Finally, detailed implementation notes are provided to motivate design "
"choices, and make the reader aware of important implications involving the use of "
"specific primitives."
msgstr ""
"Este documento apresenta o projeto atual e a implementaÁ„o da Arquitetura SMPng. "
"Primeiro, as primitivas e ferramentas b·sicas s„o apresentadas. Em seguida, È "
"apresentada uma arquitetura geral para o modelo de execuÁ„o e sincronizaÁ„o do "
"kernel do FreeBSD. Ent„o, estratÈgias de bloqueio para subsistemas especÌ≠ficos s„o "
"discutidas. , documentando as abordagens adotadas para introduzir sincronizaÁ„o e "
"paralelismo de alta granularidade para cada subsistema. Finalmente, notas de "
"implementaÁ„o detalhadas s„o fornecidas para motivar as escolhas de design e tornar "
"o leitor ciente de implicaÁÌµes importantes envolvendo o uso de primitivos especÌ≠"
"ficos. "

#: book.translate.xml:14820
#, fuzzy
msgid ""
"This document is a work-in-progress, and will be updated to reflect on-going design "
"and implementation activities associated with the SMPng Project. Many sections "
"currently exist only in outline form, but will be fleshed out as work proceeds. "
"Updates or suggestions regarding the document may be directed to the document "
"editors."
msgstr ""
"Este documento È um trabalho em andamento e ser· atualizado para refletir as "
"atividades de projeto e implementaÁ„o associadas ao Projeto SMPng. Muitas seÁÌµes "
"existem atualmente apenas em forma de tÛpicos, mas ser„o desenvolvidas Ì† medida que "
"o trabalho prossegue. AtualizaÁÌµes ou sugestÌµes relativas ao documento podem ser "
"direcionadas aos editores de documentos. "

#: book.translate.xml:14827
#, fuzzy
msgid "<primary>concurrency</primary>"
msgstr " <primary> simultaneidade </primary> "

#: book.translate.xml:14828
#, fuzzy
msgid ""
"The goal of SMPng is to allow concurrency in the kernel. The kernel is basically one "
"rather large and complex program. To make the kernel multi-threaded we use some of "
"the same tools used to make other programs multi-threaded. These include mutexes, "
"shared/exclusive locks, semaphores, and condition variables. For the definitions of "
"these and other SMP-related terms, please see the <xref linkend=\"smp-glossary\"/> "
"section of this article."
msgstr ""
"O objetivo do SMPng È permitir a simultaneidade no kernel. O kernel È basicamente um "
"programa bastante grande e complexo. Para fazer o kernel multi-threaded usamos "
"algumas das mesmas ferramentas usadas para fazer outros programas multi-threaded. "
"Estes incluem mutexes , bloqueios compartilhados / exclusivos, sem·foros e vari·veis "
"‚Äã‚Äãde condiÁ„o. Para as definiÁÌµes desses e de outros termos relacionados a PMS, "
"consulte <xref linkend=\"smp-glossary\"/> seÁ„o deste artigo. "

#: book.translate.xml:14838
#, fuzzy
msgid "Basic Tools and Locking Fundamentals"
msgstr "Ferramentas B·sicas e Fundamentos de Bloqueio"

#: book.translate.xml:14841
#, fuzzy
msgid "Atomic Instructions and Memory Barriers"
msgstr "InstruÁÌµes atÌ¥micas e barreiras de memÛria"

#: book.translate.xml:14843
#, fuzzy
msgid "<primary>atomic instructions</primary>"
msgstr " <primary> instruÁÌµes atÌ¥micas </primary> "

#: book.translate.xml:14844
#, fuzzy
msgid "<primary>memory barriers</primary>"
msgstr " <primary> barreiras de memÛria </primary> "

#: book.translate.xml:14846
#, fuzzy
msgid ""
"There are several existing treatments of memory barriers and atomic instructions, so "
"this section will not include a lot of detail. To put it simply, one can not go "
"around reading variables without a lock if a lock is used to protect writes to that "
"variable. This becomes obvious when you consider that memory barriers simply "
"determine relative order of memory operations; they do not make any guarantee about "
"timing of memory operations. That is, a memory barrier does not force the contents "
"of a CPU's local cache or store buffer to flush. Instead, the memory barrier at lock "
"release simply ensures that all writes to the protected data will be visible to "
"other CPU's or devices if the write to release the lock is visible. The CPU is free "
"to keep that data in its cache or store buffer as long as it wants. However, if "
"another CPU performs an atomic instruction on the same datum, the first CPU must "
"guarantee that the updated value is made visible to the second CPU along with any "
"other operations that memory barriers may require."
msgstr ""
"H· v·rios tratamentos existentes de barreiras de memÛria e instruÁÌµes atÌ¥micas, "
"portanto esta seÁ„o n„o incluir· muitos detalhes. Para simplificar, n„o È possÌ≠vel "
"ler vari·veis ‚Äã‚Äãsem um bloqueio se um bloqueio for usado para proteger as gravaÁÌµes "
"nessa vari·vel Isso fica Ûbvio quando vocÍ considera que as barreiras de memÛria "
"simplesmente determinam a ordem relativa das operaÁÌµes de memÛria, elas n„o "
"garantem o tempo das operaÁÌµes de memÛria, ou seja, uma barreira de memÛria n„o "
"forÁa o conte˙do do cache local Em vez disso, a barreira de memÛria na liberaÁ„o de "
"bloqueio simplesmente garante que todas as gravaÁÌµes nos dados protegidos ficar„o "
"visÌ≠veis para outras CPUs ou dispositivos, se a gravaÁ„o para liberar o bloqueio "
"estiver visÌ≠vel.A CPU est· livre para manter esses dados em seu cache ou armazenar "
"Entretanto, se outra CPU executar uma instruÁ„o atÌ¥mica no mesmo datum, a primeira "
"CPU deve garantir que o valor atualizado fique visÌ≠vel para a segunda CPU junto com "
"qualquer outra operaÁ„o. ns que as barreiras de memÛria podem exigir. "

#: book.translate.xml:14865
#, fuzzy
msgid ""
"For example, assuming a simple model where data is considered visible when it is in "
"main memory (or a global cache), when an atomic instruction is triggered on one CPU, "
"other CPU's store buffers and caches must flush any writes to that same cache line "
"along with any pending operations behind a memory barrier."
msgstr ""
"Por exemplo, supondo um modelo simples em que os dados s„o considerados visÌ≠veis "
"quando est„o na memÛria principal (ou em um cache global), quando uma instruÁ„o atÌ"
"¥mica È acionada em uma CPU, os buffers e caches de armazenamento de outra CPU "
"precisam liberar as gravaÁÌµes para o mesmo cache linha junto com quaisquer "
"operaÁÌµes pendentes por tr·s de uma barreira de memÛria. "

#: book.translate.xml:14872
#, fuzzy
msgid ""
"This requires one to take special care when using an item protected by atomic "
"instructions. For example, in the sleep mutex implementation, we have to use an "
"<function>atomic_cmpset</function> rather than an <function>atomic_set</function> to "
"turn on the <constant>MTX_CONTESTED</constant> bit. The reason is that we read the "
"value of <varname remap=\"structfield\">mtx_lock</varname> into a variable and then "
"make a decision based on that read. However, the value we read may be stale, or it "
"may change while we are making our decision. Thus, when the <function>atomic_set</"
"function> executed, it may end up setting the bit on another value than the one we "
"made the decision on. Thus, we have to use an <function>atomic_cmpset</function> to "
"set the value only if the value we made the decision on is up-to-date and valid."
msgstr ""
"Isso requer um cuidado especial ao usar um item protegido por instruÁÌµes atÌ¥micas. "
"Por exemplo, na implementaÁ„o do mutex de suspens„o, temos que usar um <function> "
"atomic_cmpset </function> em vez de um <function> atomic_set </function> para ligar "
"o <constant> MTX_CONTESTED </constant> pouco. A raz„o È que lemos o valor de "
"<varname remap=\"structfield\"> mtx_lock </varname> em uma vari·vel e, em seguida, "
"tomar uma decis„o com base nessa leitura. No entanto, o valor que lemos pode estar "
"obsoleto ou pode mudar enquanto tomamos nossa decis„o. Assim, quando o <function> "
"atomic_set </function> executado, pode acabar definindo o bit em outro valor "
"diferente daquele em que tomamos a decis„o. Assim, temos que usar um <function> "
"atomic_cmpset </function> para definir o valor apenas se o valor em que tomamos a "
"decis„o estiver atualizado e v·lido. "

#: book.translate.xml:14889
#, fuzzy
msgid ""
"Finally, atomic instructions only allow one item to be updated or read. If one needs "
"to atomically update several items, then a lock must be used instead. For example, "
"if two counters must be read and have values that are consistent relative to each "
"other, then those counters must be protected by a lock rather than by separate "
"atomic instructions."
msgstr ""
"Finalmente, as instruÁÌµes atÌ¥micas permitem apenas que um item seja atualizado ou "
"lido. Se for necess·rio atualizar atomicamente v·rios itens, um bloqueio deve ser "
"usado. Por exemplo, se dois contadores precisarem ser lidos e ter valores "
"consistentes em relaÁ„o a cada item outros, ent„o esses contadores devem ser "
"protegidos por um bloqueio, e n„o por instruÁÌµes atÌ¥micas separadas. "

#: book.translate.xml:14898
#, fuzzy
msgid "Read Locks Versus Write Locks"
msgstr "Ler bloqueios versus bloqueios de gravaÁ„o"

#: book.translate.xml:14900
#, fuzzy
msgid "<primary>read locks</primary>"
msgstr " <primary> leia bloqueios </primary> "

#: book.translate.xml:14901
#, fuzzy
msgid "<primary>write locks</primary>"
msgstr " <primary> escrever bloqueios </primary> "

#: book.translate.xml:14902
#, fuzzy
msgid ""
"Read locks do not need to be as strong as write locks. Both types of locks need to "
"ensure that the data they are accessing is not stale. However, only write access "
"requires exclusive access. Multiple threads can safely read a value. Using different "
"types of locks for reads and writes can be implemented in a number of ways."
msgstr ""
"Os bloqueios de leitura n„o precisam ser t„o fortes quanto os bloqueios de gravaÁ„o. "
"Os dois tipos de bloqueios precisam garantir que os dados que est„o acessando n„o "
"sejam obsoletos. No entanto, somente o acesso de gravaÁ„o requer acesso exclusivo. "
"V·rios segmentos podem ler um valor com seguranÁa. tipos de bloqueios para leituras "
"e gravaÁÌµes podem ser implementados de v·rias maneiras. "

#: book.translate.xml:14909
#, fuzzy
msgid ""
"First, sx locks can be used in this manner by using an exclusive lock when writing "
"and a shared lock when reading. This method is quite straightforward."
msgstr ""
"Primeiro, os bloqueios sx podem ser usados ‚Äã‚Äãdessa maneira usando um bloqueio "
"exclusivo ao escrever e um bloqueio compartilhado durante a leitura. Esse mÈtodo È "
"bastante simples."

#: book.translate.xml:14913
#, fuzzy
msgid ""
"A second method is a bit more obscure. You can protect a datum with multiple locks. "
"Then for reading that data you simply need to have a read lock of one of the locks. "
"However, to write to the data, you need to have a write lock of all of the locks. "
"This can make writing rather expensive but can be useful when data is accessed in "
"various ways. For example, the parent process pointer is protected by both the "
"<varname>proctree_lock</varname> sx lock and the per-process mutex. Sometimes the "
"proc lock is easier as we are just checking to see who a parent of a process is that "
"we already have locked. However, other places such as <function>inferior</function> "
"need to walk the tree of processes via parent pointers and locking each process "
"would be prohibitive as well as a pain to guarantee that the condition you are "
"checking remains valid for both the check and the actions taken as a result of the "
"check."
msgstr ""
"Um segundo mÈtodo È um pouco mais obscuro. VocÍ pode proteger um datum com v·rios "
"bloqueios. Em seguida, para ler esses dados, basta ter um bloqueio de leitura de um "
"dos bloqueios. No entanto, para gravar os dados, vocÍ precisa ter um bloqueio de "
"gravaÁ„o de todos os bloqueios. Isso pode tornar a escrita bastante cara, mas pode "
"ser ˙til quando os dados s„o acessados ‚Äã‚Äãde v·rias maneiras. Por exemplo, o ponteiro "
"de processo pai È protegido por ambos <varname> proctree_lock </varname> sx lock e o "
"mutex por processo. ÌÄs vezes, o proc lock È mais f·cil, pois estamos apenas "
"verificando quem È pai de um processo e j· estamos bloqueados. PorÈm, outros lugares "
"como <function> inferior </function> precisa percorrer a ·rvore de processos atravÈs "
"de ponteiros pai e bloquear cada processo seria proibitivo, assim como uma dor para "
"garantir que a condiÁ„o que vocÍ est· verificando permaneÁa v·lida tanto para a "
"verificaÁ„o quanto para as aÁÌµes tomadas como resultado da verificaÁ„o. "

#: book.translate.xml:14932
#, fuzzy
msgid "Locking Conditions and Results"
msgstr "CondiÁÌµes de bloqueio e resultados"

#: book.translate.xml:14934
#, fuzzy
msgid ""
"If you need a lock to check the state of a variable so that you can take an action "
"based on the state you read, you can not just hold the lock while reading the "
"variable and then drop the lock before you act on the value you read. Once you drop "
"the lock, the variable can change rendering your decision invalid. Thus, you must "
"hold the lock both while reading the variable and while performing the action as a "
"result of the test."
msgstr ""
"Se vocÍ precisa de um bloqueio para verificar o estado de uma vari·vel para que "
"possa realizar uma aÁ„o com base no estado que vocÍ leu, n„o È possÌ≠vel manter o "
"bloqueio enquanto lÍ a vari·vel e soltar o bloqueio antes de agir no valor que vocÍ "
"Uma vez que vocÍ soltar o bloqueio, a vari·vel pode mudar tornando sua decis„o "
"inv·lida. Assim, vocÍ deve manter o bloqueio tanto durante a leitura da vari·vel e "
"durante a execuÁ„o da aÁ„o como resultado do teste. "

#: book.translate.xml:14946
#, fuzzy
msgid "General Architecture and Design"
msgstr "Arquitetura Geral e Design"

#: book.translate.xml:14949
#, fuzzy
msgid "Interrupt Handling"
msgstr "Interrupt Handling"

#: book.translate.xml:14951
#, fuzzy
msgid "<primary>interrupt handling</primary>"
msgstr " <primary> manuseio de interrupÁÌµes </primary> "

#: book.translate.xml:14953
#, fuzzy
msgid ""
"Following the pattern of several other multi-threaded <trademark class=\"registered"
"\">UNIX</trademark> kernels, FreeBSD deals with interrupt handlers by giving them "
"their own thread context. Providing a context for interrupt handlers allows them to "
"block on locks. To help avoid latency, however, interrupt threads run at real-time "
"kernel priority. Thus, interrupt handlers should not execute for very long to avoid "
"starving other kernel threads. In addition, since multiple handlers may share an "
"interrupt thread, interrupt handlers should not sleep or use a sleepable lock to "
"avoid starving another interrupt handler."
msgstr ""
"Seguindo o padr„o de v·rios outros multi-threaded <trademark class=\"registered\"> "
"UNIX </trademark> kernels, o FreeBSD lida com manipuladores de interrupÁ„o, dando-"
"lhes seu prÛprio contexto de encadeamento. Fornecer um contexto para os "
"manipuladores de interrupÁ„o permite bloquear bloqueios. Para ajudar a evitar a "
"latÍncia, no entanto, os threads de interrupÁ„o s„o executados na prioridade do "
"kernel em tempo real. Assim, os manipuladores de interrupÁ„o n„o devem ser "
"executados por muito tempo para evitar que outros segmentos do kernel fiquem com "
"fome. AlÈm disso, como v·rios manipuladores podem compartilhar um encadeamento de "
"interrupÁ„o, os manipuladores de interrupÁ„o n„o devem dormir ou usar um bloqueio "
"adormecido para evitar passar fome a outro manipulador de interrupÁ„o. "

#: book.translate.xml:14964
#, fuzzy
msgid "<primary>interrupt threads</primary>"
msgstr " <primary> interromper tÛpicos </primary> "

#: book.translate.xml:14966
#, fuzzy
msgid ""
"The interrupt threads currently in FreeBSD are referred to as heavyweight interrupt "
"threads. They are called this because switching to an interrupt thread involves a "
"full context switch. In the initial implementation, the kernel was not preemptive "
"and thus interrupts that interrupted a kernel thread would have to wait until the "
"kernel thread blocked or returned to userland before they would have an opportunity "
"to run."
msgstr ""
"Os threads de interrupÁ„o atualmente no FreeBSD s„o chamados de threads de "
"interrupÁ„o de peso. Eles s„o chamados porque mudar para um thread de interrupÁ„o "
"envolve um switch de contexto completo. Na implementaÁ„o inicial, o kernel n„o era "
"preemptivo e assim interrupÁÌµes que interrompiam um thread do kernel tem que "
"esperar atÈ que o thread do kernel seja bloqueado ou retornado ao userland antes que "
"eles tenham a oportunidade de executar. "

#: book.translate.xml:14975
#, fuzzy
msgid "<primary>latency</primary>"
msgstr " <primary> latÍncia </primary> "

#: book.translate.xml:14976
#, fuzzy
msgid "<primary>preemption</primary>"
msgstr " <primary> preempÁ„o </primary> "

#: book.translate.xml:14978
#, fuzzy
msgid ""
"To deal with the latency problems, the kernel in FreeBSD has been made preemptive. "
"Currently, we only preempt a kernel thread when we release a sleep mutex or when an "
"interrupt comes in. However, the plan is to make the FreeBSD kernel fully preemptive "
"as described below."
msgstr ""
"Para lidar com os problemas de latÍncia, o kernel do FreeBSD tornou-se preemptivo. "
"Atualmente, nÛs apenas preemptamos um thread do kernel quando lanÁamos um mutex de "
"suspens„o ou quando uma interrupÁ„o entra. No entanto, o plano È fazer com que o "
"kernel do FreeBSD seja totalmente preventivo. como descrito abaixo."

#: book.translate.xml:14984
#, fuzzy
msgid ""
"Not all interrupt handlers execute in a thread context. Instead, some handlers "
"execute directly in primary interrupt context. These interrupt handlers are "
"currently misnamed <quote>fast</quote> interrupt handlers since the "
"<constant>INTR_FAST</constant> flag used in earlier versions of the kernel is used "
"to mark these handlers. The only interrupts which currently use these types of "
"interrupt handlers are clock interrupts and serial I/O device interrupts. Since "
"these handlers do not have their own context, they may not acquire blocking locks "
"and thus may only use spin mutexes."
msgstr ""
"Nem todos os manipuladores de interrupÁ„o executam em um contexto de encadeamento. "
"Em vez disso, alguns manipuladores executam diretamente no contexto de interrupÁ„o "
"principal. Esses manipuladores de interrupÁ„o s„o atualmente atribuÌ≠dos "
"incorretamente <quote> velozes </quote> interromper manipuladores desde o <constant> "
"INTR_FAST </constant> flag usado em versÌµes anteriores do kernel È usado para "
"marcar esses manipuladores. As ˙nicas interrupÁÌµes que atualmente usam esses tipos "
"de interrupÁ„o s„o interrupÁÌµes de clock e interrupÁÌµes de dispositivos de E / S "
"serial. Como esses manipuladores n„o tÍm seu prÛprio contexto, eles podem n„o "
"adquirir bloqueios de bloqueio e, portanto, sÛ podem usar mutexes de rotaÁ„o. "

#: book.translate.xml:14996
#, fuzzy
msgid "<primary>context switches</primary>"
msgstr " <primary> comutadores de contexto </primary> "

#: book.translate.xml:14998
#, fuzzy
msgid ""
"Finally, there is one optional optimization that can be added in MD code called "
"lightweight context switches. Since an interrupt thread executes in a kernel "
"context, it can borrow the vmspace of any process. Thus, in a lightweight context "
"switch, the switch to the interrupt thread does not switch vmspaces but borrows the "
"vmspace of the interrupted thread. In order to ensure that the vmspace of the "
"interrupted thread does not disappear out from under us, the interrupted thread is "
"not allowed to execute until the interrupt thread is no longer borrowing its "
"vmspace. This can happen when the interrupt thread either blocks or finishes. If an "
"interrupt thread blocks, then it will use its own context when it is made runnable "
"again. Thus, it can release the interrupted thread."
msgstr ""
"Finalmente, h· uma otimizaÁ„o opcional que pode ser adicionada no cÛdigo MD, chamada "
"de comutadores de contexto leves. Como um thread de interrupÁ„o È executado em um "
"contexto de kernel, ele pode emprestar o vmspace de qualquer processo. Assim, em um "
"switch de contexto leve, o thread de interrupÁ„o n„o troca vmspaces, mas toma "
"emprestado o vmspace do thread interrompido.A fim de garantir que o vmspace do "
"thread interrompido n„o desapareÁa de debaixo de nÛs, o thread interrompido n„o tem "
"permiss„o para executar atÈ que o thread de interrupÁ„o n„o seja mais emprestando "
"seu vmspace. Isso pode acontecer quando o thread de interrupÁ„o bloqueia ou "
"finaliza. Se um thread de interrupÁ„o bloquear, ele usar· seu prÛprio contexto "
"quando for tornado execut·vel novamente. Assim, ele pode liberar o thread "
"interrompido. "

#: book.translate.xml:15013
#, fuzzy
msgid ""
"The cons of this optimization are that they are very machine specific and complex "
"and thus only worth the effort if their is a large performance improvement. At this "
"point it is probably too early to tell, and in fact, will probably hurt performance "
"as almost all interrupt handlers will immediately block on Giant and require a "
"thread fix-up when they block. Also, an alternative method of interrupt handling has "
"been proposed by Mike Smith that works like so:"
msgstr ""
"Os contras desta otimizaÁ„o s„o que eles s„o muito especÌ≠ficos da m·quina e "
"complexos e, portanto, sÛ valem o esforÁo se a sua for uma grande melhoria de "
"desempenho. Neste momento, È provavelmente cedo demais para dizer e, de fato, "
"provavelmente prejudicar· o desempenho como quase todos os manipuladores de "
"interrupÁÌµes bloquear„o imediatamente o Giant e exigir„o uma correÁ„o de thread "
"quando eles bloquearem. AlÈm disso, um mÈtodo alternativo de manipulaÁ„o de "
"interrupÁÌµes foi proposto por Mike Smith que funciona assim: "

#: book.translate.xml:15024
#, fuzzy
msgid ""
"Each interrupt handler has two parts: a predicate which runs in primary interrupt "
"context and a handler which runs in its own thread context."
msgstr ""
"Cada manipulador de interrupÁ„o tem duas partes: um predicado que È executado no "
"contexto de interrupÁ„o prim·rio e um manipulador que È executado em seu prÛprio "
"contexto de encadeamento."

#: book.translate.xml:15030
#, fuzzy
msgid ""
"If an interrupt handler has a predicate, then when an interrupt is triggered, the "
"predicate is run. If the predicate returns true then the interrupt is assumed to be "
"fully handled and the kernel returns from the interrupt. If the predicate returns "
"false or there is no predicate, then the threaded handler is scheduled to run."
msgstr ""
"Se um manipulador de interrupÁ„o tiver um predicado, quando uma interrupÁ„o for "
"disparada, o predicado ser· executado. Se o predicado retornar verdadeiro, presume-"
"se que a interrupÁ„o seja totalmente tratada e o kernel retorna da interrupÁ„o. Se o "
"predicado retornar falso ou n„o È um predicado, ent„o o manipulador encadeado est· "
"programado para ser executado. "

#: book.translate.xml:15039
#, fuzzy
msgid ""
"Fitting light weight context switches into this scheme might prove rather "
"complicated. Since we may want to change to this scheme at some point in the future, "
"it is probably best to defer work on light weight context switches until we have "
"settled on the final interrupt handling architecture and determined how light weight "
"context switches might or might not fit into it."
msgstr ""
"Ajustar contextos de peso leve a esse esquema pode ser um pouco complicado. Como "
"podemos querer mudar para esse esquema em algum momento no futuro, provavelmente È "
"melhor adiar o trabalho em interruptores de contexto de peso leve atÈ termos "
"resolvido a interrupÁ„o final. lidando com a arquitetura e determinando como as "
"chaves de contexto leves podem ou n„o se encaixar nela. "

#: book.translate.xml:15049
#, fuzzy
msgid "Kernel Preemption and Critical Sections"
msgstr "PreempÁ„o do kernel e seÁÌµes crÌ≠ticas"

#: book.translate.xml:15052
#, fuzzy
msgid "Kernel Preemption in a Nutshell"
msgstr "PreempÁ„o do kernel em poucas palavras"

#: book.translate.xml:15054
#, fuzzy
msgid ""
"Kernel preemption is fairly simple. The basic idea is that a CPU should always be "
"doing the highest priority work available. Well, that is the ideal at least. There "
"are a couple of cases where the expense of achieving the ideal is not worth being "
"perfect."
msgstr ""
"PreempÁ„o do kernel È bastante simples. A idÈia b·sica È que uma CPU deve sempre "
"estar fazendo o trabalho de maior prioridade disponÌ≠vel. Bem, isso È o ideal, pelo "
"menos. H· alguns casos em que a despesa de alcanÁar o ideal n„o vale a pena ser "
"perfeito."

#: book.translate.xml:15060
#, fuzzy
msgid ""
"Implementing full kernel preemption is very straightforward: when you schedule a "
"thread to be executed by putting it on a run queue, you check to see if its priority "
"is higher than the currently executing thread. If so, you initiate a context switch "
"to that thread."
msgstr ""
"Implementar preempÁ„o completa do kernel È muito simples: quando vocÍ programa um "
"encadeamento para ser executado colocando-o em uma fila de execuÁ„o, vocÍ verifica "
"se sua prioridade È maior do que o encadeamento atualmente em execuÁ„o. Nesse caso, "
"vocÍ inicia uma alternÌ¢ncia de contexto fio."

#: book.translate.xml:15066
#, fuzzy
msgid ""
"While locks can protect most data in the case of a preemption, not all of the kernel "
"is preemption safe. For example, if a thread holding a spin mutex preempted and the "
"new thread attempts to grab the same spin mutex, the new thread may spin forever as "
"the interrupted thread may never get a chance to execute. Also, some code such as "
"the code to assign an address space number for a process during <function>exec</"
"function> on the Alpha needs to not be preempted as it supports the actual context "
"switch code. Preemption is disabled for these code sections by using a critical "
"section."
msgstr ""
"Embora os bloqueios possam proteger a maioria dos dados no caso de uma preempÁ„o, "
"nem todo o kernel È protegido por preempÁ„o. Por exemplo, se um segmento que detÈm "
"um mutex de rotaÁ„o for antecipado e o novo thread tentar obter o mesmo mutex de "
"rotaÁ„o, o novo thread pode giram para sempre, pois o thread interrompido pode nunca "
"ter a chance de executar.TambÈm, algum cÛdigo como o cÛdigo para atribuir um n˙mero "
"de espaÁo de endereÁo para um processo durante <function> exec </function> no Alpha "
"n„o precisa ser preterido, pois suporta o cÛdigo de mudanÁa de contexto real. A "
"preempÁ„o est· desativada para essas seÁÌµes de cÛdigo usando uma seÁ„o crÌ≠tica. "

#: book.translate.xml:15080
#, fuzzy
msgid "Critical Sections"
msgstr "SecÁÌµes CrÌ≠ticas"

#: book.translate.xml:15204 book.translate.xml:15082
#, fuzzy
msgid "<primary>critical sections</primary>"
msgstr " <primary> seÁÌµes crÌ≠ticas </primary> "

#: book.translate.xml:15084
#, fuzzy
msgid ""
"The responsibility of the critical section API is to prevent context switches inside "
"of a critical section. With a fully preemptive kernel, every <function>setrunqueue</"
"function> of a thread other than the current thread is a preemption point. One "
"implementation is for <function>critical_enter</function> to set a per-thread flag "
"that is cleared by its counterpart. If <function>setrunqueue</function> is called "
"with this flag set, it does not preempt regardless of the priority of the new thread "
"relative to the current thread. However, since critical sections are used in spin "
"mutexes to prevent context switches and multiple spin mutexes can be acquired, the "
"critical section API must support nesting. For this reason the current "
"implementation uses a nesting count instead of a single per-thread flag."
msgstr ""
"A responsabilidade da API da seÁ„o crÌ≠tica È evitar interruptores de contexto dentro "
"de uma seÁ„o crÌ≠tica. Com um kernel totalmente preemptivo, cada <function> "
"setrunqueue </function> de um segmento diferente do segmento atual È um ponto de "
"preempÁ„o. Uma implementaÁ„o È para <function> critical_enter </function> para "
"definir um sinalizador por thread que È limpo por sua contraparte. E se <function> "
"setrunqueue </function> È chamado com este conjunto de sinalizadores, ele n„o se "
"antecipa independentemente da prioridade do novo encadeamento relativo ao "
"encadeamento atual. No entanto, como as seÁÌµes crÌ≠ticas s„o usadas em mutexes de "
"rotaÁ„o para evitar comutadores de contexto e v·rios mutexes de rotaÁ„o podem ser "
"adquiridos, a API de seÁ„o crÌ≠tica deve oferecer suporte ao aninhamento. Por esse "
"motivo, a implementaÁ„o atual usa uma contagem de aninhamento em vez de um ˙nico "
"sinalizador por thread. "

#: book.translate.xml:15100
#, fuzzy
msgid ""
"In order to minimize latency, preemptions inside of a critical section are deferred "
"rather than dropped. If a thread that would normally be preempted to is made "
"runnable while the current thread is in a critical section, then a per-thread flag "
"is set to indicate that there is a pending preemption. When the outermost critical "
"section is exited, the flag is checked. If the flag is set, then the current thread "
"is preempted to allow the higher priority thread to run."
msgstr ""
"Para minimizar a latÍncia, as preempÁÌµes dentro de uma seÁ„o crÌ≠tica s„o adiadas em "
"vez de descartadas. Se um encadeamento que normalmente seria precedido for tornado "
"execut·vel enquanto o encadeamento atual estiver em uma seÁ„o crÌ≠tica, um "
"sinalizador por encadeamento ser· definido como indica que h· uma preempÁ„o "
"pendente. Quando a seÁ„o crÌ≠tica mais externa È encerrada, o sinalizador È "
"verificado. Se o sinalizador estiver configurado, o encadeamento atual ser· "
"precedido para permitir que o encadeamento de maior prioridade seja executado. "

#: book.translate.xml:15110
#, fuzzy
msgid "<primary>spin mutexes</primary>"
msgstr " <primary> mutexes de spin </primary> "

#: book.translate.xml:15111
#, fuzzy
msgid "<primary>mutexes</primary><secondary>spin</secondary>"
msgstr " <primary> mutexes </primary><secondary> girar </secondary> "

#: book.translate.xml:15112
#, fuzzy
msgid ""
"Interrupts pose a problem with regards to spin mutexes. If a low-level interrupt "
"handler needs a lock, it needs to not interrupt any code needing that lock to avoid "
"possible data structure corruption. Currently, providing this mechanism is "
"piggybacked onto critical section API by means of the <function>cpu_critical_enter</"
"function> and <function>cpu_critical_exit</function> functions. Currently this API "
"disables and re-enables interrupts on all of FreeBSD's current platforms. This "
"approach may not be purely optimal, but it is simple to understand and simple to get "
"right. Theoretically, this second API need only be used for spin mutexes that are "
"used in primary interrupt context. However, to make the code simpler, it is used for "
"all spin mutexes and even all critical sections. It may be desirable to split out "
"the MD API from the MI API and only use it in conjunction with the MI API in the "
"spin mutex implementation. If this approach is taken, then the MD API likely would "
"need a rename to show that it is a separate API."
msgstr ""
"InterrupÁÌµes representam um problema com relaÁ„o a mutexes de rotaÁ„o. Se um "
"manipulador de interrupÁ„o de baixo nÌ≠vel precisar de um bloqueio, ele n„o precisar· "
"interromper nenhum cÛdigo que precise desse bloqueio para evitar possÌ≠vel corrupÁ„o "
"da estrutura de dados. Atualmente, fornecer esse mecanismo È inserido na seÁ„o crÌ≠"
"tica API por meio do <function> cpu_critical_enter </function> e <function> "
"cpu_critical_exit </function> funÁÌµes. Atualmente esta API desativa e reativa "
"interrupÁÌµes em todas as plataformas atuais do FreeBSD. Essa abordagem pode n„o ser "
"puramente ideal, mas È simples de entender e simples de acertar. Teoricamente, esta "
"segunda API sÛ precisa ser usada para mutexes de spin que s„o usados ‚Äã‚Äãno contexto "
"de interrupÁ„o prim·ria. No entanto, para tornar o cÛdigo mais simples, ele È usado "
"para todos os mutexes de spin e atÈ mesmo para todas as seÁÌµes crÌ≠ticas. Pode ser "
"desej·vel dividir a API do MD da API do MI e us·-la somente em conjunto com a API do "
"MI na implementaÁ„o do mutex de rotaÁ„o. Se essa abordagem for adotada, a API do MD "
"provavelmente precisaria de uma renomeaÁ„o para mostrar que È uma API separada. "

#: book.translate.xml:15134
#, fuzzy
msgid "Design Tradeoffs"
msgstr "Tradeoffs de design"

#: book.translate.xml:15136
#, fuzzy
msgid ""
"As mentioned earlier, a couple of trade-offs have been made to sacrifice cases where "
"perfect preemption may not always provide the best performance."
msgstr ""
"Como mencionado anteriormente, algumas compensaÁÌµes foram feitas para sacrificar "
"casos em que a preempÁ„o perfeita nem sempre fornece o melhor desempenho."

#: book.translate.xml:15140
#, fuzzy
msgid ""
"The first trade-off is that the preemption code does not take other CPUs into "
"account. Suppose we have a two CPU's A and B with the priority of A's thread as 4 "
"and the priority of B's thread as 2. If CPU B makes a thread with priority 1 "
"runnable, then in theory, we want CPU A to switch to the new thread so that we will "
"be running the two highest priority runnable threads. However, the cost of "
"determining which CPU to enforce a preemption on as well as actually signaling that "
"CPU via an IPI along with the synchronization that would be required would be "
"enormous. Thus, the current code would instead force CPU B to switch to the higher "
"priority thread. Note that this still puts the system in a better position as CPU B "
"is executing a thread of priority 1 rather than a thread of priority 2."
msgstr ""
"O primeiro trade-off È que o cÛdigo de preempÁ„o n„o leva em conta outras CPUs. "
"Suponha que tenhamos dois A e B de um processador com a prioridade do encadeamento "
"de A como 4 e a prioridade do encadeamento de B como 2. Se a CPU B fizer uma thread "
"com prioridade 1 execut·vel, ent„o, em teoria, queremos que a CPU A mude para o novo "
"thread, para que possamos executar os dois threads execut·veis ‚Äã‚Äãde maior "
"prioridade, mas o custo de determinar para qual CPU aplicar uma preempÁ„o, bem como "
"sinalizar que a CPU atravÈs de um IPI, juntamente com a sincronizaÁ„o que seria "
"necess·ria seria enorme.Assim, o cÛdigo atual, em vez forÁar CPU B para mudar para o "
"segmento de maior prioridade.Note que isso ainda coloca o sistema em uma posiÁ„o "
"melhor como CPU B est· executando um encadeamento de prioridade 1 em vez de um "
"encadeamento de prioridade 2. "

#: book.translate.xml:15155
#, fuzzy
msgid ""
"The second trade-off limits immediate kernel preemption to real-time priority kernel "
"threads. In the simple case of preemption defined above, a thread is always "
"preempted immediately (or as soon as a critical section is exited) if a higher "
"priority thread is made runnable. However, many threads executing in the kernel only "
"execute in a kernel context for a short time before either blocking or returning to "
"userland. Thus, if the kernel preempts these threads to run another non-realtime "
"kernel thread, the kernel may switch out the executing thread just before it is "
"about to sleep or execute. The cache on the CPU must then adjust to the new thread. "
"When the kernel returns to the preempted thread, it must refill all the cache "
"information that was lost. In addition, two extra context switches are performed "
"that could be avoided if the kernel deferred the preemption until the first thread "
"blocked or returned to userland. Thus, by default, the preemption code will only "
"preempt immediately if the higher priority thread is a real-time priority thread."
msgstr ""
"O segundo trade-off limita a preempÁ„o imediata do kernel a threads de kernel de "
"prioridade em tempo real. No caso simples de preempÁ„o definido acima, um thread È "
"sempre preempted imediatamente (ou assim que uma seÁ„o crÌ≠tica È encerrada) se um "
"thread de prioridade mais alta for No entanto, muitos threads executados no kernel "
"sÛ executam em um contexto de kernel por um curto perÌ≠odo de tempo antes de bloquear "
"ou retornar a userland. O thread na CPU deve ent„o se ajustar ao novo thread.Quando "
"o kernel retorna para o thread preempted, ele deve preencher todas as informaÁÌµes "
"do cache que foram perdidas.AlÈm disso, o thread em execuÁ„o antes da hora de dormir "
"ou executar. duas opÁÌµes de contexto extras s„o executadas, o que poderia ser "
"evitado se o kernel adiasse a preempÁ„o atÈ que o primeiro thread fosse bloqueado ou "
"retornado Ì† userland. Assim, por padr„o, o cÛdigo de preempÁ„o sÛ se antecipar· "
"imediatamente se o thread de prioridade mais alta È um thread de prioridade em tempo "
"real. "

#: book.translate.xml:15175
#, fuzzy
msgid ""
"Turning on full kernel preemption for all kernel threads has value as a debugging "
"aid since it exposes more race conditions. It is especially useful on UP systems "
"were many races are hard to simulate otherwise. Thus, there is a kernel option "
"<literal>FULL_PREEMPTION</literal> to enable preemption for all kernel threads that "
"can be used for debugging purposes."
msgstr ""
"Ativar a preempÁ„o total do kernel para todos os encadeamentos do kernel tem valor "
"como um auxÌ≠lio de depuraÁ„o, pois expÌµe mais condiÁÌµes de corrida. Ìâ "
"especialmente ˙til em sistemas UP, pois muitas corridas s„o difÌ≠ceis de serem "
"simuladas. Assim, h· uma opÁ„o de kernel <literal> FULL_PREEMPTION </literal> para "
"ativar a preempÁ„o para todos os encadeamentos do kernel que podem ser usados ‚Äã‚Äãpara "
"propÛsitos de depuraÁ„o. "

#: book.translate.xml:15186
#, fuzzy
msgid "Thread Migration"
msgstr "Thread Migration"

#: book.translate.xml:15188
#, fuzzy
msgid "<primary>thread migration</primary>"
msgstr " <primary> migraÁ„o de thread </primary> "

#: book.translate.xml:15190
#, fuzzy
msgid ""
"Simply put, a thread migrates when it moves from one CPU to another. In a non-"
"preemptive kernel this can only happen at well-defined points such as when calling "
"<function>msleep</function> or returning to userland. However, in the preemptive "
"kernel, an interrupt can force a preemption and possible migration at any time. This "
"can have negative affects on per-CPU data since with the exception of "
"<varname>curthread</varname> and <varname>curpcb</varname> the data can change "
"whenever you migrate. Since you can potentially migrate at any time this renders "
"unprotected per-CPU data access rather useless. Thus it is desirable to be able to "
"disable migration for sections of code that need per-CPU data to be stable."
msgstr ""
"Simplificando, um thread migra quando se move de um CPU para outro. Em um kernel n„o "
"preemptiva, isso sÛ pode acontecer em pontos bem definidos, como quando se chama "
"<function> msleep </function> ou retornando ao userland. No entanto, no kernel "
"preemptivo, uma interrupÁ„o pode forÁar uma preempÁ„o e uma possÌ≠vel migraÁ„o a "
"qualquer momento. Isso pode ter efeitos negativos nos dados por CPU, pois, com a "
"exceÁ„o de <varname> encurtar </varname> e <varname> curpcb </varname> os dados "
"podem mudar sempre que vocÍ migrar. Como vocÍ pode migrar a qualquer momento, isso "
"torna o acesso aos dados desprotegidos por CPU um pouco in˙til. Assim, È desej·vel "
"poder desabilitar a migraÁ„o para seÁÌµes de cÛdigo que precisam de dados por CPU "
"para serem est·veis. "

#: book.translate.xml:15206
#, fuzzy
msgid ""
"Critical sections currently prevent migration since they do not allow context "
"switches. However, this may be too strong of a requirement to enforce in some cases "
"since a critical section also effectively blocks interrupt threads on the current "
"processor. As a result, another API has been provided to allow the current thread to "
"indicate that if it preempted it should not migrate to another CPU."
msgstr ""
"As seÁÌµes crÌ≠ticas atualmente impedem a migraÁ„o, pois n„o permitem comutadores de "
"contexto. No entanto, isso pode ser um requisito muito forte para ser aplicado em "
"alguns casos, pois uma seÁ„o crÌ≠tica tambÈm bloqueia efetivamente os threads de "
"interrupÁ„o no processador atual. Como resultado, outra API foi fornecido para "
"permitir que o segmento atual indique que, se ele se precisasse, ele n„o deveria "
"migrar para outra CPU. "

#: book.translate.xml:15214
#, fuzzy
msgid ""
"This API is known as thread pinning and is provided by the scheduler. The API "
"consists of two functions: <function>sched_pin</function> and <function>sched_unpin</"
"function>. These functions manage a per-thread nesting count <varname>td_pinned</"
"varname>. A thread is pinned when its nesting count is greater than zero and a "
"thread starts off unpinned with a nesting count of zero. Each scheduler "
"implementation is required to ensure that pinned threads are only executed on the "
"CPU that they were executing on when the <function>sched_pin</function> was first "
"called. Since the nesting count is only written to by the thread itself and is only "
"read by other threads when the pinned thread is not executing but while "
"<varname>sched_lock</varname> is held, then <varname>td_pinned</varname> does not "
"need any locking. The <function>sched_pin</function> function increments the nesting "
"count and <function>sched_unpin</function> decrements the nesting count. Note that "
"these functions only operate on the current thread and bind the current thread to "
"the CPU it is executing on at the time. To bind an arbitrary thread to a specific "
"CPU, the <function>sched_bind</function> and <function>sched_unbind</function> "
"functions should be used instead."
msgstr ""
"Essa API È conhecida como fixaÁ„o de threads e È fornecida pelo agendador. A API "
"consiste em duas funÁÌµes: <function> sched_pin </function> e <function> sched_unpin "
"</function> . Essas funÁÌµes gerenciam uma contagem de aninhamento por thread "
"<varname> td_pinned </varname> . Um encadeamento È fixado quando sua contagem de "
"aninhamento È maior que zero e um encadeamento È iniciado desmarcado com uma "
"contagem de aninhamento igual a zero. Cada implementaÁ„o do planejador È necess·ria "
"para garantir que os encadeamentos fixados sejam executados somente na CPU em que "
"estavam sendo executados quando o encadeamento <function> sched_pin </function> foi "
"chamado pela primeira vez. Como a contagem de aninhamento È gravada apenas pelo "
"prÛprio thread e È lida apenas por outros threads quando o thread fixo n„o est· em "
"execuÁ„o, mas enquanto <varname> sched_lock </varname> È realizada, ent„o <varname> "
"td_pinned </varname> n„o precisa de nenhum bloqueio. o <function> sched_pin </"
"function> funÁ„o incrementa a contagem de aninhamento e <function> sched_unpin </"
"function> decrementa a contagem de aninhamento. Observe que essas funÁÌµes sÛ operam "
"no encadeamento atual e ligam o encadeamento atual Ì† CPU que est· sendo executada "
"no momento. Para ligar um encadeamento arbitr·rio a uma CPU especÌ≠fica, o <function> "
"sched_bind </function> e <function> sched_unbind </function> funÁÌµes devem ser "
"usadas em vez disso. "

#: book.translate.xml:15240
#, fuzzy
msgid "Callouts"
msgstr "Chamadas"

#: book.translate.xml:15242
#, fuzzy
msgid ""
"The <function>timeout</function> kernel facility permits kernel services to register "
"functions for execution as part of the <function>softclock</function> software "
"interrupt. Events are scheduled based on a desired number of clock ticks, and "
"callbacks to the consumer-provided function will occur at approximately the right "
"time."
msgstr ""
"O <function> tempo esgotado </function> O recurso kernel permite que os serviÁos do "
"kernel registrem funÁÌµes para execuÁ„o como parte do <function> softclock </"
"function> interrupÁ„o de software. Os eventos s„o programados com base em um n˙mero "
"desejado de pulsos de clock, e os retornos de chamada para a funÁ„o fornecida pelo "
"consumidor ocorrer„o aproximadamente no momento certo. "

#: book.translate.xml:15249
#, fuzzy
msgid ""
"The global list of pending timeout events is protected by a global spin mutex, "
"<varname>callout_lock</varname>; all access to the timeout list must be performed "
"with this mutex held. When <function>softclock</function> is woken up, it scans the "
"list of pending timeouts for those that should fire. In order to avoid lock order "
"reversal, the <function>softclock</function> thread will release the "
"<varname>callout_lock</varname> mutex when invoking the provided <function>timeout</"
"function> callback function. If the <constant>CALLOUT_MPSAFE</constant> flag was not "
"set during registration, then Giant will be grabbed before invoking the callout, and "
"then released afterwards. The <varname>callout_lock</varname> mutex will be re-"
"grabbed before proceeding. The <function>softclock</function> code is careful to "
"leave the list in a consistent state while releasing the mutex. If "
"<constant>DIAGNOSTIC</constant> is enabled, then the time taken to execute each "
"function is measured, and a warning is generated if it exceeds a threshold."
msgstr ""
"A lista global de eventos de timeout pendentes È protegida por um mutex de rotaÁ„o "
"global, <varname> callout_lock </varname> ; todo acesso Ì† lista de tempo limite "
"deve ser executado com esse mutex mantido. Quando <function> softclock </function> È "
"acordado, varre a lista de tempos limite pendentes para aqueles que devem disparar. "
"Para evitar a revers„o da ordem de bloqueio, o <function> softclock </function> fio "
"vai liberar o <varname> callout_lock </varname> mutex ao invocar o fornecido "
"<function> tempo esgotado </function> funÁ„o de retorno de chamada. Se o <constant> "
"CALLOUT_MPSAFE </constant> flag n„o foi definido durante o registro, ent„o o Giant "
"ser· agarrado antes de invocar o texto explicativo e, em seguida, liberado "
"posteriormente. o <varname> callout_lock </varname> mutex ser· re-agarrado antes de "
"prosseguir. o <function> softclock </function> cÛdigo tem o cuidado de deixar a "
"lista em um estado consistente ao liberar o mutex. E se <constant> DIAGNÌìSTICO </"
"constant> est· habilitado, o tempo gasto para executar cada funÁ„o È medido e um "
"aviso È gerado se exceder um limite. "

#: book.translate.xml:15272
#, fuzzy
msgid "Specific Locking Strategies"
msgstr "EstratÈgias EspecÌ≠ficas de Bloqueio"

#: book.translate.xml:15275
#, fuzzy
msgid "Credentials"
msgstr "Credenciais"

#: book.translate.xml:15277
#, fuzzy
msgid "<primary>credentials</primary>"
msgstr " <primary> credenciais </primary> "

#: book.translate.xml:15279
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct ucred</varname> is the kernel's internal "
"credential structure, and is generally used as the basis for process-driven access "
"control within the kernel. BSD-derived systems use a <quote>copy-on-write</quote> "
"model for credential data: multiple references may exist for a credential structure, "
"and when a change needs to be made, the structure is duplicated, modified, and then "
"the reference replaced. Due to wide-spread caching of the credential to implement "
"access control on open, this results in substantial memory savings. With a move to "
"fine-grained SMP, this model also saves substantially on locking operations by "
"requiring that modification only occur on an unshared credential, avoiding the need "
"for explicit synchronization when consuming a known-shared credential."
msgstr ""
" <varname remap=\"structname\"> structurred </varname> È a estrutura de credenciais "
"internas do kernel e È geralmente usada como base para o controle de acesso "
"orientado a processos dentro do kernel. Sistemas derivados de BSD usam um <quote> "
"copiar-em-escrever </quote> modelo para dados de credencial: podem existir v·rias "
"referÍncias para uma estrutura de credenciais e, quando uma alteraÁ„o precisa ser "
"feita, a estrutura È duplicada, modificada e, em seguida, a referÍncia È substituÌ≠"
"da. Devido ao amplo armazenamento em cache da credencial para implementar o controle "
"de acesso em aberto, isso resulta em economias substanciais de memÛria. Com uma "
"mudanÁa para o SMP refinado, esse modelo tambÈm economiza substancialmente nas "
"operaÁÌµes de bloqueio, exigindo que essa modificaÁ„o ocorra apenas em uma "
"credencial n„o compartilhada, evitando a necessidade de sincronizaÁ„o explÌ≠cita ao "
"consumir uma credencial compartilhada conhecida. "

#: book.translate.xml:15294
#, fuzzy
msgid ""
"Credential structures with a single reference are considered mutable; shared "
"credential structures must not be modified or a race condition is risked. A mutex, "
"<varname remap=\"structfield\">cr_mtxp</varname> protects the reference count of "
"<varname remap=\"structname\">struct ucred</varname> so as to maintain consistency. "
"Any use of the structure requires a valid reference for the duration of the use, or "
"the structure may be released out from under the illegitimate consumer."
msgstr ""
"Estruturas de credenciais com uma ˙nica referÍncia s„o consideradas mut·veis; "
"estruturas de credenciais compartilhadas n„o devem ser modificadas ou uma condiÁ„o "
"de corrida È arriscada. Um mutex, <varname remap=\"structfield\"> cr_mtxp </varname> "
"protege a contagem de referÍncia de <varname remap=\"structname\"> structurred </"
"varname> de modo a manter a consistÍncia. Qualquer uso da estrutura requer uma "
"referÍncia v·lida para a duraÁ„o do uso, ou a estrutura pode ser liberada sob o "
"consumidor ilegÌ≠timo \""

#: book.translate.xml:15304
#, fuzzy
msgid ""
"The <varname remap=\"structname\">struct ucred</varname> mutex is a leaf mutex and "
"is implemented via a mutex pool for performance reasons."
msgstr ""
"O <varname remap=\"structname\"> structurred </varname> mutex È um mutex de folha e "
"È implementado por meio de um pool mutex por motivos de desempenho. "

#: book.translate.xml:15308
#, fuzzy
msgid ""
"Usually, credentials are used in a read-only manner for access control decisions, "
"and in this case <varname remap=\"structfield\">td_ucred</varname> is generally "
"preferred because it requires no locking. When a process' credential is updated the "
"<literal>proc</literal> lock must be held across the check and update operations "
"thus avoid races. The process credential <varname remap=\"structfield\">p_ucred</"
"varname> must be used for check and update operations to prevent time-of-check, time-"
"of-use races."
msgstr ""
"Geralmente, as credenciais s„o usadas de maneira somente leitura para decisÌµes de "
"controle de acesso e, nesse caso, <varname remap=\"structfield\"> td_ucred </"
"varname> È geralmente preferido porque n„o requer bloqueio. Quando a credencial de "
"um processo È atualizada, <literal> proc </literal> o bloqueio deve ser mantido "
"entre as operaÁÌµes de verificaÁ„o e atualizaÁ„o, evitando assim as corridas. A "
"credencial do processo <varname remap=\"structfield\"> p_ucred </varname> deve ser "
"usado para verificar e atualizar as operaÁÌµes para evitar corridas de tempo de "
"verificaÁ„o e tempo de uso. "

#: book.translate.xml:15318
#, fuzzy
msgid ""
"If system call invocations will perform access control after an update to the "
"process credential, the value of <varname remap=\"structfield\">td_ucred</varname> "
"must also be refreshed to the current process value. This will prevent use of a "
"stale credential following a change. The kernel automatically refreshes the <varname "
"remap=\"structfield\">td_ucred</varname> pointer in the thread structure from the "
"process <varname remap=\"structfield\">p_ucred</varname> whenever a process enters "
"the kernel, permitting use of a fresh credential for kernel access control."
msgstr ""
"Se as invocaÁÌµes de chamada do sistema realizarem o controle de acesso apÛs uma "
"atualizaÁ„o para a credencial do processo, o valor de <varname remap=\"structfield"
"\"> td_ucred </varname> tambÈm deve ser atualizado para o valor do processo atual. "
"Isso impedir· o uso de uma credencial obsoleta apÛs uma alteraÁ„o. O kernel atualiza "
"automaticamente <varname remap=\"structfield\"> td_ucred </varname> ponteiro na "
"estrutura de thread do processo <varname remap=\"structfield\"> p_ucred </varname> "
"sempre que um processo entrar no kernel, permitindo o uso de uma nova credencial "
"para o controle de acesso ao kernel. "

#: book.translate.xml:15331
#, fuzzy
msgid "File Descriptors and File Descriptor Tables"
msgstr "Descritores de Arquivo e Tabelas de Descritor de Arquivo"

#: book.translate.xml:15333
#, fuzzy
msgid "Details to follow."
msgstr "Detalhes para seguir."

#: book.translate.xml:15337
#, fuzzy
msgid "Jail Structures"
msgstr "Estruturas da cadeia"

#: book.translate.xml:15341
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct prison</varname> stores administrative details "
"pertinent to the maintenance of jails created using the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API. This includes the per-jail hostname, IP address, and related "
"settings. This structure is reference-counted since pointers to instances of the "
"structure are shared by many credential structures. A single mutex, <varname remap="
"\"structfield\">pr_mtx</varname> protects read and write access to the reference "
"count and all mutable variables inside the struct jail. Some variables are set only "
"when the jail is created, and a valid reference to the <varname remap=\"structname"
"\">struct prison</varname> is sufficient to read these values. The precise locking "
"of each entry is documented via comments in <filename>sys/jail.h</filename>."
msgstr ""
" <varname remap=\"structname\"> pris„o de estrutura </varname> armazena detalhes "
"administrativos pertinentes Ì† manutenÁ„o de cadeias criadas usando o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </manvolnum></"
"citerefentry> API. Isso inclui o nome do host, endereÁo IP e configuraÁÌµes "
"relacionadas por jail. Essa estrutura È contada por referÍncia, pois os ponteiros "
"para instÌ¢ncias da estrutura s„o compartilhados por muitas estruturas de "
"credenciais. Um ˙nico mutex, <varname remap=\"structfield\"> pr_mtx </varname> "
"protege o acesso de leitura e gravaÁ„o Ì† contagem de referÍncia e todas as "
"vari·veis ‚Äã‚Äãmut·veis ‚Äã‚Äãdentro da cadeia de struct. Algumas vari·veis ‚Äã‚Äãs„o definidas "
"somente quando o jail È criado e uma referÍncia v·lida <varname remap=\"structname"
"\"> pris„o de estrutura </varname> È suficiente para ler esses valores. O bloqueio "
"preciso de cada entrada È documentado atravÈs de coment·rios em <filename> sys / "
"jail.h </filename> "

#: book.translate.xml:15357
#, fuzzy
msgid "MAC Framework"
msgstr "MAC Framework"

#: book.translate.xml:15359
#, fuzzy
msgid "<primary>MAC</primary>"
msgstr " <primary> MAC </primary> "

#: book.translate.xml:15361
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework maintains data in a variety of kernel objects, in the "
"form of <varname remap=\"structname\">struct label</varname>. In general, labels in "
"kernel objects are protected by the same lock as the remainder of the kernel object. "
"For example, the <varname remap=\"structfield\">v_label</varname> label in <varname "
"remap=\"structname\">struct vnode</varname> is protected by the vnode lock on the "
"vnode."
msgstr ""
"O TrustedBSD MAC Framework mantÈm dados em uma variedade de objetos do kernel, na "
"forma de <varname remap=\"structname\"> rÛtulo struct </varname> . Em geral, os "
"rÛtulos nos objetos do kernel s„o protegidos pelo mesmo bloqueio que o restante do "
"objeto do kernel. Por exemplo, o <varname remap=\"structfield\"> v_label </varname> "
"rÛtulo em <varname remap=\"structname\"> struct vnode </varname> est· protegido pelo "
"bloqueio vnode no vnode. "

#: book.translate.xml:15369
#, fuzzy
msgid ""
"In addition to labels maintained in standard kernel objects, the MAC Framework also "
"maintains a list of registered and active policies. The policy list is protected by "
"a global mutex (<varname>mac_policy_list_lock</varname>) and a busy count (also "
"protected by the mutex). Since many access control checks may occur in parallel, "
"entry to the framework for a read-only access to the policy list requires holding "
"the mutex while incrementing (and later decrementing) the busy count. The mutex need "
"not be held for the duration of the MAC entry operation--some operations, such as "
"label operations on file system objects--are long-lived. To modify the policy list, "
"such as during policy registration and de-registration, the mutex must be held and "
"the reference count must be zero, to prevent modification of the list while it is in "
"use."
msgstr ""
"AlÈm de rÛtulos mantidos em objetos padr„o do kernel, o MAC Framework tambÈm mantÈm "
"uma lista de polÌ≠ticas registradas e ativas. A lista de polÌ≠ticas È protegida por um "
"mutex global ( <varname> mac_policy_list_lock </varname> ) e uma contagem ocupada "
"(tambÈm protegida pelo mutex). Como muitas verificaÁÌµes de controle de acesso podem "
"ocorrer em paralelo, a entrada na estrutura para um acesso somente leitura Ì† lista "
"de polÌ≠ticas requer a retenÁ„o do mutex ao incrementar (e decrementar "
"posteriormente) a contagem de ocupaÁÌµes. O mutex n„o precisa ser mantido durante a "
"operaÁ„o de entrada MAC - algumas operaÁÌµes, como operaÁÌµes de rÛtulo em objetos "
"do sistema de arquivos - s„o de longa duraÁ„o. Para modificar a lista de polÌ≠ticas, "
"como durante o registro de polÌ≠tica e o cancelamento de registro, o mutex deve ser "
"mantido e a contagem de referÍncia deve ser zero, para evitar a modificaÁ„o da lista "
"enquanto ela estiver em uso. "

#: book.translate.xml:15384
#, fuzzy
msgid ""
"A condition variable, <varname>mac_policy_list_not_busy</varname>, is available to "
"threads that need to wait for the list to become unbusy, but this condition variable "
"must only be waited on if the caller is holding no other locks, or a lock order "
"violation may be possible. The busy count, in effect, acts as a form of shared/"
"exclusive lock over access to the framework: the difference is that, unlike with an "
"sx lock, consumers waiting for the list to become unbusy may be starved, rather than "
"permitting lock order problems with regards to the busy count and other locks that "
"may be held on entry to (or inside) the MAC Framework."
msgstr ""
"Uma vari·vel de condiÁ„o, <varname> mac_policy_list_not_busy </varname> , est· "
"disponÌ≠vel para encadeamentos que precisam aguardar que a lista fique desuniforme, "
"mas essa vari·vel de condiÁ„o sÛ deve ser aguardada se o chamador n„o estiver "
"segurando nenhum outro bloqueio ou se uma violaÁ„o de ordem de bloqueio for possÌ≠"
"vel. A contagem ocupada, na verdade, atua como uma forma de bloqueio compartilhado / "
"exclusivo sobre o acesso Ì† estrutura: a diferenÁa È que, ao contr·rio de um "
"bloqueio sx, os consumidores que esperam que a lista se torne desusada podem ficar "
"sem alimentaÁ„o, em vez de permitir a ordem de bloqueio problemas com relaÁ„o Ì† "
"contagem de ocupaÁÌµes e outros bloqueios que podem ser mantidos na entrada para (ou "
"dentro) do MAC Framework. "

#: book.translate.xml:15398
#, fuzzy
msgid "Modules"
msgstr "MÛdulos"

#: book.translate.xml:15402
#, fuzzy
msgid ""
"For the module subsystem there exists a single lock that is used to protect the "
"shared data. This lock is a shared/exclusive (SX) lock and has a good chance of "
"needing to be acquired (shared or exclusively), therefore there are a few macros "
"that have been added to make access to the lock more easy. These macros can be "
"located in <filename>sys/module.h</filename> and are quite basic in terms of usage. "
"The main structures protected under this lock are the <varname remap=\"structname"
"\">module_t</varname> structures (when shared) and the global <varname remap="
"\"structname\">modulelist_t</varname> structure, modules. One should review the "
"related source code in <filename>kern/kern_module.c</filename> to further understand "
"the locking strategy."
msgstr ""
"Para o subsistema do mÛdulo existe um ˙nico bloqueio que È usado para proteger os "
"dados compartilhados. Esse bloqueio È um bloqueio compartilhado / exclusivo (SX) e "
"tem uma boa chance de precisar ser adquirido (compartilhado ou exclusivo), portanto, "
"h· um bloqueio. algumas macros que foram adicionadas para facilitar o acesso ao "
"bloqueio. Essas macros podem ser localizadas <filename> sys / module.h </filename> e "
"s„o bastante b·sicos em termos de uso. As principais estruturas protegidas sob este "
"bloqueio s„o as <varname remap=\"structname\"> module_t </varname> estruturas "
"(quando compartilhadas) e as <varname remap=\"structname\"> modulelist_t </varname> "
"estrutura, mÛdulos. Deve-se rever o cÛdigo fonte relacionado em <filename> kern / "
"kern_module.c </filename> para entender melhor a estratÈgia de bloqueio. "

#: book.translate.xml:15417
#, fuzzy
msgid "Newbus Device Tree"
msgstr "ÌÅrvore de Dispositivos Newbus"

#: book.translate.xml:22333 book.translate.xml:15419
#, fuzzy
msgid "<primary>Newbus</primary>"
msgstr " <primary> Newbus </primary> "

#: book.translate.xml:15421
#, fuzzy
msgid ""
"The newbus system will have one sx lock. Readers will hold a shared (read) lock "
"(<citerefentry><refentrytitle>sx_slock</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>) and writers will hold an exclusive (write) lock "
"(<citerefentry><refentrytitle>sx_xlock</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>). Internal functions will not do locking at all. Externally visible "
"ones will lock as needed. Those items that do not matter if the race is won or lost "
"will not be locked, since they tend to be read all over the place (e.g., "
"<citerefentry><refentrytitle>device_get_softc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>). There will be relatively few changes to the newbus data "
"structures, so a single lock should be sufficient and not impose a performance "
"penalty."
msgstr ""
"O sistema newbus ter· um bloqueio sx. Os leitores ter„o um bloqueio compartilhado "
"(leitura) ( <citerefentry><refentrytitle> sx_slock </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> ) e os escritores ter„o um bloqueio exclusivo (gravaÁ„o) "
"( <citerefentry><refentrytitle> sx_xlock </refentrytitle><manvolnum> 9 </manvolnum></"
"citerefentry> ). FunÁÌµes internas n„o far„o nenhum bloqueio. Os visÌ≠veis "
"externamente ser„o bloqueados conforme necess·rio. Os itens que n„o importam se a "
"corrida for vencida ou perdida n„o ser„o bloqueados, pois tendem a ser lidos em todo "
"o lugar (por exemplo, <citerefentry><refentrytitle> device_get_softc </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ). Haver· relativamente "
"poucas alteraÁÌµes nas estruturas de dados do newbus, portanto, um ˙nico bloqueio "
"deve ser suficiente e n„o impor uma penalidade de desempenho. "

#: book.translate.xml:15434
#, fuzzy
msgid "Pipes"
msgstr "Tubos"

#: book.translate.xml:15469 book.translate.xml:15436
#, fuzzy
msgid "..."
msgstr "..."

#: book.translate.xml:15440
#, fuzzy
msgid "Processes and Threads"
msgstr "Processos e Threads"

#: book.translate.xml:15442
#, fuzzy
msgid "- process hierarchy"
msgstr "- hierarquia de processos"

#: book.translate.xml:15443
#, fuzzy
msgid "- proc locks, references"
msgstr "- bloqueios proc, referÍncias"

#: book.translate.xml:15444
#, fuzzy
msgid ""
"- thread-specific copies of proc entries to freeze during system calls, including "
"td_ucred"
msgstr ""
"- cÛpias especÌ≠ficas de segmento de entradas proc para congelar durante as chamadas "
"do sistema, incluindo td_ucred"

#: book.translate.xml:15446
#, fuzzy
msgid "- inter-process operations"
msgstr "- operaÁÌµes entre processos"

#: book.translate.xml:15447
#, fuzzy
msgid "- process groups and sessions"
msgstr "- processar grupos e sessÌµes"

#: book.translate.xml:15451
#, fuzzy
msgid "Scheduler"
msgstr "Agendador"

#: book.translate.xml:15453
#, fuzzy
msgid "<primary>scheduler</primary>"
msgstr " <primary> Agendador </primary> "

#: book.translate.xml:15455
#, fuzzy
msgid ""
"Lots of references to <varname>sched_lock</varname> and notes pointing at specific "
"primitives and related magic elsewhere in the document."
msgstr ""
"Muitas referÍncias a <varname> sched_lock </varname> e notas apontando para "
"primitivos especÌ≠ficos e magias relacionadas em outras partes do documento. "

#: book.translate.xml:15461
#, fuzzy
msgid "Select and Poll"
msgstr "Selecione e Pesquise"

#: book.translate.xml:15463
#, fuzzy
msgid ""
"The <function>select</function> and <function>poll</function> functions permit "
"threads to block waiting on events on file descriptors--most frequently, whether or "
"not the file descriptors are readable or writable."
msgstr ""
"O <function> selecione </function> e <function> votaÁ„o </function> As funÁÌµes "
"permitem que os encadeamentos bloqueiem a espera de eventos nos descritores de "
"arquivos - com mais freqÌºÍncia, independentemente de os descritores de arquivos "
"serem legÌ≠veis ou grav·veis. "

#: book.translate.xml:15473
#, fuzzy
msgid "SIGIO"
msgstr "SIGIO"

#: book.translate.xml:15475
#, fuzzy
msgid ""
"The SIGIO service permits processes to request the delivery of a SIGIO signal to its "
"process group when the read/write status of specified file descriptors changes. At "
"most one process or process group is permitted to register for SIGIO from any given "
"kernel object, and that process or group is referred to as the owner. Each object "
"supporting SIGIO registration contains pointer field that is <constant>NULL</"
"constant> if the object is not registered, or points to a <varname remap=\"structname"
"\">struct sigio</varname> describing the registration. This field is protected by a "
"global mutex, <varname>sigio_lock</varname>. Callers to SIGIO maintenance functions "
"must pass in this field <quote>by reference</quote> so that local register copies of "
"the field are not made when unprotected by the lock."
msgstr ""
"O serviÁo SIGIO permite que os processos solicitem a entrega de um sinal SIGIO ao "
"seu grupo de processos quando o status de leitura / gravaÁ„o dos descritores de "
"arquivo especificados muda. No m·ximo, um processo ou grupo de processos tem "
"permiss„o para se registrar no SIGIO de qualquer objeto do kernel e esse processo ou "
"grupo È chamado de propriet·rio. Cada objeto que suporta o registro SIGIO contÈm um "
"campo de ponteiro que È <constant> NULO </constant> se o objeto n„o estiver "
"registrado, ou apontar para um <varname remap=\"structname\"> struct sigio </"
"varname> descrevendo o registro. Este campo È protegido por um mutex global, "
"<varname> sigio_lock </varname> . Os chamadores para as funÁÌµes de manutenÁ„o do "
"SIGIO devem passar neste campo <quote> por referÍncia </quote> para que as cÛpias de "
"registro locais do campo n„o sejam feitas quando desprotegidas pelo bloqueio. "

#: book.translate.xml:15490
#, fuzzy
msgid ""
"One <varname remap=\"structname\">struct sigio</varname> is allocated for each "
"registered object associated with any process or process group, and contains back-"
"pointers to the object, owner, signal information, a credential, and the general "
"disposition of the registration. Each process or progress group contains a list of "
"registered <varname remap=\"structname\">struct sigio</varname> structures, <varname "
"remap=\"structfield\">p_sigiolst</varname> for processes, and <varname remap="
"\"structfield\">pg_sigiolst</varname> for process groups. These lists are protected "
"by the process or process group locks respectively. Most fields in each <varname "
"remap=\"structname\">struct sigio</varname> are constant for the duration of the "
"registration, with the exception of the <varname remap=\"structfield\">sio_pgsigio</"
"varname> field which links the <varname remap=\"structname\">struct sigio</varname> "
"into the process or process group list. Developers implementing new kernel objects "
"supporting SIGIO will, in general, want to avoid holding structure locks while "
"invoking SIGIO supporting functions, such as <function>fsetown</function> or "
"<function>funsetown</function> to avoid defining a lock order between structure "
"locks and the global SIGIO lock. This is generally possible through use of an "
"elevated reference count on the structure, such as reliance on a file descriptor "
"reference to a pipe during a pipe operation."
msgstr ""
"1 <varname remap=\"structname\"> struct sigio </varname> È alocado para cada objeto "
"registrado associado a qualquer processo ou grupo de processos e contÈm indicadores "
"de retorno para o objeto, propriet·rio, informaÁÌµes de sinal, uma credencial e a "
"disposiÁ„o geral do registro. Cada processo ou grupo de progresso contÈm uma lista "
"de <varname remap=\"structname\"> struct sigio </varname> estruturas, <varname remap="
"\"structfield\"> p_sigiolst </varname> para processos e <varname remap=\"structfield"
"\"> pg_sigiolst </varname> para grupos de processos. Essas listas s„o protegidas "
"pelos bloqueios de processos ou grupos de processos, respectivamente. A maioria dos "
"campos em cada <varname remap=\"structname\"> struct sigio </varname> s„o constantes "
"durante o perÌ≠odo de registro, com exceÁ„o do <varname remap=\"structfield\"> "
"sio_pgsigio </varname> campo que liga o <varname remap=\"structname\"> struct sigio "
"</varname> na lista de processos ou grupos de processos. Os desenvolvedores que "
"implementam novos objetos de kernel que suportam o SIGIO, em geral, querem evitar "
"manter bloqueios de estrutura enquanto invocam funÁÌµes de suporte SIGIO, como "
"<function> fsetown </function> ou <function> funsetown </function> para evitar "
"definir uma ordem de bloqueio entre bloqueios de estrutura e o bloqueio global "
"SIGIO. Isso geralmente È possÌ≠vel atravÈs do uso de uma contagem de referÍncia "
"elevada na estrutura, como a dependÍncia de uma referÍncia de descritor de arquivo a "
"um pipe durante uma operaÁ„o de pipe. "

#: book.translate.xml:15517
#, fuzzy
msgid "Sysctl"
msgstr "Sysctl"

#: book.translate.xml:15519
#, fuzzy
msgid ""
"The <function>sysctl</function> MIB service is invoked from both within the kernel "
"and from userland applications using a system call. At least two issues are raised "
"in locking: first, the protection of the structures maintaining the namespace, and "
"second, interactions with kernel variables and functions that are accessed by the "
"sysctl interface. Since sysctl permits the direct export (and modification) of "
"kernel statistics and configuration parameters, the sysctl mechanism must become "
"aware of appropriate locking semantics for those variables. Currently, sysctl makes "
"use of a single global sx lock to serialize use of <function>sysctl</function>; "
"however, it is assumed to operate under Giant and other protections are not "
"provided. The remainder of this section speculates on locking and semantic changes "
"to sysctl."
msgstr ""
"O <function> sysctl </function> O serviÁo MIB È invocado a partir de ambos dentro do "
"kernel e de aplicativos da terra do usu·rio usando uma chamada de sistema. Pelo "
"menos dois problemas s„o levantados no bloqueio: primeiro, a proteÁ„o das estruturas "
"que mantÍm o namespace e, em segundo lugar, interaÁÌµes com vari·veis ‚Äã‚Äãe funÁÌµes "
"do kernel que s„o acessadas pela interface sysctl. Como sysctl permite a exportaÁ„o "
"direta (e modificaÁ„o) de estatÌ≠sticas do kernel e parÌ¢metros de configuraÁ„o, o "
"mecanismo sysctl deve estar ciente da semÌ¢ntica de bloqueio apropriada para essas "
"vari·veis. Atualmente, o sysctl faz uso de um ˙nico sx lock global para serializar o "
"uso de <function> sysctl </function> ; no entanto, supÌµe-se que ele opere sob "
"Gigante e outras proteÁÌµes n„o s„o fornecidas. O restante desta seÁ„o especula "
"sobre o bloqueio e alteraÁÌµes semÌ¢nticas no sysctl. "

#: book.translate.xml:15535
#, fuzzy
msgid ""
"- Need to change the order of operations for sysctl's that update values from read "
"old, copyin and copyout, write new to copyin, lock, read old and write new, unlock, "
"copyout. Normal sysctl's that just copyout the old value and set a new value that "
"they copyin may still be able to follow the old model. However, it may be cleaner to "
"use the second model for all of the sysctl handlers to avoid lock operations."
msgstr ""
"- Necessidade de alterar a ordem das operaÁÌµes para sysctl';s que atualizam valores "
"de read old, copyin e copyout, write new para copyin, lock, read old, new, unlock, "
"copyout. Sysctls normais que apenas copiam o valor antigo e definem um O novo valor "
"que eles copiam ainda pode ser capaz de seguir o modelo antigo. No entanto, pode ser "
"mais limpo usar o segundo modelo para todos os manipuladores sysctl para evitar "
"operaÁÌµes de bloqueio. "

#: book.translate.xml:15543
#, fuzzy
msgid ""
"- To allow for the common case, a sysctl could embed a pointer to a mutex in the "
"SYSCTL_FOO macros and in the struct. This would work for most sysctl's. For values "
"protected by sx locks, spin mutexes, or other locking strategies besides a single "
"sleep mutex, SYSCTL_PROC nodes could be used to get the locking right."
msgstr ""
"- Para permitir o caso comum, um sysctl poderia incorporar um ponteiro a um mutex "
"nas macros SYSCTL_FOO e no struct. Isso funcionaria para a maioria dos sysctl. Para "
"valores protegidos por bloqueios sx, mutexes de rotaÁ„o ou outras estratÈgias de "
"bloqueio alÈm de um single sleep mutex, nÛs SYSCTL_PROC poderiam ser usados ‚Äã‚Äãpara "
"obter o bloqueio certo \""

#: book.translate.xml:15552
#, fuzzy
msgid "Taskqueue"
msgstr "Taskqueue"

#: book.translate.xml:15554
#, fuzzy
msgid ""
"The taskqueue's interface has two basic locks associated with it in order to protect "
"the related shared data. The <varname>taskqueue_queues_mutex</varname> is meant to "
"serve as a lock to protect the <varname>taskqueue_queues</varname> TAILQ. The other "
"mutex lock associated with this system is the one in the <varname remap=\"structname"
"\">struct taskqueue</varname> data structure. The use of the synchronization "
"primitive here is to protect the integrity of the data in the <varname remap="
"\"structname\">struct taskqueue</varname>. It should be noted that there are no "
"separate macros to assist the user in locking down his/her own work since these "
"locks are most likely not going to be used outside of <filename>kern/subr_taskqueue."
"c</filename>."
msgstr ""
"A interface da fila de tarefas tem dois bloqueios b·sicos associados a ela para "
"proteger os dados compartilhados relacionados. <varname> taskqueue_queues_mutex </"
"varname> destina-se a servir como um bloqueio para proteger o <varname> "
"taskqueue_queues </varname> TAILQ O outro bloqueio mutex associado a este sistema È "
"aquele no <varname remap=\"structname\"> structqueueue </varname> estrutura de "
"dados. O uso da primitiva de sincronizaÁ„o aqui È para proteger a integridade dos "
"dados no <varname remap=\"structname\"> structqueueue </varname> . Deve-se notar que "
"n„o h· macros separadas para ajudar o usu·rio a bloquear seu prÛprio trabalho, j· "
"que esses bloqueios n„o ser„o mais usados ‚Äã‚Äãfora <filename> kern / subr_taskqueue.c "
"</filename> "

#: book.translate.xml:15570
#, fuzzy
msgid "Implementation Notes"
msgstr "Notas de ImplementaÁ„o"

#: book.translate.xml:15573
#, fuzzy
msgid "Sleep Queues"
msgstr "Filas do sono"

#: book.translate.xml:15575
#, fuzzy
msgid ""
"A sleep queue is a structure that holds the list of threads asleep on a wait "
"channel. Each thread that is not asleep on a wait channel carries a sleep queue "
"structure around with it. When a thread blocks on a wait channel, it donates its "
"sleep queue structure to that wait channel. Sleep queues associated with a wait "
"channel are stored in a hash table."
msgstr ""
"Uma fila de espera È uma estrutura que mantÈm a lista de threads adormecida em um "
"canal de espera. Cada thread que n„o est· dormindo em um canal de espera carrega "
"consigo uma estrutura de fila de espera. Quando um segmento bloqueia em um canal de "
"espera, ele doa estrutura da fila de espera para esse canal de espera. As filas de "
"espera associadas a um canal de espera s„o armazenadas em uma tabela de hash. "

#: book.translate.xml:15583
#, fuzzy
msgid ""
"The sleep queue hash table holds sleep queues for wait channels that have at least "
"one blocked thread. Each entry in the hash table is called a sleepqueue chain. The "
"chain contains a linked list of sleep queues and a spin mutex. The spin mutex "
"protects the list of sleep queues as well as the contents of the sleep queue "
"structures on the list. Only one sleep queue is associated with a given wait "
"channel. If multiple threads block on a wait channel than the sleep queues "
"associated with all but the first thread are stored on a list of free sleep queues "
"in the master sleep queue. When a thread is removed from the sleep queue it is given "
"one of the sleep queue structures from the master queue's free list if it is not the "
"only thread asleep on the queue. The last thread is given the master sleep queue "
"when it is resumed. Since threads may be removed from the sleep queue in a different "
"order than they are added, a thread may depart from a sleep queue with a different "
"sleep queue structure than the one it arrived with."
msgstr ""
"A tabela hash da fila de espera contÈm filas de espera para canais de espera que "
"possuem pelo menos um thread bloqueado. Cada entrada na tabela de hash È chamada de "
"cadeia sleepqueue. A cadeia contÈm uma lista vinculada de filas de espera e um mutex "
"de rotaÁ„o. a lista de filas de espera, bem como o conte˙do das estruturas da fila "
"de espera na lista.Somente uma fila de espera est· associada a um determinado canal "
"de espera.Se v·rios segmentos bloquearem em um canal de espera que as filas de "
"espera associadas a todos, exceto ao primeiro segmento s„o armazenados em uma lista "
"de filas de espera livres na fila de espera principal.Quando um thread È removido da "
"fila de espera, È dada uma das estruturas de fila de espera a partir da lista livre "
"da fila mestre, se n„o for o ˙nico thread a adormecer na fila O ˙ltimo segmento "
"recebe a fila de espera principal quando È reiniciado.Como os encadeamentos podem "
"ser removidos da fila de espera em uma ordem diferente da que foram incluÌ≠dos, um "
"encadeamento pode se afastar de uma fila de espera com uma estrutura de fila de "
"suspens„o diferente e aquele com quem chegou. "

#: book.translate.xml:15602
#, fuzzy
msgid ""
"The <function>sleepq_lock</function> function locks the spin mutex of the sleep "
"queue chain that maps to a specific wait channel. The <function>sleepq_lookup</"
"function> function looks in the hash table for the master sleep queue associated "
"with a given wait channel. If no master sleep queue is found, it returns "
"<constant>NULL</constant>. The <function>sleepq_release</function> function unlocks "
"the spin mutex associated with a given wait channel."
msgstr ""
"O <function> sleepq_lock </function> function bloqueia o mutex de rotaÁ„o da cadeia "
"de fila de espera que mapeia para um canal de espera especÌ≠fico. o <function> "
"sleepq_lookup </function> A funÁ„o procura na tabela de hash da fila de espera "
"principal associada a um determinado canal de espera. Se nenhuma fila de espera "
"principal for encontrada, ela retornar· <constant> NULO </constant> . o <function> "
"sleepq_release </function> A funÁ„o desbloqueia o mutex de rotaÁ„o associado a um "
"determinado canal de espera. "

#: book.translate.xml:15611
#, fuzzy
msgid ""
"A thread is added to a sleep queue via the <function>sleepq_add</function>. This "
"function accepts the wait channel, a pointer to the mutex that protects the wait "
"channel, a wait message description string, and a mask of flags. The sleep queue "
"chain should be locked via <function>sleepq_lock</function> before this function is "
"called. If no mutex protects the wait channel (or it is protected by Giant), then "
"the mutex pointer argument should be <constant>NULL</constant>. The flags argument "
"contains a type field that indicates the kind of sleep queue that the thread is "
"being added to and a flag to indicate if the sleep is interruptible "
"(<constant>SLEEPQ_INTERRUPTIBLE</constant>). Currently there are only two types of "
"sleep queues: traditional sleep queues managed via the <function>msleep</function> "
"and <function>wakeup</function> functions (<constant>SLEEPQ_MSLEEP</constant>) and "
"condition variable sleep queues (<constant>SLEEPQ_CONDVAR</constant>). The sleep "
"queue type and lock pointer argument are used solely for internal assertion "
"checking. Code that calls <function>sleepq_add</function> should explicitly unlock "
"any interlock protecting the wait channel after the associated sleepqueue chain has "
"been locked via <function>sleepq_lock</function> and before blocking on the sleep "
"queue via one of the waiting functions."
msgstr ""
"Um encadeamento È adicionado a uma fila de espera atravÈs do <function> sleepq_add </"
"function> . Essa funÁ„o aceita o canal de espera, um ponteiro para o mutex que "
"protege o canal de espera, uma cadeia de descriÁ„o da mensagem de espera e uma "
"m·scara de sinalizadores. A cadeia da fila de espera deve ser bloqueada via "
"<function> sleepq_lock </function> antes que esta funÁ„o seja chamada. Se nenhum "
"mutex protege o canal de espera (ou È protegido pelo Gigante), ent„o o argumento do "
"ponteiro do mutex deve ser <constant> NULO </constant> . O argumento flags contÈm um "
"campo type que indica o tipo de fila de espera que o thread est· sendo adicionado e "
"um flag para indicar se o sleep È interrompÌ≠vel ( <constant> SLEEPQ_INTERRUPTIBLE </"
"constant> ). Atualmente, existem apenas dois tipos de filas de espera: filas de sono "
"tradicionais gerenciadas pelo <function> msleep </function> e <function> acorde </"
"function> funÁÌµes ( <constant> SLEEPQ_MSLEEP </constant> ) e filas de sono de "
"vari·veis ‚Äã‚Äãde condiÁ„o ( <constant> SLEEPQ_CONDVAR </constant> ). O tipo de fila de "
"espera e o argumento de ponteiro de bloqueio s„o usados ‚Äã‚Äãsomente para verificaÁ„o "
"de asserÁ„o interna. CÛdigo que chama <function> sleepq_add </function> deve "
"desbloquear explicitamente qualquer bloqueio protegendo o canal de espera apÛs a "
"cadeia de sleepqueue associada ter sido bloqueada via <function> sleepq_lock </"
"function> e antes de bloquear na fila de espera atravÈs de uma das funÁÌµes de "
"espera. "

#: book.translate.xml:15636
#, fuzzy
msgid ""
"A timeout for a sleep is set by invoking <function>sleepq_set_timeout</function>. "
"The function accepts the wait channel and the timeout time as a relative tick count "
"as its arguments. If a sleep should be interrupted by arriving signals, the "
"<function>sleepq_catch_signals</function> function should be called as well. This "
"function accepts the wait channel as its only parameter. If there is already a "
"signal pending for this thread, then <function>sleepq_catch_signals</function> will "
"return a signal number; otherwise, it will return 0."
msgstr ""
"Um tempo limite para um sono È definido invocando <function> sleepq_set_timeout </"
"function> . A funÁ„o aceita o canal de espera e o tempo de timeout como uma contagem "
"relativa de toques como seus argumentos. Se um sono deve ser interrompido por sinais "
"de chegada, o <function> sleepq_catch_signals </function> funÁ„o deve ser chamada "
"tambÈm. Esta funÁ„o aceita o canal de espera como seu ˙nico parÌ¢metro. Se j· houver "
"um sinal pendente para este encadeamento, <function> sleepq_catch_signals </"
"function> retornar· um n˙mero de sinal; caso contr·rio, retornar· 0. "

#: book.translate.xml:15647
#, fuzzy
msgid ""
"Once a thread has been added to a sleep queue, it blocks using one of the "
"<function>sleepq_wait</function> functions. There are four wait functions depending "
"on whether or not the caller wishes to use a timeout or have the sleep aborted by "
"caught signals or an interrupt from the userland thread scheduler. The "
"<function>sleepq_wait</function> function simply waits until the current thread is "
"explicitly resumed by one of the wakeup functions. The <function>sleepq_timedwait</"
"function> function waits until either the thread is explicitly resumed or the "
"timeout set by an earlier call to <function>sleepq_set_timeout</function> expires. "
"The <function>sleepq_wait_sig</function> function waits until either the thread is "
"explicitly resumed or its sleep is aborted. The <function>sleepq_timedwait_sig</"
"function> function waits until either the thread is explicitly resumed, the timeout "
"set by an earlier call to <function>sleepq_set_timeout</function> expires, or the "
"thread's sleep is aborted. All of the wait functions accept the wait channel as "
"their first parameter. In addition, the <function>sleepq_timedwait_sig</function> "
"function accepts a second boolean parameter to indicate if the earlier call to "
"<function>sleepq_catch_signals</function> found a pending signal."
msgstr ""
"Uma vez que um thread foi adicionado a uma fila de espera, ele bloqueia usando um "
"dos <function> sleepq_wait </function> funÁÌµes. Existem quatro funÁÌµes de espera, "
"dependendo se o chamador deseja ou n„o usar um tempo limite ou interromper o sono "
"por sinais capturados ou por uma interrupÁ„o do agendador de segmentos do espaÁo do "
"usu·rio. o <function> sleepq_wait </function> funÁ„o simplesmente aguarda atÈ que o "
"segmento atual seja explicitamente retomado por uma das funÁÌµes de ativaÁ„o. o "
"<function> sleepq_timedwait </function> funÁ„o aguarda atÈ que o encadeamento seja "
"retomado explicitamente ou o tempo limite definido por uma chamada anterior para "
"<function> sleepq_set_timeout </function> expira. o <function> sleepq_wait_sig </"
"function> A funÁ„o aguarda atÈ que o encadeamento seja explicitamente retomado ou "
"que sua suspens„o seja interrompida. o <function> sleepq_timedwait_sig </function> "
"funÁ„o aguarda atÈ que o encadeamento seja explicitamente retomado, o tempo limite "
"definido por uma chamada anterior para <function> sleepq_set_timeout </function> "
"expira, ou o sono do segmento È abortado. Todas as funÁÌµes de espera aceitam o "
"canal de espera como seu primeiro parÌ¢metro. AlÈm disso, o <function> "
"sleepq_timedwait_sig </function> funÁ„o aceita um segundo parÌ¢metro booleano para "
"indicar se a chamada anterior para <function> sleepq_catch_signals </function> "
"encontrou um sinal pendente \""

#: book.translate.xml:15671
#, fuzzy
msgid ""
"If the thread is explicitly resumed or is aborted by a signal, then a value of zero "
"is returned by the wait function to indicate a successful sleep. If the thread is "
"resumed by either a timeout or an interrupt from the userland thread scheduler then "
"an appropriate errno value is returned instead. Note that since "
"<function>sleepq_wait</function> can only return 0 it does not return anything and "
"the caller should assume a successful sleep. Also, if a thread's sleep times out and "
"is aborted simultaneously then <function>sleepq_timedwait_sig</function> will return "
"an error indicating that a timeout occurred. If an error value of 0 is returned and "
"either <function>sleepq_wait_sig</function> or <function>sleepq_timedwait_sig</"
"function> was used to block, then the function <function>sleepq_calc_signal_retval</"
"function> should be called to check for any pending signals and calculate an "
"appropriate return value if any are found. The signal number returned by the earlier "
"call to <function>sleepq_catch_signals</function> should be passed as the sole "
"argument to <function>sleepq_calc_signal_retval</function>."
msgstr ""
"Se o thread È explicitamente retomado ou È abortado por um sinal, ent„o um valor de "
"zero È retornado pela funÁ„o de espera para indicar uma suspens„o bem-sucedida. Se o "
"thread for retomado por um tempo limite ou uma interrupÁ„o do agendador de segmento "
"do usu·rio valor errno apropriado È retornado. <function> sleepq_wait </function> sÛ "
"pode retornar 0, ele n„o retorna nada e o chamador deve assumir um sono bem-"
"sucedido. AlÈm disso, se o tempo de espera de um thread expirar e for abortado "
"simultaneamente, <function> sleepq_timedwait_sig </function> retornar· um erro "
"indicando que ocorreu um tempo limite. Se um valor de erro de 0 for retornado e "
"<function> sleepq_wait_sig </function> ou <function> sleepq_timedwait_sig </"
"function> foi usado para bloquear, ent„o a funÁ„o <function> "
"sleepq_calc_signal_retval </function> deve ser chamado para verificar quaisquer "
"sinais pendentes e calcular um valor de retorno apropriado, se algum for encontrado. "
"O n˙mero do sinal retornado pela chamada anterior para <function> "
"sleepq_catch_signals </function> deve ser passado como o ˙nico argumento para "
"<function> sleepq_calc_signal_retval </function> "

#: book.translate.xml:15693
#, fuzzy
msgid ""
"Threads asleep on a wait channel are explicitly resumed by the "
"<function>sleepq_broadcast</function> and <function>sleepq_signal</function> "
"functions. Both functions accept the wait channel from which to resume threads, a "
"priority to raise resumed threads to, and a flags argument to indicate which type of "
"sleep queue is being resumed. The priority argument is treated as a minimum "
"priority. If a thread being resumed already has a higher priority (numerically "
"lower) than the priority argument then its priority is not adjusted. The flags "
"argument is used for internal assertions to ensure that sleep queues are not being "
"treated as the wrong type. For example, the condition variable functions should not "
"resume threads on a traditional sleep queue. The <function>sleepq_broadcast</"
"function> function resumes all threads that are blocked on the specified wait "
"channel while <function>sleepq_signal</function> only resumes the highest priority "
"thread blocked on the wait channel. The sleep queue chain should first be locked via "
"the <function>sleepq_lock</function> function before calling these functions."
msgstr ""
"Threads dormindo em um canal de espera s„o explicitamente retomados pelo <function> "
"sleepq_broadcast </function> e <function> sleepq_signal </function> funÁÌµes. Ambas "
"as funÁÌµes aceitam o canal de espera do qual retomar os encadeamentos, uma "
"prioridade para elevar os encadeamentos iniciados e um argumento de sinalizadores "
"para indicar qual tipo de fila de espera est· sendo retomado. O argumento de "
"prioridade È tratado como uma prioridade mÌ≠nima. Se um encadeamento que est· sendo "
"retomado j· tiver uma prioridade mais alta (numericamente menor) que o argumento de "
"prioridade, sua prioridade n„o ser· ajustada. O argumento flags È usado para "
"asserÁÌµes internas para garantir que as filas de espera n„o estejam sendo tratadas "
"como o tipo errado. Por exemplo, as funÁÌµes de vari·vel de condiÁ„o n„o devem "
"retomar os encadeamentos em uma fila de espera tradicional. o <function> "
"sleepq_broadcast </function> funÁ„o retoma todos os threads que est„o bloqueados no "
"canal de espera especificado enquanto <function> sleepq_signal </function> somente "
"retoma o encadeamento de prioridade mais alta bloqueado no canal de espera. A cadeia "
"de fila de espera deve primeiro ser bloqueada pelo <function> sleepq_lock </"
"function> funÁ„o antes de chamar essas funÁÌµes. "

#: book.translate.xml:15714
#, fuzzy
msgid ""
"A sleeping thread may have its sleep interrupted by calling the "
"<function>sleepq_abort</function> function. This function must be called with "
"<varname>sched_lock</varname> held and the thread must be queued on a sleep queue. A "
"thread may also be removed from a specific sleep queue via the "
"<function>sleepq_remove</function> function. This function accepts both a thread and "
"a wait channel as an argument and only awakens the thread if it is on the sleep "
"queue for the specified wait channel. If the thread is not on a sleep queue or it is "
"on a sleep queue for a different wait channel, then this function does nothing."
msgstr ""
"Um fio de dormir pode ter seu sono interrompido chamando o <function> sleepq_abort </"
"function> funÁ„o. Esta funÁ„o deve ser chamada com <varname> sched_lock </varname> "
"mantido e o encadeamento deve estar enfileirado em uma fila de espera. Um "
"encadeamento tambÈm pode ser removido de uma fila de espera especÌ≠fica <function> "
"sleepq_remove </function> funÁ„o. Essa funÁ„o aceita um encadeamento e um canal de "
"espera como um argumento e apenas ativa o encadeamento, se estiver na fila de espera "
"do canal de espera especificado. Se o encadeamento n„o estiver em uma fila de espera "
"ou estiver em uma fila de espera para um canal de espera diferente, essa funÁ„o n„o "
"far· nada. "

#: book.translate.xml:15728
#, fuzzy
msgid "Turnstiles"
msgstr "Torniquetes"

#: book.translate.xml:15730
#, fuzzy
msgid "<primary>turnstiles</primary>"
msgstr " <primary> torniquetes </primary> "

#: book.translate.xml:15732
#, fuzzy
msgid "- Compare/contrast with sleep queues."
msgstr "- Compare / contraste com filas de sono."

#: book.translate.xml:15734
#, fuzzy
msgid "- Lookup/wait/release. - Describe TDF_TSNOBLOCK race."
msgstr "- Lookup / wait / release. - Descreva a corrida TDF_TSNOBLOCK."

#: book.translate.xml:15737
#, fuzzy
msgid "- Priority propagation."
msgstr "- PropagaÁ„o de prioridade."

#: book.translate.xml:15741
#, fuzzy
msgid "Details of the Mutex Implementation"
msgstr "Detalhes da ImplementaÁ„o Mutex"

#: book.translate.xml:15743
#, fuzzy
msgid ""
"- Should we require mutexes to be owned for mtx_destroy() since we can not safely "
"assert that they are unowned by anyone else otherwise?"
msgstr ""
"- Devemos exigir que os mutexes sejam de propriedade de mtx_destroy (), j· que n„o "
"podemos afirmar com seguranÁa que eles s„o sem dono de outra pessoa?"

#: book.translate.xml:15748
#, fuzzy
msgid "Spin Mutexes"
msgstr "Spin Mutexes"

#: book.translate.xml:15750
#, fuzzy
msgid "<primary>mutex</primary><secondary>spin</secondary>"
msgstr " <primary> mutex </primary><secondary> girar </secondary> "

#: book.translate.xml:15752
#, fuzzy
msgid "- Use a critical section..."
msgstr "- Use uma seÁ„o crÌ≠tica ..."

#: book.translate.xml:15756
#, fuzzy
msgid "Sleep Mutexes"
msgstr "Mutexes do sono"

#: book.translate.xml:15758
#, fuzzy
msgid "<primary>mutex</primary><secondary>sleep</secondary>"
msgstr " <primary> mutex </primary><secondary> dormir </secondary> "

#: book.translate.xml:15759
#, fuzzy
msgid "- Describe the races with contested mutexes"
msgstr "- Descreva as raÁas com mutexes contestados"

#: book.translate.xml:15761
#, fuzzy
msgid ""
"- Why it is safe to read mtx_lock of a contested mutex when holding the turnstile "
"chain lock."
msgstr ""
"- Por que È seguro ler o mtx_lock de um mutex contestado ao segurar a trava da "
"corrente do torniquete."

#: book.translate.xml:15767
#, fuzzy
msgid "Witness"
msgstr "Testemunha"

#: book.translate.xml:15769
#, fuzzy
msgid "<primary>witness</primary>"
msgstr " <primary> testemunha </primary> "

#: book.translate.xml:15771
#, fuzzy
msgid "- What does it do"
msgstr "- O que isso faz"

#: book.translate.xml:15773
#, fuzzy
msgid "- How does it work"
msgstr "- Como funciona"

#: book.translate.xml:15778
#, fuzzy
msgid "Miscellaneous Topics"
msgstr "TÛpicos Diversos"

#: book.translate.xml:15781
#, fuzzy
msgid "Interrupt Source and ICU Abstractions"
msgstr "Interromper fontes e abstraÁÌµes de ICU"

#: book.translate.xml:15783
#, fuzzy
msgid "- struct isrc"
msgstr "- struct isrc"

#: book.translate.xml:15785
#, fuzzy
msgid "- pic drivers"
msgstr "- drivers de pic"

#: book.translate.xml:15789
#, fuzzy
msgid "Other Random Questions/Topics"
msgstr "Outras questÌµes aleatÛrias / tÛpicos"

#: book.translate.xml:15791
#, fuzzy
msgid "- Should we pass an interlock into <function>sema_wait</function>?"
msgstr "- Devemos passar um bloqueio em <function> sema_wait </function> "

#: book.translate.xml:15794
#, fuzzy
msgid "- Should we have non-sleepable sx locks?"
msgstr "- Devemos ter fechaduras sx n„o adormecidas?"

#: book.translate.xml:15796
#, fuzzy
msgid "- Add some info about proper use of reference counts."
msgstr ""
"- Adicione algumas informaÁÌµes sobre o uso adequado de contagens de referÍncia."

#: book.translate.xml:15801
#, fuzzy
msgid "Glossary"
msgstr "Gloss·rio"

#: book.translate.xml:15804
#, fuzzy
msgid "atomic"
msgstr "atÌ¥mica"

#: book.translate.xml:15806
#, fuzzy
msgid ""
"An operation is atomic if all of its effects are visible to other CPUs together when "
"the proper access protocol is followed. In the degenerate case are atomic "
"instructions provided directly by machine architectures. At a higher level, if "
"several members of a structure are protected by a lock, then a set of operations are "
"atomic if they are all performed while holding the lock without releasing the lock "
"in between any of the operations."
msgstr ""
"Uma operaÁ„o È atÌ¥mica se todos os seus efeitos s„o visÌ≠veis para outras CPUs "
"juntos quando o protocolo de acesso apropriado È seguido. No caso degenerado s„o "
"fornecidas instruÁÌµes atÌ¥micas diretamente por arquiteturas de m·quina. Em um nÌ≠"
"vel superior, se v·rios membros de uma estrutura s„o protegidos por um bloqueio, "
"ent„o um conjunto de operaÁÌµes s„o atÌ¥micas, se todas elas forem realizadas, "
"mantendo a trava sem liberar a trava entre qualquer uma das operaÁÌµes. "

#: book.translate.xml:15866 book.translate.xml:15815
#, fuzzy
msgid "operation"
msgstr "OperaÁ„o"

#: book.translate.xml:15898 book.translate.xml:15820
#, fuzzy
msgid "block"
msgstr "quadra"

#: book.translate.xml:15822
#, fuzzy
msgid ""
"A thread is blocked when it is waiting on a lock, resource, or condition. "
"Unfortunately this term is a bit overloaded as a result."
msgstr ""
"Um encadeamento È bloqueado quando est· aguardando um bloqueio, recurso ou condiÁ„o. "
"Infelizmente, esse termo È um pouco sobrecarregado como resultado."

#: book.translate.xml:15911 book.translate.xml:15892 book.translate.xml:15826
#, fuzzy
msgid "sleep"
msgstr "dormir"

#: book.translate.xml:15831
#, fuzzy
msgid "critical section"
msgstr "seÁ„o CrÌ≠tica"

#: book.translate.xml:15833
#, fuzzy
msgid ""
"A section of code that is not allowed to be preempted. A critical section is entered "
"and exited using the <citerefentry><refentrytitle>critical_enter</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> API."
msgstr ""
"Uma seÁ„o de cÛdigo que n„o pode ser preterida. Uma seÁ„o crÌ≠tica È inserida e "
"encerrada usando o <citerefentry><refentrytitle> critical_enter </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> API \""

#: book.translate.xml:15861 book.translate.xml:15840
#, fuzzy
msgid "MD"
msgstr "MD"

#: book.translate.xml:15842
#, fuzzy
msgid "Machine dependent."
msgstr "Dependente da m·quina"

#: book.translate.xml:15857 book.translate.xml:15844
#, fuzzy
msgid "MI"
msgstr "MI"

#: book.translate.xml:15867 book.translate.xml:15849
#, fuzzy
msgid "memory operation"
msgstr "operaÁ„o de memÛria"

#: book.translate.xml:15851
#, fuzzy
msgid "A memory operation reads and/or writes to a memory location."
msgstr "Uma operaÁ„o de memÛria lÍ e / ou grava em um local da memÛria."

#: book.translate.xml:15859
#, fuzzy
msgid "Machine independent."
msgstr "M·quina independente\""

#: book.translate.xml:15871
#, fuzzy
msgid "primary interrupt context"
msgstr "contexto de interrupÁ„o prim·rio"

#: book.translate.xml:15873
#, fuzzy
msgid ""
"Primary interrupt context refers to the code that runs when an interrupt occurs. "
"This code can either run an interrupt handler directly or schedule an asynchronous "
"interrupt thread to execute the interrupt handlers for a given interrupt source."
msgstr ""
"Contexto de interrupÁ„o prim·ria refere-se ao cÛdigo que È executado quando ocorre "
"uma interrupÁ„o. Esse cÛdigo pode executar um manipulador de interrupÁ„o diretamente "
"ou agendar um thread de interrupÁ„o assÌ≠ncrono para executar os manipuladores de "
"interrupÁ„o para uma determinada origem de interrupÁ„o."

#: book.translate.xml:15882
#, fuzzy
msgid "realtime kernel thread"
msgstr "thread do kernel em tempo real"

#: book.translate.xml:15884
#, fuzzy
msgid ""
"A high priority kernel thread. Currently, the only realtime priority kernel threads "
"are interrupt threads."
msgstr ""
"Um encadeamento de kernel de alta prioridade. Atualmente, os ˙nicos encadeamentos de "
"kernel de prioridade em tempo real s„o encadeamentos de interrupÁ„o."

#: book.translate.xml:15916 book.translate.xml:15887
#, fuzzy
msgid "thread"
msgstr "fio"

#: book.translate.xml:15894
#, fuzzy
msgid ""
"A thread is asleep when it is blocked on a condition variable or a sleep queue via "
"<function>msleep</function> or <function>tsleep</function>."
msgstr ""
"Um encadeamento est· adormecido quando È bloqueado em uma vari·vel de condiÁ„o ou em "
"uma fila de espera via <function> msleep </function> ou <function> tsleep </"
"function> "

#: book.translate.xml:15903
#, fuzzy
msgid "sleepable lock"
msgstr "fecho adormecido"

#: book.translate.xml:15905
#, fuzzy
msgid ""
"A sleepable lock is a lock that can be held by a thread which is asleep. Lockmgr "
"locks and sx locks are currently the only sleepable locks in FreeBSD. Eventually, "
"some sx locks such as the allproc and proctree locks may become non-sleepable locks."
msgstr ""
"Uma trava sleepable È uma trava que pode ser mantida por um thread que est· "
"adormecido. Bloqueios lockmgr e sx lock s„o atualmente os ˙nicos bloqueios que podem "
"ser suspensos no FreeBSD. Eventualmente, alguns bloqueios sx, como os bloqueios "
"allproc e proctree, podem se tornar bloqueios n„o adormecidos. "

#: book.translate.xml:15918
#, fuzzy
msgid ""
"A kernel thread represented by a struct thread. Threads own locks and hold a single "
"execution context."
msgstr ""
"Um encadeamento de kernel representado por um encadeamento de estrutura. Encadeia os "
"prÛprios bloqueios e mantÈm um ˙nico contexto de execuÁ„o."

#: book.translate.xml:15924
#, fuzzy
msgid "wait channel"
msgstr "canal de espera"

#: book.translate.xml:15926
#, fuzzy
msgid "A kernel virtual address that threads may sleep on."
msgstr "Um endereÁo virtual do kernel no qual os threads podem dormir\""

#: book.translate.xml:22272 book.translate.xml:15936
#, fuzzy
msgid "Device Drivers"
msgstr "Drivers de dispositivo"

#: book.translate.xml:15948
#, fuzzy
msgid "Writing FreeBSD Device Drivers"
msgstr "Gravar drivers de dispositivo FreeBSD"

#: book.translate.xml:15951
#, fuzzy
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </personname> "
"<contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Escrito por </contrib> "

#: book.translate.xml:15962
#, fuzzy
msgid ""
"<personname> <firstname>J√∂rg</firstname> <surname>Wunsch</surname> </personname> "
"<contrib>Based on intro(4) manual page by </contrib>"
msgstr ""
" <personname><firstname> JÌ∂rg </firstname><surname> Wunsch </surname></"
"personname><contrib> Baseado na p·gina de manual intro (4) por </contrib> "

#: book.translate.xml:22277 book.translate.xml:15976
#, fuzzy
msgid "<primary>device driver</primary>"
msgstr " <primary> driver do dispositivo </primary> "

#: book.translate.xml:15977
#, fuzzy
msgid "<primary>pseudo-device</primary>"
msgstr " <primary> pseudo-dispositivo </primary> "

#: book.translate.xml:15979
#, fuzzy
msgid ""
"This chapter provides a brief introduction to writing device drivers for FreeBSD. A "
"device in this context is a term used mostly for hardware-related stuff that belongs "
"to the system, like disks, printers, or a graphics display with its keyboard. A "
"device driver is the software component of the operating system that controls a "
"specific device. There are also so-called pseudo-devices where a device driver "
"emulates the behavior of a device in software without any particular underlying "
"hardware. Device drivers can be compiled into the system statically or loaded on "
"demand through the dynamic kernel linker facility `kld'."
msgstr ""
"Este capÌ≠tulo fornece uma breve introduÁ„o Ì† gravaÁ„o de drivers de dispositivo "
"para o FreeBSD. Um dispositivo neste contexto È um termo usado principalmente para "
"material relacionado ao hardware que pertence ao sistema, como discos, impressoras "
"ou um monitor gr·fico com seu teclado. Um dispositivo driver È o componente de "
"software do sistema operacional que controla um dispositivo especÌ≠fico.Existem "
"tambÈm os chamados pseudo-dispositivos em que um driver de dispositivo emula o "
"comportamento de um dispositivo em um software sem qualquer hardware subjacente "
"especÌ≠fico.Os drivers de dispositivo podem ser compilados no sistema estaticamente "
"ou carregado sob demanda atravÈs do recurso de linker do kernel dinÌ¢mico `kld ';."

#: book.translate.xml:15991
#, fuzzy
msgid "<primary>device nodes</primary>"
msgstr " <primary> nÛs de dispositivo </primary> "

#: book.translate.xml:15993
#, fuzzy
msgid ""
"Most devices in a <trademark class=\"registered\">UNIX</trademark>-like operating "
"system are accessed through device-nodes, sometimes also called special files. These "
"files are usually located under the directory <filename>/dev</filename> in the "
"filesystem hierarchy."
msgstr ""
"A maioria dos dispositivos em um <trademark class=\"registered\"> UNIX </trademark> "
"como o sistema operacional s„o acessados ‚Äã‚ÄãatravÈs de nÛs de dispositivos, Ì†s vezes "
"tambÈm chamados de arquivos especiais. Esses arquivos geralmente est„o localizados "
"no diretÛrio <filename> / dev </filename> na hierarquia do sistema de arquivos. "

#: book.translate.xml:15998
#, fuzzy
msgid ""
"Device drivers can roughly be broken down into two categories; character and network "
"device drivers."
msgstr ""
"Os drivers de dispositivos podem ser divididos em duas categorias: drivers de "
"dispositivos e de rede."

#: book.translate.xml:16004
#, fuzzy
msgid "Dynamic Kernel Linker Facility - KLD"
msgstr "InstalaÁ„o do Linker Kernel DinÌ¢mico - KLD"

#: book.translate.xml:16006
#, fuzzy
msgid "<primary>kernel linking</primary> <secondary>dynamic</secondary>"
msgstr " <primary> ligaÁ„o do kernel </primary><secondary> dinÌ¢mico </secondary> "

#: book.translate.xml:16010
#, fuzzy
msgid "<primary>kernel loadable modules (KLD)</primary>"
msgstr " <primary> mÛdulos carreg·veis ‚Äã‚Äãde kernel (KLD) </primary> "

#: book.translate.xml:16014
#, fuzzy
msgid ""
"The kld interface allows system administrators to dynamically add and remove "
"functionality from a running system. This allows device driver writers to load their "
"new changes into a running kernel without constantly rebooting to test changes."
msgstr ""
"A interface kld permite que os administradores do sistema adicionem e removam "
"dinamicamente a funcionalidade de um sistema em execuÁ„o. Isso permite que os "
"gravadores de driver de dispositivo carreguem suas novas alteraÁÌµes em um kernel em "
"execuÁ„o sem constantemente reinicializar para testar as alteraÁÌµes."

#: book.translate.xml:16020
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>loading</secondary>"
msgstr " <primary> mÛdulos do kernel </primary><secondary> Carregando </secondary> "

#: book.translate.xml:16024
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>unloading</secondary>"
msgstr " <primary> mÛdulos do kernel </primary><secondary> descarga </secondary> "

#: book.translate.xml:16028
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>listing</secondary>"
msgstr " <primary> mÛdulos do kernel </primary><secondary> listando </secondary> "

#: book.translate.xml:16033
#, fuzzy
msgid "The kld interface is used through:"
msgstr "A interface kld È usada atravÈs de:"

#: book.translate.xml:16037
#, fuzzy
msgid "<command>kldload</command> - loads a new kernel module"
msgstr " <command> kldload </command> - carrega um novo mÛdulo do kernel "

#: book.translate.xml:16040
#, fuzzy
msgid "<command>kldunload</command> - unloads a kernel module"
msgstr " <command> kldunload </command> - descarrega um mÛdulo do kernel "

#: book.translate.xml:16043
#, fuzzy
msgid "<command>kldstat</command> - lists loaded modules"
msgstr " <command> kldstat </command> - listas de mÛdulos carregados "

#: book.translate.xml:16047
#, fuzzy
msgid "Skeleton Layout of a kernel module"
msgstr "Layout do esqueleto de um mÛdulo do kernel"

#: book.translate.xml:16096
#, fuzzy
msgid "Makefile"
msgstr "Makefile"

#: book.translate.xml:16098
#, fuzzy
msgid "FreeBSD provides a system makefile to simplify compiling a kernel module."
msgstr ""
"O FreeBSD fornece um makefile do sistema para simplificar a compilaÁ„o de um mÛdulo "
"do kernel."

#: book.translate.xml:16106
#, fuzzy
msgid ""
"Running <command>make</command> with this makefile will create a file "
"<filename>skeleton.ko</filename> that can be loaded into the kernel by typing:"
msgstr ""
"Corrida <command> faÁo </command> com este makefile ir· criar um arquivo <filename> "
"skeleton.ko </filename> que pode ser carregado no kernel digitando: "

#: book.translate.xml:22316 book.translate.xml:16115
#, fuzzy
msgid "Character Devices"
msgstr "Dispositivos de Personagem"

#: book.translate.xml:22318 book.translate.xml:16117
#, fuzzy
msgid "<primary>character devices</primary>"
msgstr " <primary> dispositivos de caracteres </primary> "

#: book.translate.xml:16120
#, fuzzy
msgid ""
"A character device driver is one that transfers data directly to and from a user "
"process. This is the most common type of device driver and there are plenty of "
"simple examples in the source tree."
msgstr ""
"Um driver de dispositivo de caracteres È aquele que transfere dados diretamente para "
"e de um processo do usu·rio. Esse È o tipo mais comum de driver de dispositivo e h· "
"v·rios exemplos simples na ·rvore de cÛdigo-fonte."

#: book.translate.xml:16125
#, fuzzy
msgid ""
"This simple example pseudo-device remembers whatever values are written to it and "
"can then echo them back when read."
msgstr ""
"Este pseudo-dispositivo de exemplo simples lembra-se de todos os valores que foram "
"escritos e pode, ent„o, eco·-los quando lidos."

#: book.translate.xml:16130
#, fuzzy
msgid "Example of a Sample Echo Pseudo-Device Driver for FreeBSD¬†10.X - 12.X"
msgstr ""
"Exemplo de um driver de pseudo-dispositivo de eco de amostra para o FreeBSD 10.X - "
"12.X"

#: book.translate.xml:16300
#, fuzzy
msgid "With this driver loaded try:"
msgstr "Com este driver carregado tente:"

#: book.translate.xml:16308
#, fuzzy
msgid "Real hardware devices are described in the next chapter."
msgstr "Dispositivos de hardware reais s„o descritos no prÛximo capÌ≠tulo."

#: book.translate.xml:16313
#, fuzzy
msgid "Block Devices (Are Gone)"
msgstr "Dispositivos de bloco (foram embora)"

#: book.translate.xml:22303 book.translate.xml:16315
#, fuzzy
msgid "<primary>block devices</primary>"
msgstr " <primary> dispositivos de bloco </primary> "

#: book.translate.xml:16317
#, fuzzy
msgid ""
"Other <trademark class=\"registered\">UNIX</trademark> systems may support a second "
"type of disk device known as block devices. Block devices are disk devices for which "
"the kernel provides caching. This caching makes block-devices almost unusable, or at "
"least dangerously unreliable. The caching will reorder the sequence of write "
"operations, depriving the application of the ability to know the exact disk contents "
"at any one instant in time."
msgstr ""
"De outros <trademark class=\"registered\"> UNIX </trademark> sistemas podem suportar "
"um segundo tipo de dispositivo de disco conhecido como dispositivos de bloco. "
"Dispositivos de bloco s„o dispositivos de disco para os quais o kernel fornece "
"armazenamento em cache. Esse cache torna os dispositivos de bloco quase "
"inutiliz·veis, ou pelo menos perigosamente n„o confi·veis. O cache ir· reordenar a "
"sequÍncia de operaÁÌµes de gravaÁ„o, privando o aplicativo da capacidade de saber o "
"conte˙do exato do disco a qualquer instante. "

#: book.translate.xml:16325
#, fuzzy
msgid ""
"This makes predictable and reliable crash recovery of on-disk data structures "
"(filesystems, databases, etc.) impossible. Since writes may be delayed, there is no "
"way the kernel can report to the application which particular write operation "
"encountered a write error, this further compounds the consistency problem."
msgstr ""
"Isso impossibilita a previsÌ≠vel e confi·vel recuperaÁ„o de falhas de estruturas de "
"dados em disco (sistemas de arquivos, bancos de dados, etc.). Como as gravaÁÌµes "
"podem ser atrasadas, n„o h· como o kernel reportar ao aplicativo qual operaÁ„o de "
"gravaÁ„o encontrou um erro de gravaÁ„o\" isso complica ainda mais o problema de "
"consistÍncia \""

#: book.translate.xml:16332
#, fuzzy
msgid ""
"For this reason, no serious applications rely on block devices, and in fact, almost "
"all applications which access disks directly take great pains to specify that "
"character (or <quote>raw</quote>) devices should always be used. Because the "
"implementation of the aliasing of each disk (partition) to two devices with "
"different semantics significantly complicated the relevant kernel code FreeBSD "
"dropped support for cached disk devices as part of the modernization of the disk I/O "
"infrastructure."
msgstr ""
"Por essa raz„o, nenhum aplicativo sÈrio depende de dispositivos de bloco e, de fato, "
"quase todos os aplicativos que acessam discos fazem um grande esforÁo para "
"especificar esse caractere (ou <quote> cru </quote> ) dispositivos devem sempre ser "
"usados. Como a implementaÁ„o do aliasing de cada disco (partiÁ„o) para dois "
"dispositivos com semÌ¢ntica diferente complicou significativamente o cÛdigo do "
"kernel relevante, o FreeBSD removeu o suporte para dispositivos de disco em cache "
"como parte da modernizaÁ„o da infra-estrutura de E / S de disco. "

#: book.translate.xml:16344
#, fuzzy
msgid "Network Drivers"
msgstr "Drivers de Rede"

#: book.translate.xml:16346
#, fuzzy
msgid "<primary>network devices</primary>"
msgstr " <primary> dispositivos de rede </primary> "

#: book.translate.xml:16349
#, fuzzy
msgid ""
"Drivers for network devices do not use device nodes in order to be accessed. Their "
"selection is based on other decisions made inside the kernel and instead of calling "
"open(), use of a network device is generally introduced by using the system call "
"socket(2)."
msgstr ""
"Drivers para dispositivos de rede n„o usam nÛs de dispositivos para serem acessados. "
"Sua seleÁ„o È baseada em outras decisÌµes feitas dentro do kernel e em vez de chamar "
"open (), o uso de um dispositivo de rede È geralmente introduzido usando o socket de "
"chamada do sistema ( 2) "

#: book.translate.xml:16355
#, fuzzy
msgid ""
"For more information see ifnet(9), the source of the loopback device, and Bill "
"Paul's network drivers."
msgstr ""
"Para obter mais informaÁÌµes, consulte ifnet (9), a origem do dispositivo de "
"loopback e os drivers de rede de Bill Paul."

#: book.translate.xml:16367
#, fuzzy
msgid "ISA Device Drivers"
msgstr "Drivers de dispositivo ISA"

#: book.translate.xml:19338 book.translate.xml:16369
#, fuzzy
msgid ""
"<personname><firstname>Sergey</firstname><surname>Babkin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Sergey </firstname><surname> Babkin </surname></"
"personname><contrib> Escrito por </contrib> "

#: book.translate.xml:21581 book.translate.xml:19341 book.translate.xml:16372
#, fuzzy
msgid ""
"<personname><firstname>Murray</firstname><surname>Stokely</surname></"
"personname><contrib>Modifications for Handbook made by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> ModificaÁÌµes para o manual feito por </contrib> "

#: book.translate.xml:16373
#, fuzzy
msgid ""
"<personname><firstname>Valentino</firstname><surname>Vaschetto</surname></personname>"
msgstr ""
" <personname><firstname> Valentino </firstname><surname> Vaschetto </surname></"
"personname> "

#: book.translate.xml:16374
#, fuzzy
msgid ""
"<personname><firstname>Wylie</firstname><surname>Stilwell</surname></personname>"
msgstr ""
" <personname><firstname> Wylie </firstname><surname> Stilwell </surname></"
"personname> "

#: book.translate.xml:16383
#, fuzzy
msgid "<primary>ISA</primary>"
msgstr " <primary> ISA </primary> "

#: book.translate.xml:16384
#, fuzzy
msgid "<primary>device driver</primary><secondary>ISA</secondary>"
msgstr " <primary> driver do dispositivo </primary><secondary> Ìâ UM </secondary> "

#: book.translate.xml:16386
#, fuzzy
msgid ""
"This chapter introduces the issues relevant to writing a driver for an ISA device. "
"The pseudo-code presented here is rather detailed and reminiscent of the real code "
"but is still only pseudo-code. It avoids the details irrelevant to the subject of "
"the discussion. The real-life examples can be found in the source code of real "
"drivers. In particular the drivers <literal>ep</literal> and <literal>aha</literal> "
"are good sources of information."
msgstr ""
"Este capÌ≠tulo apresenta as questÌµes relevantes para escrever um driver para um "
"dispositivo ISA. O pseudo-cÛdigo apresentado aqui È bastante detalhado e lembra o "
"cÛdigo real, mas ainda È apenas pseudo-cÛdigo. Evita os detalhes irrelevantes para o "
"assunto da discuss„o Os exemplos da vida real podem ser encontrados no cÛdigo fonte "
"dos drivers reais. <literal> ep </literal> e <literal> aha </literal> s„o boas "
"fontes de informaÁ„o \""

#: book.translate.xml:16396
#, fuzzy
msgid "Basic Information"
msgstr "InformaÁ„o b·sica"

#: book.translate.xml:16398
#, fuzzy
msgid "A typical ISA driver would need the following include files:"
msgstr "Um driver ISA tÌ≠pico precisaria dos seguintes arquivos include:"

#: book.translate.xml:16410
#, fuzzy
msgid "They describe the things specific to the ISA and generic bus subsystem."
msgstr ""
"Eles descrevem as coisas especÌ≠ficas do ISA e do subsistema de barramento genÈrico."

#: book.translate.xml:16413
#, fuzzy
msgid "<primary>object-oriented</primary>"
msgstr " <primary> Orientado a Objeto </primary> "

#: book.translate.xml:16414
#, fuzzy
msgid ""
"The bus subsystem is implemented in an object-oriented fashion, its main structures "
"are accessed by associated method functions."
msgstr ""
"O subsistema de barramento È implementado de forma orientada a objeto, suas "
"principais estruturas s„o acessadas por funÁÌµes de mÈtodo associadas."

#: book.translate.xml:16418
#, fuzzy
msgid "<primary>bus methods</primary>"
msgstr " <primary> mÈtodos de Ì¥nibus </primary> "

#: book.translate.xml:16419
#, fuzzy
msgid ""
"The list of bus methods implemented by an ISA driver is like one for any other bus. "
"For a hypothetical driver named <quote>xxx</quote> they would be:"
msgstr ""
"A lista de mÈtodos de barramento implementados por um driver ISA È como um para "
"qualquer outro barramento. Para um driver hipotÈtico chamado <quote> xxx </quote> "
"eles seriam:"

#: book.translate.xml:16425
#, fuzzy
msgid ""
"<function>static void xxx_isa_identify (driver_t *, device_t);</function> Normally "
"used for bus drivers, not device drivers. But for ISA devices this method may have "
"special use: if the device provides some device-specific (non-PnP) way to auto-"
"detect devices this routine may implement it."
msgstr ""
" <function> Vazio est·tico xxx_isa_identify (driver_t *, device_t); </function> "
"Normalmente usado para motoristas de Ì¥nibus, n„o drivers de dispositivo. Mas, para "
"dispositivos ISA, esse mÈtodo pode ter um uso especial: se o dispositivo fornecer "
"alguma maneira especÌ≠fica de dispositivo (n„o PnP) de detectar dispositivos "
"automaticamente, essa rotina poder· implement·-lo. "

#: book.translate.xml:16434
#, fuzzy
msgid ""
"<function>static int xxx_isa_probe (device_t dev);</function> Probe for a device at "
"a known (or PnP) location. This routine can also accommodate device-specific auto-"
"detection of parameters for partially configured devices."
msgstr ""
" <function> est·tico int xxx_isa_probe (device_t dev); </function> Sonda para um "
"dispositivo em um local conhecido (ou PnP). Essa rotina tambÈm pode acomodar a "
"detecÁ„o autom·tica especÌ≠fica de dispositivos de parÌ¢metros para dispositivos "
"parcialmente configurados. "

#: book.translate.xml:16442
#, fuzzy
msgid ""
"<function>static int xxx_isa_attach (device_t dev);</function> Attach and initialize "
"device."
msgstr ""
" <function> est·tico int xxx_isa_attach (device_t dev); </function> Anexe e "
"inicialize o dispositivo. "

#: book.translate.xml:16447
#, fuzzy
msgid ""
"<function>static int xxx_isa_detach (device_t dev);</function> Detach device before "
"unloading the driver module."
msgstr ""
" <function> est·tico int xxx_isa_detach (device_t dev); </function> Retire o "
"dispositivo antes de descarregar o mÛdulo do driver. "

#: book.translate.xml:16453
#, fuzzy
msgid ""
"<function>static int xxx_isa_shutdown (device_t dev);</function> Execute shutdown of "
"the device before system shutdown."
msgstr ""
" <function> est·tico int xxx_isa_shutdown (device_t dev); </function> Execute o "
"desligamento do dispositivo antes do desligamento do sistema. "

#: book.translate.xml:16459
#, fuzzy
msgid ""
"<function>static int xxx_isa_suspend (device_t dev);</function> Suspend the device "
"before the system goes to the power-save state. May also abort transition to the "
"power-save state."
msgstr ""
" <function> est·tico int xxx_isa_suspend (device_t dev); </function> Suspenda o "
"dispositivo antes que o sistema v· para o estado de economia de energia. Pode tambÈm "
"abortar a transiÁ„o para o estado de economia de energia. "

#: book.translate.xml:16466
#, fuzzy
msgid ""
"<function>static int xxx_isa_resume (device_t dev);</function> Resume the device "
"activity after return from power-save state."
msgstr ""
" <function> est·tico int xxx_isa_resume (device_t dev); </function> Retomar a "
"atividade do dispositivo apÛs o retorno do estado de economia de energia. "

#: book.translate.xml:16473
#, fuzzy
msgid ""
"<function>xxx_isa_probe()</function> and <function>xxx_isa_attach()</function> are "
"mandatory, the rest of the routines are optional, depending on the device's needs."
msgstr ""
" <function> xxx_isa_probe () </function> e <function> xxx_isa_attach () </function> "
"s„o obrigatÛrios, o resto das rotinas s„o opcionais, dependendo das necessidades do "
"dispositivo. "

#: book.translate.xml:16478
#, fuzzy
msgid "The driver is linked to the system with the following set of descriptions."
msgstr "O driver est· ligado ao sistema com o seguinte conjunto de descriÁÌµes."

#: book.translate.xml:16508
#, fuzzy
msgid "<primary>softc</primary>"
msgstr " <primary> softc </primary> "

#: book.translate.xml:16510
#, fuzzy
msgid ""
"Here struct <varname remap=\"structname\">xxx_softc</varname> is a device-specific "
"structure that contains private driver data and descriptors for the driver's "
"resources. The bus code automatically allocates one softc descriptor per device as "
"needed."
msgstr ""
"Aqui struct <varname remap=\"structname\"> xxx_softc </varname> È uma estrutura "
"especÌ≠fica do dispositivo que contÈm dados do driver privado e descritores para os "
"recursos do driver. O cÛdigo de barramento aloca automaticamente um descritor softc "
"por dispositivo, conforme necess·rio. "

#: book.translate.xml:16516
#, fuzzy
msgid "<primary>kernel module</primary>"
msgstr " <primary> mÛdulo do kernel </primary> "

#: book.translate.xml:16518
#, fuzzy
msgid ""
"If the driver is implemented as a loadable module then <function>load_function()</"
"function> is called to do driver-specific initialization or clean-up when the driver "
"is loaded or unloaded and load_argument is passed as one of its arguments. If the "
"driver does not support dynamic loading (in other words it must always be linked "
"into the kernel) then these values should be set to 0 and the last definition would "
"look like:"
msgstr ""
"Se o driver for implementado como um mÛdulo carreg·vel, <function> load_function () "
"</function> È chamado para fazer inicializaÁ„o ou limpeza especÌ≠fica do driver "
"quando o driver È carregado ou descarregado e load_argument È passado como um dos "
"seus argumentos. Se o driver n„o suportar o carregamento dinÌ¢mico (em outras "
"palavras, ele deve estar sempre vinculado ao kernel), ent„o esses valores devem ser "
"definidos como 0 e a ˙ltima definiÁ„o deve ficar assim: "

#: book.translate.xml:16530
#, fuzzy
msgid "<primary>PnP</primary>"
msgstr " <primary> PnP </primary> "

#: book.translate.xml:16532
#, fuzzy
msgid ""
"If the driver is for a device which supports PnP then a table of supported PnP IDs "
"must be defined. The table consists of a list of PnP IDs supported by this driver "
"and human-readable descriptions of the hardware types and models having these IDs. "
"It looks like:"
msgstr ""
"Se o driver for para um dispositivo que suporte PnP, uma tabela de IDs PnP compatÌ≠"
"veis deve ser definida. A tabela consiste em uma lista de IDs PnP suportados por "
"esse driver e descriÁÌµes legÌ≠veis por humanos dos tipos e modelos de hardware que "
"possuem esses IDs. Parece: "

#: book.translate.xml:16545
#, fuzzy
msgid ""
"If the driver does not support PnP devices it still needs an empty PnP ID table, "
"like:"
msgstr ""
"Se o driver n„o suporta dispositivos PnP, ele ainda precisa de uma tabela vazia de "
"IDs PnP, como:"

#: book.translate.xml:16555
#, fuzzy
msgid "<varname remap=\"structname\">device_t</varname> Pointer"
msgstr " <varname remap=\"structname\"> device_t </varname> Ponteiro "

#: book.translate.xml:16557
#, fuzzy
msgid ""
"<varname remap=\"structname\">device_t</varname> is the pointer type for the device "
"structure. Here we consider only the methods interesting from the device driver "
"writer's standpoint. The methods to manipulate values in the device structure are:"
msgstr ""
" <varname remap=\"structname\"> device_t </varname> È o tipo de ponteiro para a "
"estrutura do dispositivo. Aqui consideramos apenas os mÈtodos interessantes do ponto "
"de vista do gravador do driver de dispositivo. Os mÈtodos para manipular valores na "
"estrutura do dispositivo s„o: "

#: book.translate.xml:16565
#, fuzzy
msgid ""
"<function>device_t device_get_parent(dev)</function> Get the parent bus of a device."
msgstr ""
" <function> device_t device_get_parent (dev) </function> Obtenha o barramento pai de "
"um dispositivo \""

#: book.translate.xml:16569
#, fuzzy
msgid ""
"<function>driver_t device_get_driver(dev)</function> Get pointer to its driver "
"structure."
msgstr ""
" <function> driver_t device_get_driver (dev) </function> Obter ponteiro para sua "
"estrutura de driver \""

#: book.translate.xml:16573
#, fuzzy
msgid ""
"<function>char *device_get_name(dev)</function> Get the driver name, such as "
"<literal>\"xxx\"</literal> for our example."
msgstr ""
" <function> char * device_get_name (dev) </function> Obtenha o nome do driver, como "
"<literal> \\ \"xxx \" </literal> para o nosso exemplo \""

#: book.translate.xml:16577
#, fuzzy
msgid ""
"<function>int device_get_unit(dev)</function> Get the unit number (units are "
"numbered from 0 for the devices associated with each driver)."
msgstr ""
" <function> int device_get_unit (dev) </function> Obtenha o n˙mero da unidade (as "
"unidades s„o numeradas de 0 para os dispositivos associados a cada driver). "

#: book.translate.xml:16581
#, fuzzy
msgid ""
"<function>char *device_get_nameunit(dev)</function> Get the device name including "
"the unit number, such as <quote>xxx0</quote>, <quote>xxx1</quote> and so on."
msgstr ""
" <function> char * device_get_nameunit (dev) </function> Obtenha o nome do "
"dispositivo, incluindo o n˙mero da unidade, como <quote> xxx0 </quote> , <quote> "
"xxx1 </quote> e assim por diante."

#: book.translate.xml:16586
#, fuzzy
msgid ""
"<function>char *device_get_desc(dev)</function> Get the device description. Normally "
"it describes the exact model of device in human-readable form."
msgstr ""
" <function> char * device_get_desc (dev) </function> Obtenha a descriÁ„o do "
"dispositivo. Normalmente, descreve o modelo exato do dispositivo em forma legÌ≠vel "
"por humanos. "

#: book.translate.xml:16591
#, fuzzy
msgid ""
"<function>device_set_desc(dev, desc)</function> Set the description. This makes the "
"device description point to the string desc which may not be deallocated or changed "
"after that."
msgstr ""
" <function> device_set_desc (dev, desc) </function> Defina a descriÁ„o. Isso faz com "
"que a descriÁ„o do dispositivo aponte para a string desc que n„o pode ser desalocada "
"ou alterada depois disso. "

#: book.translate.xml:16596
#, fuzzy
msgid ""
"<function>device_set_desc_copy(dev, desc)</function> Set the description. The "
"description is copied into an internal dynamically allocated buffer, so the string "
"desc may be changed afterwards without adverse effects."
msgstr ""
" <function> device_set_desc_copy (dev, desc) </function> Defina a descriÁ„o. A "
"descriÁ„o È copiada em um buffer interno alocado dinamicamente, ent„o a string desc "
"pode ser alterada posteriormente sem efeitos adversos. "

#: book.translate.xml:16602
#, fuzzy
msgid ""
"<function>void *device_get_softc(dev)</function> Get pointer to the device "
"descriptor (struct <varname remap=\"structname\">xxx_softc</varname>) associated "
"with this device."
msgstr ""
" <function> void * device_get_softc (dev) </function> ObtÈm o ponteiro para o "
"descritor de dispositivo (struct <varname remap=\"structname\"> xxx_softc </"
"varname> ) associado a este dispositivo. "

#: book.translate.xml:16607
#, fuzzy
msgid ""
"<function>u_int32_t device_get_flags(dev)</function> Get the flags specified for the "
"device in the configuration file."
msgstr ""
" <function> u_int32_t device_get_flags (dev) </function> Obtenha os sinalizadores "
"especificados para o dispositivo no arquivo de configuraÁ„o. "

#: book.translate.xml:16613
#, fuzzy
msgid ""
"A convenience function <function>device_printf(dev, fmt, ...)</function> may be used "
"to print the messages from the device driver. It automatically prepends the unitname "
"and colon to the message."
msgstr ""
"Uma funÁ„o de conveniÍncia <function> device_printf (dev, fmt, ...) </function> pode "
"ser usado para imprimir as mensagens do driver de dispositivo. Ele preenche "
"automaticamente o nome da unidade e os dois pontos da mensagem. "

#: book.translate.xml:16618
#, fuzzy
msgid ""
"The device_t methods are implemented in the file <filename>kern/bus_subr.c</"
"filename>."
msgstr ""
"Os mÈtodos device_t s„o implementados no arquivo <filename> kern / bus_subr.c </"
"filename> "

#: book.translate.xml:16624
#, fuzzy
msgid ""
"Configuration File and the Order of Identifying and Probing During Auto-Configuration"
msgstr ""
"Arquivo de configuraÁ„o e a ordem de identificaÁ„o e pesquisa durante a configuraÁ„o "
"autom·tica"

#: book.translate.xml:16627
#, fuzzy
msgid "<primary>ISA</primary><secondary>probing</secondary>"
msgstr " <primary> Ìâ UM </primary><secondary> sondagem </secondary> "

#: book.translate.xml:16629
#, fuzzy
msgid "The ISA devices are described in the kernel configuration file like:"
msgstr "Os dispositivos ISA s„o descritos no arquivo de configuraÁ„o do kernel como:"

#: book.translate.xml:16635
#, fuzzy
msgid "<primary>IRQ</primary>"
msgstr " <primary> IRQ </primary> "

#: book.translate.xml:16637
#, fuzzy
msgid ""
"The values of port, IRQ and so on are converted to the resource values associated "
"with the device. They are optional, depending on the device's needs and abilities "
"for auto-configuration. For example, some devices do not need DRQ at all and some "
"allow the driver to read the IRQ setting from the device configuration ports. If a "
"machine has multiple ISA buses the exact bus may be specified in the configuration "
"line, like <literal>isa0</literal> or <literal>isa1</literal>, otherwise the device "
"would be searched for on all the ISA buses."
msgstr ""
"Os valores de porta, IRQ e assim por diante s„o convertidos para os valores de "
"recursos associados ao dispositivo. Eles s„o opcionais, dependendo das necessidades "
"e capacidades do dispositivo para a autoconfiguraÁ„o. Por exemplo, alguns "
"dispositivos n„o precisam de DRQ e alguns permite que o driver leia a configuraÁ„o "
"de IRQ a partir das portas de configuraÁ„o do dispositivo.Se uma m·quina tiver "
"v·rios barramentos ISA, o barramento exato pode ser especificado na linha de "
"configuraÁ„o, como <literal> isa0 </literal> ou <literal> isa1 </literal> caso "
"contr·rio, o dispositivo seria procurado em todos os barramentos ISA. "

#: book.translate.xml:16647
#, fuzzy
msgid ""
"<literal>sensitive</literal> is a resource requesting that this device must be "
"probed before all non-sensitive devices. It is supported but does not seem to be "
"used in any current driver."
msgstr ""
" <literal> sensÌ≠vel </literal> È um recurso que solicita que este dispositivo seja "
"analisado antes de todos os dispositivos n„o sensÌ≠veis. Ìâ suportado, mas n„o parece "
"ser usado em nenhum driver atual. "

#: book.translate.xml:16651
#, fuzzy
msgid ""
"For legacy ISA devices in many cases the drivers are still able to detect the "
"configuration parameters. But each device to be configured in the system must have a "
"config line. If two devices of some type are installed in the system but there is "
"only one configuration line for the corresponding driver, ie: <_:programlisting-1/> "
"then only one device will be configured."
msgstr ""
"Para dispositivos ISA legados, em muitos casos, os drivers ainda s„o capazes de "
"detectar os parÌ¢metros de configuraÁ„o. Mas cada dispositivo a ser configurado no "
"sistema deve ter uma linha de configuraÁ„o. Se dois dispositivos de algum tipo "
"estiverem instalados no sistema, h· apenas um linha de configuraÁ„o para o driver "
"correspondente, ou seja: <_: programlisting-1 /> ent„o apenas um dispositivo ser· "
"configurado. "

#: book.translate.xml:16659
#, fuzzy
msgid ""
"But for the devices supporting automatic identification by the means of Plug-n-Play "
"or some proprietary protocol one configuration line is enough to configure all the "
"devices in the system, like the one above or just simply:"
msgstr ""
"Mas para os dispositivos que suportam identificaÁ„o autom·tica por meio do Plug-n-"
"Play ou algum protocolo propriet·rio, uma linha de configuraÁ„o È suficiente para "
"configurar todos os dispositivos no sistema, como o acima ou simplesmente:"

#: book.translate.xml:16666
#, fuzzy
msgid ""
"If a driver supports both auto-identified and legacy devices and both kinds are "
"installed at once in one machine then it is enough to describe in the config file "
"the legacy devices only. The auto-identified devices will be added automatically."
msgstr ""
"Se um driver suportar dispositivos legados e identificados automaticamente e ambos "
"os tipos forem instalados de uma sÛ vez em uma m·quina, ser· suficiente descrever "
"apenas no arquivo de configuraÁ„o os dispositivos legados. Os dispositivos "
"identificados automaticamente ser„o adicionados automaticamente."

#: book.translate.xml:16672
#, fuzzy
msgid "When an ISA bus is auto-configured the events happen as follows:"
msgstr ""
"Quando um barramento ISA È configurado automaticamente, os eventos acontecem da "
"seguinte maneira:"

#: book.translate.xml:16675
#, fuzzy
msgid ""
"All the drivers' identify routines (including the PnP identify routine which "
"identifies all the PnP devices) are called in random order. As they identify the "
"devices they add them to the list on the ISA bus. Normally the drivers' identify "
"routines associate their drivers with the new devices. The PnP identify routine does "
"not know about the other drivers yet so it does not associate any with the new "
"devices it adds."
msgstr ""
"Todas as rotinas de identificaÁ„o dos motoristas (incluindo a rotina de "
"identificaÁ„o PnP que identifica todos os dispositivos PnP) s„o chamadas em ordem "
"aleatÛria. Ao identificar os dispositivos, elas s„o adicionadas Ì† lista no "
"barramento ISA. Normalmente, as rotinas de identificaÁ„o dos motoristas associam "
"drivers com os novos dispositivos. A rotina de identificaÁ„o do PnP ainda n„o "
"conhece os outros drivers, por isso n„o associa qualquer um aos novos dispositivos "
"que ele adiciona. "

#: book.translate.xml:16684
#, fuzzy
msgid ""
"The PnP devices are put to sleep using the PnP protocol to prevent them from being "
"probed as legacy devices."
msgstr ""
"Os dispositivos PnP s„o colocados em suspens„o usando o protocolo PnP para impedir "
"que sejam testados como dispositivos legados."

#: book.translate.xml:16687
#, fuzzy
msgid ""
"The probe routines of non-PnP devices marked as <literal>sensitive</literal> are "
"called. If probe for a device went successfully, the attach routine is called for it."
msgstr ""
"As rotinas de sondagem de dispositivos n„o PnP marcados como <literal> sensÌ≠vel </"
"literal> s„o chamados. Se o probe para um dispositivo foi bem-sucedido, a rotina de "
"anexaÁ„o È chamada para ele. "

#: book.translate.xml:16691
#, fuzzy
msgid "The probe and attach routines of all non-PNP devices are called likewise."
msgstr ""
"As rotinas de teste e anexaÁ„o de todos os dispositivos n„o-PNP s„o chamadas da "
"mesma forma."

#: book.translate.xml:16694
#, fuzzy
msgid ""
"The PnP devices are brought back from the sleep state and assigned the resources "
"they request: I/O and memory address ranges, IRQs and DRQs, all of them not "
"conflicting with the attached legacy devices."
msgstr ""
"Os dispositivos PnP s„o trazidos de volta do estado de suspens„o e recebem os "
"recursos que eles solicitam: E / S e intervalos de endereÁos de memÛria, IRQs e "
"DRQs, todos eles n„o conflitam com os dispositivos legados anexados."

#: book.translate.xml:16699
#, fuzzy
msgid ""
"Then for each PnP device the probe routines of all the present ISA drivers are "
"called. The first one that claims the device gets attached. It is possible that "
"multiple drivers would claim the device with different priority; in this case, the "
"highest-priority driver wins. The probe routines must call "
"<function>ISA_PNP_PROBE()</function> to compare the actual PnP ID with the list of "
"the IDs supported by the driver and if the ID is not in the table return failure. "
"That means that absolutely every driver, even the ones not supporting any PnP "
"devices must call <function>ISA_PNP_PROBE()</function>, at least with an empty PnP "
"ID table to return failure on unknown PnP devices."
msgstr ""
"Ent„o, para cada dispositivo PnP, as rotinas de an·lise de todos os drivers ISA "
"atuais s„o chamadas. A primeira que reivindica o dispositivo È anexada. Ìâ possÌ≠vel "
"que v·rios drivers reivindiquem o dispositivo com prioridade diferente; nesse caso, "
"a prioridade mais alta o driver ganha.As rotinas de teste devem chamar <function> "
"ISA_PNP_PROBE () </function> para comparar o ID PnP real com a lista de IDs "
"suportados pelo driver e se o ID n„o estiver na falha de retorno da tabela. Isso "
"significa que absolutamente todos os drivers, mesmo aqueles que n„o suportam "
"qualquer dispositivo PnP, devem ligar <function> ISA_PNP_PROBE () </function> , pelo "
"menos com uma tabela vazia de IDs PnP para retornar falhas em dispositivos PnP "
"desconhecidos. "

#: book.translate.xml:16712
#, fuzzy
msgid ""
"The probe routine returns a positive value (the error code) on error, zero or "
"negative value on success."
msgstr ""
"A rotina da sonda retorna um valor positivo (o cÛdigo de erro) no erro, valor zero "
"ou negativo no sucesso."

#: book.translate.xml:16715
#, fuzzy
msgid ""
"The negative return values are used when a PnP device supports multiple interfaces. "
"For example, an older compatibility interface and a newer advanced interface which "
"are supported by different drivers. Then both drivers would detect the device. The "
"driver which returns a higher value in the probe routine takes precedence (in other "
"words, the driver returning 0 has highest precedence, returning -1 is next, "
"returning -2 is after it and so on). In result the devices which support only the "
"old interface will be handled by the old driver (which should return -1 from the "
"probe routine) while the devices supporting the new interface as well will be "
"handled by the new driver (which should return 0 from the probe routine). If "
"multiple drivers return the same value then the one called first wins. So if a "
"driver returns value 0 it may be sure that it won the priority arbitration."
msgstr ""
"Os valores de retorno negativos s„o usados ‚Äã‚Äãquando um dispositivo PnP suporta "
"v·rias interfaces. Por exemplo, uma interface de compatibilidade mais antiga e uma "
"interface avanÁada mais recente suportada por drivers diferentes. Ent„o, ambos os "
"drivers detectariam o dispositivo. O driver que retorna um valor mais alto a rotina "
"da sonda tem precedÍncia (em outras palavras, o driver retornando 0 tem a "
"precedÍncia mais alta, retornando -1 È a prÛxima, retornando -2 È depois dela e "
"assim por diante.) Em resultado, os dispositivos que suportam apenas a interface "
"antiga ser„o manipulados pelo driver antigo (que deve retornar -1 da rotina da "
"sonda), enquanto os dispositivos que suportam a nova interface tambÈm ser„o "
"manipulados pelo novo driver (que deve retornar 0 da rotina da sonda) .Se v·rios "
"drivers retornarem o mesmo valor, ent„o o chamadas primeiras vitÛrias. Ent„o, se um "
"driver retornar o valor 0, pode ter certeza de que ganhou a arbitragem priorit·ria. "

#: book.translate.xml:16731
#, fuzzy
msgid ""
"The device-specific identify routines can also assign not a driver but a class of "
"drivers to the device. Then all the drivers in the class are probed for this device, "
"like the case with PnP. This feature is not implemented in any existing driver and "
"is not considered further in this document."
msgstr ""
"As rotinas de identificaÁ„o especÌ≠ficas do dispositivo tambÈm podem designar n„o um "
"driver, mas uma classe de drivers para o dispositivo. Ent„o, todos os drivers da "
"classe s„o testados para esse dispositivo, como no caso do PnP. Esse recurso n„o È "
"implementado em nenhum driver existente. e n„o È considerado mais adiante neste "
"documento. "

#: book.translate.xml:16737
#, fuzzy
msgid ""
"Because the PnP devices are disabled when probing the legacy devices they will not "
"be attached twice (once as legacy and once as PnP). But in case of device-dependent "
"identify routines it is the responsibility of the driver to make sure that the same "
"device will not be attached by the driver twice: once as legacy user-configured and "
"once as auto-identified."
msgstr ""
"Como os dispositivos PnP s„o desativados ao sondar os dispositivos herdados, eles "
"n„o ser„o conectados duas vezes (uma vez como legado e uma vez como PnP). Mas, no "
"caso de rotinas de identificaÁ„o dependentes de dispositivo, È responsabilidade do "
"motorista certificar-se de que o dispositivo n„o ser· conectado pelo driver duas "
"vezes: uma vez como legado configurado pelo usu·rio e uma vez como identificado "
"automaticamente. "

#: book.translate.xml:16745
#, fuzzy
msgid ""
"Another practical consequence for the auto-identified devices (both PnP and device-"
"specific) is that the flags can not be passed to them from the kernel configuration "
"file. So they must either not use the flags at all or use the flags from the device "
"unit 0 for all the auto-identified devices or use the sysctl interface instead of "
"flags."
msgstr ""
"Outra conseqÌºÍncia pr·tica para os dispositivos identificados automaticamente "
"(tanto PnP quanto especÌ≠ficos do dispositivo) È que os flags n„o podem ser passados "
"‚Äã‚Äãpara eles a partir do arquivo de configuraÁ„o do kernel. Portanto, eles n„o devem "
"usar as flags ou usar os sinalizadores do unidade de dispositivo 0 para todos os "
"dispositivos identificados automaticamente ou use a interface sysctl em vez de "
"sinalizadores. "

#: book.translate.xml:16752
#, fuzzy
msgid ""
"Other unusual configurations may be accommodated by accessing the configuration "
"resources directly with functions of families <function>resource_query_*()</"
"function> and <function>resource_*_value()</function>. Their implementations are "
"located in <filename>kern/subr_bus.c</filename>. The old IDE disk driver "
"<filename>i386/isa/wd.c</filename> contains examples of such use. But the standard "
"means of configuration must always be preferred. Leave parsing the configuration "
"resources to the bus configuration code."
msgstr ""
"Outras configuraÁÌµes incomuns podem ser acomodadas acessando os recursos de "
"configuraÁ„o diretamente com as funÁÌµes das famÌ≠lias. <function> resource_query _ * "
"() </function> e <function> recurso _ * _ valor () </function> . Suas "
"implementaÁÌµes est„o localizadas em <filename> kern / subr_bus.c </filename> . O "
"antigo driver de disco IDE <filename> i386 / isa / wd.c </filename> contÈm exemplos "
"de tal uso. Mas os meios padr„o de configuraÁ„o sempre devem ser preferidos. Deixe "
"analisando os recursos de configuraÁ„o para o cÛdigo de configuraÁ„o do barramento. "

#: book.translate.xml:16765
#, fuzzy
msgid "Resources"
msgstr "Recursos"

#: book.translate.xml:16767
#, fuzzy
msgid "<primary>resources</primary>"
msgstr " <primary> Recursos </primary> "

#: book.translate.xml:16768
#, fuzzy
msgid "<primary>device driver</primary><secondary>resources</secondary>"
msgstr " <primary> driver do dispositivo </primary><secondary> Recursos </secondary> "

#: book.translate.xml:16770
#, fuzzy
msgid ""
"The information that a user enters into the kernel configuration file is processed "
"and passed to the kernel as configuration resources. This information is parsed by "
"the bus configuration code and transformed into a value of structure device_t and "
"the bus resources associated with it. The drivers may access the configuration "
"resources directly using functions <function>resource_*</function> for more complex "
"cases of configuration. However, generally this is neither needed nor recommended, "
"so this issue is not discussed further here."
msgstr ""
"As informaÁÌµes que um usu·rio insere no arquivo de configuraÁ„o do kernel s„o "
"processadas e passadas para o kernel como recursos de configuraÁ„o. Essas "
"informaÁÌµes s„o analisadas pelo cÛdigo de configuraÁ„o do barramento e "
"transformadas em um valor de estrutura device_t e os recursos de barramento "
"associados a ele. pode acessar os recursos de configuraÁ„o diretamente usando "
"funÁÌµes <function> recurso_* </function> para casos mais complexos de configuraÁ„o. "
"No entanto, geralmente isso n„o È necess·rio nem recomendado, por isso esta quest„o "
"n„o È discutida aqui. "

#: book.translate.xml:16780
#, fuzzy
msgid ""
"The bus resources are associated with each device. They are identified by type and "
"number within the type. For the ISA bus the following types are defined:"
msgstr ""
"Os recursos de barramento est„o associados a cada dispositivo. Eles s„o "
"identificados por tipo e n˙mero dentro do tipo. Para o barramento ISA, os seguintes "
"tipos s„o definidos:"

#: book.translate.xml:16784
#, fuzzy
msgid "<primary>DMA channel</primary>"
msgstr " <primary> Canal de DMA </primary> "

#: book.translate.xml:16788
#, fuzzy
msgid "<emphasis>SYS_RES_IRQ</emphasis> - interrupt number"
msgstr " <emphasis> SYS_RES_IRQ </emphasis> - n˙mero de interrupÁ„o "

#: book.translate.xml:16793
#, fuzzy
msgid "<emphasis>SYS_RES_DRQ</emphasis> - ISA DMA channel number"
msgstr " <emphasis> SYS_RES_DRQ </emphasis> - n˙mero do canal ISA DMA "

#: book.translate.xml:16798
#, fuzzy
msgid ""
"<emphasis>SYS_RES_MEMORY</emphasis> - range of device memory mapped into the system "
"memory space"
msgstr ""
" <emphasis> SYS_RES_MEMORY </emphasis> - intervalo de memÛria do dispositivo mapeado "
"no espaÁo de memÛria do sistema "

#: book.translate.xml:16804
#, fuzzy
msgid "<emphasis>SYS_RES_IOPORT</emphasis> - range of device I/O registers"
msgstr ""
" <emphasis> SYS_RES_IOPORT </emphasis> - intervalo de registros de E / S do "
"dispositivo "

#: book.translate.xml:16809
#, fuzzy
msgid ""
"The enumeration within types starts from 0, so if a device has two memory regions it "
"would have resources of type <literal>SYS_RES_MEMORY</literal> numbered 0 and 1. The "
"resource type has nothing to do with the C language type, all the resource values "
"have the C language type <literal>unsigned long</literal> and must be cast as "
"necessary. The resource numbers do not have to be contiguous, although for ISA they "
"normally would be. The permitted resource numbers for ISA devices are:"
msgstr ""
"A enumeraÁ„o dentro de tipos comeÁa em 0, portanto, se um dispositivo tiver duas "
"regiÌµes de memÛria, ele ter· recursos do tipo <literal> SYS_RES_MEMORY </literal> "
"numerados 0 e 1. O tipo de recurso n„o tem nada a ver com o tipo de linguagem C, "
"todos os valores de recursos tÍm o tipo de linguagem C <literal> sem assinatura "
"longa </literal> e deve ser lanÁado conforme necess·rio. Os n˙meros de recursos n„o "
"precisam ser contÌ≠guos, embora, para o ISA, eles normalmente sejam. Os n˙meros de "
"recursos permitidos para dispositivos ISA s„o: "

#: book.translate.xml:16823
#, fuzzy
msgid ""
"All the resources are represented as ranges, with a start value and count. For IRQ "
"and DRQ resources the count would normally be equal to 1. The values for memory "
"refer to the physical addresses."
msgstr ""
"Todos os recursos s„o representados como intervalos, com um valor inicial e uma "
"contagem. Para recursos de IRQ e DRQ, a contagem normalmente seria igual a 1. Os "
"valores para memÛria referem-se aos endereÁos fÌ≠sicos."

#: book.translate.xml:16828
#, fuzzy
msgid "Three types of activities can be performed on resources:"
msgstr "TrÍs tipos de atividades podem ser executadas em recursos:"

#: book.translate.xml:16832
#, fuzzy
msgid "set/get"
msgstr "set / get"

#: book.translate.xml:16833
#, fuzzy
msgid "allocate/release"
msgstr "alocar / liberar"

#: book.translate.xml:16834
#, fuzzy
msgid "activate/deactivate"
msgstr "ativar / desativar"

#: book.translate.xml:16837
#, fuzzy
msgid ""
"Setting sets the range used by the resource. Allocation reserves the requested range "
"that no other driver would be able to reserve it (and checking that no other driver "
"reserved this range already). Activation makes the resource accessible to the driver "
"by doing whatever is necessary for that (for example, for memory it would be mapping "
"into the kernel virtual address space)."
msgstr ""
"A configuraÁ„o define o intervalo usado pelo recurso. A alocaÁ„o reserva o intervalo "
"solicitado que nenhum outro driver poder· reserv·-lo (e verificar se nenhum outro "
"driver j· reservou esse intervalo). A ativaÁ„o torna o recurso acessÌ≠vel ao driver "
"fazendo o que for necess·rio para isso (por exemplo, para memÛria, seria mapeado "
"para o espaÁo de endereÁo virtual do kernel). "

#: book.translate.xml:16845
#, fuzzy
msgid "The functions to manipulate resources are:"
msgstr "As funÁÌµes para manipular recursos s„o:"

#: book.translate.xml:16849
#, fuzzy
msgid ""
"<function>int bus_set_resource(device_t dev, int type, int rid, u_long start, u_long "
"count)</function>"
msgstr ""
" <function> int bus_set_resource (device_t dev, int tipo, int rid, u_long start, "
"u_long count) </function> "

#: book.translate.xml:16852
#, fuzzy
msgid ""
"Set a range for a resource. Returns 0 if successful, error code otherwise. Normally, "
"this function will return an error only if one of <literal>type</literal>, "
"<literal>rid</literal>, <literal>start</literal> or <literal>count</literal> has a "
"value that falls out of the permitted range."
msgstr ""
"Definir um intervalo para um recurso. Retorna 0 se for bem-sucedido, cÛdigo de erro. "
"Normalmente, essa funÁ„o retornar· um erro somente se um dos <literal> tipo </"
"literal> , <literal> livrar </literal> , <literal> comeÁar </literal> ou <literal> "
"contagem </literal> tem um valor que cai fora do intervalo permitido \""

#: book.translate.xml:16861
#, fuzzy
msgid "dev - driver's device"
msgstr "dev - dispositivo do motorista"

#: book.translate.xml:16864
#, fuzzy
msgid "type - type of resource, SYS_RES_*"
msgstr "tipo - tipo de recurso, SYS_RES_ *"

#: book.translate.xml:16867
#, fuzzy
msgid "rid - resource number (ID) within type"
msgstr "rid - n˙mero do recurso (ID) dentro do tipo"

#: book.translate.xml:16870
#, fuzzy
msgid "start, count - resource range"
msgstr "start, count - intervalo de recursos"

#: book.translate.xml:16876
#, fuzzy
msgid ""
"<function>int bus_get_resource(device_t dev, int type, int rid, u_long *startp, "
"u_long *countp)</function>"
msgstr ""
" <function> int bus_get_resource (device_t dev, tipo int, int livrar, u_long * "
"startp, u_long * countp) </function> "

#: book.translate.xml:16879
#, fuzzy
msgid ""
"Get the range of resource. Returns 0 if successful, error code if the resource is "
"not defined yet."
msgstr ""
"ObtÈm o intervalo de recursos. Retorna 0 se for bem-sucedido, cÛdigo de erro se o "
"recurso ainda n„o estiver definido."

#: book.translate.xml:16884
#, fuzzy
msgid ""
"<function>u_long bus_get_resource_start(device_t dev, int type, int rid) u_long "
"bus_get_resource_count (device_t dev, int type, int rid)</function>"
msgstr ""
" <function> u_long bus_get_resource_start (device_t dev, int tipo, int rid) u_long "
"bus_get_resource_count (device_t dev, tipo int, int livrado) </function> "

#: book.translate.xml:16888
#, fuzzy
msgid ""
"Convenience functions to get only the start or count. Return 0 in case of error, so "
"if the resource start has 0 among the legitimate values it would be impossible to "
"tell if the value is 0 or an error occurred. Luckily, no ISA resources for add-on "
"drivers may have a start value equal to 0."
msgstr ""
"FunÁÌµes de conveniÍncia para obter apenas o inÌ≠cio ou a contagem. Retorna 0 em caso "
"de erro, portanto, se o inÌ≠cio do recurso tiver 0 entre os valores legÌ≠timos, seria "
"impossÌ≠vel dizer se o valor È 0 ou ocorreu um erro. Felizmente, n„o h· recursos do "
"ISA para drivers add-on pode ter um valor inicial igual a 0. "

#: book.translate.xml:16897
#, fuzzy
msgid "<function>void bus_delete_resource(device_t dev, int type, int rid)</function>"
msgstr ""
" <function> void bus_delete_resource (device_t dev, tipo int, int rid) </function> "

#: book.translate.xml:16899
#, fuzzy
msgid "Delete a resource, make it undefined."
msgstr "Excluir um recurso, torn·-lo indefinido."

#: book.translate.xml:16903
#, fuzzy
msgid ""
"<function>struct resource * bus_alloc_resource(device_t dev, int type, int *rid, "
"u_long start, u_long end, u_long count, u_int flags)</function>"
msgstr ""
" <function> struct resource * bus_alloc_resource (device_t dev, int tipo, int * rid, "
"u_long inÌ≠cio, u_long end, u_long count, u_int flags) </function> "

#: book.translate.xml:16908
#, fuzzy
msgid ""
"Allocate a resource as a range of count values not allocated by anyone else, "
"somewhere between start and end. Alas, alignment is not supported. If the resource "
"was not set yet it is automatically created. The special values of start 0 and end "
"~0 (all ones) means that the fixed values previously set by "
"<function>bus_set_resource()</function> must be used instead: start and count as "
"themselves and end=(start+count), in this case if the resource was not defined "
"before then an error is returned. Although rid is passed by reference it is not set "
"anywhere by the resource allocation code of the ISA bus. (The other buses may use a "
"different approach and modify it)."
msgstr ""
"Alocar um recurso como um intervalo de valores de contagem n„o alocado por mais "
"ninguÈm, em algum lugar entre o inÌ≠cio e o final. Infelizmente, o alinhamento n„o È "
"suportado. Se o recurso ainda n„o foi definido, ele È criado automaticamente. Os "
"valores especiais de inÌ≠cio 0 e final ~ 0 (todos os) significa que os valores fixos "
"previamente definidos <function> bus_set_resource () </function> deve ser usado em "
"vez disso: start e count como si mesmo e end = (start + count), neste caso, se o "
"recurso n„o foi definido antes, um erro ser· retornado. Embora o rid seja passado "
"por referÍncia, ele n„o È definido em nenhum lugar pelo cÛdigo de alocaÁ„o de "
"recursos do barramento ISA. (Os outros Ì¥nibus podem usar uma abordagem diferente e "
"modific·-lo). "

#: book.translate.xml:16924
#, fuzzy
msgid "Flags are a bitmap, the flags interesting for the caller are:"
msgstr "Bandeiras s„o um bitmap, as bandeiras interessantes para o chamador s„o:"

#: book.translate.xml:16929
#, fuzzy
msgid ""
"<emphasis>RF_ACTIVE</emphasis> - causes the resource to be automatically activated "
"after allocation."
msgstr ""
" <emphasis> RF_ACTIVE </emphasis> - faz com que o recurso seja ativado "
"automaticamente apÛs a alocaÁ„o. "

#: book.translate.xml:16934
#, fuzzy
msgid ""
"<emphasis>RF_SHAREABLE</emphasis> - resource may be shared at the same time by "
"multiple drivers."
msgstr ""
" <emphasis> RF_SHAREABLE </emphasis> - recurso pode ser compartilhado ao mesmo tempo "
"por v·rios drivers. "

#: book.translate.xml:16939
#, fuzzy
msgid ""
"<emphasis>RF_TIMESHARE</emphasis> - resource may be time-shared by multiple drivers, "
"i.e., allocated at the same time by many but activated only by one at any given "
"moment of time."
msgstr ""
" <emphasis> RF_TIMESHARE </emphasis> - o recurso pode ser compartilhado no tempo por "
"v·rios drivers, isto È, alocado ao mesmo tempo por muitos, mas ativado apenas por um "
"em qualquer momento. "

#: book.translate.xml:16946
#, fuzzy
msgid ""
"Returns 0 on error. The allocated values may be obtained from the returned handle "
"using methods <function>rhand_*()</function>."
msgstr ""
"Retorna 0 no erro. Os valores alocados podem ser obtidos a partir do identificador "
"retornado usando mÈtodos <function> rhand _ * () </function> "

#: book.translate.xml:16951
#, fuzzy
msgid ""
"<function>int bus_release_resource(device_t dev, int type, int rid, struct resource "
"*r)</function>"
msgstr ""
" <function> int bus_release_resource (device_t dev, tipo int, int rid, recurso "
"struct * r) </function> "

#: book.translate.xml:16956
#, fuzzy
msgid ""
"Release the resource, r is the handle returned by <function>bus_alloc_resource()</"
"function>. Returns 0 on success, error code otherwise."
msgstr ""
"Libere o recurso, r È o identificador retornado por <function> bus_alloc_resource () "
"</function> . Retorna 0 em caso de sucesso, cÛdigo de erro. "

#: book.translate.xml:16962
#, fuzzy
msgid ""
"<function>int bus_activate_resource(device_t dev, int type, int rid, struct resource "
"*r)</function> <function>int bus_deactivate_resource(device_t dev, int type, int "
"rid, struct resource *r)</function>"
msgstr ""
" <function> int bus_activate_resource (device_t dev, tipo int, int rid, recurso "
"struct * r) </function><function> int bus_deactivate_resource (device_t dev, int "
"tipo, int rid, struct resource * r) </function> "

#: book.translate.xml:16969
#, fuzzy
msgid ""
"Activate or deactivate resource. Return 0 on success, error code otherwise. If the "
"resource is time-shared and currently activated by another driver then "
"<literal>EBUSY</literal> is returned."
msgstr ""
"Ativar ou desativar o recurso. Retornar 0 em caso de sucesso, cÛdigo de erro de "
"outra forma. Se o recurso for compartilhado por tempo e atualmente ativado por outro "
"driver, ent„o <literal> EBUSY </literal> È devolvido \""

#: book.translate.xml:16976
#, fuzzy
msgid ""
"<function>int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep)</function> <function>int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</function>"
msgstr ""
" <function> int bus_setup_intr (device_t dev, struct recurso * r, int flags, "
"driver_intr_t * manipulador, void * arg, void ** cookiep) </function><function> int "
"bus_teardown_intr (device_t dev, struct recurso * r, void * cookie) </function> "

#: book.translate.xml:16984
#, fuzzy
msgid ""
"Associate or de-associate the interrupt handler with a device. Return 0 on success, "
"error code otherwise."
msgstr ""
"Associe ou desassocie o manipulador de interrupÁ„o com um dispositivo. Retorne 0 ao "
"sucesso, caso contr·rio, o cÛdigo de erro."

#: book.translate.xml:16989
#, fuzzy
msgid "r - the activated resource handler describing the IRQ"
msgstr "r - o manipulador de recursos ativado que descreve o IRQ"

#: book.translate.xml:16991
#, fuzzy
msgid "flags - the interrupt priority level, one of:"
msgstr "flags - o nÌ≠vel de prioridade de interrupÁ„o, um dos seguintes:"

#: book.translate.xml:16995
#, fuzzy
msgid ""
"<function>INTR_TYPE_TTY</function> - terminals and other likewise character-type "
"devices. To mask them use <function>spltty()</function>."
msgstr ""
" <function> INTR_TYPE_TTY </function> - terminais e outros dispositivos do tipo "
"caractere. Para mascar·-los, use <function> spltty () </function> "

#: book.translate.xml:17000
#, fuzzy
msgid ""
"<function>(INTR_TYPE_TTY | INTR_TYPE_FAST)</function> - terminal type devices with "
"small input buffer, critical to the data loss on input (such as the old-fashioned "
"serial ports). To mask them use <function>spltty()</function>."
msgstr ""
" <function> (INTR_TYPE_TTY | INTR_TYPE_FAST) </function> - dispositivos do tipo "
"terminal com pequeno buffer de entrada, crÌ≠tico para a perda de dados na entrada "
"(como as portas seriais antigas). Para mascar·-los, use <function> spltty () </"
"function> "

#: book.translate.xml:17007
#, fuzzy
msgid ""
"<function>INTR_TYPE_BIO</function> - block-type devices, except those on the CAM "
"controllers. To mask them use <function>splbio()</function>."
msgstr ""
" <function> INTR_TYPE_BIO </function> - dispositivos do tipo bloco, exceto aqueles "
"nos controladores CAM. Para mascar·-los, use <function> splbio () </function> "

#: book.translate.xml:17012
#, fuzzy
msgid ""
"<function>INTR_TYPE_CAM</function> - CAM (Common Access Method) bus controllers. To "
"mask them use <function>splcam()</function>."
msgstr ""
" <function> INTR_TYPE_CAM </function> - Controladores de barramento CAM (Common "
"Access Method). Para mascar·-los, use <function> splcam () </function> "

#: book.translate.xml:17017
#, fuzzy
msgid ""
"<function>INTR_TYPE_NET</function> - network interface controllers. To mask them use "
"<function>splimp()</function>."
msgstr ""
" <function> INTR_TYPE_NET </function> - controladores de interface de rede. Para "
"mascar·-los, use <function> splimp () </function> "

#: book.translate.xml:17022
#, fuzzy
msgid ""
"<function>INTR_TYPE_MISC</function> - miscellaneous devices. There is no other way "
"to mask them than by <function>splhigh()</function> which masks all interrupts."
msgstr ""
" <function> INTR_TYPE_MISC </function> - dispositivos diversos. N„o h· outra maneira "
"de mascar·-los do que <function> splhigh () </function> que mascara todas as "
"interrupÁÌµes. "

#: book.translate.xml:17031
#, fuzzy
msgid ""
"When an interrupt handler executes all the other interrupts matching its priority "
"level will be masked. The only exception is the MISC level for which no other "
"interrupts are masked and which is not masked by any other interrupt."
msgstr ""
"Quando um manipulador de interrupÁÌµes executa todas as outras interrupÁÌµes "
"correspondentes ao seu nÌ≠vel de prioridade ser· mascarado. A ˙nica exceÁ„o È o nÌ≠vel "
"MISC para o qual nenhuma outra interrupÁ„o È mascarada e que n„o È mascarada por "
"qualquer outra interrupÁ„o."

#: book.translate.xml:17039
#, fuzzy
msgid ""
"<emphasis>handler</emphasis> - pointer to the handler function, the type "
"driver_intr_t is defined as <function>void driver_intr_t(void *)</function>"
msgstr ""
" <emphasis> manipulador </emphasis> - ponteiro para a funÁ„o de manipulador, o tipo "
"driver_intr_t È definido como <function> void driver_intr_t (void *) </function> "

#: book.translate.xml:17044
#, fuzzy
msgid ""
"<emphasis>arg</emphasis> - the argument passed to the handler to identify this "
"particular device. It is cast from void* to any real type by the handler. The old "
"convention for the ISA interrupt handlers was to use the unit number as argument, "
"the new (recommended) convention is using a pointer to the device softc structure."
msgstr ""
" <emphasis> arg </emphasis> - o argumento passado para o manipulador para "
"identificar esse dispositivo em particular. Ele È convertido de void * para qualquer "
"tipo real pelo manipulador. A antiga convenÁ„o para os manipuladores de interrupÁ„o "
"do ISA era usar o n˙mero da unidade como argumento, a nova convenÁ„o (recomendada) "
"est· usando um ponteiro para a estrutura do dispositivo. "

#: book.translate.xml:17052
#, fuzzy
msgid ""
"<emphasis>cookie[p]</emphasis> - the value received from <function>setup()</"
"function> is used to identify the handler when passed to <function>teardown()</"
"function>"
msgstr ""
" <emphasis> cookie [p] </emphasis> - o valor recebido de <function> configuraÁ„o() </"
"function> È usado para identificar o manipulador quando passado para <function> "
"destruir() </function> "

#: book.translate.xml:17059
#, fuzzy
msgid ""
"A number of methods are defined to operate on the resource handlers (struct resource "
"*). Those of interest to the device driver writers are:"
msgstr ""
"V·rios mÈtodos s„o definidos para operar nos manipuladores de recursos (struct "
"resource *). Aqueles de interesse para os gravadores de driver de dispositivo s„o:"

#: book.translate.xml:17065
#, fuzzy
msgid ""
"<function>u_long rman_get_start(r) u_long rman_get_end(r)</function> Get the start "
"and end of allocated resource range."
msgstr ""
" <function> u_long rman_get_start (r) u_long rman_get_end (r) </function> Obtenha o "
"inÌ≠cio e o fim do intervalo de recursos alocados. "

#: book.translate.xml:17070
#, fuzzy
msgid ""
"<function>void *rman_get_virtual(r)</function> Get the virtual address of activated "
"memory resource."
msgstr ""
" <function> void * rman_get_virtual (r) </function> Obtenha o endereÁo virtual do "
"recurso de memÛria ativada. "

#: book.translate.xml:17078
#, fuzzy
msgid "Bus Memory Mapping"
msgstr "Mapeamento de memÛria de barramento"

#: book.translate.xml:17080
#, fuzzy
msgid ""
"In many cases data is exchanged between the driver and the device through the "
"memory. Two variants are possible:"
msgstr ""
"Em muitos casos, os dados s„o trocados entre o driver e o dispositivo atravÈs da "
"memÛria. Duas variantes s„o possÌ≠veis:"

#: book.translate.xml:17083
#, fuzzy
msgid "(a) memory is located on the device card"
msgstr "(a) a memÛria est· localizada no cart„o do dispositivo"

#: book.translate.xml:17084
#, fuzzy
msgid "(b) memory is the main memory of the computer"
msgstr "(b) memÛria È a memÛria principal do computador"

#: book.translate.xml:17086
#, fuzzy
msgid ""
"In case (a) the driver always copies the data back and forth between the on-card "
"memory and the main memory as necessary. To map the on-card memory into the kernel "
"virtual address space the physical address and length of the on-card memory must be "
"defined as a <literal>SYS_RES_MEMORY</literal> resource. That resource can then be "
"allocated and activated, and its virtual address obtained using "
"<function>rman_get_virtual()</function>. The older drivers used the function "
"<function>pmap_mapdev()</function> for this purpose, which should not be used "
"directly any more. Now it is one of the internal steps of resource activation."
msgstr ""
"No caso (a), o driver sempre copia os dados entre a memÛria no cart„o e a memÛria "
"principal, conforme necess·rio. Para mapear a memÛria no cart„o para o espaÁo de "
"endereÁo virtual do kernel, o endereÁo fÌ≠sico eo comprimento do memÛria do cart„o "
"deve ser definida como <literal> SYS_RES_MEMORY </literal> recurso. Esse recurso "
"pode ent„o ser alocado e ativado, e seu endereÁo virtual obtido usando <function> "
"rman_get_virtual () </function> . Os drivers mais antigos usavam a funÁ„o <function> "
"pmap_mapdev () </function> para este fim, que n„o deve ser usado diretamente mais. "
"Agora È uma das etapas internas da ativaÁ„o de recursos. "

#: book.translate.xml:17098
#, fuzzy
msgid ""
"Most of the ISA cards will have their memory configured for physical location "
"somewhere in range 640KB-1MB. Some of the ISA cards require larger memory ranges "
"which should be placed somewhere under 16MB (because of the 24-bit address "
"limitation on the ISA bus). In that case if the machine has more memory than the "
"start address of the device memory (in other words, they overlap) a memory hole must "
"be configured at the address range used by devices. Many BIOSes allow configuration "
"of a memory hole of 1MB starting at 14MB or 15MB. FreeBSD can handle the memory "
"holes properly if the BIOS reports them properly (this feature may be broken on old "
"BIOSes)."
msgstr ""
"A maioria das placas ISA ter· sua memÛria configurada para localizaÁ„o fÌ≠sica em "
"algum lugar no intervalo de 640 KB-1 MB. Algumas das placas ISA exigem intervalos de "
"memÛria maiores que devem ser colocados em algum lugar abaixo de 16 MB (devido Ì† "
"limitaÁ„o de endereÁo de 24 bits no barramento ISA Nesse caso, se a m·quina tiver "
"mais memÛria do que o endereÁo inicial da memÛria do dispositivo (em outras "
"palavras, eles se sobrepÌµem), um orifÌ≠cio de memÛria deve ser configurado na faixa "
"de endereÁos usada pelos dispositivos.Muitos BIOS permitem a configuraÁ„o de um orifÌ≠"
"cio de memÛria. 1MB a partir de 14MB ou 15MB O FreeBSD pode lidar com os buracos de "
"memÛria se o BIOS reportar corretamente (este recurso pode estar quebrado em BIOS "
"antigas). "

#: book.translate.xml:17110
#, fuzzy
msgid ""
"In case (b) just the address of the data is sent to the device, and the device uses "
"DMA to actually access the data in the main memory. Two limitations are present: "
"First, ISA cards can only access memory below 16MB. Second, the contiguous pages in "
"virtual address space may not be contiguous in physical address space, so the device "
"may have to do scatter/gather operations. The bus subsystem provides ready solutions "
"for some of these problems, the rest has to be done by the drivers themselves."
msgstr ""
"No caso (b) apenas o endereÁo dos dados È enviado para o dispositivo, e o "
"dispositivo usa DMA para acessar os dados na memÛria principal. Duas limitaÁÌµes "
"est„o presentes: Primeiro, as placas ISA sÛ podem acessar memÛria abaixo de 16MB. , "
"as p·ginas contÌ≠guas no espaÁo de endereÁo virtual podem n„o ser contÌ≠guas no espaÁo "
"de endereÁo fÌ≠sico, portanto, o dispositivo pode ter que fazer operaÁÌµes de "
"dispers„o / coleta.O subsistema de barramento fornece soluÁÌµes prontas para alguns "
"desses problemas, o restante deve ser feito pelos drivers si mesmos."

#: book.translate.xml:17120
#, fuzzy
msgid ""
"Two structures are used for DMA memory allocation, <varname>bus_dma_tag_t</varname> "
"and <varname>bus_dmamap_t</varname>. Tag describes the properties required for the "
"DMA memory. Map represents a memory block allocated according to these properties. "
"Multiple maps may be associated with the same tag."
msgstr ""
"Duas estruturas s„o usadas para alocaÁ„o de memÛria DMA, <varname> bus_dma_tag_t </"
"varname> e <varname> bus_dmamap_t </varname> . Tag descreve as propriedades "
"necess·rias para a memÛria DMA. Mapa representa um bloco de memÛria alocado de "
"acordo com essas propriedades. V·rios mapas podem estar associados Ì† mesma tag. "

#: book.translate.xml:17126
#, fuzzy
msgid ""
"Tags are organized into a tree-like hierarchy with inheritance of the properties. A "
"child tag inherits all the requirements of its parent tag, and may make them more "
"strict but never more loose."
msgstr ""
"As tags s„o organizadas em uma hierarquia em forma de ·rvore com heranÁa das "
"propriedades. Uma tag filha herda todos os requisitos de sua tag pai e pode torn·-"
"los mais rÌ≠gidos, mas nunca mais frouxos."

#: book.translate.xml:17131
#, fuzzy
msgid ""
"Normally one top-level tag (with no parent) is created for each device unit. If "
"multiple memory areas with different requirements are needed for each device then a "
"tag for each of them may be created as a child of the parent tag."
msgstr ""
"Normalmente, uma tag de nÌ≠vel superior (sem pai) È criada para cada unidade de "
"dispositivo. Se v·rias ·reas de memÛria com requisitos diferentes forem necess·rias "
"para cada dispositivo, uma tag para cada uma delas poder· ser criada como filha da "
"tag pai."

#: book.translate.xml:17136
#, fuzzy
msgid "The tags can be used to create a map in two ways."
msgstr "As tags podem ser usadas para criar um mapa de duas maneiras."

#: book.translate.xml:17138
#, fuzzy
msgid ""
"First, a chunk of contiguous memory conformant with the tag requirements may be "
"allocated (and later may be freed). This is normally used to allocate relatively "
"long-living areas of memory for communication with the device. Loading of such "
"memory into a map is trivial: it is always considered as one chunk in the "
"appropriate physical memory range."
msgstr ""
"Primeiro, um pedaÁo de memÛria contÌ≠gua em conformidade com os requisitos de tag "
"pode ser alocado (e mais tarde pode ser liberado). Isso È normalmente usado para "
"alocar ·reas de memÛria relativamente longas para comunicaÁ„o com o dispositivo. "
"Carregamento de tal memÛria em um mapa. È trivial: È sempre considerado como um "
"pedaÁo na faixa de memÛria fÌ≠sica apropriada \""

#: book.translate.xml:17146
#, fuzzy
msgid ""
"Second, an arbitrary area of virtual memory may be loaded into a map. Each page of "
"this memory will be checked for conformance to the map requirement. If it conforms "
"then it is left at its original location. If it is not then a fresh conformant "
"<quote>bounce page</quote> is allocated and used as intermediate storage. When "
"writing the data from the non-conformant original pages they will be copied to their "
"bounce pages first and then transferred from the bounce pages to the device. When "
"reading the data would go from the device to the bounce pages and then copied to "
"their non-conformant original pages. The process of copying between the original and "
"bounce pages is called synchronization. This is normally used on a per-transfer "
"basis: buffer for each transfer would be loaded, transfer done and buffer unloaded."
msgstr ""
"Segundo, uma ·rea arbitr·ria da memÛria virtual pode ser carregada em um mapa. Cada "
"p·gina dessa memÛria ser· verificada quanto Ì† conformidade com o requisito do mapa. "
"Se estiver em conformidade, ela ser· deixada no local original. Se n„o for, ent„o, "
"um novo conformant <quote> p·gina de rejeiÁ„o </quote> È alocado e usado como "
"armazenamento intermedi·rio. Ao gravar os dados das p·ginas originais n„o conformes, "
"eles ser„o copiados primeiro para suas p·ginas devolvidas e depois transferidos das "
"p·ginas devolvidas para o dispositivo. Ao ler os dados, eles iriam do dispositivo "
"para as p·ginas devolvidas e depois copiados para as p·ginas originais n„o "
"conformes. O processo de cÛpia entre as p·ginas original e de retorno È chamado de "
"sincronizaÁ„o. Isso È normalmente usado em uma base por transferÍncia: buffer para "
"cada transferÍncia seria carregado, transferÍncia feita e buffer descarregado. "

#: book.translate.xml:17161
#, fuzzy
msgid "The functions working on the DMA memory are:"
msgstr "As funÁÌµes que trabalham na memÛria DMA s„o:"

#: book.translate.xml:17165
#, fuzzy
msgid ""
"<function>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, bus_dma_filter_t "
"*filter, void *filterarg, bus_size_t maxsize, int nsegments, bus_size_t maxsegsz, "
"int flags, bus_dma_tag_t *dmat)</function>"
msgstr ""
" <function> int bus_dma_tag_create (bus_dma_tag_t pai, bus_size_t alinhamento, "
"bus_size_t limite, bus_addr_t lowaddr, bus_addr_t highaddr, bus_dma_filter_t * "
"filtro, void * filterarg, bus_size_t maxsize, int nsegmentos, bus_size_t maxsegsz, "
"int sinalizadores, bus_dma_tag_t * dmat) </function> "

#: book.translate.xml:17171
#, fuzzy
msgid "Create a new tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Crie uma nova tag. Retorna 0 em caso de sucesso, caso contr·rio, o cÛdigo de erro."

#: book.translate.xml:17176
#, fuzzy
msgid "<emphasis>parent</emphasis> - parent tag, or NULL to create a top-level tag."
msgstr ""
" <emphasis> pai </emphasis> - tag pai ou NULL para criar uma tag de nÌ≠vel superior. "

#: book.translate.xml:17181
#, fuzzy
msgid ""
"<emphasis>alignment</emphasis> - required physical alignment of the memory area to "
"be allocated for this tag. Use value 1 for <quote>no specific alignment</quote>. "
"Applies only to the future <function>bus_dmamem_alloc()</function> but not "
"<function>bus_dmamap_create()</function> calls."
msgstr ""
" <emphasis> alinhamento </emphasis> - necess·rio alinhamento fÌ≠sico da ·rea de "
"memÛria a ser alocada para esta tag. Use o valor 1 para <quote> sem alinhamento "
"especÌ≠fico </quote> . Aplica-se apenas ao futuro <function> bus_dmamem_alloc () </"
"function> mas n„o <function> bus_dmamap_create () </function> chama \""

#: book.translate.xml:17190
#, fuzzy
msgid ""
"<emphasis>boundary</emphasis> - physical address boundary that must not be crossed "
"when allocating the memory. Use value 0 for <quote>no boundary</quote>. Applies only "
"to the future <function>bus_dmamem_alloc()</function> but not "
"<function>bus_dmamap_create()</function> calls. Must be power of 2. If the memory is "
"planned to be used in non-cascaded DMA mode (i.e., the DMA addresses will be "
"supplied not by the device itself but by the ISA DMA controller) then the boundary "
"must be no larger than 64KB (64*1024) due to the limitations of the DMA hardware."
msgstr ""
" <emphasis> fronteira </emphasis> - limite de endereÁo fÌ≠sico que n„o deve ser "
"ultrapassado ao alocar a memÛria. Use o valor 0 para <quote> sem limite </quote> . "
"Aplica-se apenas ao futuro <function> bus_dmamem_alloc () </function> mas n„o "
"<function> bus_dmamap_create () </function> chamadas. Deve ser a potÍncia de 2. Se a "
"memÛria for planejada para ser usada no modo DMA n„o em cascata (ou seja, os "
"endereÁos DMA ser„o fornecidos n„o pelo prÛprio dispositivo, mas pelo controlador "
"ISA DMA), o limite n„o dever· ser maior que 64 KB (64 * 1024) devido Ì†s limitaÁÌµes "
"do hardware DMA. "

#: book.translate.xml:17204
#, fuzzy
msgid ""
"<emphasis>lowaddr, highaddr</emphasis> - the names are slightly misleading; these "
"values are used to limit the permitted range of physical addresses used to allocate "
"the memory. The exact meaning varies depending on the planned future use:"
msgstr ""
" <emphasis> lowaddr, highaddr </emphasis> - os nomes s„o ligeiramente enganadores; "
"esses valores s„o usados ‚Äã‚Äãpara limitar o intervalo permitido de endereÁos fÌ≠sicos "
"usados ‚Äã‚Äãpara alocar a memÛria. O significado exato varia dependendo do uso futuro "
"planejado: "

#: book.translate.xml:17212
#, fuzzy
msgid ""
"For <function>bus_dmamem_alloc()</function> all the addresses from 0 to lowaddr-1 "
"are considered permitted, the higher ones are forbidden."
msgstr ""
"Para <function> bus_dmamem_alloc () </function> todos os endereÁos de 0 a lowaddr-1 "
"s„o considerados permitidos, os mais altos s„o proibidos. "

#: book.translate.xml:17218
#, fuzzy
msgid ""
"For <function>bus_dmamap_create()</function> all the addresses outside the inclusive "
"range [lowaddr; highaddr] are considered accessible. The addresses of pages inside "
"the range are passed to the filter function which decides if they are accessible. If "
"no filter function is supplied then all the range is considered unaccessible."
msgstr ""
"Para <function> bus_dmamap_create () </function> todos os endereÁos fora do "
"intervalo inclusivo [lowaddr; highaddr] s„o considerados acessÌ≠veis. Os endereÁos "
"das p·ginas dentro do intervalo s„o passados ‚Äã‚Äãpara a funÁ„o de filtro que decide se "
"eles est„o acessÌ≠veis. Se nenhuma funÁ„o de filtro for fornecida, todo o intervalo "
"ser· considerado inacessÌ≠vel. "

#: book.translate.xml:17228
#, fuzzy
msgid "For the ISA devices the normal values (with no filter function) are:"
msgstr "Para os dispositivos ISA, os valores normais (sem funÁ„o de filtro) s„o:"

#: book.translate.xml:17230
#, fuzzy
msgid "lowaddr = BUS_SPACE_MAXADDR_24BIT"
msgstr "lowaddr = BUS_SPACE_MAXADDR_24BIT"

#: book.translate.xml:17231
#, fuzzy
msgid "highaddr = BUS_SPACE_MAXADDR"
msgstr "highaddr = BUS_SPACE_MAXADDR"

#: book.translate.xml:17238
#, fuzzy
msgid ""
"<emphasis>filter, filterarg</emphasis> - the filter function and its argument. If "
"NULL is passed for filter then the whole range [lowaddr, highaddr] is considered "
"unaccessible when doing <function>bus_dmamap_create()</function>. Otherwise the "
"physical address of each attempted page in range [lowaddr; highaddr] is passed to "
"the filter function which decides if it is accessible. The prototype of the filter "
"function is: <function>int filterfunc(void *arg, bus_addr_t paddr)</function>. It "
"must return 0 if the page is accessible, non-zero otherwise."
msgstr ""
" <emphasis> filtrar, filtrar </emphasis> - a funÁ„o de filtro e seu argumento. Se "
"NULL for passado para filtro, todo o intervalo [lowaddr, highaddr] ser· considerado "
"inacessÌ≠vel ao fazer <function> bus_dmamap_create () </function> . Caso contr·rio, o "
"endereÁo fÌ≠sico de cada p·gina tentada no intervalo [lowaddr; highaddr] È passado "
"para a funÁ„o de filtro que decide se È acessÌ≠vel. O protÛtipo da funÁ„o de filtro "
"È: <function> int filterfunc (void * arg, bus_addr_t paddr) </function> . Ele deve "
"retornar 0 se a p·gina estiver acessÌ≠vel, diferente de zero. "

#: book.translate.xml:17252
#, fuzzy
msgid ""
"<emphasis>maxsize</emphasis> - the maximal size of memory (in bytes) that may be "
"allocated through this tag. In case it is difficult to estimate or could be "
"arbitrarily big, the value for ISA devices would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
" <emphasis> tamanho m·ximo </emphasis> - o tamanho m·ximo de memÛria (em bytes) que "
"pode ser alocado atravÈs desta tag. No caso de ser difÌ≠cil estimar ou ser "
"arbitrariamente grande, o valor dos dispositivos ISA seria <literal> "
"BUS_SPACE_MAXSIZE_24BIT </literal> "

#: book.translate.xml:17260
#, fuzzy
msgid ""
"<emphasis>nsegments</emphasis> - maximal number of scatter-gather segments supported "
"by the device. If unrestricted then the value <literal>BUS_SPACE_UNRESTRICTED</"
"literal> should be used. This value is recommended for the parent tags, the actual "
"restrictions would then be specified for the descendant tags. Tags with nsegments "
"equal to <literal>BUS_SPACE_UNRESTRICTED</literal> may not be used to actually load "
"maps, they may be used only as parent tags. The practical limit for nsegments seems "
"to be about 250-300, higher values will cause kernel stack overflow (the hardware "
"can not normally support that many scatter-gather buffers anyway)."
msgstr ""
" <emphasis> nsegmentos </emphasis> - N˙mero m·ximo de segmentos de coleta dispersa "
"suportados pelo dispositivo. Se irrestrito, ent„o o valor <literal> "
"BUS_SPACE_UNRESTRICTED </literal> deve ser usado. Esse valor È recomendado para as "
"tags pai, as restriÁÌµes reais seriam, ent„o, especificadas para as tags "
"descendentes. Tags com nsegmentos iguais a <literal> BUS_SPACE_UNRESTRICTED </"
"literal> n„o podem ser usados ‚Äã‚Äãpara carregar mapas, eles podem ser usados ‚Äã‚Äãapenas "
"como tags pai. O limite pr·tico para nsegments parece ser de cerca de 250-300, "
"valores mais altos causar„o estouro de pilha do kernel (o hardware normalmente n„o "
"suporta muitos buffers de dispers„o de coleta). "

#: book.translate.xml:17275
#, fuzzy
msgid ""
"<emphasis>maxsegsz</emphasis> - maximal size of a scatter-gather segment supported "
"by the device. The maximal value for ISA device would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
" <emphasis> maxsegsz </emphasis> - tamanho m·ximo de um segmento de coleta dispersa "
"suportado pelo dispositivo. O valor m·ximo para o dispositivo ISA seria <literal> "
"BUS_SPACE_MAXSIZE_24BIT </literal> "

#: book.translate.xml:17282
#, fuzzy
msgid "<emphasis>flags</emphasis> - a bitmap of flags. The only interesting flags are:"
msgstr ""
" <emphasis> bandeiras </emphasis> - um bitmap de bandeiras. As ˙nicas bandeiras "
"interessantes s„o: "

#: book.translate.xml:17287
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_ALLOCNOW</emphasis> - requests to allocate all the potentially "
"needed bounce pages when creating the tag."
msgstr ""
" <emphasis> BUS_DMA_ALLOCNOW </emphasis> - solicitaÁÌµes para alocar todas as "
"p·ginas de rejeiÁ„o potencialmente necess·rias ao criar a tag. "

#: book.translate.xml:17293
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_ISA</emphasis> - mysterious flag used only on Alpha machines. It "
"is not defined for the i386 machines. Probably it should be used by all the ISA "
"drivers for Alpha machines but it looks like there are no such drivers yet."
msgstr ""
" <emphasis> BUS_DMA_ISA </emphasis> - bandeira misteriosa usada somente em m·quinas "
"Alpha. N„o est· definido para as m·quinas i386. Provavelmente deve ser usado por "
"todos os drivers ISA para m·quinas Alpha, mas parece que ainda n„o existem drivers. "

#: book.translate.xml:17303
#, fuzzy
msgid ""
"<emphasis>dmat</emphasis> - pointer to the storage for the new tag to be returned."
msgstr ""
" <emphasis> dmat </emphasis> - ponteiro para o armazenamento para a nova tag a ser "
"devolvida. "

#: book.translate.xml:17312
#, fuzzy
msgid "<function>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</function>"
msgstr " <function> int bus_dma_tag_destroy (bus_dma_tag_t dmat) </function> "

#: book.translate.xml:17315
#, fuzzy
msgid "Destroy a tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Destrua uma tag. Retorna 0 em caso de sucesso, caso contr·rio, o cÛdigo de erro."

#: book.translate.xml:17318
#, fuzzy
msgid "dmat - the tag to be destroyed."
msgstr "dmat - a tag a ser destruÌ≠da."

#: book.translate.xml:17323
#, fuzzy
msgid ""
"<function>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)</function>"
msgstr ""
" <function> int bus_dmamem_alloc (bus_dma_tag_t_dmat, void ** vaddr, int flags, "
"bus_dmamap_t * mapp) </function> "

#: book.translate.xml:17327
#, fuzzy
msgid ""
"Allocate an area of contiguous memory described by the tag. The size of memory to be "
"allocated is tag's maxsize. Returns 0 on success, the error code otherwise. The "
"result still has to be loaded by <function>bus_dmamap_load()</function> before being "
"used to get the physical address of the memory."
msgstr ""
"Aloca uma ·rea de memÛria contÌ≠gua descrita pela tag. O tamanho da memÛria a ser "
"alocada È maxsize da tag. Retorna 0 em caso de sucesso, caso contr·rio o cÛdigo de "
"erro. O resultado ainda tem que ser carregado por <function> bus_dmamap_load () </"
"function> antes de ser usado para obter o endereÁo fÌ≠sico da memÛria \""

#: book.translate.xml:17495 book.translate.xml:17423 book.translate.xml:17392
#: book.translate.xml:17336
#, fuzzy
msgid "<emphasis>dmat</emphasis> - the tag"
msgstr " <emphasis> dmat </emphasis> - a etiqueta"

#: book.translate.xml:17341
#, fuzzy
msgid ""
"<emphasis>vaddr</emphasis> - pointer to the storage for the kernel virtual address "
"of the allocated area to be returned."
msgstr ""
" <emphasis> vaddr </emphasis> - ponteiro para o armazenamento do endereÁo virtual do "
"kernel da ·rea alocada a ser retornada. "

#: book.translate.xml:17348
#, fuzzy
msgid "flags - a bitmap of flags. The only interesting flag is:"
msgstr "flags - um bitmap de bandeiras. A ˙nica bandeira interessante È:"

#: book.translate.xml:17353
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_NOWAIT</emphasis> - if the memory is not immediately available "
"return the error. If this flag is not set then the routine is allowed to sleep until "
"the memory becomes available."
msgstr ""
" <emphasis> BUS_DMA_NOWAIT </emphasis> - se a memÛria n„o estiver imediatamente "
"disponÌ≠vel, devolva o erro. Se esse sinalizador n„o estiver definido, a rotina "
"poder· ser suspensa atÈ que a memÛria fique disponÌ≠vel. "

#: book.translate.xml:17364
#, fuzzy
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be returned."
msgstr ""
" <emphasis> mapp </emphasis> - ponteiro para o armazenamento para o novo mapa a ser "
"devolvido. "

#: book.translate.xml:17373
#, fuzzy
msgid ""
"<function>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t map)</"
"function>"
msgstr ""
" <function> void bus_dmamem_free (bus_dma_tag_t dmat, void * vaddr, mapa de "
"bus_dmamap_t) </function> "

#: book.translate.xml:17377
#, fuzzy
msgid ""
"Free the memory allocated by <function>bus_dmamem_alloc()</function>. At present, "
"freeing of the memory allocated with ISA restrictions is not implemented. Because of "
"this the recommended model of use is to keep and re-use the allocated areas for as "
"long as possible. Do not lightly free some area and then shortly allocate it again. "
"That does not mean that <function>bus_dmamem_free()</function> should not be used at "
"all: hopefully it will be properly implemented soon."
msgstr ""
"Libere a memÛria alocada por <function> bus_dmamem_alloc () </function> . "
"Atualmente, a liberaÁ„o da memÛria alocada com restriÁÌµes ISA n„o est· "
"implementada. Por isso, o modelo de uso recomendado È manter e reutilizar as ·reas "
"alocadas pelo maior tempo possÌ≠vel. N„o liberte levemente alguma ·rea e, em seguida, "
"aloque-a de novo. Isso n„o significa que <function> bus_dmamem_free () </function> "
"n„o deve ser usado: esperamos que seja implementado em breve. "

#: book.translate.xml:17396
#, fuzzy
msgid "<emphasis>vaddr</emphasis> - the kernel virtual address of the memory"
msgstr " <emphasis> vaddr </emphasis> - o endereÁo virtual do kernel da memÛria "

#: book.translate.xml:17402
#, fuzzy
msgid ""
"<emphasis>map</emphasis> - the map of the memory (as returned from "
"<function>bus_dmamem_alloc()</function>)"
msgstr ""
" <emphasis> mapa </emphasis> - o mapa da memÛria (conforme retornado de <function> "
"bus_dmamem_alloc () </function> ) "

#: book.translate.xml:17412
#, fuzzy
msgid ""
"<function>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t *mapp)</"
"function>"
msgstr ""
" <function> int bus_dmamap_create (bus_dma_tag_t dmat, sinalizadores int, "
"bus_dmamap_t * mapp) </function> "

#: book.translate.xml:17416
#, fuzzy
msgid ""
"Create a map for the tag, to be used in <function>bus_dmamap_load()</function> "
"later. Returns 0 on success, the error code otherwise."
msgstr ""
"Crie um mapa para a tag, para ser usado em <function> bus_dmamap_load () </function> "
"mais tarde. Retorna 0 em caso de sucesso, caso contr·rio, o cÛdigo de erro. "

#: book.translate.xml:17428
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - theoretically, a bit map of flags. But no flags are "
"defined yet, so at present it will be always 0."
msgstr ""
" <emphasis> bandeiras </emphasis> - teoricamente, um pouco mapa de bandeiras. Mas "
"nenhum sinalizador ainda est· definido, ent„o no momento ser· sempre 0. "

#: book.translate.xml:17435
#, fuzzy
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be returned"
msgstr ""
" <emphasis> mapp </emphasis> - ponteiro para o armazenamento para o novo mapa a ser "
"devolvido "

#: book.translate.xml:17444
#, fuzzy
msgid ""
"<function>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</function>"
msgstr ""
" <function> int bus_dmamap_destroy (bus_dma_tag_t dmat, bus_dmamap_t map) </"
"function> "

#: book.translate.xml:17448
#, fuzzy
msgid "Destroy a map. Returns 0 on success, the error code otherwise."
msgstr "Destrua um mapa. Retorna 0 em sucesso, o cÛdigo de erro de outra forma."

#: book.translate.xml:17454
#, fuzzy
msgid "dmat - the tag to which the map is associated"
msgstr "dmat - a tag Ì† qual o mapa est· associado"

#: book.translate.xml:17459
#, fuzzy
msgid "map - the map to be destroyed"
msgstr "mapa - o mapa a ser destruÌ≠do"

#: book.translate.xml:17467
#, fuzzy
msgid ""
"<function>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void *buf, "
"bus_size_t buflen, bus_dmamap_callback_t *callback, void *callback_arg, int flags)</"
"function>"
msgstr ""
" <function> int bus_dmamap_load (bus_dma_tag_t dmat, bus_dmamap_t mapa, void * buf, "
"bus_size_t buflen, bus_dmamap_callback_t * retorno de chamada, void * callback_arg, "
"int flags) </function> "

#: book.translate.xml:17473
#, fuzzy
msgid ""
"Load a buffer into the map (the map must be previously created by "
"<function>bus_dmamap_create()</function> or <function>bus_dmamem_alloc()</"
"function>). All the pages of the buffer are checked for conformance to the tag "
"requirements and for those not conformant the bounce pages are allocated. An array "
"of physical segment descriptors is built and passed to the callback routine. This "
"callback routine is then expected to handle it in some way. The number of bounce "
"buffers in the system is limited, so if the bounce buffers are needed but not "
"immediately available the request will be queued and the callback will be called "
"when the bounce buffers will become available. Returns 0 if the callback was "
"executed immediately or <errorname>EINPROGRESS</errorname> if the request was queued "
"for future execution. In the latter case the synchronization with queued callback "
"routine is the responsibility of the driver."
msgstr ""
"Carregue um buffer no mapa (o mapa deve ser criado anteriormente por <function> "
"bus_dmamap_create () </function> ou <function> bus_dmamem_alloc () </function> ). "
"Todas as p·ginas do buffer s„o verificadas quanto Ì† conformidade com os requisitos "
"da tag e, para aqueles que n„o est„o em conformidade, as p·ginas devolvidas s„o "
"alocadas. Uma matriz de descritores de segmento fÌ≠sico È criada e passada para a "
"rotina de retorno de chamada. Espera-se, ent„o, que essa rotina de retorno de "
"chamada lide com isso de alguma forma. O n˙mero de buffers de rejeiÁ„o no sistema È "
"limitado, portanto, se os buffers de rejeiÁ„o forem necess·rios, mas n„o estiverem "
"disponÌ≠veis imediatamente, a solicitaÁ„o ser· enfileirada e o retorno de chamada "
"ser· chamado quando os buffers de rejeiÁ„o ficar„o disponÌ≠veis. Retorna 0 se o "
"retorno de chamada foi executado imediatamente ou <errorname> EINPROGRESS </"
"errorname> se a solicitaÁ„o foi enfileirada para execuÁ„o futura. Neste ˙ltimo caso, "
"a sincronizaÁ„o com a rotina de retorno de chamada em fila È de responsabilidade do "
"driver. "

#: book.translate.xml:17500
#, fuzzy
msgid "<emphasis>map</emphasis> - the map"
msgstr " <emphasis> mapa </emphasis> - o mapa"

#: book.translate.xml:17505
#, fuzzy
msgid "<emphasis>buf</emphasis> - kernel virtual address of the buffer"
msgstr " <emphasis> buf </emphasis> - endereÁo virtual do kernel do buffer "

#: book.translate.xml:17511
#, fuzzy
msgid "<emphasis>buflen</emphasis> - length of the buffer"
msgstr " <emphasis> buflen </emphasis> - comprimento do buffer "

#: book.translate.xml:17516
#, fuzzy
msgid ""
"<emphasis>callback</emphasis>,<function> callback_arg</function> - the callback "
"function and its argument"
msgstr ""
" <emphasis> ligue de volta </emphasis> , <function> callback_arg </function> - a "
"funÁ„o de retorno de chamada e seu argumento "

#: book.translate.xml:17524
#, fuzzy
msgid "The prototype of callback function is:"
msgstr "O protÛtipo da funÁ„o de retorno de chamada È:"

#: book.translate.xml:17527
#, fuzzy
msgid ""
"<function>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int error)</"
"function>"
msgstr ""
" <function> void callback (erro void * arg, bus_dma_segment_t * seg, int nseg, int) "
"</function> "

#: book.translate.xml:17534
#, fuzzy
msgid ""
"<emphasis>arg</emphasis> - the same as callback_arg passed to "
"<function>bus_dmamap_load()</function>"
msgstr ""
" <emphasis> arg </emphasis> - o mesmo que callback_arg passado para <function> "
"bus_dmamap_load () </function> "

#: book.translate.xml:17540
#, fuzzy
msgid "<emphasis>seg</emphasis> - array of the segment descriptors"
msgstr " <emphasis> seg </emphasis> - matriz dos descritores de segmento "

#: book.translate.xml:17546
#, fuzzy
msgid "<emphasis>nseg</emphasis> - number of descriptors in array"
msgstr " <emphasis> nseg </emphasis> - n˙mero de descritores na matriz "

#: book.translate.xml:17552
#, fuzzy
msgid ""
"<emphasis>error</emphasis> - indication of the segment number overflow: if it is set "
"to <errorname>EFBIG</errorname> then the buffer did not fit into the maximal number "
"of segments permitted by the tag. In this case only the permitted number of "
"descriptors will be in the array. Handling of this situation is up to the driver: "
"depending on the desired semantics it can either consider this an error or split the "
"buffer in two and handle the second part separately"
msgstr ""
" <emphasis> erro </emphasis> - indicaÁ„o do excesso de n˙mero de segmento: se "
"estiver configurado para <errorname> EFBIG </errorname> ent„o o buffer n„o se "
"encaixava no n˙mero m·ximo de segmentos permitido pela tag. Nesse caso, apenas o "
"n˙mero permitido de descritores estar· na matriz. O manuseio desta situaÁ„o depende "
"do driver: dependendo da semÌ¢ntica desejada, ele pode considerar isso como um erro "
"ou dividir o buffer em dois e manipular a segunda parte separadamente "

#: book.translate.xml:17566
#, fuzzy
msgid "Each entry in the segments array contains the fields:"
msgstr "Cada entrada na matriz de segmentos contÈm os campos:"

#: book.translate.xml:17573
#, fuzzy
msgid "<emphasis>ds_addr</emphasis> - physical bus address of the segment"
msgstr " <emphasis> ds_addr </emphasis> - endereÁo de barramento fÌ≠sico do segmento "

#: book.translate.xml:17579
#, fuzzy
msgid "<emphasis>ds_len</emphasis> - length of the segment"
msgstr " <emphasis> ds_len </emphasis> - comprimento do segmento "

#: book.translate.xml:17588
#, fuzzy
msgid ""
"<function>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</function>"
msgstr ""
" <function> void bus_dmamap_unload (bus_dma_tag_t dmat, bus_dmamap_t map) </"
"function> "

#: book.translate.xml:17592
#, fuzzy
msgid "unload the map."
msgstr "descarregar o mapa."

#: book.translate.xml:17626 book.translate.xml:17597
#, fuzzy
msgid "<emphasis>dmat</emphasis> - tag"
msgstr " <emphasis> DMAT </emphasis> - dia "

#: book.translate.xml:17631 book.translate.xml:17602
#, fuzzy
msgid "<emphasis>map</emphasis> - loaded map"
msgstr " <emphasis> mapa </emphasis> - mapa carregado "

#: book.translate.xml:17611
#, fuzzy
msgid ""
"<function>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)</function>"
msgstr ""
" <function> void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t mapa, "
"bus_dmasync_op_t op) </function> "

#: book.translate.xml:17615
#, fuzzy
msgid ""
"Synchronise a loaded buffer with its bounce pages before and after physical transfer "
"to or from device. This is the function that does all the necessary copying of data "
"between the original buffer and its mapped version. The buffers must be synchronized "
"both before and after doing the transfer."
msgstr ""
"Sincronize um buffer carregado com suas p·ginas de rejeiÁ„o antes e depois da "
"transferÍncia fÌ≠sica para ou do dispositivo. Essa È a funÁ„o que faz toda a cÛpia "
"necess·ria de dados entre o buffer original e sua vers„o mapeada. Os buffers devem "
"ser sincronizados antes e depois de fazer a transferÍncia."

#: book.translate.xml:17636
#, fuzzy
msgid "<emphasis>op</emphasis> - type of synchronization operation to perform:"
msgstr " <emphasis> op </emphasis> - tipo de operaÁ„o de sincronizaÁ„o a executar: "

#: book.translate.xml:17645
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_PREREAD</function> - before reading from device into buffer"
msgstr ""
" <function> BUS_DMASYNC_PREREAD </function> - antes de ler do dispositivo para o "
"buffer "

#: book.translate.xml:17651
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_POSTREAD</function> - after reading from device into buffer"
msgstr ""
" <function> BUS_DMASYNC_POSTREAD </function> - depois de ler do dispositivo no "
"buffer "

#: book.translate.xml:17657
#, fuzzy
msgid "<function>BUS_DMASYNC_PREWRITE</function> - before writing the buffer to device"
msgstr ""
" <function> BUS_DMASYNC_PREWRITE </function> - antes de escrever o buffer para o "
"dispositivo "

#: book.translate.xml:17663
#, fuzzy
msgid "<function>BUS_DMASYNC_POSTWRITE</function> - after writing the buffer to device"
msgstr ""
" <function> BUS_DMASYNC_POSTWRITE </function> - depois de escrever o buffer para o "
"dispositivo "

#: book.translate.xml:17674
#, fuzzy
msgid ""
"As of now PREREAD and POSTWRITE are null operations but that may change in the "
"future, so they must not be ignored in the driver. Synchronization is not needed for "
"the memory obtained from <function>bus_dmamem_alloc()</function>."
msgstr ""
"A partir de agora, PREREAD e POSTWRITE s„o operaÁÌµes nulas, mas que podem mudar no "
"futuro, portanto, elas n„o devem ser ignoradas no driver. A sincronizaÁ„o n„o È "
"necess·ria para a memÛria obtida de <function> bus_dmamem_alloc () </function> "

#: book.translate.xml:17680
#, fuzzy
msgid ""
"Before calling the callback function from <function>bus_dmamap_load()</function> the "
"segment array is stored in the stack. And it gets pre-allocated for the maximal "
"number of segments allowed by the tag. Because of this the practical limit for the "
"number of segments on i386 architecture is about 250-300 (the kernel stack is 4KB "
"minus the size of the user structure, size of a segment array entry is 8 bytes, and "
"some space must be left). Because the array is allocated based on the maximal number "
"this value must not be set higher than really needed. Fortunately, for most of "
"hardware the maximal supported number of segments is much lower. But if the driver "
"wants to handle buffers with a very large number of scatter-gather segments it "
"should do that in portions: load part of the buffer, transfer it to the device, load "
"next part of the buffer, and so on."
msgstr ""
"Antes de chamar a funÁ„o de retorno de chamada <function> bus_dmamap_load () </"
"function> o array de segmentos È armazenado na pilha. E ele È prÈ-alocado para o "
"n˙mero m·ximo de segmentos permitido pela tag. Devido a isso, o limite pr·tico para "
"o n˙mero de segmentos na arquitetura i386 È de cerca de 250-300 (a pilha do kernel È "
"4KB menos o tamanho da estrutura do usu·rio, o tamanho de uma entrada de matriz de "
"segmento È de 8 bytes e algum espaÁo deve ser deixado) . Como a matriz È alocada com "
"base no n˙mero m·ximo, esse valor n„o deve ser definido mais alto do que o realmente "
"necess·rio. Felizmente, para a maioria do hardware, o n˙mero m·ximo de segmentos "
"suportados È muito menor. Mas se o driver quiser manipular buffers com um n˙mero "
"muito grande de segmentos de dispers„o, ele deve fazer isso em partes: carregar "
"parte do buffer, transferi-lo para o dispositivo, carregar a prÛxima parte do buffer "
"e assim por diante. "

#: book.translate.xml:17697
#, fuzzy
msgid ""
"Another practical consequence is that the number of segments may limit the size of "
"the buffer. If all the pages in the buffer happen to be physically non-contiguous "
"then the maximal supported buffer size for that fragmented case would be (nsegments "
"* page_size). For example, if a maximal number of 10 segments is supported then on "
"i386 maximal guaranteed supported buffer size would be 40K. If a higher size is "
"desired then special tricks should be used in the driver."
msgstr ""
"Outra conseqÌºÍncia pr·tica È que o n˙mero de segmentos pode limitar o tamanho do "
"buffer. Se todas as p·ginas no buffer forem fisicamente n„o contÌ≠guas, o tamanho "
"m·ximo do buffer suportado para esse caso fragmentado seria (nsegments * page_size). "
"Por exemplo, se um n˙mero m·ximo de 10 segmentos for suportado, em i386 o tamanho "
"m·ximo do buffer suportado garantido seria 40 K. Se um tamanho maior for desejado, "
"ent„o truques especiais devem ser usados ‚Äã‚Äãno driver. "

#: book.translate.xml:17707
#, fuzzy
msgid ""
"If the hardware does not support scatter-gather at all or the driver wants to "
"support some buffer size even if it is heavily fragmented then the solution is to "
"allocate a contiguous buffer in the driver and use it as intermediate storage if the "
"original buffer does not fit."
msgstr ""
"Se o hardware n„o suporta scatter-gather ou se o driver quiser suportar algum "
"tamanho de buffer mesmo que seja muito fragmentado, a soluÁ„o È alocar um buffer "
"contÌ≠guo no driver e us·-lo como armazenamento intermedi·rio se o buffer original "
"n„o serve."

#: book.translate.xml:17714
#, fuzzy
msgid ""
"Below are the typical call sequences when using a map depend on the use of the map. "
"The characters -&gt; are used to show the flow of time."
msgstr ""
"Abaixo est„o as seqÌºÍncias de chamadas tÌ≠picas ao usar um mapa dependem do uso do "
"mapa. Os caracteres -&gt; s„o usados ‚Äã‚Äãpara mostrar o fluxo de tempo."

#: book.translate.xml:17719
#, fuzzy
msgid ""
"For a buffer which stays practically fixed during all the time between attachment "
"and detachment of a device:"
msgstr ""
"Para um buffer que fica praticamente fixo durante todo o tempo entre a conex„o e o "
"desligamento de um dispositivo:"

#: book.translate.xml:17722
#, fuzzy
msgid ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ...use buffer... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"
msgstr ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ... use buffer ... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"

#: book.translate.xml:17727
#, fuzzy
msgid ""
"For a buffer that changes frequently and is passed from outside the driver: <_:"
"programlisting-1/>"
msgstr ""
"Para um buffer que muda com freqÌºÍncia e È passado de fora do driver: <_: "
"programlisting-1 />"

#: book.translate.xml:17740
#, fuzzy
msgid ""
"When loading a map created by <function>bus_dmamem_alloc()</function> the passed "
"address and size of the buffer must be the same as used in "
"<function>bus_dmamem_alloc()</function>. In this case it is guaranteed that the "
"whole buffer will be mapped as one segment (so the callback may be based on this "
"assumption) and the request will be executed immediately (EINPROGRESS will never be "
"returned). All the callback needs to do in this case is to save the physical address."
msgstr ""
"Ao carregar um mapa criado por <function> bus_dmamem_alloc () </function> o endereÁo "
"passado e tamanho do buffer deve ser o mesmo usado em <function> bus_dmamem_alloc () "
"</function> . Nesse caso, È garantido que o buffer inteiro ser· mapeado como um "
"segmento (para que o retorno de chamada possa se basear nessa suposiÁ„o) e a "
"solicitaÁ„o ser· executada imediatamente (o EINPROGRESS nunca ser· retornado). Todo "
"o retorno de chamada que precisa ser feito neste caso È salvar o endereÁo fÌ≠sico. "

#: book.translate.xml:17751
#, fuzzy
msgid "A typical example would be:"
msgstr "Um exemplo tÌ≠pico seria:"

#: book.translate.xml:17789
#, fuzzy
msgid ""
"Looks a bit long and complicated but that is the way to do it. The practical "
"consequence is: if multiple memory areas are allocated always together it would be a "
"really good idea to combine them all into one structure and allocate as one (if the "
"alignment and boundary limitations permit)."
msgstr ""
"Parece um pouco longo e complicado, mas È assim. A consequÍncia pr·tica È: se v·rias "
"·reas de memÛria forem alocadas sempre juntas, seria uma boa idÈia combin·-las em "
"uma estrutura e alocar como uma (se a limitaÁÌµes de alinhamento e limite permitem). "

#: book.translate.xml:17796
#, fuzzy
msgid ""
"When loading an arbitrary buffer into the map created by "
"<function>bus_dmamap_create()</function> special measures must be taken to "
"synchronize with the callback in case it would be delayed. The code would look like:"
msgstr ""
"Ao carregar um buffer arbitr·rio no mapa criado por <function> bus_dmamap_create () "
"</function> Medidas especiais devem ser tomadas para sincronizar com o retorno de "
"chamada caso ele seja atrasado. O cÛdigo ficaria assim: "

#: book.translate.xml:17826
#, fuzzy
msgid "Two possible approaches for the processing of requests are:"
msgstr "Duas abordagens possÌ≠veis para o processamento de pedidos s„o:"

#: book.translate.xml:17829
#, fuzzy
msgid ""
"1. If requests are completed by marking them explicitly as done (such as the CAM "
"requests) then it would be simpler to put all the further processing into the "
"callback driver which would mark the request when it is done. Then not much extra "
"synchronization is needed. For the flow control reasons it may be a good idea to "
"freeze the request queue until this request gets completed."
msgstr ""
"1. Se as solicitaÁÌµes forem concluÌ≠das marcando-as explicitamente como concluÌ≠das "
"(como as solicitaÁÌµes de CAM), seria mais simples colocar todo o processamento "
"adicional no driver de retorno de chamada que marcaria a solicitaÁ„o quando isso È "
"feito. Para os motivos de controle de fluxo, pode ser uma boa ideia congelar a fila "
"de solicitaÁÌµes atÈ que essa solicitaÁ„o seja concluÌ≠da. "

#: book.translate.xml:17838
#, fuzzy
msgid ""
"2. If requests are completed when the function returns (such as classic read or "
"write requests on character devices) then a synchronization flag should be set in "
"the buffer descriptor and <function>tsleep()</function> called. Later when the "
"callback gets called it will do its processing and check this synchronization flag. "
"If it is set then the callback should issue a wakeup. In this approach the callback "
"function could either do all the needed processing (just like the previous case) or "
"simply save the segments array in the buffer descriptor. Then after callback "
"completes the calling function could use this saved segments array and do all the "
"processing."
msgstr ""
"2. Se as solicitaÁÌµes forem concluÌ≠das quando a funÁ„o retornar (como solicitaÁÌµes "
"cl·ssicas de leitura ou gravaÁ„o em dispositivos de caracteres), um sinalizador de "
"sincronizaÁ„o dever· ser definido no descritor de buffer e <function> tsleep () </"
"function> chamado. Mais tarde, quando o retorno de chamada for chamado, ele far· seu "
"processamento e verificar· esse sinalizador de sincronizaÁ„o. Se estiver definido, o "
"retorno de chamada deve emitir uma ativaÁ„o. Nessa abordagem, a funÁ„o de retorno de "
"chamada poderia fazer todo o processamento necess·rio (como no caso anterior) ou "
"simplesmente salvar a matriz de segmentos no descritor de buffer. Ent„o, depois que "
"o retorno de chamada for concluÌ≠do, a funÁ„o de chamada poder· usar essa matriz de "
"segmentos salvos e fazer todo o processamento. "

#: book.translate.xml:19279 book.translate.xml:17858
#, fuzzy
msgid "DMA"
msgstr "DMA"

#: book.translate.xml:17861
#, fuzzy
msgid "<primary>Direct Memory Access (DMA)</primary>"
msgstr " <primary> Acesso Direto Ì† MemÛria (DMA) </primary> "

#: book.translate.xml:17863
#, fuzzy
msgid ""
"The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA "
"controller (actually, two of them but that is an irrelevant detail). To make the "
"early ISA devices simple and cheap the logic of the bus control and address "
"generation was concentrated in the DMA controller. Fortunately, FreeBSD provides a "
"set of functions that mostly hide the annoying details of the DMA controller from "
"the device drivers."
msgstr ""
"O Direct Memory Access (DMA) È implementado no barramento ISA atravÈs do controlador "
"DMA (na verdade, dois deles, mas isso È um detalhe irrelevante). Para tornar os "
"primeiros dispositivos ISA simples e baratos, a lÛgica do controle de barramento e "
"geraÁ„o de endereÁos estava concentrada no controlador de DMA. Felizmente, o FreeBSD "
"fornece um conjunto de funÁÌµes que ocultam principalmente os detalhes irritantes do "
"controlador de DMA dos drivers de dispositivos. "

#: book.translate.xml:17874
#, fuzzy
msgid ""
"The simplest case is for the fairly intelligent devices. Like the bus master devices "
"on PCI they can generate the bus cycles and memory addresses all by themselves. The "
"only thing they really need from the DMA controller is bus arbitration. So for this "
"purpose they pretend to be cascaded slave DMA controllers. And the only thing needed "
"from the system DMA controller is to enable the cascaded mode on a DMA channel by "
"calling the following function when attaching the driver:"
msgstr ""
"O caso mais simples È para os dispositivos razoavelmente inteligentes. Como os "
"dispositivos mestre de barramento em PCI, eles podem gerar os ciclos de barramento e "
"os endereÁos de memÛria sozinhos. A ˙nica coisa que eles realmente precisam do "
"controlador de DMA È a arbitragem de barramento. fingir ser controladores DMA "
"escravo em cascata. E a ˙nica coisa necess·ria do controlador DMA do sistema È "
"ativar o modo em cascata em um canal DMA chamando a seguinte funÁ„o ao anexar o "
"driver: "

#: book.translate.xml:17886
#, fuzzy
msgid "<function>void isa_dmacascade(int channel_number)</function>"
msgstr " <function> void isa_dmacascade (int channel_number) </function> "

#: book.translate.xml:17890
#, fuzzy
msgid ""
"All the further activity is done by programming the device. When detaching the "
"driver no DMA-related functions need to be called."
msgstr ""
"Toda a atividade adicional È feita pela programaÁ„o do dispositivo. Ao desconectar o "
"driver, nenhuma funÁ„o relacionada ao DMA precisa ser chamada."

#: book.translate.xml:17896
#, fuzzy
msgid "For the simpler devices things get more complicated. The functions used are:"
msgstr ""
"Para os dispositivos mais simples, as coisas ficam mais complicadas. As funÁÌµes "
"usadas s„o:"

#: book.translate.xml:17904
#, fuzzy
msgid "<function>int isa_dma_acquire(int chanel_number)</function>"
msgstr " <function> int isa_dma_acquire (int chanel_number) </function> "

#: book.translate.xml:17907
#, fuzzy
msgid ""
"Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was already "
"reserved by this or a different driver. Most of the ISA devices are not able to "
"share DMA channels anyway, so normally this function is called when attaching a "
"device. This reservation was made redundant by the modern interface of bus resources "
"but still must be used in addition to the latter. If not used then later, other DMA "
"routines will panic."
msgstr ""
"Reserve um canal DMA. Retorna 0 em sucesso ou EBUSY se o canal j· estiver reservado "
"por este ou um driver diferente. A maioria dos dispositivos ISA n„o È capaz de "
"compartilhar canais DMA, ent„o normalmente essa funÁ„o È chamada ao conectar um "
"dispositivo. Essa reserva foi tornada redundante pela interface moderna dos recursos "
"de barramento, mas ainda deve ser usada em adiÁ„o a esta ˙ltima. Se n„o for usada, "
"mais tarde, outras rotinas de DMA entrar„o em pÌ¢nico. "

#: book.translate.xml:17921
#, fuzzy
msgid "<function>int isa_dma_release(int chanel_number)</function>"
msgstr " <function> int isa_dma_release (int chanel_number) </function> "

#: book.translate.xml:17924
#, fuzzy
msgid ""
"Release a previously reserved DMA channel. No transfers must be in progress when the "
"channel is released (in addition the device must not try to initiate transfer after "
"the channel is released)."
msgstr ""
"Liberar um canal de DMA previamente reservado. Nenhuma transferÍncia deve estar em "
"progresso quando o canal for liberado (alÈm disso, o dispositivo n„o deve tentar "
"iniciar a transferÍncia apÛs o canal ser liberado)."

#: book.translate.xml:17933
#, fuzzy
msgid "<function>void isa_dmainit(int chan, u_int bouncebufsize)</function>"
msgstr " <function> void isa_dmainit (int chan, u_int bouncebufsize) </function> "

#: book.translate.xml:17937
#, fuzzy
msgid ""
"Allocate a bounce buffer for use with the specified channel. The requested size of "
"the buffer can not exceed 64KB. This bounce buffer will be automatically used later "
"if a transfer buffer happens to be not physically contiguous or outside of the "
"memory accessible by the ISA bus or crossing the 64KB boundary. If the transfers "
"will be always done from buffers which conform to these conditions (such as those "
"allocated by <function>bus_dmamem_alloc()</function> with proper limitations) then "
"<function>isa_dmainit()</function> does not have to be called. But it is quite "
"convenient to transfer arbitrary data using the DMA controller. The bounce buffer "
"will automatically care of the scatter-gather issues."
msgstr ""
"Alocar um buffer de rejeiÁ„o para uso com o canal especificado. O tamanho solicitado "
"do buffer n„o pode exceder 64 KB. Esse buffer de rejeiÁ„o ser· usado automaticamente "
"mais tarde se um buffer de transferÍncia n„o estiver fisicamente contÌ≠guo ou fora da "
"memÛria acessÌ≠vel pelo ISA barramento ou cruzando o limite de 64 Kb. Se as "
"transferÍncias forem sempre feitas a partir de buffers que estejam de acordo com "
"estas condiÁÌµes (tais <function> bus_dmamem_alloc () </function> com limitaÁÌµes "
"adequadas) <function> isa_dmainit () </function> n„o precisa ser chamado. Mas È "
"bastante conveniente transferir dados arbitr·rios usando o controlador de DMA. O "
"buffer de rejeiÁ„o cuidar· automaticamente dos problemas de dispers„o e coleta. "

#: book.translate.xml:17957
#, fuzzy
msgid "<emphasis>chan</emphasis> - channel number"
msgstr " <emphasis> chan </emphasis> - n˙mero do canal"

#: book.translate.xml:17962
#, fuzzy
msgid "<emphasis>bouncebufsize</emphasis> - size of the bounce buffer in bytes"
msgstr ""
" <emphasis> bouncebufsize </emphasis> - tamanho do buffer de rejeiÁ„o em bytes "

#: book.translate.xml:17973
#, fuzzy
msgid ""
"<function>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int chan)</"
"function>"
msgstr ""
" <function> void isa_dmastart (sinalizadores int, caddr_t addr, u_int nbytes, int "
"chan) </function> "

#: book.translate.xml:17977
#, fuzzy
msgid ""
"Prepare to start a DMA transfer. This function must be called to set up the DMA "
"controller before actually starting transfer on the device. It checks that the "
"buffer is contiguous and falls into the ISA memory range, if not then the bounce "
"buffer is automatically used. If bounce buffer is required but not set up by "
"<function>isa_dmainit()</function> or too small for the requested transfer size then "
"the system will panic. In case of a write request with bounce buffer the data will "
"be automatically copied to the bounce buffer."
msgstr ""
"Prepare-se para iniciar uma transferÍncia de DMA. Esta funÁ„o deve ser chamada para "
"configurar o controlador de DMA antes de iniciar a transferÍncia no dispositivo. Ele "
"verifica se o buffer È contÌ≠guo e cai no intervalo de memÛria ISA, sen„o o buffer de "
"rejeiÁ„o È automaticamente Se o buffer de rejeiÁ„o for necess·rio, mas n„o "
"configurado <function> isa_dmainit () </function> ou muito pequeno para o tamanho de "
"transferÍncia solicitado, o sistema entra em pÌ¢nico. No caso de uma solicitaÁ„o de "
"gravaÁ„o com buffer de rejeiÁ„o, os dados ser„o automaticamente copiados para o "
"buffer de rejeiÁ„o. "

#: book.translate.xml:17992
#, fuzzy
msgid ""
"flags - a bitmask determining the type of operation to be done. The direction bits "
"B_READ and B_WRITE are mutually exclusive."
msgstr ""
"flags - um bitmask que determina o tipo de operaÁ„o a ser executada. Os bits de "
"direÁ„o B_READ e B_WRITE s„o mutuamente exclusivos."

#: book.translate.xml:17999
#, fuzzy
msgid "B_READ - read from the ISA bus into memory"
msgstr "B_READ - ler do barramento ISA na memÛria"

#: book.translate.xml:18004
#, fuzzy
msgid "B_WRITE - write from the memory to the ISA bus"
msgstr "B_WRITE - escreva da memÛria para o barramento ISA"

#: book.translate.xml:18009
#, fuzzy
msgid ""
"B_RAW - if set then the DMA controller will remember the buffer and after the end of "
"transfer will automatically re-initialize itself to repeat transfer of the same "
"buffer again (of course, the driver may change the data in the buffer before "
"initiating another transfer in the device). If not set then the parameters will work "
"only for one transfer, and <function>isa_dmastart()</function> will have to be "
"called again before initiating the next transfer. Using B_RAW makes sense only if "
"the bounce buffer is not used."
msgstr ""
"B_RAW - se configurado, o controlador de DMA se lembrar· do buffer e, apÛs o tÈrmino "
"da transferÍncia, reinicializar· automaticamente para repetir a transferÍncia do "
"mesmo buffer novamente (È claro, o driver pode alterar os dados no buffer antes de "
"iniciar outra transferÍncia Se n„o estiver definido, os parÌ¢metros funcionar„o "
"apenas para uma transferÍncia e <function> isa_dmastart () </function> ter· que ser "
"chamado novamente antes de iniciar a prÛxima transferÍncia. O uso de B_RAW faz "
"sentido apenas se o buffer de rejeiÁ„o n„o for usado. "

#: book.translate.xml:18027
#, fuzzy
msgid "addr - virtual address of the buffer"
msgstr "addr - endereÁo virtual do buffer"

#: book.translate.xml:18032
#, fuzzy
msgid ""
"nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is not "
"allowed: the DMA controller will understand it as 64KB while the kernel code will "
"understand it as 0 and that would cause unpredictable effects. For channels number 4 "
"and higher the length must be even because these channels transfer 2 bytes at a "
"time. In case of an odd length the last byte will not be transferred."
msgstr ""
"nbytes - comprimento do buffer. Deve ser menor ou igual a 64 KB. Comprimento de 0 "
"n„o È permitido: o controlador de DMA o entender· como 64 KB enquanto o cÛdigo do "
"kernel o entender· como 0 e isso causaria efeitos imprevisÌ≠veis. Para o n˙mero de "
"canais 4 e maior o comprimento deve ser mesmo porque estes canais transferem 2 bytes "
"de cada vez. No caso de um comprimento Ì≠mpar, o ˙ltimo byte n„o ser· transferido. "

#: book.translate.xml:18044
#, fuzzy
msgid "chan - channel number"
msgstr "chan - n˙mero do canal"

#: book.translate.xml:18050
#, fuzzy
msgid ""
"<function>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</function>"
msgstr ""
" <function> void isa_dmadone (sinalizadores int, caddr_t addr, int nbytes, int chan) "
"</function> "

#: book.translate.xml:18054
#, fuzzy
msgid ""
"Synchronize the memory after device reports that transfer is done. If that was a "
"read operation with a bounce buffer then the data will be copied from the bounce "
"buffer to the original buffer. Arguments are the same as for "
"<function>isa_dmastart()</function>. Flag B_RAW is permitted but it does not affect "
"<function>isa_dmadone()</function> in any way."
msgstr ""
"Sincronize a memÛria apÛs o dispositivo informar que a transferÍncia est· concluÌ≠da. "
"Se essa foi uma operaÁ„o de leitura com um buffer de rejeiÁ„o, os dados ser„o "
"copiados do buffer de rejeiÁ„o para o buffer original. Os argumentos s„o os mesmos "
"que para <function> isa_dmastart () </function> . A sinalizaÁ„o B_RAW È permitida, "
"mas n„o afeta <function> isa_dmadone () </function> de qualquer forma \""

#: book.translate.xml:18066
#, fuzzy
msgid "<function>int isa_dmastatus(int channel_number)</function>"
msgstr " <function> int isa_dmastatus (int channel_number) </function> "

#: book.translate.xml:18069
#, fuzzy
msgid ""
"Returns the number of bytes left in the current transfer to be transferred. In case "
"the flag B_READ was set in <function>isa_dmastart()</function> the number returned "
"will never be equal to zero. At the end of transfer it will be automatically reset "
"back to the length of buffer. The normal use is to check the number of bytes left "
"after the device signals that the transfer is completed. If the number of bytes is "
"not 0 then something probably went wrong with that transfer."
msgstr ""
"Retorna o n˙mero de bytes restantes na transferÍncia atual a ser transferida. Caso o "
"sinalizador B_READ tenha sido configurado em <function> isa_dmastart () </function> "
"o n˙mero retornado nunca ser· igual a zero. No final da transferÍncia, ele ser· "
"redefinido automaticamente de volta ao tamanho do buffer. O uso normal È verificar o "
"n˙mero de bytes restantes depois que o dispositivo sinaliza que a transferÍncia foi "
"concluÌ≠da. Se o n˙mero de bytes n„o for 0, ent„o algo provavelmente deu errado com "
"essa transferÍncia. "

#: book.translate.xml:18083
#, fuzzy
msgid "<function>int isa_dmastop(int channel_number)</function>"
msgstr " <function> int isa_dmastop (int channel_number) </function> "

#: book.translate.xml:18086
#, fuzzy
msgid "Aborts the current transfer and returns the number of bytes left untransferred."
msgstr "Anula a transferÍncia atual e retorna o n˙mero de bytes n„o transferidos."

#: book.translate.xml:18095
#, fuzzy
msgid "xxx_isa_probe"
msgstr "xxx_isa_probe"

#: book.translate.xml:18098
#, fuzzy
msgid ""
"This function probes if a device is present. If the driver supports auto-detection "
"of some part of device configuration (such as interrupt vector or memory address) "
"this auto-detection must be done in this routine."
msgstr ""
"Esta funÁ„o investiga se um dispositivo est· presente. Se o driver suportar a "
"detecÁ„o autom·tica de alguma parte da configuraÁ„o do dispositivo (como vetor de "
"interrupÁ„o ou endereÁo de memÛria), esta detecÁ„o autom·tica deve ser feita nesta "
"rotina."

#: book.translate.xml:18105
#, fuzzy
msgid ""
"As for any other bus, if the device cannot be detected or is detected but failed the "
"self-test or some other problem happened then it returns a positive value of error. "
"The value <errorname>ENXIO</errorname> must be returned if the device is not "
"present. Other error values may mean other conditions. Zero or negative values mean "
"success. Most of the drivers return zero as success."
msgstr ""
"Quanto a qualquer outro barramento, se o dispositivo n„o puder ser detectado ou for "
"detectado, mas falhar no autoteste ou algum outro problema ocorrer, ele retornar· um "
"valor positivo de erro. O valor <errorname> ENXIO </errorname> deve ser devolvido se "
"o dispositivo n„o estiver presente. Outros valores de erro podem significar outras "
"condiÁÌµes. Valores zero ou negativos significam sucesso. A maioria dos motoristas "
"retorna zero como sucesso. "

#: book.translate.xml:18115
#, fuzzy
msgid ""
"The negative return values are used when a PnP device supports multiple interfaces. "
"For example, an older compatibility interface and a newer advanced interface which "
"are supported by different drivers. Then both drivers would detect the device. The "
"driver which returns a higher value in the probe routine takes precedence (in other "
"words, the driver returning 0 has highest precedence, one returning -1 is next, one "
"returning -2 is after it and so on). In result the devices which support only the "
"old interface will be handled by the old driver (which should return -1 from the "
"probe routine) while the devices supporting the new interface as well will be "
"handled by the new driver (which should return 0 from the probe routine)."
msgstr ""
"Os valores de retorno negativos s„o usados ‚Äã‚Äãquando um dispositivo PnP suporta "
"v·rias interfaces. Por exemplo, uma interface de compatibilidade mais antiga e uma "
"interface avanÁada mais recente suportada por drivers diferentes. Ent„o, ambos os "
"drivers detectariam o dispositivo. O driver que retorna um valor mais alto a rotina "
"da sonda tem precedÍncia (em outras palavras, o driver retornando 0 tem a "
"precedÍncia mais alta, uma retornando -1 È a prÛxima, uma retornando -2 È depois "
"dela e assim por diante) Em resultado, os dispositivos que suportam apenas a "
"interface antiga ser„o manipulados pelo driver antigo (que deve retornar -1 da "
"rotina da sonda), enquanto os dispositivos que suportam a nova interface tambÈm "
"ser„o manipulados pelo novo driver (que deve retornar 0 da rotina da sonda). "

#: book.translate.xml:18131
#, fuzzy
msgid ""
"The device descriptor struct xxx_softc is allocated by the system before calling the "
"probe routine. If the probe routine returns an error the descriptor will be "
"automatically deallocated by the system. So if a probing error occurs the driver "
"must make sure that all the resources it used during probe are deallocated and that "
"nothing keeps the descriptor from being safely deallocated. If the probe completes "
"successfully the descriptor will be preserved by the system and later passed to the "
"routine <function>xxx_isa_attach()</function>. If a driver returns a negative value "
"it can not be sure that it will have the highest priority and its attach routine "
"will be called. So in this case it also must release all the resources before "
"returning and if necessary allocate them again in the attach routine. When "
"<function>xxx_isa_probe()</function> returns 0 releasing the resources before "
"returning is also a good idea and a well-behaved driver should do so. But in cases "
"where there is some problem with releasing the resources the driver is allowed to "
"keep resources between returning 0 from the probe routine and execution of the "
"attach routine."
msgstr ""
"O descritor de dispositivo struct xxx_softc È alocado pelo sistema antes de chamar a "
"rotina de an·lise. Se a rotina de an·lise retornar um erro, o descritor ser· "
"desalocado automaticamente pelo sistema. Portanto, se ocorrer um erro de an·lise, o "
"driver deve certificar-se de que todos os recursos usados ‚Äã‚Äãdurante o probe s„o "
"desalocados e nada impede que o descritor seja desalocado com seguranÁa.Se o probe "
"for concluÌ≠do com Íxito, o descritor ser· preservado pelo sistema e, posteriormente, "
"passado para a rotina <function> xxx_isa_attach () </function> . Se um driver "
"retornar um valor negativo, ele n„o pode ter certeza de que ter· a prioridade mais "
"alta e sua rotina de anexaÁ„o ser· chamada. Portanto, neste caso, tambÈm deve "
"liberar todos os recursos antes de retornar e, se necess·rio, aloc·-los novamente na "
"rotina de anexaÁ„o. Quando <function> xxx_isa_probe () </function> Retorna 0 "
"liberando os recursos antes de retornar tambÈm È uma boa idÈia e um driver bem "
"comportado deve fazÍ-lo. Mas nos casos em que houver algum problema com a liberaÁ„o "
"dos recursos, o driver poder· manter os recursos entre o retorno de 0 da rotina de "
"an·lise e a execuÁ„o da rotina de anexaÁ„o. "

#: book.translate.xml:18155
#, fuzzy
msgid "A typical probe routine starts with getting the device descriptor and unit:"
msgstr "Uma rotina de sonda tÌ≠pica comeÁa com o descritor e a unidade do dispositivo:"

#: book.translate.xml:18168
#, fuzzy
msgid ""
"Then check for the PnP devices. The check is carried out by a table containing the "
"list of PnP IDs supported by this driver and human-readable descriptions of the "
"device models corresponding to these IDs."
msgstr ""
"Ent„o, verifique os dispositivos PnP. A verificaÁ„o È realizada por uma tabela "
"contendo a lista de IDs PnP suportados por este driver e descriÁÌµes legÌ≠veis por "
"humanos dos modelos de dispositivos correspondentes a esses IDs."

#: book.translate.xml:18180
#, fuzzy
msgid ""
"The logic of ISA_PNP_PROBE is the following: If this card (device unit) was not "
"detected as PnP then ENOENT will be returned. If it was detected as PnP but its "
"detected ID does not match any of the IDs in the table then ENXIO is returned. "
"Finally, if it has PnP support and it matches on of the IDs in the table, 0 is "
"returned and the appropriate description from the table is set by "
"<function>device_set_desc()</function>."
msgstr ""
"A lÛgica de ISA_PNP_PROBE È a seguinte: Se esta placa (unidade de dispositivo) n„o "
"foi detectada como PnP, ent„o ENOENT ser· retornado. Se ela foi detectada como PnP, "
"mas sua ID detectada n„o corresponde a nenhuma das IDs na tabela, ent„o ENXIO È "
"Finalmente, se ele tiver suporte PnP e corresponder aos IDs na tabela, 0 ser· "
"retornado e a descriÁ„o apropriada da tabela ser· definida por <function> "
"device_set_desc () </function> "

#: book.translate.xml:18191
#, fuzzy
msgid "If a driver supports only PnP devices then the condition would look like:"
msgstr "Se um driver suporta apenas dispositivos PnP, a condiÁ„o seria semelhante a:"

#: book.translate.xml:18199
#, fuzzy
msgid ""
"No special treatment is required for the drivers which do not support PnP because "
"they pass an empty PnP ID table and will always get ENXIO if called on a PnP card."
msgstr ""
"Nenhum tratamento especial È requerido para os drivers que n„o suportam PnP porque "
"eles passam uma tabela vazia de ID PnP e sempre recebem ENXIO se forem chamados em "
"uma placa PnP."

#: book.translate.xml:18205
#, fuzzy
msgid ""
"The probe routine normally needs at least some minimal set of resources, such as I/O "
"port number to find the card and probe it. Depending on the hardware the driver may "
"be able to discover the other necessary resources automatically. The PnP devices "
"have all the resources pre-set by the PnP subsystem, so the driver does not need to "
"discover them by itself."
msgstr ""
"A rotina de an·lise normalmente precisa de pelo menos um conjunto mÌ≠nimo de "
"recursos, como o n˙mero da porta I / O para encontrar a placa e sond·-la. Dependendo "
"do hardware, o driver pode descobrir os outros recursos necess·rios automaticamente. "
"Os dispositivos PnP todos os recursos prÈ-definidos pelo subsistema PnP, para que o "
"driver n„o precise descobri-los sozinho. "

#: book.translate.xml:18215
#, fuzzy
msgid ""
"Typically the minimal information required to get access to the device is the I/O "
"port number. Then some devices allow to get the rest of information from the device "
"configuration registers (though not all devices do that). So first we try to get the "
"port start value:"
msgstr ""
"Normalmente, a informaÁ„o mÌ≠nima necess·ria para obter acesso ao dispositivo È o "
"n˙mero da porta de E / S. Ent„o, alguns dispositivos permitem obter o restante das "
"informaÁÌµes dos registros de configuraÁ„o do dispositivo (embora nem todos os "
"dispositivos faÁam isso). o valor inicial da porta: "

#: book.translate.xml:18227
#, fuzzy
msgid ""
"The base port address is saved in the structure softc for future use. If it will be "
"used very often then calling the resource function each time would be prohibitively "
"slow. If we do not get a port we just return an error. Some device drivers can "
"instead be clever and try to probe all the possible ports, like this:"
msgstr ""
"O endereÁo da porta base È salvo na estrutura softc para uso futuro. Se for usado "
"com muita freqÌºÍncia, chamar a funÁ„o resource a cada vez seria proibitivamente "
"lento. Se n„o obtivermos uma porta, retornaremos um erro. Alguns drivers de "
"dispositivo em vez disso, pode ser inteligente e tentar investigar todas as portas "
"possÌ≠veis, como esta: "

#: book.translate.xml:18283
#, fuzzy
msgid ""
"Of course, normally the driver's <function>identify()</function> routine should be "
"used for such things. But there may be one valid reason why it may be better to be "
"done in <function>probe()</function>: if this probe would drive some other sensitive "
"device crazy. The probe routines are ordered with consideration of the "
"<literal>sensitive</literal> flag: the sensitive devices get probed first and the "
"rest of the devices later. But the <function>identify()</function> routines are "
"called before any probes, so they show no respect to the sensitive devices and may "
"upset them."
msgstr ""
"Claro, normalmente o motorista <function> identificar() </function> rotina deve ser "
"usada para tais coisas. Mas pode haver uma raz„o v·lida para que seja melhor ser "
"feito <function> sonda () </function> : se esta sonda forÁar algum outro dispositivo "
"sensÌ≠vel louco. As rotinas de sondagem s„o ordenadas com a consideraÁ„o do <literal> "
"sensÌ≠vel </literal> sinalizador: os dispositivos sensÌ≠veis s„o examinados primeiro e "
"o restante dos dispositivos posteriormente. Mas o <function> identificar() </"
"function> rotinas s„o chamadas antes de qualquer teste, ent„o elas n„o mostram "
"respeito pelos dispositivos sensÌ≠veis e podem perturb·-las. "

#: book.translate.xml:18297
#, fuzzy
msgid ""
"Now, after we got the starting port we need to set the port count (except for PnP "
"devices) because the kernel does not have this information in the configuration file."
msgstr ""
"Agora, depois que tivermos a porta inicial, precisamos configurar a contagem de "
"portas (exceto para dispositivos PnP), porque o kernel n„o tem essas informaÁÌµes no "
"arquivo de configuraÁ„o."

#: book.translate.xml:18309
#, fuzzy
msgid ""
"Finally allocate and activate a piece of port address space (special values of start "
"and end mean <quote>use those we set by <function>bus_set_resource()</function></"
"quote>):"
msgstr ""
"Finalmente alocar e ativar um pedaÁo de espaÁo de endereÁo de porta (valores "
"especiais de inÌ≠cio e tÈrmino significam <quote> usar aqueles que estabelecemos "
"<function> bus_set_resource () </function></quote> ): "

#: book.translate.xml:18324
#, fuzzy
msgid ""
"Now having access to the port-mapped registers we can poke the device in some way "
"and check if it reacts like it is expected to. If it does not then there is probably "
"some other device or no device at all at this address."
msgstr ""
"Agora, tendo acesso aos registradores mapeados pela porta, podemos cutucar o "
"dispositivo de alguma forma e verificar se ele reage como esperado. Se isso n„o "
"ocorrer, provavelmente haver· algum outro dispositivo ou nenhum dispositivo nesse "
"endereÁo."

#: book.translate.xml:18331
#, fuzzy
msgid ""
"Normally drivers do not set up the interrupt handlers until the attach routine. "
"Instead they do probes in the polling mode using the <function>DELAY()</function> "
"function for timeout. The probe routine must never hang forever, all the waits for "
"the device must be done with timeouts. If the device does not respond within the "
"time it is probably broken or misconfigured and the driver must return error. When "
"determining the timeout interval give the device some extra time to be on the safe "
"side: although <function>DELAY()</function> is supposed to delay for the same amount "
"of time on any machine it has some margin of error, depending on the exact CPU."
msgstr ""
"Normalmente, os drivers n„o configuram os manipuladores de interrupÁ„o atÈ a rotina "
"de anexaÁ„o. Em vez disso, eles fazem sondas no modo de pesquisa <function> DEMORA() "
"</function> funÁ„o para o tempo limite. A rotina de an·lise nunca deve ser "
"interrompida para sempre, todas as esperas do dispositivo devem ser feitas com "
"tempos limite. Se o dispositivo n„o responder dentro do tempo provavelmente est· "
"quebrado ou mal configurado e o driver deve retornar um erro. Ao determinar o "
"intervalo de timeout, dÍ ao dispositivo algum tempo extra para estar no lado seguro: "
"<function> DEMORA() </function> È suposto para atrasar a mesma quantidade de tempo "
"em qualquer m·quina que tenha alguma margem de erro, dependendo da CPU exata \""

#: book.translate.xml:18346
#, fuzzy
msgid ""
"If the probe routine really wants to check that the interrupts really work it may "
"configure and probe the interrupts too. But that is not recommended."
msgstr ""
"Se a rotina de an·lise realmente quer verificar se as interrupÁÌµes realmente "
"funcionam, pode configurar e investigar as interrupÁÌµes tambÈm. Mas isso n„o È "
"recomendado."

#: book.translate.xml:18358
#, fuzzy
msgid ""
"The function <function>xxx_probe_ports()</function> may also set the device "
"description depending on the exact model of device it discovers. But if there is "
"only one supported device model this can be as well done in a hardcoded way. Of "
"course, for the PnP devices the PnP support sets the description from the table "
"automatically."
msgstr ""
"A funÁ„o <function> xxx_probe_ports () </function> TambÈm pode definir a descriÁ„o "
"do dispositivo dependendo do modelo exato do dispositivo que ele descobre. Mas se "
"houver apenas um modelo de dispositivo suportado, isso tambÈm pode ser feito de "
"maneira codificada. Ìâ claro que, para os dispositivos PnP, o suporte PnP define a "
"descriÁ„o da tabela automaticamente. "

#: book.translate.xml:18372
#, fuzzy
msgid ""
"Then the probe routine should either discover the ranges of all the resources by "
"reading the device configuration registers or make sure that they were set "
"explicitly by the user. We will consider it with an example of on-board memory. The "
"probe routine should be as non-intrusive as possible, so allocation and check of "
"functionality of the rest of resources (besides the ports) would be better left to "
"the attach routine."
msgstr ""
"Ent„o, a rotina de an·lise deve descobrir os intervalos de todos os recursos lendo "
"os registros de configuraÁ„o do dispositivo ou certificar-se de que eles foram "
"definidos explicitamente pelo usu·rio. Vamos consider·-lo com um exemplo de memÛria "
"on-board. A rotina de an·lise deve ser o mais n„o intrusivo possÌ≠vel, portanto, a "
"alocaÁ„o e a verificaÁ„o da funcionalidade do restante dos recursos (alÈm das "
"portas) seriam melhor deixadas para a rotina de anexaÁ„o \""

#: book.translate.xml:18383
#, fuzzy
msgid ""
"The memory address may be specified in the kernel configuration file or on some "
"devices it may be pre-configured in non-volatile configuration registers. If both "
"sources are available and different, which one should be used? Probably if the user "
"bothered to set the address explicitly in the kernel configuration file they know "
"what they are doing and this one should take precedence. An example of "
"implementation could be:"
msgstr ""
"O endereÁo de memÛria pode ser especificado no arquivo de configuraÁ„o do kernel ou "
"em alguns dispositivos ele pode ser prÈ-configurado em registros de configuraÁ„o n„o "
"vol·teis. Se ambas as fontes estiverem disponÌ≠veis e diferentes, qual deve ser "
"usado? Provavelmente se o usu·rio se incomodou em definir o endereÁo explicitamente "
"no arquivo de configuraÁ„o do kernel eles sabem o que est„o fazendo e este deve ter "
"precedÍncia. Um exemplo de implementaÁ„o poderia ser: "

#: book.translate.xml:18439
#, fuzzy
msgid "Resources for IRQ and DRQ are easy to check by analogy."
msgstr "Recursos para IRQ e DRQ s„o f·ceis de verificar por analogia."

#: book.translate.xml:18443
#, fuzzy
msgid "If all went well then release all the resources and return success."
msgstr "Se tudo correu bem, libere todos os recursos e retorne o sucesso."

#: book.translate.xml:18450
#, fuzzy
msgid ""
"Finally, handle the troublesome situations. All the resources should be deallocated "
"before returning. We make use of the fact that before the structure softc is passed "
"to us it gets zeroed out, so we can find out if some resource was allocated: then "
"its descriptor is non-zero."
msgstr ""
"Finalmente, lide com as situaÁÌµes problem·ticas. Todos os recursos devem ser "
"desalocados antes de retornar. Usamos o fato de que antes que a estrutura seja "
"passada para nÛs, ela È zerada, para que possamos descobrir se algum recurso foi "
"alocado. descritor È diferente de zero. "

#: book.translate.xml:18466
#, fuzzy
msgid ""
"That would be all for the probe routine. Freeing of resources is done from multiple "
"places, so it is moved to a function which may look like:"
msgstr ""
"Isso seria tudo para a rotina da sonda. A liberaÁ„o de recursos È feita a partir de "
"v·rios lugares, ent„o È movida para uma funÁ„o que pode parecer:"

#: book.translate.xml:18525
#, fuzzy
msgid "xxx_isa_attach"
msgstr "xxx_isa_attach"

#: book.translate.xml:18528
#, fuzzy
msgid ""
"The attach routine actually connects the driver to the system if the probe routine "
"returned success and the system had chosen to attach that driver. If the probe "
"routine returned 0 then the attach routine may expect to receive the device "
"structure softc intact, as it was set by the probe routine. Also if the probe "
"routine returns 0 it may expect that the attach routine for this device shall be "
"called at some point in the future. If the probe routine returns a negative value "
"then the driver may make none of these assumptions."
msgstr ""
"A rotina anexar realmente conecta o driver ao sistema se a rotina da sonda tiver "
"retornado sucesso e o sistema tiver escolhido anexar esse driver. Se a rotina da "
"sonda retornasse 0, a rotina de anexaÁ„o poderia receber a estrutura do dispositivo "
"softc intacta, como era AlÈm disso, se a rotina da sonda retornar 0, pode-se esperar "
"que a rotina de anexaÁ„o para este dispositivo seja chamada em algum momento no "
"futuro.Se a rotina da sonda retornar um valor negativo, o motorista n„o far· nenhuma "
"dessas suposiÁÌµes. "

#: book.translate.xml:18540
#, fuzzy
msgid ""
"The attach routine returns 0 if it completed successfully or error code otherwise."
msgstr ""
"A rotina de anexaÁ„o retorna 0 se foi concluÌ≠da com sucesso ou, caso contr·rio, o "
"cÛdigo de erro."

#: book.translate.xml:18544
#, fuzzy
msgid ""
"The attach routine starts just like the probe routine, with getting some frequently "
"used data into more accessible variables."
msgstr ""
"A rotina de anexaÁ„o comeÁa exatamente como a rotina de an·lise, com a obtenÁ„o de "
"alguns dados usados ‚Äã‚Äãcom frequÍncia em vari·veis ‚Äã‚Äãmais acessÌ≠veis."

#: book.translate.xml:18553
#, fuzzy
msgid ""
"Then allocate and activate all the necessary resources. Because normally the port "
"range will be released before returning from probe, it has to be allocated again. We "
"expect that the probe routine had properly set all the resource ranges, as well as "
"saved them in the structure softc. If the probe routine had left some resource "
"allocated then it does not need to be allocated again (which would be considered an "
"error)."
msgstr ""
"Em seguida, aloque e ative todos os recursos necess·rios. Como normalmente o "
"intervalo de portas ser· liberado antes de retornar do probe, ele deve ser alocado "
"novamente. Esperamos que a rotina de an·lise tenha definido corretamente todos os "
"intervalos de recursos e os salvou em a estrutura softc.Se a rotina de an·lise tiver "
"deixado algum recurso alocado, ela n„o precisar· ser alocada novamente (o que seria "
"considerado um erro). "

#: book.translate.xml:18581
#, fuzzy
msgid ""
"The DMA request channel (DRQ) is allocated likewise. To initialize it use functions "
"of the <function>isa_dma*()</function> family. For example:"
msgstr ""
"O canal de requisiÁ„o DMA (DRQ) È alocado da mesma forma. Para inicializ·-lo, use as "
"funÁÌµes do <function> isa_dma * () </function> famÌ≠lia. Por exemplo:"

#: book.translate.xml:18586
#, fuzzy
msgid "<function>isa_dmacascade(sc-&gt;drq0);</function>"
msgstr " <function> isa_dmacascade (sc-&gt; drq0); </function> "

#: book.translate.xml:18588
#, fuzzy
msgid ""
"The interrupt request line (IRQ) is a bit special. Besides allocation the driver's "
"interrupt handler should be associated with it. Historically in the old ISA drivers "
"the argument passed by the system to the interrupt handler was the device unit "
"number. But in modern drivers the convention suggests passing the pointer to "
"structure softc. The important reason is that when the structures softc are "
"allocated dynamically then getting the unit number from softc is easy while getting "
"softc from the unit number is difficult. Also this convention makes the drivers for "
"different buses look more uniform and allows them to share the code: each bus gets "
"its own probe, attach, detach and other bus-specific routines while the bulk of the "
"driver code may be shared among them."
msgstr ""
"A linha de requisiÁ„o de interrupÁ„o (IRQ) È um pouco especial. AlÈm da alocaÁ„o, o "
"manipulador de interrupÁ„o do driver deve estar associado a ela. Historicamente, nos "
"antigos drivers ISA, o argumento transmitido pelo sistema ao manipulador de "
"interrupÁ„o era o n˙mero da unidade. drivers a convenÁ„o sugere passar o ponteiro "
"para a estrutura softc.A raz„o importante È que quando o softc estruturas s„o "
"alocados dinamicamente, em seguida, obtendo o n˙mero da unidade do softc È f·cil, "
"enquanto obtendo softc do n˙mero da unidade È difÌ≠cil.TambÈm esta convenÁ„o faz com "
"que os drivers para diferentes os barramentos parecem mais uniformes e permitem que "
"eles compartilhem o cÛdigo: cada barramento recebe sua prÛpria sonda, anexar, "
"desconectar e outras rotinas especÌ≠ficas de barramento, enquanto a maior parte do "
"cÛdigo do driver pode ser compartilhada entre eles. "

#: book.translate.xml:18624
#, fuzzy
msgid ""
"If the device needs to make DMA to the main memory then this memory should be "
"allocated like described before:"
msgstr ""
"Se o dispositivo precisa fazer o DMA para a memÛria principal, ent„o esta memÛria "
"deve ser alocada como descrito anteriormente:"

#: book.translate.xml:18677
#, fuzzy
msgid ""
"After all the necessary resources are allocated the device should be initialized. "
"The initialization may include testing that all the expected features are functional."
msgstr ""
"Depois que todos os recursos necess·rios s„o alocados, o dispositivo deve ser "
"inicializado. A inicializaÁ„o pode incluir testes de que todos os recursos esperados "
"s„o funcionais."

#: book.translate.xml:18685
#, fuzzy
msgid ""
"The bus subsystem will automatically print on the console the device description set "
"by probe. But if the driver wants to print some extra information about the device "
"it may do so, for example:"
msgstr ""
"O subsistema de barramento ir· imprimir automaticamente no console a descriÁ„o do "
"dispositivo definida pela sonda. Mas se o motorista quiser imprimir alguma "
"informaÁ„o extra sobre o dispositivo, pode fazÍ-lo, por exemplo:"

#: book.translate.xml:18694
#, fuzzy
msgid ""
"If the initialization routine experiences any problems then printing messages about "
"them before returning error is also recommended."
msgstr ""
"Se a rotina de inicializaÁ„o apresentar algum problema, a impress„o de mensagens "
"sobre eles antes de retornar o erro tambÈm È recomendada."

#: book.translate.xml:18698
#, fuzzy
msgid ""
"The final step of the attach routine is attaching the device to its functional "
"subsystem in the kernel. The exact way to do it depends on the type of the driver: a "
"character device, a block device, a network device, a CAM SCSI bus device and so on."
msgstr ""
"A etapa final da rotina de anexaÁ„o È anexar o dispositivo ao seu subsistema "
"funcional no kernel. A maneira exata de fazer isso depende do tipo do driver: um "
"dispositivo de caractere, um dispositivo de bloco, um dispositivo de rede, um "
"barramento CAM SCSI dispositivo e assim por diante. "

#: book.translate.xml:18704
#, fuzzy
msgid "If all went well then return success."
msgstr "Se tudo correu bem, ent„o retorne o sucesso."

#: book.translate.xml:18712
#, fuzzy
msgid ""
"Finally, handle the troublesome situations. All the resources should be deallocated "
"before returning an error. We make use of the fact that before the structure softc "
"is passed to us it gets zeroed out, so we can find out if some resource was "
"allocated: then its descriptor is non-zero."
msgstr ""
"Finalmente, lide com as situaÁÌµes problem·ticas. Todos os recursos devem ser "
"desalocados antes de retornar um erro. Fazemos uso do fato de que antes que a "
"estrutura seja passada para nÛs, ela È zerada, para que possamos descobrir se algum "
"recurso foi alocado: ent„o seu descritor È diferente de zero. "

#: book.translate.xml:18727
#, fuzzy
msgid "That would be all for the attach routine."
msgstr "Isso seria tudo para a rotina de anexar."

#: book.translate.xml:18733
#, fuzzy
msgid "xxx_isa_detach"
msgstr "xxx_isa_detach"

#: book.translate.xml:18735
#, fuzzy
msgid ""
"If this function is present in the driver and the driver is compiled as a loadable "
"module then the driver gets the ability to be unloaded. This is an important feature "
"if the hardware supports hot plug. But the ISA bus does not support hot plug, so "
"this feature is not particularly important for the ISA devices. The ability to "
"unload a driver may be useful when debugging it, but in many cases installation of "
"the new version of the driver would be required only after the old version somehow "
"wedges the system and a reboot will be needed anyway, so the efforts spent on "
"writing the detach routine may not be worth it. Another argument that unloading "
"would allow upgrading the drivers on a production machine seems to be mostly "
"theoretical. Installing a new version of a driver is a dangerous operation which "
"should never be performed on a production machine (and which is not permitted when "
"the system is running in secure mode). Still, the detach routine may be provided for "
"the sake of completeness."
msgstr ""
"Se esta funÁ„o estiver presente no driver e o driver for compilado como um mÛdulo "
"carreg·vel, o driver ter· a capacidade de ser descarregado. Esse È um recurso "
"importante se o hardware suportar hot plug. Mas o barramento ISA n„o suporta hot "
"plug, Portanto, esse recurso n„o È particularmente importante para os dispositivos "
"ISA.A capacidade de descarregar um driver pode ser ˙til ao depur·-lo, mas em muitos "
"casos a instalaÁ„o da nova vers„o do driver seria necess·ria somente depois que a "
"vers„o antiga de alguma forma forÁar o sistema uma reinicializaÁ„o ser· necess·ria "
"de qualquer maneira, ent„o os esforÁos gastos em escrever a rotina de desconex„o "
"podem n„o valer a pena.Um argumento de que descarregar permitiria a atualizaÁ„o dos "
"drivers em uma m·quina de produÁ„o parece ser mais teÛrico.A instalaÁ„o de uma nova "
"vers„o de um driver È operaÁ„o perigosa que nunca deve ser executada em uma m·quina "
"de produÁ„o (e que n„o È permitida quando o sistema est· sendo executado no modo "
"seguro) .Ainda assim, a rotina de separaÁ„o pode ser fornecida para completar ess. "

#: book.translate.xml:18756
#, fuzzy
msgid ""
"The detach routine returns 0 if the driver was successfully detached or the error "
"code otherwise."
msgstr ""
"A rotina de desanexaÁ„o retorna 0 se o driver foi desconectado com sucesso ou o "
"cÛdigo de erro ocorreu de outra forma."

#: book.translate.xml:18761
#, fuzzy
msgid ""
"The logic of detach is a mirror of the attach. The first thing to do is to detach "
"the driver from its kernel subsystem. If the device is currently open then the "
"driver has two choices: refuse to be detached or forcibly close and proceed with "
"detach. The choice used depends on the ability of the particular kernel subsystem to "
"do a forced close and on the preferences of the driver's author. Generally the "
"forced close seems to be the preferred alternative. <_:programlisting-1/>"
msgstr ""
"A lÛgica de desanexar È um espelho da conex„o. A primeira coisa a fazer È separar o "
"driver do subsistema do kernel. Se o dispositivo estiver aberto, o driver tem duas "
"opÁÌµes: recusar-se a ser desanexado ou forÁosamente fechado e continuar com A "
"escolha usada depende da habilidade do subsistema do kernel em fazer um fechamento "
"forÁado e nas preferÍncias do autor do driver.Geralmente, o fechamento forÁado "
"parece ser a alternativa preferida. <_: programlisting-1 /> "

#: book.translate.xml:18777
#, fuzzy
msgid ""
"Next the driver may want to reset the hardware to some consistent state. That "
"includes stopping any ongoing transfers, disabling the DMA channels and interrupts "
"to avoid memory corruption by the device. For most of the drivers this is exactly "
"what the shutdown routine does, so if it is included in the driver we can just call "
"it."
msgstr ""
"Em seguida, o driver pode querer redefinir o hardware para algum estado consistente. "
"Isso inclui parar qualquer transferÍncia em andamento, desabilitar os canais DMA e "
"interromper para evitar corrupÁ„o de memÛria pelo dispositivo. Para a maioria dos "
"drivers, isso È exatamente o que a rotina de desligamento faz. por isso, se estiver "
"incluÌ≠do no driver, podemos cham·-lo. "

#: book.translate.xml:18785
#, fuzzy
msgid "<function>xxx_isa_shutdown(dev);</function>"
msgstr " <function> xxx_isa_shutdown (dev); </function> "

#: book.translate.xml:18787
#, fuzzy
msgid "And finally release all the resources and return success. <_:programlisting-1/>"
msgstr ""
"E, finalmente, liberar todos os recursos e retornar o sucesso. <_: Programlisting-1 /"
">"

#: book.translate.xml:18796
#, fuzzy
msgid "xxx_isa_shutdown"
msgstr "xxx_isa_shutdown"

#: book.translate.xml:18798
#, fuzzy
msgid ""
"This routine is called when the system is about to be shut down. It is expected to "
"bring the hardware to some consistent state. For most of the ISA devices no special "
"action is required, so the function is not really necessary because the device will "
"be re-initialized on reboot anyway. But some devices have to be shut down with a "
"special procedure, to make sure that they will be properly detected after soft "
"reboot (this is especially true for many devices with proprietary identification "
"protocols). In any case disabling DMA and interrupts in the device registers and "
"stopping any ongoing transfers is a good idea. The exact action depends on the "
"hardware, so we do not consider it here in any detail."
msgstr ""
"Essa rotina È chamada quando o sistema est· prestes a ser desligado. Espera-se que o "
"hardware fique em um estado consistente. Para a maioria dos dispositivos ISA, "
"nenhuma aÁ„o especial È necess·ria, portanto, a funÁ„o n„o È realmente necess·ria "
"porque o dispositivo ser reinicializado na reinicializaÁ„o de qualquer maneira.Mas "
"alguns dispositivos tem que ser desligado com um procedimento especial, para se "
"certificar de que eles ser„o detectados corretamente apÛs a reinicializaÁ„o suave "
"(isso È especialmente verdadeiro para muitos dispositivos com protocolos de "
"identificaÁ„o propriet·rios). desabilitar o DMA e interromper os registros do "
"dispositivo e parar qualquer transferÍncia em andamento È uma boa idÈia. A aÁ„o "
"exata depende do hardware, portanto, n„o o consideramos aqui em detalhes. "

#: book.translate.xml:18816
#, fuzzy
msgid "xxx_intr"
msgstr "Xxx_intr"

#: book.translate.xml:18818
#, fuzzy
msgid "<primary>interrupt handler</primary>"
msgstr " <primary> manipulador de interrupÁÌµes </primary> "

#: book.translate.xml:18820
#, fuzzy
msgid ""
"The interrupt handler is called when an interrupt is received which may be from this "
"particular device. The ISA bus does not support interrupt sharing (except in some "
"special cases) so in practice if the interrupt handler is called then the interrupt "
"almost for sure came from its device. Still, the interrupt handler must poll the "
"device registers and make sure that the interrupt was generated by its device. If "
"not it should just return."
msgstr ""
"O manipulador de interrupÁ„o È chamado quando uma interrupÁ„o È recebida, que pode "
"ser deste dispositivo em particular. O barramento ISA n„o suporta o compartilhamento "
"de interrupÁÌµes (exceto em alguns casos especiais), ent„o, na pr·tica, se o "
"manipulador de interrupÁ„o for chamado, Ainda assim, o manipulador de interrupÁ„o "
"deve pesquisar os registros do dispositivo e certificar-se de que a interrupÁ„o foi "
"gerada por seu dispositivo. Caso contr·rio, ele deve apenas retornar. "

#: book.translate.xml:18831
#, fuzzy
msgid ""
"The old convention for the ISA drivers was getting the device unit number as an "
"argument. This is obsolete, and the new drivers receive whatever argument was "
"specified for them in the attach routine when calling <function>bus_setup_intr()</"
"function>. By the new convention it should be the pointer to the structure softc. So "
"the interrupt handler commonly starts as:"
msgstr ""
"A antiga convenÁ„o para os drivers ISA estava obtendo o n˙mero da unidade do "
"dispositivo como um argumento. Isso È obsoleto e os novos drivers recebem qualquer "
"argumento especificado para eles na rotina anexar ao chamar <function> "
"bus_setup_intr () </function> . Pela nova convenÁ„o deve ser o ponteiro para a "
"estrutura softc. Ent„o, o manipulador de interrupÁ„o geralmente comeÁa como: "

#: book.translate.xml:18848
#, fuzzy
msgid ""
"It runs at the interrupt priority level specified by the interrupt type parameter of "
"<function>bus_setup_intr()</function>. That means that all the other interrupts of "
"the same type as well as all the software interrupts are disabled."
msgstr ""
"Ele È executado no nÌ≠vel de prioridade de interrupÁ„o especificado pelo parÌ¢metro "
"de tipo de interrupÁ„o de <function> bus_setup_intr () </function> . Isso significa "
"que todas as outras interrupÁÌµes do mesmo tipo, bem como todas as interrupÁÌµes de "
"software, est„o desativadas. "

#: book.translate.xml:18856
#, fuzzy
msgid "To avoid races it is commonly written as a loop:"
msgstr "Para evitar corridas, geralmente È escrito como um loop:"

#: book.translate.xml:18866
#, fuzzy
msgid ""
"The interrupt handler has to acknowledge interrupt to the device only but not to the "
"interrupt controller, the system takes care of the latter."
msgstr ""
"O handler de interrupÁ„o tem que reconhecer a interrupÁ„o apenas para o dispositivo, "
"mas n„o para o controlador de interrupÁ„o, o sistema cuida do ˙ltimo."

#: book.translate.xml:18882
#, fuzzy
msgid "PCI Devices"
msgstr "Dispositivos PCI"

#: book.translate.xml:18884
#, fuzzy
msgid "<primary>PCI bus</primary>"
msgstr " <primary> Barramento PCI </primary> "

#: book.translate.xml:18886
#, fuzzy
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device driver for "
"a device on a PCI bus."
msgstr ""
"Este capÌ≠tulo vai falar sobre os mecanismos do FreeBSD para escrever um driver de "
"dispositivo para um dispositivo em um barramento PCI."

#: book.translate.xml:18890
#, fuzzy
msgid "Probe and Attach"
msgstr "Sonda e Anexar"

#: book.translate.xml:18892
#, fuzzy
msgid ""
"Information here about how the PCI bus code iterates through the unattached devices "
"and see if a newly loaded kld will attach to any of them."
msgstr ""
"InformaÁÌµes aqui sobre como o cÛdigo de barramento PCI percorre os dispositivos n„o "
"conectados e ver se um kld recÈm-carregado ser· anexado a qualquer um deles."

#: book.translate.xml:18897
#, fuzzy
msgid "Sample Driver Source (<filename>mypci.c</filename>)"
msgstr "Exemplo de fonte de driver ( <filename> mypci.c </filename> ) "

#: book.translate.xml:19107
#, fuzzy
msgid "<filename>Makefile</filename> for Sample Driver"
msgstr " <filename> Makefile </filename> para o driver de exemplo "

#: book.translate.xml:19117
#, fuzzy
msgid ""
"If you place the above source file and <filename>Makefile</filename> into a "
"directory, you may run <command>make</command> to compile the sample driver. "
"Additionally, you may run <command>make load</command> to load the driver into the "
"currently running kernel and <command>make unload</command> to unload the driver "
"after it is loaded."
msgstr ""
"Se vocÍ colocar o arquivo de origem acima e <filename> Makefile </filename> em um "
"diretÛrio, vocÍ pode executar <command> faÁo </command> para compilar o driver de "
"exemplo. AlÈm disso, vocÍ pode executar <command> fazer carga </command> para "
"carregar o driver no kernel atualmente em execuÁ„o e <command> descarregar </"
"command> para descarregar o driver depois que ele for carregado. "

#: book.translate.xml:19127
#, fuzzy
msgid "Additional Resources"
msgstr "Recursos adicionais"

#: book.translate.xml:19129
#, fuzzy
msgid "<link xlink:href=\"http://www.pcisig.org/\">PCI Special Interest Group</link>"
msgstr ""
" <link xlink:href=\"http://www.pcisig.org/\"> Grupo de Interesse Especial PCI </"
"link> "

#: book.translate.xml:19132
#, fuzzy
msgid "PCI System Architecture, Fourth Edition by Tom Shanley, et al."
msgstr "PCI System Architecture, quarta ediÁ„o por Tom Shanley, et al."

#: book.translate.xml:19140
#, fuzzy
msgid "Bus Resources"
msgstr "Recursos de Ì¥nibus"

#: book.translate.xml:19142
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>resources</secondary>"
msgstr " <primary> Barramento PCI </primary><secondary> Recursos </secondary> "

#: book.translate.xml:19143
#, fuzzy
msgid ""
"FreeBSD provides an object-oriented mechanism for requesting resources from a parent "
"bus. Almost all devices will be a child member of some sort of bus (PCI, ISA, USB, "
"SCSI, etc) and these devices need to acquire resources from their parent bus (such "
"as memory segments, interrupt lines, or DMA channels)."
msgstr ""
"O FreeBSD fornece um mecanismo orientado a objeto para solicitar recursos de um "
"barramento pai. Quase todos os dispositivos ser„o um membro filho de algum tipo de "
"barramento (PCI, ISA, USB, SCSI, etc) e esses dispositivos precisam adquirir "
"recursos de seus pais. barramento (como segmentos de memÛria, linhas de interrupÁ„o "
"ou canais DMA). "

#: book.translate.xml:19150
#, fuzzy
msgid "Base Address Registers"
msgstr "Registros de endereÁo base"

#: book.translate.xml:19152
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>Base Address Registers</secondary>"
msgstr ""
" <primary> Barramento PCI </primary><secondary> Registradores de endereÁos base </"
"secondary> "

#: book.translate.xml:19154
#, fuzzy
msgid ""
"To do anything particularly useful with a PCI device you will need to obtain the "
"<emphasis>Base Address Registers</emphasis> (BARs) from the PCI Configuration space. "
"The PCI-specific details of obtaining the BAR are abstracted in the "
"<function>bus_alloc_resource()</function> function."
msgstr ""
"Para fazer algo particularmente ˙til com um dispositivo PCI, vocÍ precisar· obter o "
"<emphasis> Registradores de endereÁos base </emphasis> (BARs) do espaÁo de "
"configuraÁ„o PCI. Os detalhes especÌ≠ficos do PCI para obter a BAR s„o resumidos no "
"<function> bus_alloc_resource () </function> funÁ„o."

#: book.translate.xml:19160
#, fuzzy
msgid ""
"For example, a typical driver might have something similar to this in the "
"<function>attach()</function> function:"
msgstr ""
"Por exemplo, um driver tÌ≠pico pode ter algo semelhante a isso no <function> anexar() "
"</function> funÁ„o:"

#: book.translate.xml:19185
#, fuzzy
msgid ""
"Handles for each base address register are kept in the <varname remap=\"structname"
"\">softc</varname> structure so that they can be used to write to the device later."
msgstr ""
"As alÁas para cada registro de endereÁo base s„o mantidas na <varname remap="
"\"structname\"> softc </varname> estrutura para que eles possam ser usados ‚Äã‚Äãpara "
"gravar no dispositivo mais tarde \""

#: book.translate.xml:19189
#, fuzzy
msgid ""
"These handles can then be used to read or write from the device registers with the "
"<function>bus_space_*</function> functions. For example, a driver might contain a "
"shorthand function to read from a board specific register like this:"
msgstr ""
"Essas alÁas podem ser usadas para ler ou gravar nos registros do dispositivo com o "
"<function> bus_space_ * </function> funÁÌµes. Por exemplo, um driver pode conter uma "
"funÁ„o abreviada para ler de um registro especÌ≠fico da placa como este: "

#: book.translate.xml:19201
#, fuzzy
msgid "Similarly, one could write to the registers with:"
msgstr "Da mesma forma, pode-se escrever para os registros com:"

#: book.translate.xml:19210
#, fuzzy
msgid ""
"These functions exist in 8bit, 16bit, and 32bit versions and you should use "
"<function>bus_space_{read|write}_{1|2|4}</function> accordingly."
msgstr ""
"Estas funÁÌµes existem nas versÌµes 8bit, 16bit e 32bit e vocÍ deve usar <function> "
"bus_space_ {leia | escreva} _ {1 | 2 | 4} </function> adequadamente."

#: book.translate.xml:19216
#, fuzzy
msgid ""
"In FreeBSD 7.0 and later, you can use the <function>bus_*</function> functions "
"instead of <function>bus_space_*</function>. The <function>bus_*</function> "
"functions take a <type>struct resource *</type> pointer instead of a bus tag and "
"handle. Thus, you could drop the bus tag and bus handle members from the <varname "
"remap=\"structname\">softc</varname> and rewrite the <function>board_read()</"
"function> function as:"
msgstr ""
"No FreeBSD 7.0 e posterior, vocÍ pode usar o <function> Ì¥nibus_* </function> "
"funÁÌµes em vez de <function> bus_space_ * </function> . o <function> Ì¥nibus_* </"
"function> funÁÌµes tomar um <type> recurso struct </type> ponteiro em vez de uma "
"marca de barramento e identificador. Assim, vocÍ pode soltar a tag de barramento e "
"os membros da barra de bus do <varname remap=\"structname\"> softc </varname> e "
"reescrever o <function> board_read () </function> funciona como:"

#: book.translate.xml:21046 book.translate.xml:19234
#, fuzzy
msgid "Interrupts"
msgstr "Interrompe"

#: book.translate.xml:19236
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>interrupts</secondary>"
msgstr " <primary> Barramento PCI </primary><secondary> interrompe </secondary> "

#: book.translate.xml:19237
#, fuzzy
msgid ""
"Interrupts are allocated from the object-oriented bus code in a way similar to the "
"memory resources. First an IRQ resource must be allocated from the parent bus, and "
"then the interrupt handler must be set up to deal with this IRQ."
msgstr ""
"As interrupÁÌµes s„o alocadas a partir do cÛdigo de barramento orientado a objetos "
"de maneira semelhante aos recursos de memÛria. Primeiro, um recurso de IRQ deve ser "
"alocado a partir do barramento pai e, em seguida, o manipulador de interrupÁ„o deve "
"ser configurado para lidar com esse IRQ."

#: book.translate.xml:19242
#, fuzzy
msgid ""
"Again, a sample from a device <function>attach()</function> function says more than "
"words."
msgstr ""
"Mais uma vez, uma amostra de um dispositivo <function> anexar() </function> funÁ„o "
"diz mais que palavras \""

#: book.translate.xml:19267
#, fuzzy
msgid ""
"Some care must be taken in the detach routine of the driver. You must quiesce the "
"device's interrupt stream, and remove the interrupt handler. Once "
"<function>bus_teardown_intr()</function> has returned, you know that your interrupt "
"handler will no longer be called and that all threads that might have been executing "
"this interrupt handler have returned. Since this function can sleep, you must not "
"hold any mutexes when calling this function."
msgstr ""
"Alguns cuidados devem ser tomados na rotina de desconex„o do driver. VocÍ deve "
"desativar o fluxo de interrupÁ„o do dispositivo e remover o manipulador de "
"interrupÁ„o. <function> bus_teardown_intr () </function> retornou, vocÍ sabe que seu "
"manipulador de interrupÁÌµes n„o ser· mais chamado e que todos os encadeamentos que "
"podem estar executando este manipulador de interrupÁÌµes retornaram. Como esta "
"funÁ„o pode dormir, vocÍ n„o deve manter nenhum mutex ao chamar esta funÁ„o. "

#: book.translate.xml:19281
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>DMA</secondary>"
msgstr " <primary> Barramento PCI </primary><secondary> DMA </secondary> "

#: book.translate.xml:19282
#, fuzzy
msgid ""
"This section is obsolete, and present only for historical reasons. The proper "
"methods for dealing with these issues is to use the <function>bus_space_dma*()</"
"function> functions instead. This paragraph can be removed when this section is "
"updated to reflect that usage. However, at the moment, the API is in a bit of flux, "
"so once that settles down, it would be good to update this section to reflect that."
msgstr ""
"Esta seÁ„o È obsoleta e est· presente apenas por razÌµes histÛricas. Os mÈtodos "
"apropriados para lidar com essas questÌµes È usar <function> bus_space_dma * () </"
"function> funciona em vez disso. Este par·grafo pode ser removido quando esta seÁ„o "
"for atualizada para refletir esse uso. No entanto, no momento, a API est· em um "
"pouco de fluxo, portanto, uma vez que isso se resolva, seria bom atualizar esta "
"seÁ„o para refletir isso. "

#: book.translate.xml:19290
#, fuzzy
msgid ""
"On the PC, peripherals that want to do bus-mastering DMA must deal with physical "
"addresses. This is a problem since FreeBSD uses virtual memory and deals almost "
"exclusively with virtual addresses. Fortunately, there is a function, "
"<function>vtophys()</function> to help."
msgstr ""
"No PC, perifÈricos que querem fazer bus masterizaÁ„o devem lidar com endereÁos fÌ≠"
"sicos. Isso È um problema j· que o FreeBSD usa memÛria virtual e lida quase "
"exclusivamente com endereÁos virtuais. Felizmente, existe uma funÁ„o, <function> "
"vtophys () </function> ajudar."

#: book.translate.xml:19302
#, fuzzy
msgid ""
"The solution is a bit different on the alpha however, and what we really want is a "
"function called <function>vtobus()</function>."
msgstr ""
"A soluÁ„o È um pouco diferente no alfa, e o que realmente queremos È uma funÁ„o "
"chamada <function> vtobus () </function> "

#: book.translate.xml:19316
#, fuzzy
msgid "Deallocating Resources"
msgstr "Recursos de desalocaÁ„o"

#: book.translate.xml:19318
#, fuzzy
msgid ""
"It is very important to deallocate all of the resources that were allocated during "
"<function>attach()</function>. Care must be taken to deallocate the correct stuff "
"even on a failure condition so that the system will remain usable while your driver "
"dies."
msgstr ""
"Ìâ muito importante desalocar todos os recursos que foram alocados durante a "
"<function> anexar() </function> . Ìâ preciso tomar cuidado para desalocar o material "
"correto, mesmo em uma condiÁ„o de falha, para que o sistema permaneÁa utiliz·vel "
"enquanto o driver morre. "

#: book.translate.xml:19336
#, fuzzy
msgid "Common Access Method SCSI Controllers"
msgstr "Controladores SCSI do MÈtodo de Acesso Comum"

#: book.translate.xml:19350
#, fuzzy
msgid "<primary>SCSI</primary>"
msgstr " <primary> SCSI </primary> "

#: book.translate.xml:19351
#, fuzzy
msgid ""
"This document assumes that the reader has a general understanding of device drivers "
"in FreeBSD and of the SCSI protocol. Much of the information in this document was "
"extracted from the drivers:"
msgstr ""
"Este documento pressupÌµe que o leitor tenha uma compreens„o geral dos drivers de "
"dispositivos no FreeBSD e no protocolo SCSI. Muitas das informaÁÌµes contidas neste "
"documento foram extraÌ≠das dos drivers:"

#: book.translate.xml:19358
#, fuzzy
msgid ""
"ncr (<filename>/sys/pci/ncr.c</filename>) by Wolfgang Stanglmeier and Stefan Esser"
msgstr ""
"ncr ( <filename> /sys/pci/ncr.c </filename> ) de Wolfgang Stanglmeier e Stefan Esser "

#: book.translate.xml:19362
#, fuzzy
msgid "sym (<filename>/sys/dev/sym/sym_hipd.c</filename>) by Gerard Roudier"
msgstr "sym ( <filename> /sys/dev/sym/sym_hipd.c </filename> ) de Gerard Roudier "

#: book.translate.xml:19367
#, fuzzy
msgid "aic7xxx (<filename>/sys/dev/aic7xxx/aic7xxx.c</filename>) by Justin T. Gibbs"
msgstr ""
"aic7xxx ( <filename> /sys/dev/aic7xxx/aic7xxx.c </filename> ) por Justin T. Gibbs "

#: book.translate.xml:19373
#, fuzzy
msgid ""
"and from the CAM code itself (by Justin T. Gibbs, see <filename>/sys/cam/*</"
"filename>). When some solution looked the most logical and was essentially verbatim "
"extracted from the code by Justin T. Gibbs, I marked it as <quote>recommended</"
"quote>."
msgstr ""
"e do prÛprio cÛdigo CAM (por Justin T. Gibbs, veja <filename> / sys / cam / * </"
"filename> ). Quando alguma soluÁ„o parecia a mais lÛgica e essencialmente extraÌ≠da "
"do cÛdigo por Justin T. Gibbs, eu a marquei como <quote> recomendado </quote> "

#: book.translate.xml:19379
#, fuzzy
msgid ""
"The document is illustrated with examples in pseudo-code. Although sometimes the "
"examples have many details and look like real code, it is still pseudo-code. It was "
"written to demonstrate the concepts in an understandable way. For a real driver "
"other approaches may be more modular and efficient. It also abstracts from the "
"hardware details, as well as issues that would cloud the demonstrated concepts or "
"that are supposed to be described in the other chapters of the developers handbook. "
"Such details are commonly shown as calls to functions with descriptive names, "
"comments or pseudo-statements. Fortunately real life full-size examples with all the "
"details can be found in the real drivers."
msgstr ""
"O documento È ilustrado com exemplos em pseudo-cÛdigo. Embora algumas vezes os "
"exemplos tenham muitos detalhes e pareÁam com cÛdigo real, ainda È pseudo-cÛdigo. "
"Foi escrito para demonstrar os conceitos de uma maneira compreensÌ≠vel. Para um "
"driver real outras abordagens pode ser mais modular e eficiente, alÈm de abstrair os "
"detalhes do hardware, bem como problemas que poderiam ofuscar os conceitos "
"demonstrados ou que deveriam ser descritos nos outros capÌ≠tulos do manual do "
"desenvolvedor.Tais detalhes s„o comumente mostrados como chamadas para funÁÌµes com "
"nomes descritivos, coment·rios ou pseudo-declaraÁÌµes. Felizmente exemplos em "
"tamanho real com todos os detalhes podem ser encontrados nos drivers reais. "

#: book.translate.xml:19394
#, fuzzy
msgid "General Architecture"
msgstr "Arquitetura Geral"

#: book.translate.xml:19396
#, fuzzy
msgid "<primary>Common Access Method (CAM)</primary>"
msgstr " <primary> MÈtodo de acesso comum (CAM) </primary> "

#: book.translate.xml:19400
#, fuzzy
msgid ""
"CAM stands for Common Access Method. It is a generic way to address the I/O buses in "
"a SCSI-like way. This allows a separation of the generic device drivers from the "
"drivers controlling the I/O bus: for example the disk driver becomes able to control "
"disks on both SCSI, IDE, and/or any other bus so the disk driver portion does not "
"have to be rewritten (or copied and modified) for every new I/O bus. Thus the two "
"most important active entities are:"
msgstr ""
"CAM significa Common Access Method. Ìâ uma maneira genÈrica de endereÁar os "
"barramentos de E / S de maneira SCSI. Isso permite uma separaÁ„o dos drivers de "
"dispositivos genÈricos dos drivers que controlam o barramento de E / S: por exemplo, "
"o disco O driver torna-se capaz de controlar discos em SCSI, IDE e / ou qualquer "
"outro barramento, portanto a parte do driver de disco n„o precisa ser reescrita (ou "
"copiada e modificada) para cada novo barramento de E / S. estamos:"

#: book.translate.xml:19409
#, fuzzy
msgid "<primary>CD-ROM</primary>"
msgstr " <primary> CD-ROM </primary> "

#: book.translate.xml:19410
#, fuzzy
msgid "<primary>tape</primary>"
msgstr " <primary> fita </primary> "

#: book.translate.xml:19411
#, fuzzy
msgid "<primary>IDE</primary>"
msgstr " <primary> AQUI </primary> "

#: book.translate.xml:19414
#, fuzzy
msgid ""
"<emphasis>Peripheral Modules</emphasis> - a driver for peripheral devices (disk, "
"tape, CD-ROM, etc.)"
msgstr ""
" <emphasis> MÛdulos PerifÈricos </emphasis> - um driver para dispositivos "
"perifÈricos (disco, fita, CD-ROM, etc.) "

#: book.translate.xml:19420
#, fuzzy
msgid ""
"<emphasis>SCSI Interface Modules </emphasis>(SIM) - a Host Bus Adapter drivers for "
"connecting to an I/O bus such as SCSI or IDE."
msgstr ""
" <emphasis> MÛdulos de Interface SCSI </emphasis> (SIM) - drivers do Host Bus "
"Adapter para conex„o com um barramento de E / S, como SCSI ou IDE. "

#: book.translate.xml:19426
#, fuzzy
msgid ""
"A peripheral driver receives requests from the OS, converts them to a sequence of "
"SCSI commands and passes these SCSI commands to a SCSI Interface Module. The SCSI "
"Interface Module is responsible for passing these commands to the actual hardware "
"(or if the actual hardware is not SCSI but, for example, IDE then also converting "
"the SCSI commands to the native commands of the hardware)."
msgstr ""
"Um driver perifÈrico recebe solicitaÁÌµes do SO, converte-as em uma sequÍncia de "
"comandos SCSI e passa esses comandos SCSI para um MÛdulo de Interface SCSI. O MÛdulo "
"de Interface SCSI È respons·vel por passar esses comandos ao hardware real (ou se o "
"hardware real for n„o SCSI mas, por exemplo, IDE, em seguida, tambÈm convertendo os "
"comandos SCSI para os comandos nativos do hardware). "

#: book.translate.xml:19434
#, fuzzy
msgid ""
"Because we are interested in writing a SCSI adapter driver here, from this point on "
"we will consider everything from the SIM standpoint."
msgstr ""
"Porque estamos interessados ‚Äã‚Äãem escrever um driver de adaptador SCSI aqui, a partir "
"deste ponto consideraremos tudo do ponto de vista do SIM."

#: book.translate.xml:19438
#, fuzzy
msgid "A typical SIM driver needs to include the following CAM-related header files:"
msgstr ""
"Um driver SIM tÌ≠pico precisa incluir os seguintes arquivos de cabeÁalho relacionados "
"ao CAM:"

#: book.translate.xml:19448
#, fuzzy
msgid ""
"The first thing each SIM driver must do is register itself with the CAM subsystem. "
"This is done during the driver's <function>xxx_attach()</function> function (here "
"and further xxx_ is used to denote the unique driver name prefix). The "
"<function>xxx_attach()</function> function itself is called by the system bus auto-"
"configuration code which we do not describe here."
msgstr ""
"A primeira coisa que cada driver SIM deve fazer È registrar-se no subsistema CAM. "
"Isso È feito durante o <function> xxx_attach () </function> function (aqui e mais "
"xxx_ È usado para denotar o prefixo do nome do driver exclusivo). o <function> "
"xxx_attach () </function> A prÛpria funÁ„o È chamada pelo cÛdigo de configuraÁ„o "
"autom·tica do barramento do sistema, que n„o descrevemos aqui. "

#: book.translate.xml:19456
#, fuzzy
msgid ""
"This is achieved in multiple steps: first it is necessary to allocate the queue of "
"requests associated with this SIM:"
msgstr ""
"Isso È conseguido em v·rias etapas: primeiro È necess·rio alocar a fila de "
"solicitaÁÌµes associadas a este SIM:"

#: book.translate.xml:19465
#, fuzzy
msgid ""
"Here <literal>SIZE</literal> is the size of the queue to be allocated, maximal "
"number of requests it could contain. It is the number of requests that the SIM "
"driver can handle in parallel on one SCSI card. Commonly it can be calculated as:"
msgstr ""
"Aqui <literal> TAMANHO </literal> È o tamanho da fila a ser alocada, o n˙mero m·ximo "
"de solicitaÁÌµes que ela pode conter. Ìâ o n˙mero de solicitaÁÌµes que o driver do "
"SIM pode manipular em paralelo em uma placa SCSI. Comumente, pode ser calculado "
"como: "

#: book.translate.xml:19473
#, fuzzy
msgid "Next we create a descriptor of our SIM:"
msgstr "Em seguida, criamos um descritor do nosso SIM:"

#: book.translate.xml:19484
#, fuzzy
msgid ""
"Note that if we are not able to create a SIM descriptor we free the <varname remap="
"\"structname\">devq</varname> also because we can do nothing else with it and we "
"want to conserve memory."
msgstr ""
"Note que se n„o formos capazes de criar um descritor SIM, nÛs liberaremos o <varname "
"remap=\"structname\"> devq </varname> tambÈm porque n„o podemos fazer mais nada e "
"queremos conservar a memÛria. "

#: book.translate.xml:19489
#, fuzzy
msgid "<primary>SCSI</primary><secondary>bus</secondary>"
msgstr " <primary> SCSI </primary><secondary> Ì¥nibus </secondary> "

#: book.translate.xml:19488
#, fuzzy
msgid ""
"If a SCSI card has multiple SCSI buses<_:indexterm-1/> on it then each bus requires "
"its own <varname remap=\"structname\">cam_sim</varname> structure."
msgstr ""
"Se uma placa SCSI tem v·rios barramentos SCSI <_: indexterm-1 />, cada barramento "
"requer o seu prÛprio <varname remap=\"structname\"> cam_sim </varname> estrutura."

#: book.translate.xml:19493
#, fuzzy
msgid ""
"An interesting question is what to do if a SCSI card has more than one SCSI bus, do "
"we need one <varname remap=\"structname\">devq</varname> structure per card or per "
"SCSI bus? The answer given in the comments to the CAM code is: either way, as the "
"driver's author prefers."
msgstr ""
"Uma quest„o interessante È o que fazer se uma placa SCSI tem mais de um barramento "
"SCSI, precisamos de um <varname remap=\"structname\"> devq </varname> estrutura por "
"cart„o ou por barramento SCSI? A resposta dada nos coment·rios ao cÛdigo do CAM È: "
"de qualquer forma, como o autor do motorista prefere. "

#: book.translate.xml:19499
#, fuzzy
msgid "The arguments are:"
msgstr "Os argumentos s„o:"

#: book.translate.xml:19696 book.translate.xml:19506
#, fuzzy
msgid ""
"<funcdef>static void <function>xxx_action</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter>, <parameter>union ccb *ccb</parameter> </"
"paramdef>"
msgstr ""
" <funcdef> vazio est·tico <function> xxx_action </function></"
"funcdef><paramdef><parameter> struct cam_sim * sim </parameter> , <parameter> uni„o "
"ccb * ccb </parameter></paramdef> "

#: book.translate.xml:19503
#, fuzzy
msgid ""
"<function>action_func</function> - pointer to the driver's <function>xxx_action</"
"function> function. <_:funcsynopsis-1/>"
msgstr ""
" <function> action_func </function> - ponteiro para o motorista <function> "
"xxx_action </function> funÁ„o. <_: funcsynopsis-1 /> "

#: book.translate.xml:20947 book.translate.xml:19522
#, fuzzy
msgid ""
"<funcdef>static void <function>xxx_poll</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter> </paramdef>"
msgstr ""
" <funcdef> vazio est·tico <function> xxx_poll </function></"
"funcdef><paramdef><parameter> struct cam_sim * sim </parameter></paramdef> "

#: book.translate.xml:19519
#, fuzzy
msgid ""
"<function>poll_func</function> - pointer to the driver's <function>xxx_poll()</"
"function> <_:funcsynopsis-1/>"
msgstr ""
" <function> poll_func </function> - ponteiro para o motorista <function> xxx_poll () "
"</function> <_: funcsynopsis-1 /> "

#: book.translate.xml:19534
#, fuzzy
msgid ""
"driver_name - the name of the actual driver, such as <quote>ncr</quote> or "
"<quote>wds</quote>."
msgstr ""
"driver_name - o nome do driver real, como <quote> ncr </quote> ou <quote> wds </"
"quote> "

#: book.translate.xml:19540
#, fuzzy
msgid ""
"<varname remap=\"structname\">softc</varname> - pointer to the driver's internal "
"descriptor for this SCSI card. This pointer will be used by the driver in future to "
"get private data."
msgstr ""
" <varname remap=\"structname\"> softc </varname> - ponteiro para o descritor interno "
"do driver para esta placa SCSI. Esse ponteiro ser· usado pelo driver no futuro para "
"obter dados privados. "

#: book.translate.xml:19547
#, fuzzy
msgid ""
"unit - the controller unit number, for example for controller <quote>mps0</quote> "
"this number will be 0"
msgstr ""
"unidade - o n˙mero da unidade do controlador, por exemplo, para o controlador "
"<quote> mps0 </quote> esse n˙mero ser· 0 "

#: book.translate.xml:19553
#, fuzzy
msgid ""
"mtx - Lock associated with this SIM. For SIMs that don't know about locking, pass in "
"Giant. For SIMs that do, pass in the lock used to guard this SIM's data structures. "
"This lock will be held when xxx_action and xxx_poll are called."
msgstr ""
"mtx - Bloqueio associado a este SIM. Para SIMs que n„o sabem sobre bloqueio, passe "
"para Gigante. Para os SIMs, passe o bloqueio usado para proteger as estruturas de "
"dados deste SIM. Este bloqueio ser· mantido quando xxx_action e xxx_poll estiverem "
"chamado."

#: book.translate.xml:19560
#, fuzzy
msgid ""
"max_dev_transactions - maximal number of simultaneous transactions per SCSI target "
"in the non-tagged mode. This value will be almost universally equal to 1, with "
"possible exceptions only for the non-SCSI cards. Also the drivers that hope to take "
"advantage by preparing one transaction while another one is executed may set it to 2 "
"but this does not seem to be worth the complexity."
msgstr ""
"max_dev_transactions - n˙mero m·ximo de transaÁÌµes simultÌ¢neas por destino SCSI no "
"modo n„o marcado. Esse valor ser· quase universalmente igual a 1, com possÌ≠veis "
"exceÁÌµes apenas para as placas n„o-SCSI. AlÈm disso, os drivers que esperam tirar "
"proveito preparando um transaÁ„o enquanto outro È executado pode configur·-lo para "
"2, mas isso n„o parece valer a complexidade \""

#: book.translate.xml:19570
#, fuzzy
msgid ""
"max_tagged_dev_transactions - the same thing, but in the tagged mode. Tags are the "
"SCSI way to initiate multiple transactions on a device: each transaction is assigned "
"a unique tag and the transaction is sent to the device. When the device completes "
"some transaction it sends back the result together with the tag so that the SCSI "
"adapter (and the driver) can tell which transaction was completed. This argument is "
"also known as the maximal tag depth. It depends on the abilities of the SCSI adapter."
msgstr ""
"max_tagged_dev_transactions - a mesma coisa, mas no modo marcado. Tags s„o a maneira "
"SCSI de iniciar v·rias transaÁÌµes em um dispositivo: a cada transaÁ„o È atribuÌ≠da "
"uma tag ˙nica e a transaÁ„o È enviada para o dispositivo. Quando o dispositivo "
"conclui alguma transaÁ„o, ele envia retorne o resultado junto com a tag para que o "
"adaptador SCSI (e o driver) possa dizer qual transaÁ„o foi concluÌ≠da. Esse argumento "
"tambÈm È conhecido como a profundidade m·xima da marcaÁ„o. Depende das capacidades "
"do adaptador SCSI. "

#: book.translate.xml:19584
#, fuzzy
msgid "<primary>SCSI</primary><secondary>adapter</secondary>"
msgstr " <primary> SCSI </primary><secondary> adaptador </secondary> "

#: book.translate.xml:19583
#, fuzzy
msgid ""
"Finally we register the SCSI buses associated with our SCSI adapter<_:indexterm-1/>:"
msgstr ""
"Finalmente, registramos os barramentos SCSI associados ao nosso adaptador SCSI <_: "
"indexterm-1 />:"

#: book.translate.xml:19591
#, fuzzy
msgid ""
"If there is one <varname remap=\"structname\">devq</varname> structure per SCSI bus "
"(i.e., we consider a card with multiple buses as multiple cards with one bus each) "
"then the bus number will always be 0, otherwise each bus on the SCSI card should be "
"get a distinct number. Each bus needs its own separate structure cam_sim."
msgstr ""
"Se houver um <varname remap=\"structname\"> devq </varname> estrutura por barramento "
"SCSI (isto È, consideramos uma placa com m˙ltiplos barramentos como m˙ltiplas placas "
"com um barramento cada), ent„o o n˙mero do barramento ser· sempre 0, caso contr·rio, "
"cada barramento na placa SCSI deve receber um n˙mero distinto. Cada Ì¥nibus precisa "
"de sua prÛpria estrutura separada, cam_sim. "

#: book.translate.xml:19598
#, fuzzy
msgid ""
"After that our controller is completely hooked to the CAM system. The value of "
"<varname remap=\"structname\">devq</varname> can be discarded now: sim will be "
"passed as an argument in all further calls from CAM and devq can be derived from it."
msgstr ""
"Depois disso, nosso controlador È completamente conectado ao sistema CAM. O valor de "
"<varname remap=\"structname\"> devq </varname> pode ser descartado agora: o sim ser· "
"passado como um argumento em todas as outras chamadas do CAM e o devq pode ser "
"derivado dele. "

#: book.translate.xml:19603
#, fuzzy
msgid ""
"CAM provides the framework for such asynchronous events. Some events originate from "
"the lower levels (the SIM drivers), some events originate from the peripheral "
"drivers, some events originate from the CAM subsystem itself. Any driver can "
"register callbacks for some types of the asynchronous events, so that it would be "
"notified if these events occur."
msgstr ""
"O CAM fornece a estrutura para tais eventos assÌ≠ncronos. Alguns eventos se originam "
"dos nÌ≠veis mais baixos (os drivers SIM), alguns eventos s„o originados dos drivers "
"perifÈricos, alguns eventos s„o originados do prÛprio subsistema CAM. Qualquer "
"driver pode registrar retornos de chamada para alguns tipos de eventos. eventos assÌ≠"
"ncronos, para que seja notificado se esses eventos ocorrerem. "

#: book.translate.xml:19610
#, fuzzy
msgid ""
"A typical example of such an event is a device reset. Each transaction and event "
"identifies the devices to which it applies by the means of <quote>path</quote>. The "
"target-specific events normally occur during a transaction with this device. So the "
"path from that transaction may be re-used to report this event (this is safe because "
"the event path is copied in the event reporting routine but not deallocated nor "
"passed anywhere further). Also it is safe to allocate paths dynamically at any time "
"including the interrupt routines, although that incurs certain overhead, and a "
"possible problem with this approach is that there may be no free memory at that "
"time. For a bus reset event we need to define a wildcard path including all devices "
"on the bus. So we can create the path for the future bus reset events in advance and "
"avoid problems with the future memory shortage:"
msgstr ""
"Um exemplo tÌ≠pico de tal evento È uma reinicializaÁ„o do dispositivo. Cada transaÁ„o "
"e evento identifica os dispositivos aos quais ele se aplica por meio de <quote> "
"caminho </quote> . Os eventos especÌ≠ficos de destino normalmente ocorrem durante uma "
"transaÁ„o com este dispositivo. Portanto, o caminho dessa transaÁ„o pode ser "
"reutilizado para relatar esse evento (isso È seguro porque o caminho do evento È "
"copiado na rotina de relatÛrio de evento, mas n„o desalocado nem transmitido em "
"nenhum outro lugar). TambÈm È seguro alocar caminhos dinamicamente a qualquer "
"momento, incluindo as rotinas de interrupÁ„o, embora isso incorra em certa "
"sobrecarga, e um possÌ≠vel problema com essa abordagem È que pode n„o haver memÛria "
"livre naquele momento. Para um evento de redefiniÁ„o de barramento, precisamos "
"definir um caminho curinga incluindo todos os dispositivos no barramento. Assim, "
"podemos criar o caminho para os futuros eventos de redefiniÁ„o de barramento com "
"antecedÍncia e evitar problemas com a falta de memÛria futura: "

#: book.translate.xml:19639
#, fuzzy
msgid "As you can see the path includes:"
msgstr "Como vocÍ pode ver o caminho inclui:"

#: book.translate.xml:19643
#, fuzzy
msgid "ID of the peripheral driver (NULL here because we have none)"
msgstr "ID do driver perifÈrico (NULL aqui porque n„o temos nenhum)"

#: book.translate.xml:19648
#, fuzzy
msgid "ID of the SIM driver (<function>cam_sim_path(sim)</function>)"
msgstr "ID do driver do SIM ( <function> cam_sim_path (sim) </function> ) "

#: book.translate.xml:19653
#, fuzzy
msgid ""
"SCSI target number of the device (CAM_TARGET_WILDCARD means <quote>all devices</"
"quote>)"
msgstr ""
"N˙mero alvo SCSI do dispositivo (CAM_TARGET_WILDCARD significa <quote> todos os "
"dispositivos </quote> ) "

#: book.translate.xml:19658
#, fuzzy
msgid ""
"SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means <quote>all LUNs</quote>)"
msgstr ""
"N˙mero SCSI LUN do subdivice (CAM_LUN_WILDCARD significa <quote> todas as LUNs </"
"quote> ) "

#: book.translate.xml:19663
#, fuzzy
msgid ""
"If the driver can not allocate this path it will not be able to work normally, so in "
"that case we dismantle that SCSI bus."
msgstr ""
"Se o driver n„o puder alocar este caminho, ele n„o poder· funcionar normalmente, "
"ent„o, nesse caso, desmontaremos esse barramento SCSI."

#: book.translate.xml:19667
#, fuzzy
msgid ""
"And we save the path pointer in the <varname remap=\"structname\">softc</varname> "
"structure for future use. After that we save the value of sim (or we can also "
"discard it on the exit from <function>xxx_probe()</function> if we wish)."
msgstr ""
"E nÛs salvamos o ponteiro do caminho no <varname remap=\"structname\"> softc </"
"varname> estrutura para uso futuro. Depois disso, salvamos o valor de sim (ou tambÈm "
"podemos descart·-lo na saÌ≠da de <function> xxx_probe () </function> se quisermos. "

#: book.translate.xml:19672
#, fuzzy
msgid ""
"That is all for a minimalistic initialization. To do things right there is one more "
"issue left."
msgstr ""
"Isso È tudo para uma inicializaÁ„o minimalista. Para fazer as coisas certas, resta "
"mais uma quest„o."

#: book.translate.xml:19675
#, fuzzy
msgid ""
"For a SIM driver there is one particularly interesting event: when a target device "
"is considered lost. In this case resetting the SCSI negotiations with this device "
"may be a good idea. So we register a callback for this event with CAM. The request "
"is passed to CAM by requesting CAM action on a CAM control block for this type of "
"request:"
msgstr ""
"Para um driver SIM h· um evento particularmente interessante: quando um dispositivo "
"de destino È considerado perdido. Neste caso, a reinicializaÁ„o das negociaÁÌµes "
"SCSI com este dispositivo pode ser uma boa idÈia. Portanto, registramos um retorno "
"de chamada para este evento com o CAM. passou para CAM solicitando aÁ„o CAM em um "
"bloco de controle CAM para este tipo de solicitaÁ„o: "

#: book.translate.xml:19691
#, fuzzy
msgid ""
"Now we take a look at the <function>xxx_action()</function> and "
"<function>xxx_poll()</function> driver entry points."
msgstr ""
"Agora vamos dar uma olhada no <function> xxx_action () </function> e <function> "
"xxx_poll () </function> pontos de entrada do motorista. "

#: book.translate.xml:19707
#, fuzzy
msgid ""
"Do some action on request of the CAM subsystem. Sim describes the SIM for the "
"request, CCB is the request itself. CCB stands for <quote>CAM Control Block</quote>. "
"It is a union of many specific instances, each describing arguments for some type of "
"transactions. All of these instances share the CCB header where the common part of "
"arguments is stored."
msgstr ""
"FaÁa alguma aÁ„o a pedido do subsistema CAM. Sim descreve o SIM para o pedido, CCB È "
"o prÛprio pedido. CCB significa <quote> Bloco de Controle CAM </quote> . Ìâ uma uni„o "
"de v·rias instÌ¢ncias especÌ≠ficas, cada uma descrevendo argumentos para algum tipo "
"de transaÁ„o. Todas essas instÌ¢ncias compartilham o cabeÁalho do CCB onde a parte "
"comum dos argumentos È armazenada. "

#: book.translate.xml:19714
#, fuzzy
msgid ""
"CAM supports the SCSI controllers working in both initiator (<quote>normal</quote>) "
"mode and target (simulating a SCSI device) mode. Here we only consider the part "
"relevant to the initiator mode."
msgstr ""
"O CAM suporta os controladores SCSI que funcionam no iniciador ( <quote> normal </"
"quote> ) Modo e modo de destino (simulando um dispositivo SCSI). Aqui nÛs "
"consideramos apenas a parte relevante para o modo iniciador \""

#: book.translate.xml:19719
#, fuzzy
msgid ""
"There are a few function and macros (in other words, methods) defined to access the "
"public data in the struct sim:"
msgstr ""
"Existem algumas funÁÌµes e macros (em outras palavras, mÈtodos) definidas para "
"acessar os dados p˙blicos no struct sim:"

#: book.translate.xml:19725
#, fuzzy
msgid "<function>cam_sim_path(sim)</function> - the path ID (see above)"
msgstr " <function> cam_sim_path (sim) </function> - o ID do caminho (veja acima) "

#: book.translate.xml:19730
#, fuzzy
msgid "<function>cam_sim_name(sim)</function> - the name of the sim"
msgstr " <function> cam_sim_name (sim) </function> - o nome do sim "

#: book.translate.xml:19735
#, fuzzy
msgid ""
"<function>cam_sim_softc(sim)</function> - the pointer to the softc (driver private "
"data) structure"
msgstr ""
" <function> cam_sim_softc (sim) </function> - o ponteiro para a estrutura do softc "
"(driver private data) "

#: book.translate.xml:19740
#, fuzzy
msgid "<function> cam_sim_unit(sim)</function> - the unit number"
msgstr " <function> cam_sim_unit (sim) </function> - o n˙mero da unidade "

#: book.translate.xml:19745
#, fuzzy
msgid "<function> cam_sim_bus(sim)</function> - the bus ID"
msgstr " <function> cam_sim_bus (sim) </function> - o ID do Ì¥nibus "

#: book.translate.xml:19750
#, fuzzy
msgid ""
"To identify the device, <function>xxx_action()</function> can get the unit number "
"and pointer to its structure softc using these functions."
msgstr ""
"Para identificar o dispositivo, <function> xxx_action () </function> pode obter o "
"n˙mero da unidade e o ponteiro para sua estrutura usando essas funÁÌµes. "

#: book.translate.xml:19754
#, fuzzy
msgid ""
"The type of request is stored in <varname remap=\"structfield\">ccb-&gt;ccb_h."
"func_code</varname>. So generally <function>xxx_action()</function> consists of a "
"big switch:"
msgstr ""
"O tipo de solicitaÁ„o È armazenado em <varname remap=\"structfield\"> ccb-&gt; ccb_h."
"func_code </varname> . Ent„o geralmente <function> xxx_action () </function> "
"consiste em um grande interruptor: "

#: book.translate.xml:19773
#, fuzzy
msgid ""
"As can be seen from the default case (if an unknown command was received) the return "
"code of the command is set into <varname remap=\"structfield\">ccb-&gt;ccb_h.status</"
"varname> and the completed CCB is returned back to CAM by calling "
"<function>xpt_done(ccb)</function>."
msgstr ""
"Como pode ser visto a partir do caso padr„o (se um comando desconhecido foi "
"recebido) o cÛdigo de retorno do comando È definido em <varname remap=\"structfield"
"\"> ccb-&gt; ccb_h.status </varname> e o CCB preenchido È devolvido ao CAM, chamando "
"<function> xpt_done (ccb) </function> "

#: book.translate.xml:19779
#, fuzzy
msgid ""
"<function>xpt_done()</function> does not have to be called from "
"<function>xxx_action()</function>: For example an I/O request may be enqueued inside "
"the SIM driver and/or its SCSI controller. Then when the device would post an "
"interrupt signaling that the processing of this request is complete "
"<function>xpt_done()</function> may be called from the interrupt handling routine."
msgstr ""
" <function> xpt_done () </function> n„o precisa ser chamado de <function> xxx_action "
"() </function> Por exemplo, uma solicitaÁ„o de E / S pode ser enfileirada dentro do "
"driver do SIM e / ou seu controlador SCSI. Ent„o, quando o dispositivo postar uma "
"interrupÁ„o, sinalizando que o processamento desta solicitaÁ„o est· completo "
"<function> xpt_done () </function> pode ser chamado a partir da rotina de tratamento "
"de interrupÁÌµes. "

#: book.translate.xml:19787
#, fuzzy
msgid ""
"Actually, the CCB status is not only assigned as a return code but a CCB has some "
"status all the time. Before CCB is passed to the <function>xxx_action()</function> "
"routine it gets the status CCB_REQ_INPROG meaning that it is in progress. There are "
"a surprising number of status values defined in <filename>/sys/cam/cam.h</filename> "
"which should be able to represent the status of a request in great detail. More "
"interesting yet, the status is in fact a <quote>bitwise or</quote> of an enumerated "
"status value (the lower 6 bits) and possible additional flag-like bits (the upper "
"bits). The enumerated values will be discussed later in more detail. The summary of "
"them can be found in the Errors Summary section. The possible status flags are:"
msgstr ""
"Na verdade, o status do CCB n„o È atribuÌ≠do apenas como um cÛdigo de retorno, mas um "
"CCB tem algum status o tempo todo. Antes de o CCB ser passado para o <function> "
"xxx_action () </function> rotina obtÈm o status CCB_REQ_INPROG, o que significa que "
"est· em andamento. H· um n˙mero surpreendente de valores de status definidos em "
"<filename> /sys/cam/cam.h </filename> que deve ser capaz de representar o status de "
"uma solicitaÁ„o em grande detalhe. Mais interessante ainda, o status È de fato um "
"<quote> bit a bit ou </quote> de um valor de status enumerado (os 6 bits inferiores) "
"e possÌ≠veis bits semelhantes a sinalizadores adicionais (os bits superiores). Os "
"valores enumerados ser„o discutidos mais adiante com mais detalhes. O resumo deles "
"pode ser encontrado na seÁ„o Resumo de Erros. Os possÌ≠veis flags de status s„o: "

#: book.translate.xml:19803
#, fuzzy
msgid ""
"<emphasis>CAM_DEV_QFRZN</emphasis> - if the SIM driver gets a serious error (for "
"example, the device does not respond to the selection or breaks the SCSI protocol) "
"when processing a CCB it should freeze the request queue by calling "
"<function>xpt_freeze_simq()</function>, return the other enqueued but not processed "
"yet CCBs for this device back to the CAM queue, then set this flag for the "
"troublesome CCB and call <function>xpt_done()</function>. This flag causes the CAM "
"subsystem to unfreeze the queue after it handles the error."
msgstr ""
" <emphasis> CAM_DEV_QFRZN </emphasis> - se o driver SIM receber um erro grave (por "
"exemplo, o dispositivo n„o responder Ì† seleÁ„o ou quebrar o protocolo SCSI) ao "
"processar um CCB, ele dever· congelar a fila de solicitaÁ„o chamando <function> "
"xpt_freeze_simq () </function> , retorne os outros enfileirados mas n„o processados "
"‚Äã‚Äãainda aos CCBs para este dispositivo de volta para a fila do CAM, defina esse "
"sinalizador para o CCB problem·tico e chame <function> xpt_done () </function> . "
"Esse sinalizador faz com que o subsistema CAM descongele a fila depois que ela "
"manipula o erro. "

#: book.translate.xml:19816
#, fuzzy
msgid ""
"<emphasis>CAM_AUTOSNS_VALID</emphasis> - if the device returned an error condition "
"and the flag CAM_DIS_AUTOSENSE is not set in CCB the SIM driver must execute the "
"REQUEST SENSE command automatically to extract the sense (extended error "
"information) data from the device. If this attempt was successful the sense data "
"should be saved in the CCB and this flag set."
msgstr ""
" <emphasis> CAM_AUTOSNS_VALID </emphasis> - se o dispositivo retornou uma condiÁ„o "
"de erro e o sinalizador CAM_DIS_AUTOSENSE n„o est· definido no CCB, o driver SIM "
"deve executar o comando REQUEST SENSE automaticamente para extrair os dados de "
"sentido (informaÁÌµes de erro estendidas) do dispositivo. Se esta tentativa foi bem "
"sucedida, os dados do sentido devem ser salvos no CCB e este sinalizador definido. "

#: book.translate.xml:19826
#, fuzzy
msgid ""
"<emphasis>CAM_RELEASE_SIMQ</emphasis> - like CAM_DEV_QFRZN but used in case there is "
"some problem (or resource shortage) with the SCSI controller itself. Then all the "
"future requests to the controller should be stopped by <function>xpt_freeze_simq()</"
"function>. The controller queue will be restarted after the SIM driver overcomes the "
"shortage and informs CAM by returning some CCB with this flag set."
msgstr ""
" <emphasis> CAM_RELEASE_SIMQ </emphasis> - como o CAM_DEV_QFRZN mas usado no caso de "
"haver algum problema (ou escassez de recursos) com o prÛprio controlador SCSI. Ent„o "
"todos os pedidos futuros ao controlador devem ser interrompidos por <function> "
"xpt_freeze_simq () </function> . A fila do controlador ser· reiniciada apÛs o driver "
"do SIM superar a falta e informar o CAM retornando algum CCB com este sinalizador "
"definido. "

#: book.translate.xml:19837
#, fuzzy
msgid ""
"<emphasis>CAM_SIM_QUEUED</emphasis> - when SIM puts a CCB into its request queue "
"this flag should be set (and removed when this CCB gets dequeued before being "
"returned back to CAM). This flag is not used anywhere in the CAM code now, so its "
"purpose is purely diagnostic."
msgstr ""
" <emphasis> CAM_SIM_QUEUED </emphasis> - quando o SIM coloca um CCB em sua fila de "
"pedidos, este sinalizador deve ser definido (e removido quando este CCB È retirado "
"da fila antes de ser devolvido ao CAM). Este sinalizador n„o È usado em qualquer "
"lugar no cÛdigo CAM agora, ent„o seu propÛsito È puramente diagnÛstico. "

#: book.translate.xml:19845
#, fuzzy
msgid "<emphasis>CAM_QOS_VALID</emphasis> - The QOS data is now valid."
msgstr " <emphasis> CAM_QOS_VALID </emphasis> - Os dados QOS agora s„o v·lidos. "

#: book.translate.xml:19850
#, fuzzy
msgid ""
"The function <function>xxx_action()</function> is not allowed to sleep, so all the "
"synchronization for resource access must be done using SIM or device queue freezing. "
"Besides the aforementioned flags the CAM subsystem provides functions "
"<function>xpt_release_simq()</function> and <function>xpt_release_devq()</function> "
"to unfreeze the queues directly, without passing a CCB to CAM."
msgstr ""
"A funÁ„o <function> xxx_action () </function> n„o È permitido dormir, portanto, toda "
"a sincronizaÁ„o para acesso ao recurso deve ser feita usando o congelamento da fila "
"do SIM ou do dispositivo. AlÈm das bandeiras acima mencionadas, o subsistema CAM "
"fornece funÁÌµes <function> xpt_release_simq () </function> e <function> "
"xpt_release_devq () </function> para descongelar as filas diretamente, sem passar um "
"CCB para CAM \""

#: book.translate.xml:19858
#, fuzzy
msgid "The CCB header contains the following fields:"
msgstr "O cabeÁalho do CCB contÈm os seguintes campos:"

#: book.translate.xml:19862
#, fuzzy
msgid "<emphasis>path</emphasis> - path ID for the request"
msgstr " <emphasis> caminho </emphasis> - ID do caminho para o pedido "

#: book.translate.xml:19867
#, fuzzy
msgid "<emphasis>target_id</emphasis> - target device ID for the request"
msgstr ""
" <emphasis> target_id </emphasis> - ID do dispositivo de destino para o pedido "

#: book.translate.xml:19872
#, fuzzy
msgid "<emphasis>target_lun</emphasis> - LUN ID of the target device"
msgstr " <emphasis> target_lun </emphasis> - ID do LUN do dispositivo de destino "

#: book.translate.xml:19877
#, fuzzy
msgid ""
"<emphasis>timeout</emphasis> - timeout interval for this command, in milliseconds"
msgstr ""
" <emphasis> tempo esgotado </emphasis> - intervalo de tempo limite para este "
"comando, em milissegundos "

#: book.translate.xml:19882
#, fuzzy
msgid ""
"<emphasis>timeout_ch</emphasis> - a convenience place for the SIM driver to store "
"the timeout handle (the CAM subsystem itself does not make any assumptions about it)"
msgstr ""
" <emphasis> timeout_ch </emphasis> - um local de conveniÍncia para o driver do SIM "
"armazenar o identificador de tempo limite (o prÛprio subsistema CAM n„o faz nenhuma "
"suposiÁ„o sobre ele) "

#: book.translate.xml:19889
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - various bits of information about the request "
"spriv_ptr0, spriv_ptr1 - fields reserved for private use by the SIM driver (such as "
"linking to the SIM queues or SIM private control blocks); actually, they exist as "
"unions: spriv_ptr0 and spriv_ptr1 have the type (void *), spriv_field0 and "
"spriv_field1 have the type unsigned long, sim_priv.entries[0].bytes and sim_priv."
"entries[1].bytes are byte arrays of the size consistent with the other incarnations "
"of the union and sim_priv.bytes is one array, twice bigger."
msgstr ""
" <emphasis> bandeiras </emphasis> - v·rios bits de informaÁ„o sobre o pedido "
"spriv_ptr0, spriv_ptr1 - campos reservados para uso privado pelo driver do SIM (como "
"links para as filas do SIM ou blocos de controle privados do SIM); na verdade, eles "
"existem como unions: spriv_ptr0 e spriv_ptr1 tem o tipo (void *), spriv_field0 e "
"spriv_field1 tem o tipo unsigned long, sim_priv.entries [0] .bytes e sim_priv."
"entries [1] .bytes s„o matrizes de byte do tamanho consistente com as outras "
"encarnaÁÌµes da uni„o e sim_priv.bytes È uma matriz, duas vezes maior \""

#: book.translate.xml:19902
#, fuzzy
msgid ""
"The recommended way of using the SIM private fields of CCB is to define some "
"meaningful names for them and use these meaningful names in the driver, like:"
msgstr ""
"A maneira recomendada de usar os campos privados do SIM do CCB È definir alguns "
"nomes significativos para eles e usar esses nomes significativos no driver, como:"

#: book.translate.xml:19909
#, fuzzy
msgid "The most common initiator mode requests are:"
msgstr "As solicitaÁÌµes de modo de iniciador mais comuns s„o:"

#: book.translate.xml:19913
#, fuzzy
msgid "<emphasis>XPT_SCSI_IO</emphasis> - execute an I/O transaction"
msgstr " <emphasis> XPT_SCSI_IO </emphasis> - executar uma transaÁ„o de E / S "

#: book.translate.xml:19916
#, fuzzy
msgid ""
"The instance <quote>struct ccb_scsiio csio</quote> of the union ccb is used to "
"transfer the arguments. They are:"
msgstr ""
"A instÌ¢ncia <quote> struct ccb_scsiio csio </quote> da uni„o ccb È usado para "
"transferir os argumentos. Eles s„o:"

#: book.translate.xml:19922
#, fuzzy
msgid ""
"<emphasis>cdb_io</emphasis> - pointer to the SCSI command buffer or the buffer itself"
msgstr ""
" <emphasis> cdb_io </emphasis> - ponteiro para o buffer de comando SCSI ou o prÛprio "
"buffer "

#: book.translate.xml:19927
#, fuzzy
msgid "<emphasis>cdb_len</emphasis> - SCSI command length"
msgstr " <emphasis> cdb_len </emphasis> - comprimento do comando SCSI "

#: book.translate.xml:19932
#, fuzzy
msgid ""
"<emphasis>data_ptr</emphasis> - pointer to the data buffer (gets a bit complicated "
"if scatter/gather is used)"
msgstr ""
" <emphasis> data_ptr </emphasis> - ponteiro para o buffer de dados (fica um pouco "
"complicado se scatter / gather for usado) "

#: book.translate.xml:19938
#, fuzzy
msgid "<emphasis>dxfer_len</emphasis> - length of the data to transfer"
msgstr " <emphasis> dxfer_len </emphasis> - comprimento dos dados a transferir "

#: book.translate.xml:19943
#, fuzzy
msgid "<emphasis>sglist_cnt</emphasis> - counter of the scatter/gather segments"
msgstr " <emphasis> sglist_cnt </emphasis> - contador dos segmentos scatter / gather "

#: book.translate.xml:19948
#, fuzzy
msgid "<emphasis>scsi_status</emphasis> - place to return the SCSI status"
msgstr " <emphasis> scsi_status </emphasis> - local para retornar o status SCSI "

#: book.translate.xml:19953
#, fuzzy
msgid ""
"<emphasis>sense_data</emphasis> - buffer for the SCSI sense information if the "
"command returns an error (the SIM driver is supposed to run the REQUEST SENSE "
"command automatically in this case if the CCB flag CAM_DIS_AUTOSENSE is not set)"
msgstr ""
" <emphasis> sense_data </emphasis> - buffer para as informaÁÌµes do sentido SCSI, se "
"o comando retornar um erro (o driver SIM dever· executar o comando REQUEST SENSE "
"automaticamente, neste caso, se o sinalizador do CCB CAM_DIS_AUTOSENSE n„o estiver "
"definido) "

#: book.translate.xml:19961
#, fuzzy
msgid ""
"<emphasis>sense_len</emphasis> - the length of that buffer (if it happens to be "
"higher than size of sense_data the SIM driver must silently assume the smaller "
"value) resid, sense_resid - if the transfer of data or SCSI sense returned an error "
"these are the returned counters of the residual (not transferred) data. They do not "
"seem to be especially meaningful, so in a case when they are difficult to compute "
"(say, counting bytes in the SCSI controller's FIFO buffer) an approximate value will "
"do as well. For a successfully completed transfer they must be set to zero."
msgstr ""
" <emphasis> sense_len </emphasis> - o comprimento desse buffer (se for maior que o "
"tamanho de sense_data que o driver do SIM deve assumir silenciosamente o valor "
"menor) resid, sense_resid - se a transferÍncia de dados ou o sentido SCSI retornar "
"um erro, esses s„o os contadores retornados do valor residual. dados (n„o "
"transferidos). Eles n„o parecem ser especialmente significativos, portanto, em um "
"caso em que È difÌ≠cil computar (digamos, contar bytes no buffer FIFO do controlador "
"SCSI), um valor aproximado tambÈm funcionar·. Para uma transferÍncia concluÌ≠da com "
"sucesso, eles devem ser definidos como zero. "

#: book.translate.xml:19976
#, fuzzy
msgid "<emphasis>tag_action</emphasis> - the kind of tag to use:"
msgstr " <emphasis> tag_action </emphasis> - o tipo de tag a usar: "

#: book.translate.xml:19981
#, fuzzy
msgid "CAM_TAG_ACTION_NONE - do not use tags for this transaction"
msgstr "CAM_TAG_ACTION_NONE - n„o use tags para esta transaÁ„o"

#: book.translate.xml:19986
#, fuzzy
msgid ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - value equal to the "
"appropriate tag message (see /sys/cam/scsi/scsi_message.h); this gives only the tag "
"type, the SIM driver must assign the tag value itself"
msgstr ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - valor igual Ì† mensagem de "
"tag apropriada (consulte /sys/cam/scsi/scsi_message.h); isso fornece apenas o tipo "
"de tag, o driver do SIM deve atribuir o prÛprio valor de tag"

#: book.translate.xml:19996
#, fuzzy
msgid "The general logic of handling this request is the following:"
msgstr "A lÛgica geral de lidar com essa solicitaÁ„o È a seguinte:"

#: book.translate.xml:19999
#, fuzzy
msgid ""
"The first thing to do is to check for possible races, to make sure that the command "
"did not get aborted when it was sitting in the queue:"
msgstr ""
"A primeira coisa a fazer È verificar possÌ≠veis corridas, para garantir que o comando "
"n„o seja abortado quando estiver na fila:"

#: book.translate.xml:20010
#, fuzzy
msgid "Also we check that the device is supported at all by our controller:"
msgstr "TambÈm verificamos se o dispositivo È suportado pelo nosso controlador:"

#: book.translate.xml:20027
#, fuzzy
msgid "<primary>hardware control block</primary>"
msgstr " <primary> bloco de controle de hardware </primary> "

#: book.translate.xml:20025
#, fuzzy
msgid ""
"Then allocate whatever data structures (such as card-dependent hardware control "
"block<_:indexterm-1/>) we need to process this request. If we can not then freeze "
"the SIM queue and remember that we have a pending operation, return the CCB back and "
"ask CAM to re-queue it. Later when the resources become available the SIM queue must "
"be unfrozen by returning a ccb with the <literal>CAM_SIMQ_RELEASE</literal> bit set "
"in its status. Otherwise, if all went well, link the CCB with the hardware control "
"block (HCB) and mark it as queued."
msgstr ""
"Ent„o aloque quaisquer estruturas de dados (como o bloco de controle de hardware "
"dependente de cart„o <_: indexterm-1 />) que precisamos processar esta requisiÁ„o. "
"Se n„o pudermos, congelar a fila do SIM e lembrar que temos uma operaÁ„o pendente, "
"retornar o CCB de volta e peÁa ao CAM para reenvi·-lo. Mais tarde, quando os "
"recursos estiverem disponÌ≠veis, a fila do SIM deve ser descongelada retornando um "
"ccb com o <literal> CAM_SIMQ_RELEASE </literal> bit definido em seu status. Caso "
"contr·rio, se tudo correr bem, vincule o CCB ao bloco de controle de hardware (HCB) "
"e marque-o como na fila. "

#: book.translate.xml:20051
#, fuzzy
msgid ""
"Extract the target data from CCB into the hardware control block. Check if we are "
"asked to assign a tag and if yes then generate an unique tag and build the SCSI tag "
"messages. The SIM driver is also responsible for negotiations with the devices to "
"set the maximal mutually supported bus width, synchronous rate and offset."
msgstr ""
"Extraia os dados de destino do CCB no bloco de controle de hardware. Verifique se "
"somos solicitados a atribuir uma tag e, se sim, gerar uma tag ˙nica e criar as "
"mensagens de tag SCSI. O driver do SIM tambÈm È respons·vel pelas negociaÁÌµes com "
"os dispositivos a serem definidos a largura de barramento m·xima mutuamente "
"suportada, a taxa sÌ≠ncrona e o deslocamento \""

#: book.translate.xml:20065
#, fuzzy
msgid ""
"Then set up the SCSI command. The command storage may be specified in the CCB in "
"many interesting ways, specified by the CCB flags. The command buffer can be "
"contained in CCB or pointed to, in the latter case the pointer may be physical or "
"virtual. Since the hardware commonly needs physical address we always convert the "
"address to the physical one, typically using the busdma API."
msgstr ""
"Em seguida, configure o comando SCSI. O armazenamento de comando pode ser "
"especificado no CCB de muitas maneiras interessantes, especificado pelos "
"sinalizadores do CCB. O buffer de comando pode estar contido no CCB ou apontado, no "
"˙ltimo caso, o ponteiro pode ser fÌ≠sico ou Como o hardware normalmente precisa de "
"endereÁo fÌ≠sico, sempre convertemos o endereÁo para o fÌ≠sico, geralmente usando a "
"API busdma. "

#: book.translate.xml:20073
#, fuzzy
msgid ""
"In case if a physical address is requested it is OK to return the CCB with the "
"status <errorname>CAM_REQ_INVALID</errorname>, the current drivers do that. If "
"necessary a physical address can be also converted or mapped back to a virtual "
"address but with big pain, so we do not do that."
msgstr ""
"No caso de um endereÁo fÌ≠sico ser solicitado, È OK retornar o CCB com o status "
"<errorname> CAM_REQ_INVALID </errorname> , os drivers atuais fazem isso. Se "
"necess·rio, um endereÁo fÌ≠sico tambÈm pode ser convertido ou mapeado de volta para "
"um endereÁo virtual, mas com grande dificuldade, por isso n„o fazemos isso. "

#: book.translate.xml:20095
#, fuzzy
msgid ""
"Now it is time to set up the data. Again, the data storage may be specified in the "
"CCB in many interesting ways, specified by the CCB flags. First we get the direction "
"of the data transfer. The simplest case is if there is no data to transfer:"
msgstr ""
"Agora È hora de configurar os dados. Novamente, o armazenamento de dados pode ser "
"especificado no CCB de muitas maneiras interessantes, especificado pelos "
"sinalizadores do CCB. Primeiro, obtemos a direÁ„o da transferÍncia de dados. O caso "
"mais simples È se houver nenhum dado para transferir: "

#: book.translate.xml:20106
#, fuzzy
msgid ""
"Then we check if the data is in one chunk or in a scatter-gather list, and the "
"addresses are physical or virtual. The SCSI controller may be able to handle only a "
"limited number of chunks of limited length. If the request hits this limitation we "
"return an error. We use a special function to return the CCB to handle in one place "
"the HCB resource shortages. The functions to add chunks are driver-dependent, and "
"here we leave them without detailed implementation. See description of the SCSI "
"command (CDB) handling for the details on the address-translation issues. If some "
"variation is too difficult or impossible to implement with a particular card it is "
"OK to return the status <errorname>CAM_REQ_INVALID</errorname>. Actually, it seems "
"like the scatter-gather ability is not used anywhere in the CAM code now. But at "
"least the case for a single non-scattered virtual buffer must be implemented, it is "
"actively used by CAM."
msgstr ""
"Em seguida, verificamos se os dados est„o em um fragmento ou em uma lista de "
"dispers„o-coleta, e os endereÁos s„o fÌ≠sicos ou virtuais. O controlador SCSI pode "
"manipular apenas um n˙mero limitado de fragmentos de tamanho limitado. Se a "
"solicitaÁ„o atingir esse limitaÁ„o nÛs retornamos um erro.NÛs usamos uma funÁ„o "
"especial para retornar o CCB para lidar em um lugar a escassez de recursos HCB.As "
"funÁÌµes para adicionar pedaÁos s„o dependentes do driver, e aqui nÛs deix·-los sem "
"implementaÁ„o detalhada.Veja a descriÁ„o do comando SCSI (CDB) tratando dos detalhes "
"sobre os problemas de traduÁ„o de endereÁos.Se alguma variaÁ„o for muito difÌ≠cil ou "
"impossÌ≠vel de implementar com um cart„o especÌ≠fico, n„o h· problema em retornar o "
"status <errorname> CAM_REQ_INVALID </errorname> . Na verdade, parece que a "
"habilidade de espalhar-reunir n„o È usada em nenhum lugar no cÛdigo CAM agora. Mas "
"pelo menos o caso de um ˙nico buffer virtual n„o disperso deve ser implementado, ele "
"È usado ativamente pelo CAM. "

#: book.translate.xml:20173
#, fuzzy
msgid "If disconnection is disabled for this CCB we pass this information to the hcb:"
msgstr ""
"Se a desconex„o estiver desativada para este CCB, nÛs passamos esta informaÁ„o para "
"o hcb:"

#: book.translate.xml:20179
#, fuzzy
msgid ""
"If the controller is able to run REQUEST SENSE command all by itself then the value "
"of the flag CAM_DIS_AUTOSENSE should also be passed to it, to prevent automatic "
"REQUEST SENSE if the CAM subsystem does not want it."
msgstr ""
"Se o controlador puder executar o comando REQUEST SENSE sozinho, o valor do "
"sinalizador CAM_DIS_AUTOSENSE tambÈm dever· ser passado para ele, para evitar o "
"REQUEST SENSE autom·tico se o subsistema CAM n„o o quiser."

#: book.translate.xml:20184
#, fuzzy
msgid ""
"The only thing left is to set up the timeout, pass our hcb to the hardware and "
"return, the rest will be done by the interrupt handler (or timeout handler)."
msgstr ""
"A ˙nica coisa que resta È configurar o tempo limite, passar o nosso hcb para o "
"hardware e retornar, o resto ser· feito pelo manipulador de interrupÁ„o (ou "
"manipulador de tempo limite)."

#: book.translate.xml:20193
#, fuzzy
msgid "And here is a possible implementation of the function returning CCB:"
msgstr "E aqui est· uma implementaÁ„o possÌ≠vel da funÁ„o que retorna o CCB:"

#: book.translate.xml:20218
#, fuzzy
msgid ""
"<emphasis>XPT_RESET_DEV</emphasis> - send the SCSI <quote>BUS DEVICE RESET</quote> "
"message to a device"
msgstr ""
" <emphasis> XPT_RESET_DEV </emphasis> - enviar o SCSI <quote> REDUÌáÌÉO DO DISPOSITIVO "
"DE BARRAMENTO </quote> mensagem para um dispositivo "

#: book.translate.xml:20221
#, fuzzy
msgid ""
"There is no data transferred in CCB except the header and the most interesting "
"argument of it is target_id. Depending on the controller hardware a hardware control "
"block just like for the XPT_SCSI_IO request may be constructed (see XPT_SCSI_IO "
"request description) and sent to the controller or the SCSI controller may be "
"immediately programmed to send this RESET message to the device or this request may "
"be just not supported (and return the status <errorname>CAM_REQ_INVALID</"
"errorname>). Also on completion of the request all the disconnected transactions for "
"this target must be aborted (probably in the interrupt routine)."
msgstr ""
"N„o h· dados transferidos no CCB, exceto o cabeÁalho e o argumento mais interessante "
"dele È target_id. Dependendo do hardware do controlador, um bloco de controle de "
"hardware como para o pedido XPT_SCSI_IO pode ser construÌ≠do (ver descriÁ„o da "
"solicitaÁ„o XPT_SCSI_IO) e enviado ao controlador ou o controlador SCSI pode ser "
"programado imediatamente para enviar esta mensagem RESET para o dispositivo ou esta "
"solicitaÁ„o pode n„o ser suportada (e retornar o status <errorname> CAM_REQ_INVALID "
"</errorname> ). TambÈm na conclus„o da solicitaÁ„o, todas as transaÁÌµes "
"desconectadas para este destino devem ser abortadas (provavelmente na rotina de "
"interrupÁ„o). "

#: book.translate.xml:20234
#, fuzzy
msgid ""
"Also all the current negotiations for the target are lost on reset, so they might be "
"cleaned too. Or they clearing may be deferred, because anyway the target would "
"request re-negotiation on the next transaction."
msgstr ""
"AlÈm disso, todas as negociaÁÌµes atuais para a meta s„o perdidas na redefiniÁ„o, "
"para que possam ser limpas tambÈm. Ou a compensaÁ„o pode ser adiada, porque, de "
"qualquer maneira, a meta solicitaria a renegociaÁ„o na prÛxima transaÁ„o."

#: book.translate.xml:20242
#, fuzzy
msgid "<emphasis>XPT_RESET_BUS</emphasis> - send the RESET signal to the SCSI bus"
msgstr ""
" <emphasis> XPT_RESET_BUS </emphasis> - envie o sinal RESET para o barramento SCSI "

#: book.translate.xml:20245
#, fuzzy
msgid ""
"No arguments are passed in the CCB, the only interesting argument is the SCSI bus "
"indicated by the struct sim pointer."
msgstr ""
"Nenhum argumento È passado no CCB, o ˙nico argumento interessante È o barramento "
"SCSI indicado pelo ponteiro struct sim."

#: book.translate.xml:20249
#, fuzzy
msgid ""
"A minimalistic implementation would forget the SCSI negotiations for all the devices "
"on the bus and return the status CAM_REQ_CMP."
msgstr ""
"Uma implementaÁ„o minimalista esqueceria as negociaÁÌµes do SCSI para todos os "
"dispositivos no barramento e retornaria o status CAM_REQ_CMP."

#: book.translate.xml:20253
#, fuzzy
msgid ""
"The proper implementation would in addition actually reset the SCSI bus (possible "
"also reset the SCSI controller) and mark all the CCBs being processed, both those in "
"the hardware queue and those being disconnected, as done with the status "
"CAM_SCSI_BUS_RESET. Like:"
msgstr ""
"A implementaÁ„o adequada, alÈm disso, realmente redefinir o barramento SCSI (possÌ≠"
"vel tambÈm redefinir o controlador SCSI) e marcar todos os CCBs sendo processados, "
"tanto aqueles na fila de hardware quanto aqueles desconectados, como feito com o "
"status CAM_SCSI_BUS_RESET. Como:"

#: book.translate.xml:20308
#, fuzzy
msgid ""
"Implementing the SCSI bus reset as a function may be a good idea because it would be "
"re-used by the timeout function as a last resort if the things go wrong."
msgstr ""
"Implementar a reinicializaÁ„o do barramento SCSI como uma funÁ„o pode ser uma boa "
"idÈia, porque ela seria reutilizada pela funÁ„o de tempo limite como ˙ltimo recurso "
"se as coisas derem errado."

#: book.translate.xml:20315
#, fuzzy
msgid "<emphasis>XPT_ABORT</emphasis> - abort the specified CCB"
msgstr " <emphasis> XPT_ABORT </emphasis> - abortar o CCB especificad"

#: book.translate.xml:20318
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct ccb_abort cab</quote> of "
"the union ccb. The only argument field in it is:"
msgstr ""
"Os argumentos s„o transferidos na instÌ¢ncia <quote> t·xi do struct ccb_abort </"
"quote> da uni„o ccb. O ˙nico campo de argumento È: "

#: book.translate.xml:20322
#, fuzzy
msgid "<emphasis>abort_ccb</emphasis> - pointer to the CCB to be aborted"
msgstr " <emphasis> abort_ccb </emphasis> - apontador para o CCB ser abortado "

#: book.translate.xml:20325
#, fuzzy
msgid ""
"If the abort is not supported just return the status CAM_UA_ABORT. This is also the "
"easy way to minimally implement this call, return CAM_UA_ABORT in any case."
msgstr ""
"Se o cancelamento n„o for suportado, apenas retorne o status CAM_UA_ABORT. Esta È "
"tambÈm a maneira mais f·cil de implementar minimamente esta chamada, retornando "
"CAM_UA_ABORT em qualquer caso."

#: book.translate.xml:20329
#, fuzzy
msgid ""
"The hard way is to implement this request honestly. First check that abort applies "
"to a SCSI transaction:"
msgstr ""
"A maneira mais difÌ≠cil È implementar essa solicitaÁ„o com honestidade. Primeiro, "
"verifique se a anulaÁ„o se aplica a uma transaÁ„o SCSI:"

#: book.translate.xml:20341
#, fuzzy
msgid ""
"Then it is necessary to find this CCB in our queue. This can be done by walking the "
"list of all our hardware control blocks in search for one associated with this CCB:"
msgstr ""
"Ent„o È necess·rio encontrar este CCB em nossa fila. Isso pode ser feito andando a "
"lista de todos os nossos blocos de controle de hardware em busca de um associado a "
"este CCB:"

#: book.translate.xml:20370
#, fuzzy
msgid ""
"Now we look at the current processing status of the HCB. It may be either sitting in "
"the queue waiting to be sent to the SCSI bus, being transferred right now, or "
"disconnected and waiting for the result of the command, or actually completed by "
"hardware but not yet marked as done by software. To make sure that we do not get in "
"any races with hardware we mark the HCB as being aborted, so that if this HCB is "
"about to be sent to the SCSI bus the SCSI controller will see this flag and skip it."
msgstr ""
"Agora olhamos para o status atual do processamento do HCB. Ele pode estar na fila "
"esperando para ser enviado para o barramento SCSI, sendo transferido agora ou "
"desconectado e aguardando o resultado do comando, ou realmente concluÌ≠do por "
"hardware, mas ainda n„o marcado como feito por software.Para ter certeza de que n„o "
"entraremos em nenhuma corrida com hardware, marcaremos o HCB como sendo abortado, de "
"modo que, se esse HCB estiver prestes a ser enviado para o barramento SCSI, o "
"controlador SCSI ver· esta bandeira e pule-a. "

#: book.translate.xml:20399
#, fuzzy
msgid ""
"If the CCB is being transferred right now we would like to signal to the SCSI "
"controller in some hardware-dependent way that we want to abort the current "
"transfer. The SCSI controller would set the SCSI ATTENTION signal and when the "
"target responds to it send an ABORT message. We also reset the timeout to make sure "
"that the target is not sleeping forever. If the command would not get aborted in "
"some reasonable time like 10 seconds the timeout routine would go ahead and reset "
"the whole SCSI bus. Because the command will be aborted in some reasonable time we "
"can just return the abort request now as successfully completed, and mark the "
"aborted CCB as aborted (but not mark it as done yet)."
msgstr ""
"Se o CCB est· sendo transferido agora, gostarÌ≠amos de sinalizar para o controlador "
"SCSI de alguma maneira dependente de hardware que queremos abortar a transferÍncia "
"atual. O controlador SCSI configuraria o sinal SCSI ATTENTION e quando o destino "
"responder a ele, enviarÌ≠amos uma mensagem ABORT.NÛs tambÈm redefinimos o tempo "
"limite para ter certeza de que o alvo n„o est· dormindo para sempre.Se o comando n„o "
"fosse abortado em algum tempo razo·vel como 10 segundos, a rotina de tempo limite "
"iria adiante e reinicializaria todo o barramento SCSI. ser· abortado em algum tempo "
"razo·vel, podemos simplesmente retornar a requisiÁ„o abortar agora como concluÌ≠da "
"com sucesso, e marcar o CCB abortado como abortado (mas n„o marc·-lo como feito "
"ainda). "

#: book.translate.xml:20429
#, fuzzy
msgid ""
"If the CCB is in the list of disconnected then set it up as an abort request and re-"
"queue it at the front of hardware queue. Reset the timeout and report the abort "
"request to be completed."
msgstr ""
"Se o CCB estiver na lista de desconectados, configure-o como uma solicitaÁ„o de "
"interrupÁ„o e enfileire-o novamente na frente da fila de hardware. Redefina o tempo "
"limite e informe a solicitaÁ„o de interrupÁ„o a ser concluÌ≠da."

#: book.translate.xml:20446
#, fuzzy
msgid ""
"That is all for the ABORT request, although there is one more issue. Because the "
"ABORT message cleans all the ongoing transactions on a LUN we have to mark all the "
"other active transactions on this LUN as aborted. That should be done in the "
"interrupt routine, after the transaction gets aborted."
msgstr ""
"Isso È tudo para o pedido ABORT, embora haja mais um problema. Como a mensagem ABORT "
"limpa todas as transaÁÌµes em andamento em um LUN, temos que marcar todas as outras "
"transaÁÌµes ativas neste LUN como abortadas. Isso deve ser feito na interrupÁ„o "
"rotina, apÛs a transaÁ„o ser anulada. "

#: book.translate.xml:20453
#, fuzzy
msgid ""
"Implementing the CCB abort as a function may be quite a good idea, this function can "
"be re-used if an I/O transaction times out. The only difference would be that the "
"timed out transaction would return the status CAM_CMD_TIMEOUT for the timed out "
"request. Then the case XPT_ABORT would be small, like that:"
msgstr ""
"Implementar o cancelamento do CCB como uma funÁ„o pode ser uma boa idÈia, essa "
"funÁ„o pode ser reutilizada se uma transaÁ„o de E / S atingir o tempo limite. A "
"˙nica diferenÁa seria que a transaÁ„o expirada retornaria o status CAM_CMD_TIMEOUT "
"para o tempo limite esgotado. Ent„o, o caso XPT_ABORT seria pequeno, assim: "

#: book.translate.xml:20479
#, fuzzy
msgid ""
"<emphasis>XPT_SET_TRAN_SETTINGS</emphasis> - explicitly set values of SCSI transfer "
"settings"
msgstr ""
" <emphasis> XPT_SET_TRAN_SETTINGS </emphasis> - definir explicitamente valores de "
"configuraÁÌµes de transferÍncia SCSI "

#: book.translate.xml:20482
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct ccb_trans_setting cts</"
"quote> of the union ccb:"
msgstr ""
"Os argumentos s„o transferidos na instÌ¢ncia <quote> struct ccb_trans_setting cts </"
"quote> da uni„o ccb: "

#: book.translate.xml:20488
#, fuzzy
msgid ""
"<emphasis>valid</emphasis> - a bitmask showing which settings should be updated:"
msgstr ""
" <emphasis> v·lido </emphasis> - uma bitmask mostrando quais configuraÁÌµes devem "
"ser atualizadas: "

#: book.translate.xml:20493
#, fuzzy
msgid "<emphasis>CCB_TRANS_SYNC_RATE_VALID</emphasis> - synchronous transfer rate"
msgstr ""
" <emphasis> CCB_TRANS_SYNC_RATE_VALID </emphasis> - taxa de transferÍncia sÌ≠ncrona "

#: book.translate.xml:20498
#, fuzzy
msgid "<emphasis>CCB_TRANS_SYNC_OFFSET_VALID</emphasis> - synchronous offset"
msgstr " <emphasis> CCB_TRANS_SYNC_OFFSET_VALID </emphasis> - deslocamento sÌ≠ncrono "

#: book.translate.xml:20503
#, fuzzy
msgid "<emphasis>CCB_TRANS_BUS_WIDTH_VALID</emphasis> - bus width"
msgstr " <emphasis> CCB_TRANS_BUS_WIDTH_VALID </emphasis> - largura do Ì¥nibus"

#: book.translate.xml:20508
#, fuzzy
msgid "<emphasis>CCB_TRANS_DISC_VALID</emphasis> - set enable/disable disconnection"
msgstr ""
" <emphasis> CCB_TRANS_DISC_VALID </emphasis> - definir ativar / desativar a "
"desconex„o "

#: book.translate.xml:20513
#, fuzzy
msgid "<emphasis>CCB_TRANS_TQ_VALID</emphasis> - set enable/disable tagged queuing"
msgstr ""
" <emphasis> CCB_TRANS_TQ_VALID </emphasis> - definir ativar / desativar "
"enfileiramento marcado "

#: book.translate.xml:20518
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - consists of two parts, binary arguments and "
"identification of sub-operations. The binary arguments are:"
msgstr ""
" <emphasis> bandeiras </emphasis> - consiste em duas partes, argumentos bin·rios e "
"identificaÁ„o de suboperaÁÌµes. Os argumentos bin·rios s„o: "

#: book.translate.xml:20524
#, fuzzy
msgid "<emphasis>CCB_TRANS_DISC_ENB</emphasis> - enable disconnection"
msgstr " <emphasis> CCB_TRANS_DISC_ENB </emphasis> - habilitar a desconex„o "

#: book.translate.xml:20529
#, fuzzy
msgid "<emphasis>CCB_TRANS_TAG_ENB</emphasis> - enable tagged queuing"
msgstr " <emphasis> CCB_TRANS_TAG_ENB </emphasis> - ativar enfileiramento marcado "

#: book.translate.xml:20536
#, fuzzy
msgid "the sub-operations are:"
msgstr "as suboperaÁÌµes s„o:"

#: book.translate.xml:20540
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_CURRENT_SETTINGS</emphasis> - change the current negotiations"
msgstr ""
" <emphasis> CCB_TRANS_CURRENT_SETTINGS </emphasis> - mudar as negociaÁÌµes atuais "

#: book.translate.xml:20545
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_USER_SETTINGS</emphasis> - remember the desired user values "
"sync_period, sync_offset - self-explanatory, if sync_offset==0 then the asynchronous "
"mode is requested bus_width - bus width, in bits (not bytes)"
msgstr ""
" <emphasis> CCB_TRANS_USER_SETTINGS </emphasis> - lembre-se dos valores de usu·rio "
"desejados sync_period, sync_offset - autoexplicativos, se sync_offset == 0 ent„o o "
"modo assÌ≠ncrono È solicitado bus_width - largura do barramento, em bits (n„o bytes) "

#: book.translate.xml:20555
#, fuzzy
msgid ""
"Two sets of negotiated parameters are supported, the user settings and the current "
"settings. The user settings are not really used much in the SIM drivers, this is "
"mostly just a piece of memory where the upper levels can store (and later recall) "
"its ideas about the parameters. Setting the user parameters does not cause re-"
"negotiation of the transfer rates. But when the SCSI controller does a negotiation "
"it must never set the values higher than the user parameters, so it is essentially "
"the top boundary."
msgstr ""
"Dois conjuntos de parÌ¢metros negociados s„o suportados, as configuraÁÌµes do "
"usu·rio e as configuraÁÌµes atuais. As configuraÁÌµes do usu·rio n„o s„o muito "
"usadas nos drivers do SIM, isso È apenas uma parte da memÛria onde os nÌ≠veis "
"superiores podem armazenar (e mais tarde chamar) idÈias sobre os parÌ¢metros. "
"Definir os parÌ¢metros do usu·rio n„o causa renegociaÁ„o das taxas de transferÍncia. "
"Mas quando o controlador SCSI faz uma negociaÁ„o, ele nunca deve definir os valores "
"mais altos que os parÌ¢metros do usu·rio, portanto, È essencialmente o limite "
"superior. "

#: book.translate.xml:20566
#, fuzzy
msgid ""
"The current settings are, as the name says, current. Changing them means that the "
"parameters must be re-negotiated on the next transfer. Again, these <quote>new "
"current settings</quote> are not supposed to be forced on the device, just they are "
"used as the initial step of negotiations. Also they must be limited by actual "
"capabilities of the SCSI controller: for example, if the SCSI controller has 8-bit "
"bus and the request asks to set 16-bit wide transfers this parameter must be "
"silently truncated to 8-bit transfers before sending it to the device."
msgstr ""
"As configuraÁÌµes atuais s„o, como o nome diz, atuais. Alter·-las significa que os "
"parÌ¢metros devem ser renegociados na prÛxima transferÍncia. Novamente, esses "
"<quote> novas configuraÁÌµes atuais </quote> N„o È suposto ser forÁado no "
"dispositivo, apenas eles s„o usados ‚Äã‚Äãcomo o passo inicial das negociaÁÌµes. AlÈm "
"disso, eles devem ser limitados pelos recursos reais do controlador SCSI: por "
"exemplo, se o controlador SCSI tiver um barramento de 8 bits e a solicitaÁ„o "
"solicitar a configuraÁ„o de transferÍncias de 16 bits, esse parÌ¢metro deve ser "
"silenciosamente truncado para transferÍncias de 8 bits antes de envi·-lo para o "
"dispositivo. "

#: book.translate.xml:20578
#, fuzzy
msgid ""
"One caveat is that the bus width and synchronous parameters are per target while the "
"disconnection and tag enabling parameters are per lun."
msgstr ""
"Uma ressalva È que a largura do barramento e os parÌ¢metros sÌ≠ncronos s„o por alvo "
"enquanto os parÌ¢metros de habilitaÁ„o de desconex„o e tag s„o por lun."

#: book.translate.xml:20582
#, fuzzy
msgid ""
"The recommended implementation is to keep 3 sets of negotiated (bus width and "
"synchronous transfer) parameters:"
msgstr ""
"A implementaÁ„o recomendada È manter 3 conjuntos de parÌ¢metros negociados (largura "
"de barramento e transferÍncia sÌ≠ncrona):"

#: book.translate.xml:20588
#, fuzzy
msgid "<emphasis>user</emphasis> - the user set, as above"
msgstr " <emphasis> do utilizador </emphasis> - o usu·rio definido, como acima "

#: book.translate.xml:20593
#, fuzzy
msgid "<emphasis>current</emphasis> - those actually in effect"
msgstr " <emphasis> atual </emphasis> - aqueles realmente em vigor "

#: book.translate.xml:20598
#, fuzzy
msgid ""
"<emphasis>goal</emphasis> - those requested by setting of the <quote>current</quote> "
"parameters"
msgstr ""
" <emphasis> objetivo </emphasis> - os pedidos pela fixaÁ„o do <quote> atual </quote> "
"parÌ¢metros "

#: book.translate.xml:20604
#, fuzzy
msgid "The code looks like:"
msgstr "O cÛdigo parece:"

#: book.translate.xml:20654
#, fuzzy
msgid ""
"Then when the next I/O request will be processed it will check if it has to re-"
"negotiate, for example by calling the function target_negotiated(hcb). It can be "
"implemented like this:"
msgstr ""
"Ent„o, quando a prÛxima requisiÁ„o de I / O for processada, ela verificar· se ela "
"precisa renegociar, por exemplo, chamando a funÁ„o target_negotiated (hcb). Ela pode "
"ser implementada assim:"

#: book.translate.xml:20673
#, fuzzy
msgid ""
"After the values are re-negotiated the resulting values must be assigned to both "
"current and goal parameters, so for future I/O transactions the current and goal "
"parameters would be the same and <function>target_negotiated()</function> would "
"return TRUE. When the card is initialized (in <function>xxx_attach()</function>) the "
"current negotiation values must be initialized to narrow asynchronous mode, the goal "
"and current values must be initialized to the maximal values supported by controller."
msgstr ""
"Depois que os valores s„o renegociados, os valores resultantes devem ser atribuÌ≠dos "
"aos parÌ¢metros atuais e de meta, portanto, para futuras transaÁÌµes de E / S, os "
"parÌ¢metros atuais e de meta seriam os mesmos e <function> target_negotiated () </"
"function> retornaria TRUE. Quando o cart„o È inicializado (em <function> xxx_attach "
"() </function> ) os valores de negociaÁ„o atuais devem ser inicializados para "
"restringir o modo assÌ≠ncrono, a meta e os valores atuais devem ser inicializados "
"para os valores m·ximos suportados pelo controlador. "

#: book.translate.xml:20684
#, fuzzy
msgid ""
"<emphasis>XPT_GET_TRAN_SETTINGS</emphasis> - get values of SCSI transfer settings"
msgstr ""
" <emphasis> XPT_GET_TRAN_SETTINGS </emphasis> - obter valores de configuraÁÌµes de "
"transferÍncia SCSI "

#: book.translate.xml:20687
#, fuzzy
msgid ""
"This operations is the reverse of XPT_SET_TRAN_SETTINGS. Fill up the CCB instance "
"<quote>struct ccb_trans_setting cts</quote> with data as requested by the flags "
"CCB_TRANS_CURRENT_SETTINGS or CCB_TRANS_USER_SETTINGS (if both are set then the "
"existing drivers return the current settings). Set all the bits in the valid field."
msgstr ""
"Esta operaÁ„o È o contr·rio de XPT_SET_TRAN_SETTINGS. Preencha a instÌ¢ncia do CCB "
"<quote> struct ccb_trans_setting cts </quote> com dados conforme solicitado pelos "
"sinalizadores CCB_TRANS_CURRENT_SETTINGS ou CCB_TRANS_USER_SETTINGS (se ambos "
"estiverem configurados, os drivers existentes retornar„o as configuraÁÌµes atuais). "
"Defina todos os bits no campo v·lido. "

#: book.translate.xml:20695
#, fuzzy
msgid ""
"<emphasis>XPT_CALC_GEOMETRY</emphasis> - calculate logical (BIOS)<_:indexterm-1/> "
"geometry of the disk"
msgstr ""
" <emphasis> XPT_CALC_GEOMETRY </emphasis> - calcular lÛgica (BIOS) <_: indexterm-1 /"
"> geometria do disco "

#: book.translate.xml:20699
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct ccb_calc_geometry ccg</"
"quote> of the union ccb:"
msgstr ""
"Os argumentos s„o transferidos na instÌ¢ncia <quote> struct ccb_calc_geometry ccg </"
"quote> da uni„o ccb: "

#: book.translate.xml:20706
#, fuzzy
msgid "<emphasis>block_size</emphasis> - input, block (A.K.A sector) size in bytes"
msgstr ""
" <emphasis> tamanho do bloco </emphasis> - entrada, bloco (setor AKA) tamanho em "
"bytes "

#: book.translate.xml:20711
#, fuzzy
msgid "<emphasis>volume_size</emphasis> - input, volume size in bytes"
msgstr " <emphasis> volume_size </emphasis> - entrada, tamanho do volume em bytes "

#: book.translate.xml:20716
#, fuzzy
msgid "<emphasis>cylinders</emphasis> - output, logical cylinders"
msgstr " <emphasis> cilindros </emphasis> - saÌ≠da, cilindros lÛgicos "

#: book.translate.xml:20721
#, fuzzy
msgid "<emphasis>heads</emphasis> - output, logical heads"
msgstr " <emphasis> cabeÁas </emphasis> - saÌ≠da, cabeÁas lÛgicas "

#: book.translate.xml:20726
#, fuzzy
msgid "<emphasis>secs_per_track</emphasis> - output, logical sectors per track"
msgstr " <emphasis> secs_per_track </emphasis> - saÌ≠da, setores lÛgicos por trilha "

#: book.translate.xml:20732
#, fuzzy
msgid "<primary>SCSI</primary> <secondary>BIOS</secondary>"
msgstr " <primary> SCSI </primary><secondary> BIOS </secondary> "

#: book.translate.xml:20731
#, fuzzy
msgid ""
"If the returned geometry differs much enough from what the SCSI controller BIOS<_:"
"indexterm-1/> thinks and a disk on this SCSI controller is used as bootable the "
"system may not be able to boot. The typical calculation example taken from the "
"aic7xxx driver is:"
msgstr ""
"Se a geometria retornada difere o suficiente do que o BIOS do controlador SCSI <_: "
"indexterm-1 /> pensa e um disco neste controlador SCSI È usado como inicializ·vel, o "
"sistema pode n„o ser capaz de inicializar. O exemplo de c·lculo tÌ≠pico obtido do "
"driver aic7xxx È: "

#: book.translate.xml:20761
#, fuzzy
msgid ""
"This gives the general idea, the exact calculation depends on the quirks of the "
"particular BIOS. If BIOS provides no way set the <quote>extended translation</quote> "
"flag in EEPROM this flag should normally be assumed equal to 1. Other popular "
"geometries are:"
msgstr ""
"Isso d· a idÈia geral, o c·lculo exato depende das peculiaridades do BIOS em "
"particular. Se o BIOS n„o fornece nenhuma maneira de definir o <quote> traduÁ„o "
"estendida </quote> flag na EEPROM este sinalizador deve normalmente ser assumido "
"igual a 1. Outras geometrias populares s„o: "

#: book.translate.xml:20770
#, fuzzy
msgid ""
"Some system BIOSes and SCSI BIOSes fight with each other with variable success, for "
"example a combination of Symbios 875/895 SCSI and Phoenix BIOS can give geometry "
"128/63 after power up and 255/63 after a hard reset or soft reboot."
msgstr ""
"Algumas BIOS de sistema e BIOS SCSI lutam entre si com sucesso vari·vel, por "
"exemplo, uma combinaÁ„o de Symbios 875/895 SCSI e Phoenix BIOS pode fornecer uma "
"geometria de 128/63 apÛs a energizaÁ„o e 255/63 apÛs uma reinicializaÁ„o a frio ou "
"reinicializaÁ„o suave."

#: book.translate.xml:20778
#, fuzzy
msgid ""
"<emphasis>XPT_PATH_INQ</emphasis> - path inquiry, in other words get the SIM driver "
"and SCSI controller (also known as HBA - Host Bus Adapter) properties"
msgstr ""
" <emphasis> XPT_PATH_INQ </emphasis> - consulta de caminho, em outras palavras, "
"obtenha o driver SIM e as propriedades do controlador SCSI (tambÈm conhecido como "
"HBA - Host Bus Adapter) "

#: book.translate.xml:20782
#, fuzzy
msgid ""
"The properties are returned in the instance <quote>struct ccb_pathinq cpi</quote> of "
"the union ccb:"
msgstr ""
"As propriedades s„o retornadas na instÌ¢ncia <quote> struct ccb_pathinq cpi </quote> "
"da uni„o ccb: "

#: book.translate.xml:20788
#, fuzzy
msgid "version_num - the SIM driver version number, now all drivers use 1"
msgstr ""
"version_num - o n˙mero da vers„o do driver do SIM, agora todos os drivers usam 1"

#: book.translate.xml:20793
#, fuzzy
msgid "hba_inquiry - bitmask of features supported by the controller:"
msgstr "hba_inquiry - bitmask de recursos suportados pelo controlador:"

#: book.translate.xml:20798
#, fuzzy
msgid "PI_MDP_ABLE - supports MDP message (something from SCSI3?)"
msgstr "PI_MDP_ABLE - suporta mensagem MDP (algo do SCSI3?)"

#: book.translate.xml:20803
#, fuzzy
msgid "PI_WIDE_32 - supports 32 bit wide SCSI"
msgstr "PI_WIDE_32 - suporta SCSI de 32 bits de largura"

#: book.translate.xml:20808
#, fuzzy
msgid "PI_WIDE_16 - supports 16 bit wide SCSI"
msgstr "PI_WIDE_16 - suporta SCSI de 16 bits de largura"

#: book.translate.xml:20813
#, fuzzy
msgid "PI_SDTR_ABLE - can negotiate synchronous transfer rate"
msgstr "PI_SDTR_ABLE - pode negociar taxa de transferÍncia sÌ≠ncrona"

#: book.translate.xml:20818
#, fuzzy
msgid "PI_LINKED_CDB - supports linked commands"
msgstr "PI_LINKED_CDB - suporta comandos vinculados"

#: book.translate.xml:20823
#, fuzzy
msgid "PI_TAG_ABLE - supports tagged commands"
msgstr "PI_TAG_ABLE - suporta comandos marcados"

#: book.translate.xml:20828
#, fuzzy
msgid ""
"PI_SOFT_RST - supports soft reset alternative (hard reset and soft reset are "
"mutually exclusive within a SCSI bus)"
msgstr ""
"PI_SOFT_RST - suporta alternativa de redefiniÁ„o suave (hard reset e soft reset s„o "
"mutuamente exclusivos dentro de um barramento SCSI)"

#: book.translate.xml:20834
#, fuzzy
msgid "target_sprt - flags for target mode support, 0 if unsupported"
msgstr ""
"target_sprt - sinalizadores para suporte ao modo de destino, 0 se n„o suportado"

#: book.translate.xml:20839
#, fuzzy
msgid "hba_misc - miscellaneous controller features:"
msgstr "hba_misc - recursos diversos do controlador:"

#: book.translate.xml:20844
#, fuzzy
msgid "PIM_SCANHILO - bus scans from high ID to low ID"
msgstr "PIM_SCANHILO - bus varre de alta identificaÁ„o para baixa ID"

#: book.translate.xml:20849
#, fuzzy
msgid "PIM_NOREMOVE - removable devices not included in scan"
msgstr "PIM_NOREMOVE - dispositivos removÌ≠veis n„o incluÌ≠dos na verificaÁ„o"

#: book.translate.xml:20854
#, fuzzy
msgid "PIM_NOINITIATOR - initiator role not supported"
msgstr "PIM_NOINITIATOR - funÁ„o do iniciador n„o suportada"

#: book.translate.xml:20859
#, fuzzy
msgid "PIM_NOBUSRESET - user has disabled initial BUS RESET"
msgstr "PIM_NOBUSRESET - usu·rio desabilitou inicial BUS RESET"

#: book.translate.xml:20864
#, fuzzy
msgid ""
"hba_eng_cnt - mysterious HBA engine count, something related to compression, now is "
"always set to 0"
msgstr ""
"hba_eng_cnt - misteriosa contagem de mecanismos do HBA, algo relacionado Ì† "
"compactaÁ„o, agora est· sempre definido como 0"

#: book.translate.xml:20869
#, fuzzy
msgid "vuhba_flags - vendor-unique flags, unused now"
msgstr "vuhba_flags - bandeiras exclusivas de fornecedores, n„o usadas agora"

#: book.translate.xml:20873
#, fuzzy
msgid ""
"max_target - maximal supported target ID (7 for 8-bit bus, 15 for 16-bit bus, 127 "
"for Fibre Channel)"
msgstr ""
"max_target - ID de alvo suportado maximal (7 para bus de 8 bits, 15 para bus de 16 "
"bits, 127 para o Fibre Channel)"

#: book.translate.xml:20879
#, fuzzy
msgid ""
"max_lun - maximal supported LUN ID (7 for older SCSI controllers, 63 for newer ones)"
msgstr ""
"max_lun - maximal LUN ID suportado (7 para controladores SCSI mais antigos, 63 para "
"os mais novos)"

#: book.translate.xml:20884
#, fuzzy
msgid "async_flags - bitmask of installed Async handler, unused now"
msgstr "async_flags - bitmask do manipulador Async instalado, n„o usado agora"

#: book.translate.xml:20889
#, fuzzy
msgid "hpath_id - highest Path ID in the subsystem, unused now"
msgstr "hpath_id - maior ID do caminho no subsistema, n„o usado agora"

#: book.translate.xml:20894
#, fuzzy
msgid "unit_number - the controller unit number, cam_sim_unit(sim)"
msgstr "unit_number - o n˙mero da unidade controladora, cam_sim_unit (sim)"

#: book.translate.xml:20899
#, fuzzy
msgid "bus_id - the bus number, cam_sim_bus(sim)"
msgstr "bus_id - o n˙mero do barramento, cam_sim_bus (sim)"

#: book.translate.xml:20903
#, fuzzy
msgid "initiator_id - the SCSI ID of the controller itself"
msgstr "initiator_id - o ID SCSI do prÛprio controlador"

#: book.translate.xml:20908
#, fuzzy
msgid ""
"base_transfer_speed - nominal transfer speed in KB/s for asynchronous narrow "
"transfers, equals to 3300 for SCSI"
msgstr ""
"base_transfer_speed - velocidade de transferÍncia nominal em KB / s para "
"transferÍncias estreitas assÌ≠ncronas, igual a 3300 para SCSI"

#: book.translate.xml:20914
#, fuzzy
msgid ""
"sim_vid - SIM driver's vendor id, a zero-terminated string of maximal length "
"SIM_IDLEN including the terminating zero"
msgstr ""
"sim_vid - ID do fornecedor do driver SIM, uma string terminada em zero de "
"comprimento m·ximo SIM_IDLEN incluindo o zero de finalizaÁ„o"

#: book.translate.xml:20920
#, fuzzy
msgid ""
"hba_vid - SCSI controller's vendor id, a zero-terminated string of maximal length "
"HBA_IDLEN including the terminating zero"
msgstr ""
"hba_vid - ID do fornecedor do controlador SCSI, uma cadeia terminada em zero de "
"comprimento m·ximo HBA_IDLEN incluindo o zero de finalizaÁ„o"

#: book.translate.xml:20926
#, fuzzy
msgid ""
"dev_name - device driver name, a zero-terminated string of maximal length DEV_IDLEN "
"including the terminating zero, equal to cam_sim_name(sim)"
msgstr ""
"dev_name - nome do driver de dispositivo, uma cadeia terminada em zero de "
"comprimento m·ximo DEV_IDLEN incluindo o zero final, igual a cam_sim_name (sim)"

#: book.translate.xml:20932
#, fuzzy
msgid "The recommended way of setting the string fields is using strncpy, like:"
msgstr ""
"A maneira recomendada de configurar os campos de string È usando strncpy, como:"

#: book.translate.xml:20937
#, fuzzy
msgid ""
"After setting the values set the status to CAM_REQ_CMP and mark the CCB as done."
msgstr ""
"Depois de definir os valores, defina o status como CAM_REQ_CMP e marque o CCB como "
"concluÌ≠do."

#: book.translate.xml:20944
#, fuzzy
msgid "Polling"
msgstr "Polling"

#: book.translate.xml:20957
#, fuzzy
msgid ""
"The poll function is used to simulate the interrupts when the interrupt subsystem is "
"not functioning (for example, when the system has crashed and is creating the system "
"dump). The CAM subsystem sets the proper interrupt level before calling the poll "
"routine. So all it needs to do is to call the interrupt routine (or the other way "
"around, the poll routine may be doing the real action and the interrupt routine "
"would just call the poll routine). Why bother about a separate function then? "
"Because of different calling conventions. The <function>xxx_poll</function> routine "
"gets the struct cam_sim pointer as its argument when the PCI interrupt routine by "
"common convention gets pointer to the struct <varname remap=\"structname"
"\">xxx_softc</varname> and the ISA interrupt routine gets just the device unit "
"number. So the poll routine would normally look as:"
msgstr ""
"A funÁ„o de pesquisa È usada para simular as interrupÁÌµes quando o subsistema de "
"interrupÁ„o n„o est· funcionando (por exemplo, quando o sistema travou e est· "
"criando o dump do sistema). O subsistema CAM define o nÌ≠vel de interrupÁ„o adequado "
"antes de chamar a rotina de pesquisa. ele precisa fazer È chamar a rotina de "
"interrupÁ„o (ou vice-versa, a rotina de poll pode estar fazendo a aÁ„o real e a "
"rotina de interrupÁ„o apenas chamaria a rotina de poll) Por que se preocupar com uma "
"funÁ„o separada ent„o? convenÁÌµes. <function> xxx_poll </function> rotina obtÈm o "
"ponteiro struct cam_sim como seu argumento quando a rotina de interrupÁ„o PCI por "
"convenÁ„o comum obtÈm ponteiro para a estrutura <varname remap=\"structname\"> "
"xxx_softc </varname> e a rotina de interrupÁ„o ISA obtÈm apenas o n˙mero da unidade "
"do dispositivo. Ent„o a rotina de pesquisa normalmente seria como: "

#: book.translate.xml:20979
#, fuzzy
msgid "or"
msgstr "ou"

#: book.translate.xml:20989
#, fuzzy
msgid "Asynchronous Events"
msgstr "Eventos assÌ≠ncronos"

#: book.translate.xml:20991
#, fuzzy
msgid ""
"If an asynchronous event callback has been set up then the callback function should "
"be defined."
msgstr ""
"Se um retorno de chamada de evento assÌ≠ncrono tiver sido configurado, a funÁ„o de "
"retorno de chamada dever· ser definida."

#: book.translate.xml:20999
#, fuzzy
msgid "callback_arg - the value supplied when registering the callback"
msgstr "callback_arg - o valor fornecido ao registrar o retorno de chamada"

#: book.translate.xml:21004
#, fuzzy
msgid "code - identifies the type of event"
msgstr "cÛdigo - identifica o tipo de evento"

#: book.translate.xml:21008
#, fuzzy
msgid "path - identifies the devices to which the event applies"
msgstr "caminho - identifica os dispositivos aos quais o evento se aplica"

#: book.translate.xml:21013
#, fuzzy
msgid "arg - event-specific argument"
msgstr "arg - argumento especÌ≠fico do evento"

#: book.translate.xml:21017
#, fuzzy
msgid "Implementation for a single type of event, AC_LOST_DEVICE, looks like:"
msgstr "ImplementaÁ„o para um ˙nico tipo de evento, AC_LOST_DEVICE, se parece com:"

#: book.translate.xml:21048
#, fuzzy
msgid "<primary>SCSI</primary><secondary>interrupts</secondary>"
msgstr " <primary> SCSI </primary><secondary> interrompe </secondary> "

#: book.translate.xml:21050
#, fuzzy
msgid ""
"The exact type of the interrupt routine depends on the type of the peripheral bus "
"(PCI, ISA and so on) to which the SCSI controller is connected."
msgstr ""
"O tipo exato da rotina de interrupÁ„o depende do tipo de barramento do perifÈrico "
"(PCI, ISA e assim por diante) ao qual o controlador SCSI est· conectado."

#: book.translate.xml:21054
#, fuzzy
msgid ""
"The interrupt routines of the SIM drivers run at the interrupt level splcam. So "
"<function>splcam()</function> should be used in the driver to synchronize activity "
"between the interrupt routine and the rest of the driver (for a multiprocessor-aware "
"driver things get yet more interesting but we ignore this case here). The pseudo-"
"code in this document happily ignores the problems of synchronization. The real code "
"must not ignore them. A simple-minded approach is to set <function>splcam()</"
"function> on the entry to the other routines and reset it on return thus protecting "
"them by one big critical section. To make sure that the interrupt level will be "
"always restored a wrapper function can be defined, like:"
msgstr ""
"As rotinas de interrupÁ„o dos drivers SIM s„o executadas no splcam do nÌ≠vel de "
"interrupÁ„o. <function> splcam () </function> deve ser usado no driver para "
"sincronizar a atividade entre a rotina de interrupÁ„o e o restante do driver (para "
"um driver com reconhecimento de multiprocessador, as coisas ficam ainda mais "
"interessantes, mas ignoramos este caso aqui). O pseudo-cÛdigo neste documento ignora "
"felizmente os problemas de sincronizaÁ„o. O cÛdigo real n„o deve ignor·-los. Uma "
"abordagem simplista È definir <function> splcam () </function> na entrada para as "
"outras rotinas e redefini-lo no retorno, protegendo-as por uma grande seÁ„o crÌ≠tica. "
"Para ter certeza de que o nÌ≠vel de interrupÁ„o ser· sempre restaurado, uma funÁ„o "
"wrapper pode ser definida, como: "

#: book.translate.xml:21082
#, fuzzy
msgid ""
"This approach is simple and robust but the problem with it is that interrupts may "
"get blocked for a relatively long time and this would negatively affect the system's "
"performance. On the other hand the functions of the <function>spl()</function> "
"family have rather high overhead, so vast amount of tiny critical sections may not "
"be good either."
msgstr ""
"Esta abordagem È simples e robusta, mas o problema È que as interrupÁÌµes podem "
"ficar bloqueadas por um tempo relativamente longo e isso afetaria negativamente o "
"desempenho do sistema. Por outro lado, as funÁÌµes do <function> spl () </function> "
"a famÌ≠lia tem uma sobrecarga bastante alta, uma quantidade t„o grande de seÁÌµes crÌ≠"
"ticas min˙sculas pode n„o ser boa tambÈm \""

#: book.translate.xml:21089
#, fuzzy
msgid ""
"The conditions handled by the interrupt routine and the details depend very much on "
"the hardware. We consider the set of <quote>typical</quote> conditions."
msgstr ""
"As condiÁÌµes manipuladas pela rotina de interrupÁ„o e os detalhes dependem muito do "
"hardware. Consideramos o conjunto de <quote> tÌ≠pica </quote> condiÁÌµes. "

#: book.translate.xml:21093
#, fuzzy
msgid ""
"First, we check if a SCSI reset was encountered on the bus (probably caused by "
"another SCSI controller on the same SCSI bus). If so we drop all the enqueued and "
"disconnected requests, report the events and re-initialize our SCSI controller. It "
"is important that during this initialization the controller will not issue another "
"reset or else two controllers on the same SCSI bus could ping-pong resets forever. "
"The case of fatal controller error/hang could be handled in the same place, but it "
"will probably need also sending RESET signal to the SCSI bus to reset the status of "
"the connections with the SCSI devices."
msgstr ""
"Primeiro, verificamos se uma reinicializaÁ„o SCSI foi encontrada no barramento "
"(provavelmente causada por outro controlador SCSI no mesmo barramento SCSI). Se "
"assim for, descartamos todas as solicitaÁÌµes enfileiradas e desconectadas, "
"relatamos os eventos e reinicializamos nosso controlador SCSI. Ìâ importante que "
"durante esta inicializaÁ„o o controlador n„o emita outra reinicializaÁ„o ou ent„o "
"dois controladores no mesmo barramento SCSI possam reiniciar o ping pong para sempre "
"O caso de erro / travamento do controlador fatal pode ser tratado no mesmo local, "
"mas provavelmente tambÈm precisa enviar o sinal RESET ao barramento SCSI para "
"redefinir o status das conexÌµes com os dispositivos SCSI. "

#: book.translate.xml:21165
#, fuzzy
msgid ""
"If interrupt is not caused by a controller-wide condition then probably something "
"has happened to the current hardware control block. Depending on the hardware there "
"may be other non-HCB-related events, we just do not consider them here. Then we "
"analyze what happened to this HCB:"
msgstr ""
"Se a interrupÁ„o n„o È causada por uma condiÁ„o de controle geral, provavelmente "
"algo aconteceu com o bloco de controle de hardware atual. Dependendo do hardware, "
"pode haver outros eventos n„o relacionados ao HCB, nÛs n„o os consideramos aqui. "
"Ent„o analisamos o que aconteceu com este HCB: "

#: book.translate.xml:21189
#, fuzzy
msgid ""
"First we check if the HCB has completed and if so we check the returned SCSI status."
msgstr ""
"Primeiro, verificamos se o HCB foi concluÌ≠do e, nesse caso, verificamos o status do "
"SCSI retornado."

#: book.translate.xml:21195
#, fuzzy
msgid ""
"Then look if this status is related to the REQUEST SENSE command and if so handle it "
"in a simple way."
msgstr ""
"Ent„o olhe se este status est· relacionado ao comando REQUEST SENSE e, se for o "
"caso, manipule-o de maneira simples."

#: book.translate.xml:21210
#, fuzzy
msgid ""
"Else the command itself has completed, pay more attention to details. If auto-sense "
"is not disabled for this CCB and the command has failed with sense data then run "
"REQUEST SENSE command to receive that data."
msgstr ""
"Se o comando em si tiver sido concluÌ≠do, preste mais atenÁ„o aos detalhes. Se o auto-"
"sentido n„o estiver desativado para este CCB e o comando falhar com dados de "
"detecÁ„o, execute o comando REQUEST SENSE para receber esses dados."

#: book.translate.xml:21235
#, fuzzy
msgid ""
"One typical thing would be negotiation events: negotiation messages received from a "
"SCSI target (in answer to our negotiation attempt or by target's initiative) or the "
"target is unable to negotiate (rejects our negotiation messages or does not answer "
"them)."
msgstr ""
"Uma coisa tÌ≠pica seria eventos de negociaÁ„o: mensagens de negociaÁ„o recebidas de "
"um alvo SCSI (em resposta Ì† nossa tentativa de negociaÁ„o ou por iniciativa do "
"alvo) ou o alvo È incapaz de negociar (rejeita nossas mensagens de negociaÁ„o ou n„o "
"as responde)."

#: book.translate.xml:21293
#, fuzzy
msgid ""
"Then we handle any errors that could have happened during auto-sense in the same "
"simple-minded way as before. Otherwise we look closer at the details again."
msgstr ""
"Ent„o, lidamos com quaisquer erros que poderiam ter ocorrido durante a detecÁ„o "
"autom·tica da mesma maneira simplÛria de antes. Caso contr·rio, veremos mais de "
"perto os detalhes novamente."

#: book.translate.xml:21302
#, fuzzy
msgid ""
"The next event we consider is unexpected disconnect. Which is considered normal "
"after an ABORT or BUS DEVICE RESET message and abnormal in other cases."
msgstr ""
"O prÛximo evento que consideramos È uma desconex„o inesperada. O que È considerado "
"normal apÛs uma mensagem ABORT ou BUS DEVICE RESET e anormal em outros casos."

#: book.translate.xml:21345
#, fuzzy
msgid ""
"If the target refuses to accept tags we notify CAM about that and return back all "
"commands for this LUN:"
msgstr ""
"Se o destino se recusar a aceitar tags, nÛs notificaremos o CAM sobre isso e "
"retornaremos todos os comandos para este LUN:"

#: book.translate.xml:21360
#, fuzzy
msgid ""
"Then we check a number of other conditions, with processing basically limited to "
"setting the CCB status:"
msgstr ""
"Em seguida, verificamos v·rias outras condiÁÌµes, com o processamento basicamente "
"limitado Ì† configuraÁ„o do status do CCB:"

#: book.translate.xml:21385
#, fuzzy
msgid ""
"Then we check if the error was serious enough to freeze the input queue until it "
"gets proceeded and do so if it is:"
msgstr ""
"Em seguida, verificamos se o erro foi grave o suficiente para congelar a fila de "
"entrada atÈ que ela continue e faÁa isso, se for:"

#: book.translate.xml:21406
#, fuzzy
msgid ""
"This concludes the generic interrupt handling although specific controllers may "
"require some additions."
msgstr ""
"Isso conclui o tratamento genÈrico de interrupÁ„o, embora os controladores especÌ≠"
"ficos possam exigir algumas adiÁÌµes."

#: book.translate.xml:21411
#, fuzzy
msgid "Errors Summary"
msgstr "Resumo de Erros"

#: book.translate.xml:21413
#, fuzzy
msgid "<primary>SCSI</primary><secondary>errors</secondary>"
msgstr " <primary> SCSI </primary><secondary> erros </secondary> "

#: book.translate.xml:21415
#, fuzzy
msgid ""
"When executing an I/O request many things may go wrong. The reason of error can be "
"reported in the CCB status with great detail. Examples of use are spread throughout "
"this document. For completeness here is the summary of recommended responses for the "
"typical error conditions:"
msgstr ""
"Ao executar uma solicitaÁ„o de E / S, muitas coisas podem dar errado. O motivo do "
"erro pode ser relatado no status CCB com muitos detalhes. Exemplos de uso est„o "
"espalhados por este documento. Para completar, aqui est· o resumo das respostas "
"recomendadas para o tÌ≠pico condiÁÌµes de erro: "

#: book.translate.xml:21423
#, fuzzy
msgid ""
"<emphasis>CAM_RESRC_UNAVAIL</emphasis> - some resource is temporarily unavailable "
"and the SIM driver cannot generate an event when it will become available. An "
"example of this resource would be some intra-controller hardware resource for which "
"the controller does not generate an interrupt when it becomes available."
msgstr ""
" <emphasis> CAM_RESRC_UNAVAIL </emphasis> - algum recurso est· temporariamente "
"indisponÌ≠vel e o driver do SIM n„o pode gerar um evento quando ele estiver disponÌ≠"
"vel. Um exemplo desse recurso seria algum recurso de hardware intra-controlador para "
"o qual o controlador n„o gera uma interrupÁ„o quando se torna disponÌ≠vel. "

#: book.translate.xml:21432
#, fuzzy
msgid "<emphasis>CAM_UNCOR_PARITY</emphasis> - unrecovered parity error occurred"
msgstr ""
" <emphasis> CAM_UNCOR_PARITY </emphasis> - erro de paridade n„o recuperado ocorrido "

#: book.translate.xml:21437
#, fuzzy
msgid ""
"<emphasis>CAM_DATA_RUN_ERR</emphasis> - data overrun or unexpected data phase (going "
"in other direction than specified in CAM_DIR_MASK) or odd transfer length for wide "
"transfer"
msgstr ""
" <emphasis> CAM_DATA_RUN_ERR </emphasis> - saturaÁ„o de dados ou fase de dados "
"inesperada (indo em outra direÁ„o que n„o a especificada em CAM_DIR_MASK) ou "
"comprimento de transferÍncia Ì≠mpar para transferÍncia ampla "

#: book.translate.xml:21444
#, fuzzy
msgid ""
"<emphasis>CAM_SEL_TIMEOUT</emphasis> - selection timeout occurred (target does not "
"respond)"
msgstr ""
" <emphasis> CAM_SEL_TIMEOUT </emphasis> - tempo limite de seleÁ„o ocorreu (o alvo "
"n„o responde) "

#: book.translate.xml:21449
#, fuzzy
msgid ""
"<emphasis>CAM_CMD_TIMEOUT</emphasis> - command timeout occurred (the timeout "
"function ran)"
msgstr ""
" <emphasis> CAM_CMD_TIMEOUT </emphasis> - ocorreu o tempo limite do comando (a "
"funÁ„o de tempo limite foi executada) "

#: book.translate.xml:21454
#, fuzzy
msgid "<emphasis>CAM_SCSI_STATUS_ERROR</emphasis> - the device returned error"
msgstr " <emphasis> CAM_SCSI_STATUS_ERROR </emphasis> - o dispositivo retornou o erro "

#: book.translate.xml:21459
#, fuzzy
msgid ""
"<emphasis>CAM_AUTOSENSE_FAIL</emphasis> - the device returned error and the REQUEST "
"SENSE COMMAND failed"
msgstr ""
" <emphasis> CAM_AUTOSENSE_FAIL </emphasis> - o dispositivo retornou um erro e o "
"comando REQUEST SENSE COMMAND falhou "

#: book.translate.xml:21464
#, fuzzy
msgid "<emphasis>CAM_MSG_REJECT_REC</emphasis> - MESSAGE REJECT message was received"
msgstr ""
" <emphasis> CAM_MSG_REJECT_REC </emphasis> - Mensagem de REJEIÌáÌÉO DE MENSAGEM foi "
"recebida "

#: book.translate.xml:21469
#, fuzzy
msgid "<emphasis>CAM_SCSI_BUS_RESET</emphasis> - received SCSI bus reset"
msgstr " <emphasis> CAM_SCSI_BUS_RESET </emphasis> - reset do barramento SCSI recebid"

#: book.translate.xml:21474
#, fuzzy
msgid ""
"<emphasis>CAM_REQ_CMP_ERR</emphasis> - <quote>impossible</quote> SCSI phase occurred "
"or something else as weird or just a generic error if further detail is not available"
msgstr ""
" <emphasis> CAM_REQ_CMP_ERR </emphasis> - <quote> impossÌ≠vel </quote> Fase SCSI "
"ocorreu ou algo mais estranho ou apenas um erro genÈrico se mais detalhes n„o "
"estiverem disponÌ≠veis "

#: book.translate.xml:21481
#, fuzzy
msgid "<emphasis>CAM_UNEXP_BUSFREE</emphasis> - unexpected disconnect occurred"
msgstr " <emphasis> CAM_UNEXP_BUSFREE </emphasis> - desconex„o inesperada ocorreu "

#: book.translate.xml:21486
#, fuzzy
msgid ""
"<emphasis>CAM_BDR_SENT</emphasis> - BUS DEVICE RESET message was sent to the target"
msgstr ""
" <emphasis> CAM_BDR_SENT </emphasis> - A mensagem BUS DEVICE RESET foi enviada para "
"o alvo "

#: book.translate.xml:21491
#, fuzzy
msgid "<emphasis>CAM_UNREC_HBA_ERROR</emphasis> - unrecoverable Host Bus Adapter Error"
msgstr ""
" <emphasis> CAM_UNREC_HBA_ERROR </emphasis> - erro de adaptador de barramento de "
"host irrecuper·vel "

#: book.translate.xml:21496
#, fuzzy
msgid ""
"<emphasis>CAM_REQ_TOO_BIG</emphasis> - the request was too large for this controller"
msgstr ""
" <emphasis> CAM_REQ_TOO_BIG </emphasis> - o pedido era muito grande para esse "
"controlador "

#: book.translate.xml:21501
#, fuzzy
msgid ""
"<emphasis>CAM_REQUEUE_REQ</emphasis> - this request should be re-queued to preserve "
"transaction ordering. This typically occurs when the SIM recognizes an error that "
"should freeze the queue and must place other queued requests for the target at the "
"sim level back into the XPT queue. Typical cases of such errors are selection "
"timeouts, command timeouts and other like conditions. In such cases the troublesome "
"command returns the status indicating the error, the and the other commands which "
"have not be sent to the bus yet get re-queued."
msgstr ""
" <emphasis> CAM_REQUEUE_REQ </emphasis> - essa solicitaÁ„o deve ser enfileirada "
"novamente para preservar a ordem de transaÁ„o. Isso normalmente ocorre quando o SIM "
"reconhece um erro que deve congelar a fila e deve colocar outras solicitaÁÌµes na "
"fila para o destino no nÌ≠vel do sim de volta na fila do XPT. Casos tÌ≠picos de tais "
"erros s„o tempos limite de seleÁ„o, tempos limite de comando e outras condiÁÌµes "
"semelhantes. Em tais casos, o comando problem·tico retorna o status indicando o "
"erro, oe os outros comandos que n„o foram enviados para o barramento ainda s„o re-"
"enfileirados. "

#: book.translate.xml:21514
#, fuzzy
msgid ""
"<emphasis>CAM_LUN_INVALID</emphasis> - the LUN ID in the request is not supported by "
"the SCSI controller"
msgstr ""
" <emphasis> CAM_LUN_INVALID </emphasis> - o ID do LUN na solicitaÁ„o n„o È suportado "
"pelo controlador SCSI "

#: book.translate.xml:21519
#, fuzzy
msgid ""
"<emphasis>CAM_TID_INVALID</emphasis> - the target ID in the request is not supported "
"by the SCSI controller"
msgstr ""
" <emphasis> CAM_TID_INVALID </emphasis> - o ID de destino na solicitaÁ„o n„o È "
"suportado pelo controlador SCSI "

#: book.translate.xml:21526
#, fuzzy
msgid "Timeout Handling"
msgstr "Timeout Handling"

#: book.translate.xml:21528
#, fuzzy
msgid ""
"When the timeout for an HCB expires that request should be aborted, just like with "
"an XPT_ABORT request. The only difference is that the returned status of aborted "
"request should be CAM_CMD_TIMEOUT instead of CAM_REQ_ABORTED (that is why "
"implementation of the abort better be done as a function). But there is one more "
"possible problem: what if the abort request itself will get stuck? In this case the "
"SCSI bus should be reset, just like with an XPT_RESET_BUS request (and the idea "
"about implementing it as a function called from both places applies here too). Also "
"we should reset the whole SCSI bus if a device reset request got stuck. So after all "
"the timeout function would look like:"
msgstr ""
"Quando o tempo limite de um HCB expira, o pedido deve ser abortado, assim como com "
"um pedido XPT_ABORT. A ˙nica diferenÁa È que o status retornado do pedido abortado "
"deve ser CAM_CMD_TIMEOUT ao invÈs de CAM_REQ_ABORTED (È por isso que a implementaÁ„o "
"do aborto deve ser feita como Mas h· mais um problema possÌ≠vel: e se o prÛprio "
"pedido de abortar ficar preso? Nesse caso, o barramento SCSI deve ser redefinido, "
"assim como com uma solicitaÁ„o XPT_RESET_BUS (e a idÈia de implement·-lo como uma "
"funÁ„o chamada de ambos os lugares se aplicam aqui tambÈm. TambÈm devemos redefinir "
"todo o barramento SCSI se uma solicitaÁ„o de reinicializaÁ„o do dispositivo ficar "
"travada. Ent„o, depois de toda a funÁ„o de tempo limite, seria: "

#: book.translate.xml:21559
#, fuzzy
msgid ""
"When we abort a request all the other disconnected requests to the same target/LUN "
"get aborted too. So there appears a question, should we return them with status "
"CAM_REQ_ABORTED or CAM_CMD_TIMEOUT? The current drivers use CAM_CMD_TIMEOUT. This "
"seems logical because if one request got timed out then probably something really "
"bad is happening to the device, so if they would not be disturbed they would time "
"out by themselves."
msgstr ""
"Quando abortamos um pedido, todos os outros pedidos desconectados para o mesmo "
"destino / LUN s„o abortados tambÈm. Ent„o, aparece uma pergunta, devemos devolvÍ-los "
"com status CAM_REQ_ABORTED ou CAM_CMD_TIMEOUT? Os drivers atuais usam "
"CAM_CMD_TIMEOUT. Isso parece lÛgico porque se um pedido Se o tempo expirar, È "
"prov·vel que algo realmente ruim esteja acontecendo com o dispositivo, por isso, se "
"eles n„o forem incomodados, eles perder„o o tempo sozinhos \""

#: book.translate.xml:21576
#, fuzzy
msgid "USB Devices"
msgstr "Dispositivos USB"

#: book.translate.xml:21578
#, fuzzy
msgid ""
"<personname><firstname>Nick</firstname><surname>Hibma</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Nick </firstname><surname> Hibma </surname></"
"personname><contrib> Escrito por </contrib> "

#: book.translate.xml:21590
#, fuzzy
msgid "<primary>Universal Serial Bus (USB)</primary>"
msgstr " <primary> Barramento Serial Universal (USB) </primary> "

#: book.translate.xml:21591
#, fuzzy
msgid "<primary>NetBSD</primary>"
msgstr " <primary> NetBSD </primary> "

#: book.translate.xml:21593
#, fuzzy
msgid ""
"The Universal Serial Bus (USB) is a new way of attaching devices to personal "
"computers. The bus architecture features two-way communication and has been "
"developed as a response to devices becoming smarter and requiring more interaction "
"with the host. USB support is included in all current PC chipsets and is therefore "
"available in all recently built PCs. Apple's introduction of the USB-only iMac has "
"been a major incentive for hardware manufacturers to produce USB versions of their "
"devices. The future PC specifications specify that all legacy connectors on PCs "
"should be replaced by one or more USB connectors, providing generic plug and play "
"capabilities. Support for USB hardware was available at a very early stage in NetBSD "
"and was developed by Lennart Augustsson for the NetBSD project. The code has been "
"ported to FreeBSD and we are currently maintaining a shared code base. For the "
"implementation of the USB subsystem a number of features of USB are important."
msgstr ""
"O Universal Serial Bus (USB) È uma nova maneira de conectar dispositivos a "
"computadores pessoais. A arquitetura de barramento possui comunicaÁ„o bidirecional e "
"foi desenvolvida como uma resposta a dispositivos que se tornam mais inteligentes e "
"exigem mais interaÁ„o com o host. O suporte USB est· incluÌ≠do em todos os atuais "
"chipsets para PC e, portanto, est· disponÌ≠vel em todos os PCs recÈm-construÌ≠dos.A "
"introduÁ„o do iMac apenas para USB tem sido um grande incentivo para fabricantes de "
"hardware produzirem versÌµes USB de seus dispositivos.As especificaÁÌµes futuras do "
"PC especificam que todos os conectores legados em PCs deve ser substituÌ≠do por um ou "
"mais conectores USB, fornecendo capacidades genÈricas de plug and play O suporte "
"para hardware USB estava disponÌ≠vel em um est·gio muito inicial no NetBSD e foi "
"desenvolvido por Lennart Augustsson para o projeto NetBSD O cÛdigo foi portado para "
"o FreeBSD e nÛs Atualmente, est„o mantendo uma base de cÛdigo compartilhada. Para a "
"implementaÁ„o do subsistema USB, um n˙mero de recursos de USB È importante. "

#: book.translate.xml:21610
#, fuzzy
msgid ""
"<emphasis>Lennart Augustsson has done most of the implementation of the USB support "
"for the NetBSD project. Many thanks for this incredible amount of work. Many thanks "
"also to Ardy and Dirk for their comments and proofreading of this paper.</emphasis>"
msgstr ""
" <emphasis> Lennart Augustsson fez a maior parte da implementaÁ„o do suporte a USB "
"para o projeto NetBSD. Muito obrigado por esta incrÌ≠vel quantidade de trabalho. "
"Muito obrigado tambÈm a Ardy e Dirk por seus coment·rios e revis„o deste artigo. </"
"emphasis> "

#: book.translate.xml:21617
#, fuzzy
msgid ""
"Devices connect to ports on the computer directly or on devices called hubs, forming "
"a treelike device structure."
msgstr ""
"Os dispositivos se conectam a portas no computador diretamente ou em dispositivos "
"chamados hubs, formando uma estrutura de dispositivo semelhante a uma ·rvore."

#: book.translate.xml:21621
#, fuzzy
msgid "The devices can be connected and disconnected at run time."
msgstr "Os dispositivos podem ser conectados e desconectados em tempo de execuÁ„o."

#: book.translate.xml:21624
#, fuzzy
msgid "Devices can suspend themselves and trigger resumes of the host system"
msgstr "Dispositivos podem se suspender e acionar currÌ≠culos do sistema host"

#: book.translate.xml:21627
#, fuzzy
msgid ""
"As the devices can be powered from the bus, the host software has to keep track of "
"power budgets for each hub."
msgstr ""
"Como os dispositivos podem ser alimentados pelo barramento, o software hospedeiro "
"precisa monitorar os orÁamentos de energia de cada hub\""

#: book.translate.xml:21631
#, fuzzy
msgid ""
"Different quality of service requirements by the different device types together "
"with the maximum of 126 devices that can be connected to the same bus, require "
"proper scheduling of transfers on the shared bus to take full advantage of the "
"12Mbps bandwidth available. (over 400Mbps with USB 2.0)"
msgstr ""
"Diferentes exigÍncias de qualidade de serviÁo pelos diferentes tipos de "
"dispositivos, juntamente com o m·ximo de 126 dispositivos que podem ser conectados "
"ao mesmo barramento, requerem agendamento adequado de transferÍncias no barramento "
"compartilhado para aproveitar ao m·ximo a largura de banda de 12Mbps disponÌ≠vel. USB "
"2.0) "

#: book.translate.xml:21638
#, fuzzy
msgid ""
"Devices are intelligent and contain easily accessible information about themselves"
msgstr ""
"Os dispositivos s„o inteligentes e contÍm informaÁÌµes facilmente acessÌ≠veis sobre "
"si mesmos"

#: book.translate.xml:21643
#, fuzzy
msgid ""
"The development of drivers for the USB subsystem and devices connected to it is "
"supported by the specifications that have been developed and will be developed. "
"These specifications are publicly available from the USB home pages. Apple has been "
"very strong in pushing for standards based drivers, by making drivers for the "
"generic classes available in their operating system MacOS and discouraging the use "
"of separate drivers for each new device. This chapter tries to collate essential "
"information for a basic understanding of the USB 2.0 implementation stack in FreeBSD/"
"NetBSD. It is recommended however to read it together with the relevant 2.0 "
"specifications and other developer resources:"
msgstr ""
"O desenvolvimento de drivers para o subsistema USB e dispositivos conectados a ele È "
"suportado pelas especificaÁÌµes que foram desenvolvidas e que ser„o desenvolvidas. "
"Essas especificaÁÌµes est„o disponÌ≠veis publicamente nas home pages USB. A Apple tem "
"sido muito forte em pressionar por drivers baseados em padrÌµes. , fazendo drivers "
"para as classes genÈricas disponÌ≠veis em seu sistema operacional MacOS e "
"desencorajando o uso de drivers separados para cada novo dispositivo.Este capÌ≠tulo "
"tenta coletar informaÁÌµes essenciais para uma compreens„o b·sica da pilha de "
"implementaÁ„o USB 2.0 no FreeBSD / NetBSD. recomendado, no entanto, para lÍ-lo em "
"conjunto com as especificaÁÌµes relevantes 2.0 e outros recursos do desenvolvedor: "

#: book.translate.xml:21658
#, fuzzy
msgid ""
"USB 2.0 Specification (<link xlink:href=\"http://www.usb.org/developers/docs/"
"usb20_docs/\">http://www.usb.org/developers/docs/usb20_docs/</link>)"
msgstr ""
"EspecificaÁ„o USB 2.0 ( <link xlink:href=\"http://www.usb.org/developers/docs/"
"usb20_docs/\"> http://www.usb.org/developers/docs/usb20_docs/ </link> ) "

#: book.translate.xml:21662
#, fuzzy
msgid ""
"Universal Host Controller Interface (<acronym>UHCI</acronym>) Specification (<link "
"xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf\">ftp://ftp."
"netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</link>"
msgstr ""
"EspecificaÁ„o <acronym>UHCI</acronym> (Universal Host Controller Interface) <link "
"xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf\"> ftp://ftp."
"netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf) </link> "

#: book.translate.xml:21667
#, fuzzy
msgid ""
"Open Host Controller Interface (<acronym>OHCI</acronym>) Specification(<link xlink:"
"href=\"ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf\">ftp://ftp."
"compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</link>)"
msgstr ""
"EspecificaÁ„o da Interface do Controlador de Host Aberto ( <acronym>OHCI</acronym> ) "
"( <link xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf"
"\"> ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf </link> ) "

#: book.translate.xml:21672
#, fuzzy
msgid ""
"Developer section of <acronym>USB</acronym> home page (<link xlink:href=\"http://www."
"usb.org/developers/\">http://www.usb.org/developers/</link>)"
msgstr ""
"SeÁ„o do desenvolvedor da home page do <acronym>USB</acronym> ( <link xlink:href="
"\"http://www.usb.org/developers/\"> http://www.usb.org/developers/ </link> ) "

#: book.translate.xml:21677
#, fuzzy
msgid "Structure of the USB Stack"
msgstr "Estrutura da pilha USB"

#: book.translate.xml:21679
#, fuzzy
msgid ""
"The USB support in FreeBSD can be split into three layers. The lowest layer contains "
"the host controller driver, providing a generic interface to the hardware and its "
"scheduling facilities. It supports initialisation of the hardware, scheduling of "
"transfers and handling of completed and/or failed transfers. Each host controller "
"driver implements a virtual hub providing hardware independent access to the "
"registers controlling the root ports on the back of the machine."
msgstr ""
"O suporte USB no FreeBSD pode ser dividido em trÍs camadas. A camada mais baixa "
"contÈm o driver controlador host, fornecendo uma interface genÈrica para o hardware "
"e suas facilidades de agendamento. Suporta inicializaÁ„o do hardware, agendamento de "
"transferÍncias e tratamento de Cada controlador de host implementa um hub virtual "
"fornecendo acesso independente de hardware aos registros que controlam as portas "
"raiz na parte traseira da m·quina. "

#: book.translate.xml:21688
#, fuzzy
msgid ""
"The middle layer handles the device connection and disconnection, basic "
"initialisation of the device, driver selection, the communication channels (pipes) "
"and does resource management. This services layer also controls the default pipes "
"and the device requests transferred over them."
msgstr ""
"A camada intermedi·ria lida com a conex„o e desconex„o do dispositivo, inicializaÁ„o "
"b·sica do dispositivo, seleÁ„o de driver, canais de comunicaÁ„o (pipes) e "
"gerenciamento de recursos. Essa camada de serviÁos tambÈm controla os pipes padr„o e "
"as solicitaÁÌµes de dispositivos transferidos."

#: book.translate.xml:21695
#, fuzzy
msgid ""
"The top layer contains the individual drivers supporting specific (classes of) "
"devices. These drivers implement the protocol that is used over the pipes other than "
"the default pipe. They also implement additional functionality to make the device "
"available to other parts of the kernel or userland. They use the USB driver "
"interface (USBDI) exposed by the services layer."
msgstr ""
"A camada superior contÈm os drivers individuais que suportam dispositivos especÌ≠"
"ficos (classes de). Esses drivers implementam o protocolo que È usado nos pipes "
"diferentes do padr„o. Eles tambÈm implementam funcionalidade adicional para "
"disponibilizar o dispositivo para outras partes do kernel ou Eles usam a interface "
"do driver USB (USBDI) exposta pela camada de serviÁos. "

#: book.translate.xml:21706
#, fuzzy
msgid "Host Controllers"
msgstr "Host Controllers"

#: book.translate.xml:21708
#, fuzzy
msgid "<primary>USB</primary><secondary>host controllers</secondary>"
msgstr " <primary> USB </primary><secondary> controladores de host </secondary> "

#: book.translate.xml:21709
#, fuzzy
msgid ""
"The host controller (HC) controls the transmission of packets on the bus. Frames of "
"1 millisecond are used. At the start of each frame the host controller generates a "
"Start of Frame (SOF) packet."
msgstr ""
"O controlador host (HC) controla a transmiss„o de pacotes no barramento. S„o usados "
"‚Äã‚Äãquadros de 1 milissegundo. No inÌ≠cio de cada quadro, o controlador host gera um "
"pacote Start of Frame (SOF)."

#: book.translate.xml:21714
#, fuzzy
msgid ""
"The SOF packet is used to synchronise to the start of the frame and to keep track of "
"the frame number. Within each frame packets are transferred, either from host to "
"device (out) or from device to host (in). Transfers are always initiated by the host "
"(polled transfers). Therefore there can only be one host per USB bus. Each transfer "
"of a packet has a status stage in which the recipient of the data can return either "
"ACK (acknowledge reception), NAK (retry), STALL (error condition) or nothing "
"(garbled data stage, device not available or disconnected). Section 8.5 of the USB "
"2.0 Specification explains the details of packets in more detail. Four different "
"types of transfers can occur on a USB bus: control, bulk, interrupt and isochronous. "
"The types of transfers and their characteristics are described below."
msgstr ""
"O pacote SOF È usado para sincronizar com o inÌ≠cio do quadro e para acompanhar o "
"n˙mero do quadro. Dentro de cada pacote de quadros s„o transferidos, de host para "
"dispositivo (out) ou de dispositivo para host (in). As transferÍncias s„o sempre "
"Portanto, sÛ pode haver um host por barramento USB Cada transferÍncia de um pacote "
"tem um est·gio de status no qual o destinat·rio dos dados pode retornar ou ACK "
"(recepÁ„o de confirmaÁ„o), NAK (repetiÁ„o), STALL (condiÁ„o de erro) ou nada "
"(est·gio de dados truncados, dispositivo n„o disponÌ≠vel ou desconectado). A SeÁ„o "
"8.5 da EspecificaÁ„o USB 2.0 explica os detalhes dos pacotes em mais detalhes. "
"Quatro tipos diferentes de transferÍncias podem ocorrer em um barramento USB: "
"controle, volume , interrupÁÌµes e isÛcronas. Os tipos de transferÍncias e suas "
"caracterÌ≠sticas s„o descritas a seguir. "

#: book.translate.xml:21729
#, fuzzy
msgid ""
"Large transfers between the device on the USB bus and the device driver are split up "
"into multiple packets by the host controller or the HC driver."
msgstr ""
"Grandes transferÍncias entre o dispositivo no barramento USB e o driver do "
"dispositivo s„o divididas em v·rios pacotes pelo controlador host ou pelo driver HC."

#: book.translate.xml:21733
#, fuzzy
msgid ""
"Device requests (control transfers) to the default endpoints are special. They "
"consist of two or three phases: SETUP, DATA (optional) and STATUS. The set-up packet "
"is sent to the device. If there is a data phase, the direction of the data packet(s) "
"is given in the set-up packet. The direction in the status phase is the opposite of "
"the direction during the data phase, or IN if there was no data phase. The host "
"controller hardware also provides registers with the current status of the root "
"ports and the changes that have occurred since the last reset of the status change "
"register. Access to these registers is provided through a virtualised hub as "
"suggested in the USB specification. The virtual hub must comply with the hub device "
"class given in chapter 11 of that specification. It must provide a default pipe "
"through which device requests can be sent to it. It returns the standard andhub "
"class specific set of descriptors. It should also provide an interrupt pipe that "
"reports changes happening at its ports. There are currently two specifications for "
"host controllers available: Universal Host Controller Interface (<acronym>UHCI</"
"acronym>) from Intel and Open Host Controller Interface (<acronym>OHCI</acronym>) "
"from Compaq, Microsoft, and National Semiconductor. The <acronym>UHCI</acronym> "
"specification has been designed to reduce hardware complexity by requiring the host "
"controller driver to supply a complete schedule of the transfers for each frame. "
"OHCI type controllers are much more independent by providing a more abstract "
"interface doing a lot of work themselves."
msgstr ""
"As solicitaÁÌµes de dispositivos (transferÍncias de controle) para os terminais "
"padr„o s„o especiais. Elas consistem em duas ou trÍs fases: CONFIGURAÌáÌÉO, DADOS "
"(opcional) e STATUS. O pacote de configuraÁ„o È enviado para o dispositivo. Se "
"houver uma fase de dados, o A direÁ„o do (s) pacote (s) de dados È dada no pacote de "
"configuraÁ„o A direÁ„o na fase de status È o oposto da direÁ„o durante a fase de "
"dados, ou IN se n„o houver fase de dados O hardware controlador de host tambÈm "
"fornece registros com o status atual das portas raiz e as mudanÁas ocorridas desde a "
"˙ltima reconfiguraÁ„o do registro de mudanÁa de status.O acesso a esses registros È "
"fornecido por meio de um hub virtualizado, conforme sugerido na especificaÁ„o USB.O "
"hub virtual deve estar de acordo com o dispositivo de hub classe dada no capÌ≠tulo 11 "
"da especificaÁ„o.Ele deve fornecer um pipe padr„o atravÈs do qual as solicitaÁÌµes "
"de dispositivo podem ser enviadas para ele.Ele retorna o conjunto de descritores de "
"classe andhub padr„o.Ele tambÈm deve fornecer um pipe de interrupÁ„o que relata "
"mudanÁas happe nos seus portos. Existem atualmente duas especificaÁÌµes para "
"controladores host disponÌ≠veis: Interface <acronym>UHCI</acronym> (Universal Host "
"Controller Interface) da Intel e <acronym>OHCI</acronym> (Open Host Controller "
"Interface) da Compaq, Microsoft e National Semiconductor. A especificaÁ„o "
"<acronym>UHCI</acronym> foi projetada para reduzir a complexidade do hardware "
"exigindo que o driver do controlador host forneÁa uma programaÁ„o completa das "
"transferÍncias para cada quadro. Os controladores do tipo OHCI s„o muito mais "
"independentes, fornecendo uma interface mais abstrata, fazendo muito trabalho por "
"conta prÛpria. "

#: book.translate.xml:21762
#, fuzzy
msgid "UHCI"
msgstr "UHCI"

#: book.translate.xml:21764
#, fuzzy
msgid "<primary>USB</primary><secondary>UHCI</secondary>"
msgstr " <primary> USB </primary><secondary> UHCI </secondary> "

#: book.translate.xml:21766
#, fuzzy
msgid ""
"The UHCI host controller maintains a framelist with 1024 pointers to per frame data "
"structures. It understands two different data types: transfer descriptors (TD) and "
"queue heads (QH). Each TD represents a packet to be communicated to or from a device "
"endpoint. QHs are a means to groupTDs (and QHs) together."
msgstr ""
"O controlador host UHCI mantÈm uma lista de quadros com 1024 ponteiros para "
"estruturas de dados por quadro. Ele entende dois tipos de dados diferentes: "
"descritores de transferÍncia (TD) e cabeÁalhos de fila (QH). Cada TD representa um "
"pacote a ser comunicado para ou de um terminal de dispositivo QHs s„o um meio para "
"agrupar os DTs (e os QHs) juntos. "

#: book.translate.xml:21773
#, fuzzy
msgid ""
"Each transfer consists of one or more packets. The UHCI driver splits large "
"transfers into multiple packets. For every transfer, apart from isochronous "
"transfers, a QH is allocated. For every type of transfer these QHs are collected at "
"a QH for that type. Isochronous transfers have to be executed first because of the "
"fixed latency requirement and are directly referred to by the pointer in the "
"framelist. The last isochronous TD refers to the QH for interrupt transfers for that "
"frame. All QHs for interrupt transfers point at the QH for control transfers, which "
"in turn points at the QH for bulk transfers. The following diagram gives a graphical "
"overview of this:"
msgstr ""
"Cada transferÍncia consiste em um ou mais pacotes. O driver UHCI divide grandes "
"transferÍncias em v·rios pacotes. Para cada transferÍncia, alÈm das transferÍncias "
"isÛcronas, um QH È alocado. Para cada tipo de transferÍncia, esses QHs s„o coletados "
"em um QH para esse tipo. TransferÍncias isÛcronas tÍm que ser executadas primeiro "
"por causa do requisito de latÍncia fixa e s„o diretamente referenciadas pelo "
"ponteiro na lista de quadros.O ˙ltimo TD isÛcrono refere-se ao QH para "
"transferÍncias de interrupÁ„o para esse quadro.Todos os QHs para transferÍncias "
"interrompidas apontam para o QH para controle de transferÍncias, que por sua vez, "
"aponta para o QH para transferÍncias em massa. O diagrama a seguir d· uma vis„o "
"geral do gr·fico: "

#: book.translate.xml:21786
#, fuzzy
msgid ""
"This results in the following schedule being run in each frame. After fetching the "
"pointer for the current frame from the framelist the controller first executes the "
"TDs for all the isochronous packets in that frame. The last of these TDs refers to "
"the QH for the interrupt transfers for thatframe. The host controller will then "
"descend from that QH to the QHs for the individual interrupt transfers. After "
"finishing that queue, the QH for the interrupt transfers will refer the controller "
"to the QH for all control transfers. It will execute all the subqueues scheduled "
"there, followed by all the transfers queued at the bulk QH. To facilitate the "
"handling of finished or failed transfers different types of interrupts are generated "
"by the hardware at the end of each frame. In the last TD for a transfer the "
"Interrupt-On Completion bit is set by the HC driver to flag an interrupt when the "
"transfer has completed. An error interrupt is flagged if a TD reaches its maximum "
"error count. If the short packet detect bit is set in a TD and less than the set "
"packet length is transferred this interrupt is flagged to notify the controller "
"driver of the completed transfer. It is the host controller driver's task to find "
"out which transfer has completed or produced an error. When called the interrupt "
"service routine will locate all the finished transfers and call their callbacks."
msgstr ""
"Isso resulta no seguinte cronograma sendo executado em cada quadro. Depois de buscar "
"o ponteiro para o quadro atual a partir da lista de quadros, o controlador primeiro "
"executa os TDs para todos os pacotes isÛcronos naquele quadro. O ˙ltimo desses TDs "
"refere-se ao QH para o quadro. interromper transferÍncias para aquele frame.O "
"controlador host ent„o descer· daquele QH para os QHs para as transferÍncias de "
"interrupÁÌµes individuais.Depois de terminar essa fila, o QH para as transferÍncias "
"de interrupÁÌµes ir· referenciar o controlador para o QH para todas as "
"transferÍncias de controle. as subfilas programadas l·, seguidas por todas as "
"transferÍncias enfileiradas no QH em massa Para facilitar o processamento de "
"transferÍncias concluÌ≠das ou com falha, diferentes tipos de interrupÁÌµes s„o "
"gerados pelo hardware no final de cada quadro. -On O bit de conclus„o È definido "
"pelo driver HC para sinalizar uma interrupÁ„o quando a transferÍncia for concluÌ≠da."
"Uma interrupÁ„o de erro È sinalizada se um TD atingir sua contagem m·xima de erros. "
"bit de detecÁ„o de pacote È definido em um TD e menor que o comprimento do pacote "
"configurado È transferido, essa interrupÁ„o È marcada para notificar o driver do "
"controlador da transferÍncia concluÌ≠da. Ìâ a tarefa do driver do controlador host "
"descobrir qual transferÍncia concluiu ou produziu um erro. Quando chamada, a rotina "
"de serviÁo de interrupÁ„o localizar· todas as transferÍncias concluÌ≠das e chamar· "
"seus retornos de chamada. "

#: book.translate.xml:21811
#, fuzzy
msgid ""
"Refer to the <acronym>UHCI</acronym> Specification for a more elaborate description."
msgstr ""
"Consulte a EspecificaÁ„o <acronym>UHCI</acronym> para uma descriÁ„o mais elaborada."

#: book.translate.xml:21817
#, fuzzy
msgid "OHCI"
msgstr "OHCI"

#: book.translate.xml:21819
#, fuzzy
msgid "<primary>USB</primary><secondary>OHCI</secondary>"
msgstr " <primary> USB </primary><secondary> OHCI </secondary> "

#: book.translate.xml:21820
#, fuzzy
msgid ""
"Programming an OHCI host controller is much simpler. The controller assumes that a "
"set of endpoints is available, and is aware of scheduling priorities and the "
"ordering of the types of transfers in a frame. The main data structure used by the "
"host controller is the endpoint descriptor (ED) to which a queue of transfer "
"descriptors (TDs) is attached. The ED contains the maximum packet size allowed for "
"an endpoint and the controller hardware does the splitting into packets. The "
"pointers to the data buffers are updated after each transfer and when the start and "
"end pointer are equal, the TD is retired to the done-queue. The four types of "
"endpoints (interrupt, isochronous, control, and bulk) have their own queues. Control "
"and bulk endpoints are queued each at their own queue. Interrupt EDs are queued in a "
"tree, with the level in the tree defining the frequency at which they run."
msgstr ""
"A programaÁ„o de um controlador host OHCI È muito mais simples. O controlador assume "
"que um conjunto de terminais est· disponÌ≠vel e est· ciente das prioridades de "
"planejamento e da ordenaÁ„o dos tipos de transferÍncias em um quadro. A estrutura de "
"dados principal usada pelo controlador host È a descritor de endpoint (ED) ao qual "
"uma fila de descritores de transferÍncia (TDs) È anexada.O ED contÈm o tamanho "
"m·ximo de pacote permitido para um endpoint e o hardware do controlador faz a "
"divis„o em pacotes.Os ponteiros para os buffers de dados s„o atualizados apÛs cada "
"transferÍncia e quando o ponteiro inicial e final s„o iguais, o TD È retirado para a "
"fila done.Os quatro tipos de endpoints (interrupÁ„o, isÛcrono, controle e bulk) tÍm "
"suas prÛprias filas.Os endpoints de controle e em massa s„o enfileirados cada um em "
"suas prÛprias filas. Os EDs de interrupÁ„o s„o enfileirados em uma ·rvore, com o nÌ≠"
"vel na ·rvore definindo a frequÍncia na qual eles s„o executados. "

#: book.translate.xml:21837
#, fuzzy
msgid ""
"The schedule being run by the host controller in each frame looks as follows. The "
"controller will first run the non-periodic control and bulk queues, up to a time "
"limit set by the HC driver. Then the interrupt transfers for that frame number are "
"run, by using the lower five bits of the frame number as an index into level 0 of "
"the tree of interrupts EDs. At the end of this tree the isochronous EDs are "
"connected and these are traversed subsequently. The isochronous TDs contain the "
"frame number of the first frame the transfer should be run in. After all the "
"periodic transfers have been run, the control and bulk queues are traversed again. "
"Periodically the interrupt service routine is called to process the done queue and "
"call the callbacks for each transfer and reschedule interrupt and isochronous "
"endpoints."
msgstr ""
"O agendamento que est· sendo executado pelo controlador host em cada quadro È o "
"seguinte. O controlador primeiro executar· o controle n„o periÛdico e as filas em "
"massa, atÈ um limite de tempo definido pelo driver HC. Ent„o as transferÍncias de "
"interrupÁ„o para esse n˙mero de quadros s„o executado, usando os cinco bits "
"inferiores do n˙mero do quadro como um Ì≠ndice no nÌ≠vel 0 da ·rvore de interrupÁÌµes "
"EDs. No final desta ·rvore os EDs isÛcronos s„o conectados e estes s„o percorridos "
"subseqÌºentemente.Os TDs isÛcronos contÍm o n˙mero do quadro de interrupÁÌµes. o "
"primeiro quadro em que a transferÍncia deve ser executada. Depois que todas as "
"transferÍncias periÛdicas tiverem sido executadas, as filas de controle e em massa "
"ser„o novamente percorridas. Periodicamente, a rotina de serviÁo de interrupÁ„o È "
"chamada para processar a fila concluÌ≠da e chamar os retornos de chamada para cada "
"interrupÁ„o de transferÍncia e reprogramaÁ„o e pontos finais isÛcronos \""

#: book.translate.xml:21853
#, fuzzy
msgid ""
"See the <acronym>UHCI</acronym> Specification for a more elaborate description. The "
"middle layer provides access to the device in a controlled way and maintains "
"resources in use by the different drivers and the services layer. The layer takes "
"care of the following aspects:"
msgstr ""
"Veja a EspecificaÁ„o <acronym>UHCI</acronym> para uma descriÁ„o mais elaborada. A "
"camada intermedi·ria fornece acesso ao dispositivo de maneira controlada e mantÈm os "
"recursos em uso pelos diferentes drivers e pela camada de serviÁos. A camada cuida "
"dos seguintes aspectos:"

#: book.translate.xml:21861
#, fuzzy
msgid "The device configuration information"
msgstr "A informaÁ„o de configuraÁ„o do dispositivo"

#: book.translate.xml:21863
#, fuzzy
msgid "The pipes to communicate with a device"
msgstr "Os canais para se comunicar com um dispositivo"

#: book.translate.xml:21865
#, fuzzy
msgid "Probing and attaching and detaching form a device."
msgstr "Sondar e anexar e desanexar formam um dispositivo."

#: book.translate.xml:21873
#, fuzzy
msgid "USB Device Information"
msgstr "InformaÁÌµes do dispositivo USB"

#: book.translate.xml:21876
#, fuzzy
msgid "Device Configuration Information"
msgstr "InformaÁÌµes de configuraÁ„o do dispositivo"

#: book.translate.xml:21878
#, fuzzy
msgid ""
"Each device provides different levels of configuration information. Each device has "
"one or more configurations, of which one is selected during probe/attach. A "
"configuration provides power and bandwidth requirements. Within each configuration "
"there can be multiple interfaces. A device interface is a collection of endpoints. "
"For example USB speakers can have an interface for the audio data (Audio Class) and "
"an interface for the knobs, dials and buttons (HID Class). All interfaces in a "
"configuration are active at the same time and can be attached to by different "
"drivers. Each interface can have alternates, providing different quality of service "
"parameters. In for example cameras this is used to provide different frame sizes and "
"numbers of frames per second."
msgstr ""
"Cada dispositivo fornece diferentes nÌ≠veis de informaÁÌµes de configuraÁ„o. Cada "
"dispositivo tem uma ou mais configuraÁÌµes, uma das quais È selecionada durante a "
"sonda / conex„o. Uma configuraÁ„o fornece requisitos de potÍncia e largura de banda. "
"Dentro de cada configuraÁ„o pode haver v·rias interfaces. Uma interface de "
"dispositivo È uma coleÁ„o de pontos de extremidade.Por exemplo, os alto-falantes USB "
"podem ter uma interface para os dados de ·udio (classe de ·udio) e uma interface "
"para os botÌµes, botÌµes e mostradores (classe HID) .Todas as interfaces em uma "
"configuraÁ„o est„o ativas ao mesmo tempo por diferentes drivers. Cada interface pode "
"ter alternativas, fornecendo diferentes parÌ¢metros de qualidade de serviÁo. Em cÌ"
"¢meras, por exemplo, isso È usado para fornecer diferentes tamanhos de quadros e "
"n˙meros de quadros por segundo. "

#: book.translate.xml:21893
#, fuzzy
msgid ""
"Within each interface, 0 or more endpoints can be specified. Endpoints are the "
"unidirectional access points for communicating with a device. They provide buffers "
"to temporarily store incoming or outgoing data from the device. Each endpoint has a "
"unique address within a configuration, the endpoint's number plus its direction. The "
"default endpoint, endpoint 0, is not part of any interface and available in all "
"configurations. It is managed by the services layer and not directly available to "
"device drivers."
msgstr ""
"Dentro de cada interface, 0 ou mais nÛs de extremidade podem ser especificados. Os "
"pontos de extremidade s„o os pontos de acesso unidirecionais para comunicaÁ„o com um "
"dispositivo. Eles fornecem buffers para armazenar temporariamente dados de entrada "
"ou saÌ≠da do dispositivo. Cada nÛ de extremidade possui um endereÁo exclusivo dentro "
"de uma configuraÁ„o. O n˙mero do nÛ de extremidade mais sua direÁ„o. O ponto de "
"extremidade padr„o, ponto de extremidade 0, n„o faz parte de nenhuma interface e "
"est· disponÌ≠vel em todas as configuraÁÌµes. Ele È gerenciado pela camada de serviÁos "
"e n„o est· diretamente disponÌ≠vel para os drivers de dispositivos. "

#: book.translate.xml:21909
#, fuzzy
msgid ""
"This hierarchical configuration information is described in the device by a standard "
"set of descriptors (see section 9.6 of the USB specification). They can be requested "
"through the Get Descriptor Request. The services layer caches these descriptors to "
"avoid unnecessary transfers on the USB bus. Access to the descriptors is provided "
"through function calls."
msgstr ""
"Essas informaÁÌµes de configuraÁ„o hier·rquica s„o descritas no dispositivo por um "
"conjunto padr„o de descritores (consulte a seÁ„o 9.6 da especificaÁ„o USB). Elas "
"podem ser solicitadas por meio da solicitaÁ„o Get Descriptor. A camada de serviÁos "
"armazena esses descritores para evitar transferÍncias desnecess·rias no barramento "
"USB O acesso aos descritores È fornecido atravÈs de chamadas de funÁ„o. "

#: book.translate.xml:21918
#, fuzzy
msgid ""
"Device descriptors: General information about the device, like Vendor, Product and "
"Revision Id, supported device class, subclass and protocol if applicable, maximum "
"packet size for the default endpoint, etc."
msgstr ""
"Descritores de dispositivo: informaÁÌµes gerais sobre o dispositivo, como "
"fornecedor, produto e ID de revis„o, classe de dispositivo compatÌ≠vel, subclasse e "
"protocolo, se aplic·vel, tamanho m·ximo de pacote para o endpoint padr„o etc."

#: book.translate.xml:21923
#, fuzzy
msgid ""
"Configuration descriptors: The number of interfaces in this configuration, suspend "
"and resume functionality supported and power requirements."
msgstr ""
"Descritores de configuraÁ„o: o n˙mero de interfaces nesta configuraÁ„o, suspender e "
"retomar a funcionalidade suportada e os requisitos de energia."

#: book.translate.xml:21928
#, fuzzy
msgid ""
"Interface descriptors: interface class, subclass and protocol if applicable, number "
"of alternate settings for the interface and the number of endpoints."
msgstr ""
"Descritores de interface: classe de interface, subclasse e protocolo, se aplic·vel, "
"n˙mero de configuraÁÌµes alternativas para a interface e o n˙mero de pontos de "
"extremidade."

#: book.translate.xml:21933
#, fuzzy
msgid ""
"Endpoint descriptors: Endpoint address, direction and type, maximum packet size "
"supported and polling frequency if type is interrupt endpoint. There is no "
"descriptor for the default endpoint (endpoint 0) and it is never counted in an "
"interface descriptor."
msgstr ""
"Endpoint descriptors: EndereÁo, direÁ„o e tipo do endpoint, tamanho m·ximo do pacote "
"suportado e frequÍncia de sondagem se o tipo for ponto final de interrupÁ„o. N„o h· "
"um descritor para o endpoint padr„o (endpoint 0) e ele nunca È contado em um "
"descritor de interface."

#: book.translate.xml:21939
#, fuzzy
msgid ""
"String descriptors: In the other descriptors string indices are supplied for some "
"fields.These can be used to retrieve descriptive strings, possibly in multiple "
"languages."
msgstr ""
"Descritores de strings: Nos outros descritores, s„o fornecidos Ì≠ndices de strings "
"para alguns campos. Eles podem ser usados ‚Äã‚Äãpara recuperar strings descritivas, "
"possivelmente em m˙ltiplos idiomas."

#: book.translate.xml:21946
#, fuzzy
msgid ""
"Class specifications can add their own descriptor types that are available through "
"the GetDescriptor Request."
msgstr ""
"As especificaÁÌµes de classe podem adicionar seus prÛprios tipos de descritores que "
"est„o disponÌ≠veis por meio da solicitaÁ„o GetDescriptor."

#: book.translate.xml:21949
#, fuzzy
msgid ""
"Pipes Communication to end points on a device flows through so-called pipes. Drivers "
"submit transfers to endpoints to a pipe and provide a callback to be called on "
"completion or failure of the transfer (asynchronous transfers) or wait for "
"completion (synchronous transfer). Transfers to an endpoint are serialised in the "
"pipe. A transfer can either complete, fail or time-out (if a time-out has been set). "
"There are two types of time-outs for transfers. Time-outs can happen due to time-out "
"on the USBbus (milliseconds). These time-outs are seen as failures and can be due to "
"disconnection of the device. A second form of time-out is implemented in software "
"and is triggered when a transfer does not complete within a specified amount of time "
"(seconds). These are caused by a device acknowledging negatively (NAK) the "
"transferred packets. The cause for this is the device not being ready to receive "
"data, buffer under- or overrun or protocol errors."
msgstr ""
"Pipes ComunicaÁ„o para pontos finais em um dispositivo flui atravÈs de chamados "
"pipes. Drivers enviam transferÍncias para pontos de extremidade para um pipe e "
"fornecem um retorno de chamada a ser chamado na conclus„o ou falha da transferÍncia "
"(transferÍncias assÌ≠ncronas) ou aguardar conclus„o (transferÍncia sÌ≠ncrona) "
"TransferÍncias para um endpoint s„o serializadas no pipe Uma transferÍncia pode ser "
"completada, falha ou time-out (se um time-out tiver sido definido) Existem dois "
"tipos de time-outs para transferÍncias. para time-out no USBbus (milissegundos). "
"Estes tempos debitados s„o vistos como falhas e podem ser devidos Ì† desconex„o do "
"dispositivo.Uma segunda forma de time-out È implementada no software e È disparada "
"quando uma transferÍncia n„o È concluÌ≠da dentro um determinado perÌ≠odo de tempo "
"(segundos). Eles s„o causados ‚Äã‚Äãpor um dispositivo que reconhece negativamente (NAK) "
"os pacotes transferidos. A causa para isso È o dispositivo n„o estar pronto para "
"receber dados, erros de buffer ou de sub ou de protocolo. "

#: book.translate.xml:21967
#, fuzzy
msgid ""
"If a transfer over a pipe is larger than the maximum packet size specified in the "
"associated endpoint descriptor, the host controller (OHCI) or the HC driver (UHCI) "
"will split the transfer into packets of maximum packet size, with the last packet "
"possibly smaller than the maximum packet size."
msgstr ""
"Se uma transferÍncia em um pipe for maior que o tamanho m·ximo de pacote "
"especificado no descritor de terminal associado, o controlador host (OHCI) ou o "
"driver HC (UHCI) dividir· a transferÍncia em pacotes de tamanho m·ximo de pacote, "
"com o ˙ltimo pacote possivelmente menor que o tamanho m·ximo do pacote. "

#: book.translate.xml:21974
#, fuzzy
msgid ""
"Sometimes it is not a problem for a device to return less data than requested. For "
"example abulk-in-transfer to a modem might request 200 bytes of data, but the modem "
"has only 5 bytes available at that time. The driver can set the short packet (SPD) "
"flag. It allows the host controller to accept a packet even if the amount of data "
"transferred is less than requested. This flag is only valid for in-transfers, as the "
"amount of data to be sent to a device is always known beforehand. If an "
"unrecoverable error occurs in a device during a transfer the pipe is stalled. Before "
"any more data is accepted or sent the driver needs to resolve the cause of the stall "
"and clear the endpoint stall condition through send the clear endpoint halt device "
"request over the default pipe. The default endpoint should never stall."
msgstr ""
"ÌÄs vezes, n„o È um problema para um dispositivo retornar menos dados do que o "
"solicitado. Por exemplo, a transferÍncia de dados em um modem pode solicitar 200 "
"bytes de dados, mas o modem tem apenas 5 bytes disponÌ≠veis no momento. O driver pode "
"definir O sinalizador de pacote curto (SPD) permite que o controlador host aceite um "
"pacote, mesmo que a quantidade de dados transferidos seja menor que a solicitada, "
"este sinalizador sÛ È v·lido para transferÍncias, como a quantidade de dados a ser "
"enviada para um dispositivo. Se um erro irrecuper·vel ocorrer em um dispositivo "
"durante uma transferÍncia, o tubo ser· paralisado.Antes de mais dados serem aceitos "
"ou enviados, o driver precisa resolver a causa da paralisaÁ„o e limpar a condiÁ„o de "
"parada do endpoint atravÈs do envio do ponto de extremidade limpo interromper a "
"solicitaÁ„o do dispositivo pelo canal padr„o. O ponto de extremidade padr„o nunca "
"deve parar. "

#: book.translate.xml:21989
#, fuzzy
msgid ""
"There are four different types of endpoints and corresponding pipes: - Control "
"pipe / default pipe: There is one control pipe per device, connected to the default "
"endpoint (endpoint 0). The pipe carries the device requests and associated data. The "
"difference between transfers over the default pipe and other pipes is that the "
"protocol for the transfers is described in the USB specification. These requests are "
"used to reset and configure the device. A basic set of commands that must be "
"supported by each device is provided in chapter 9 of the USB specification. The "
"commands supported on this pipe can be extended by a device class specification to "
"support additional functionality."
msgstr ""
"Existem quatro tipos diferentes de terminais e canais correspondentes: - Canal de "
"controle / canal padr„o: H· um canal de controle por dispositivo, conectado ao ponto "
"de extremidade padr„o (ponto de extremidade 0). O canal transporta as solicitaÁÌµes "
"de dispositivo e dados associados. A diferenÁa entre transferÍncias atravÈs do pipe "
"padr„o e outros canais È que o protocolo para as transferÍncias È descrito na "
"especificaÁ„o USB.Esses pedidos s„o usados ‚Äã‚Äãpara redefinir e configurar o "
"dispositivo.Um conjunto b·sico de comandos que devem ser suportados por cada "
"dispositivo È fornecido no capÌ≠tulo 9 da especificaÁ„o USB. Os comandos suportados "
"neste pipe podem ser estendidos por uma especificaÁ„o de classe de dispositivo para "
"suportar funcionalidades adicionais. "

#: book.translate.xml:22004
#, fuzzy
msgid "Bulk pipe: This is the USB equivalent to a raw transmission medium."
msgstr "Tubo em massa: este È o equivalente USB a um meio de transmiss„o bruto."

#: book.translate.xml:22006
#, fuzzy
msgid ""
"Interrupt pipe: The host sends a request for data to the device and if the device "
"has nothing to send, it will NAK the data packet. Interrupt transfers are scheduled "
"at a frequency specified when creating the pipe."
msgstr ""
"Interrupt pipe: O host envia uma solicitaÁ„o de dados para o dispositivo e se o "
"dispositivo n„o tiver nada para enviar, ele NAK o pacote de dados. Interromper "
"transferÍncias s„o agendadas em uma freqÌºÍncia especificada ao criar o pipe."

#: book.translate.xml:22012
#, fuzzy
msgid ""
"Isochronous pipe: These pipes are intended for isochronous data, for example video "
"or audio streams, with fixed latency, but no guaranteed delivery. Some support for "
"pipes of this type is available in the current implementation. Packets in control, "
"bulk and interrupt transfers are retried if an error occurs during transmission or "
"the device acknowledges the packet negatively (NAK) due to for example lack of "
"buffer space to store the incoming data. Isochronous packets are however not retried "
"in case of failed delivery or NAK of a packet as this might violate the timing "
"constraints."
msgstr ""
"Tubo IsÛcrono: Esses canos s„o destinados a dados isÛcronos, por exemplo, fluxos de "
"vÌ≠deo ou ·udio, com latÍncia fixa, mas sem entrega garantida. Algum suporte para "
"tubos deste tipo est· disponÌ≠vel na implementaÁ„o atual. Pacotes no controle, em "
"massa e interrupÁ„o de transferÍncias s„o repetidos se ocorrer um erro durante a "
"transmiss„o ou o dispositivo reconhecer o pacote negativamente (NAK) devido a, por "
"exemplo, falta de espaÁo no buffer para armazenar os dados recebidos.N„o È possÌ≠vel "
"tentar novamente pacotes isÛcronos em caso de falha na entrega ou NAK de um pacote. "
"pode violar as restriÁÌµes de tempo. "

#: book.translate.xml:22025
#, fuzzy
msgid ""
"The availability of the necessary bandwidth is calculated during the creation of the "
"pipe. Transfers are scheduled within frames of 1 millisecond. The bandwidth "
"allocation within a frame is prescribed by the USB specification, section 5.6 [ 2]. "
"Isochronous and interrupt transfers are allowed to consume up to 90% of the "
"bandwidth within a frame. Packets for control and bulk transfers are scheduled after "
"all isochronous and interrupt packets and will consume all the remaining bandwidth."
msgstr ""
"A disponibilidade da largura de banda necess·ria È calculada durante a criaÁ„o do "
"pipe. As transferÍncias s„o programadas em quadros de 1 milissegundo. A alocaÁ„o de "
"largura de banda dentro de um quadro È prescrita pela especificaÁ„o USB, seÁ„o 5.6 "
"[2]. S„o permitidas transferÍncias isÛcronas e de interrupÁ„o para consumir atÈ 90% "
"da largura de banda dentro de um quadro. Pacotes para controle e transferÍncias em "
"massa s„o agendados apÛs todos os pacotes isÛcronos e de interrupÁ„o e consumir„o "
"toda a largura de banda restante. "

#: book.translate.xml:22035
#, fuzzy
msgid ""
"More information on scheduling of transfers and bandwidth reclamation can be found "
"in chapter 5 of the USB specification, section 1.3 of the UHCI specification, and "
"section 3.4.2 of the OHCI specification."
msgstr ""
"Mais informaÁÌµes sobre o agendamento de transferÍncias e a recuperaÁ„o de banda "
"podem ser encontradas no capÌ≠tulo 5 da especificaÁ„o USB, na seÁ„o 1.3 da "
"especificaÁ„o UHCI e na seÁ„o 3.4.2 da especificaÁ„o OHCI."

#: book.translate.xml:22044
#, fuzzy
msgid "Device Probe and Attach"
msgstr "Device Probe and Attach"

#: book.translate.xml:22046
#, fuzzy
msgid "<primary>USB</primary><secondary>probe</secondary>"
msgstr " <primary> USB </primary><secondary> sonda </secondary> "

#: book.translate.xml:22047
#, fuzzy
msgid ""
"After the notification by the hub that a new device has been connected, the service "
"layer switches on the port, providing the device with 100 mA of current. At this "
"point the device is in its default state and listening to device address 0. The "
"services layer will proceed to retrieve the various descriptors through the default "
"pipe. After that it will send a Set Address request to move the device away from the "
"default device address (address 0). Multiple device drivers might be able to support "
"the device. For example a modem driver might be able to support an ISDN TA through "
"the AT compatibility interface. A driver for that specific model of the ISDN adapter "
"might however be able to provide much better support for this device. To support "
"this flexibility, the probes return priorities indicating their level of support. "
"Support for a specific revision of a product ranks the highest and the generic "
"driver the lowest priority. It might also be that multiple drivers could attach to "
"one device if there are multiple interfaces within one configuration. Each driver "
"only needs to support a subset of the interfaces."
msgstr ""
"ApÛs a notificaÁ„o pelo hub de que um novo dispositivo foi conectado, a camada de "
"serviÁo liga a porta, fornecendo ao dispositivo 100 mA de corrente. Neste ponto, o "
"dispositivo est· no estado padr„o e escutando o endereÁo 0 do dispositivo. A camada "
"de serviÁos proceder· Ì† recuperaÁ„o dos v·rios descritores por meio do canal padr„o "
"e, depois disso, enviar· uma solicitaÁ„o Set Address para afastar o dispositivo do "
"endereÁo padr„o do dispositivo (endereÁo 0). V·rios drivers de dispositivo podem ser "
"compatÌ≠veis com o dispositivo. Por exemplo, um driver de modem pode ser capaz de "
"suportar um ISDN TA atravÈs da interface de compatibilidade AT Um driver para esse "
"modelo especÌ≠fico do adaptador ISDN pode, no entanto, ser capaz de fornecer um "
"suporte muito melhor para este dispositivo Para suportar essa flexibilidade, as "
"sondas retornam prioridades indicando o seu nÌ≠vel de suporte Suporte para uma "
"revis„o especÌ≠fica de um produto classifica o mais alto eo driver genÈrico a menor "
"prioridade.Pode tambÈm ser que v·rios drivers poderiam anexar a um dev gelo se "
"houver v·rias interfaces dentro de uma configuraÁ„o. Cada driver precisa apenas "
"suportar um subconjunto das interfaces. "

#: book.translate.xml:22066
#, fuzzy
msgid ""
"The probing for a driver for a newly attached device checks first for device "
"specific drivers. If not found, the probe code iterates over all supported "
"configurations until a driver attaches in a configuration. To support devices with "
"multiple drivers on different interfaces, the probe iterates over all interfaces in "
"a configuration that have not yet been claimed by a driver. Configurations that "
"exceed the power budget for the hub are ignored. During attach the driver should "
"initialise the device to its proper state, but not reset it, as this will make the "
"device disconnect itself from the bus and restart the probing process for it. To "
"avoid consuming unnecessary bandwidth should not claim the interrupt pipe at attach "
"time, but should postpone allocating the pipe until the file is opened and the data "
"is actually used. When the file is closed the pipe should be closed again, even "
"though the device might still be attached."
msgstr ""
"A detecÁ„o de um driver para um dispositivo recÈm-conectado verifica primeiro os "
"drivers especÌ≠ficos do dispositivo. Se n„o encontrado, o cÛdigo do probe repete "
"todas as configuraÁÌµes suportadas atÈ que um driver seja anexado em uma "
"configuraÁ„o. Para suportar dispositivos com v·rios drivers em diferentes interfaces "
"itera em todas as interfaces em uma configuraÁ„o que ainda n„o foi reivindicada por "
"um driver. As configuraÁÌµes que excedem o orÁamento de energia para o hub s„o "
"ignoradas. Durante a conex„o, o driver deve inicializar o dispositivo no estado "
"correto, mas n„o redefini-lo, pois isso faÁa com que o dispositivo desconecte-se do "
"barramento e reinicie o processo de teste para evitar o consumo de largura de banda "
"desnecess·ria n„o deve reivindicar o pipe de interrupÁ„o no momento da conex„o, mas "
"deve adiar a alocaÁ„o do canal atÈ que o arquivo seja aberto e os dados realmente "
"usados. o arquivo est· fechado, o tubo deve ser fechado novamente, mesmo que o "
"dispositivo ainda possa estar conectado. "

#: book.translate.xml:22084
#, fuzzy
msgid "Device Disconnect and Detach"
msgstr "Desconectar e desanexar o dispositivo"

#: book.translate.xml:22086
#, fuzzy
msgid "<primary>USB</primary><secondary>disconnect</secondary>"
msgstr " <primary> USB </primary><secondary> desconectar </secondary> "

#: book.translate.xml:22087
#, fuzzy
msgid ""
"A device driver should expect to receive errors during any transaction with the "
"device. The design of USB supports and encourages the disconnection of devices at "
"any point in time. Drivers should make sure that they do the right thing when the "
"device disappears."
msgstr ""
"Um driver de dispositivo deve esperar receber erros durante qualquer transaÁ„o com o "
"dispositivo. O design do USB suporta e encoraja a desconex„o de dispositivos a "
"qualquer momento. Os drivers devem garantir que eles faÁam a coisa certa quando o "
"dispositivo desaparecer."

#: book.translate.xml:22093
#, fuzzy
msgid ""
"Furthermore a device that has been disconnected and reconnected will not be "
"reattached at the same device instance. This might change in the future when more "
"devices support serial numbers (see the device descriptor) or other means of "
"defining an identity for a device have been developed."
msgstr ""
"AlÈm disso, um dispositivo que tenha sido desconectado e reconectado n„o ser· "
"reconectado na mesma instÌ¢ncia do dispositivo. Isso pode mudar no futuro quando "
"mais dispositivos suportarem n˙meros de sÈrie (consulte o descritor de dispositivo) "
"ou outros meios de definir uma identidade para um dispositivo. desenvolvido."

#: book.translate.xml:22100
#, fuzzy
msgid ""
"The disconnection of a device is signaled by a hub in the interrupt packet delivered "
"to the hub driver. The status change information indicates which port has seen a "
"connection change. The device detach method for all device drivers for the device "
"connected on that port are called and the structures cleaned up. If the port status "
"indicates that in the mean time a device has been connected to that port, the "
"procedure for probing and attaching the device will be started. A device reset will "
"produce a disconnect-connect sequence on the hub and will be handled as described "
"above."
msgstr ""
"A desconex„o de um dispositivo È sinalizada por um hub no pacote de interrupÁ„o "
"entregue ao driver do hub. As informaÁÌµes de mudanÁa de status indicam qual porta "
"detectou uma alteraÁ„o de conex„o. O mÈtodo de remoÁ„o de dispositivo para todos os "
"drivers de dispositivos conectados ao dispositivo est· Se o status da porta indicar "
"que, nesse meio tempo, um dispositivo foi conectado a essa porta, ser· iniciado o "
"procedimento para sondar e conectar o dispositivo.Uma reinicializaÁ„o do dispositivo "
"produzir· uma sequÍncia de conex„o de desconex„o no sistema. hub e ser· tratado "
"conforme descrito acima. "

#: book.translate.xml:22115
#, fuzzy
msgid "USB Drivers Protocol Information"
msgstr "InformaÁÌµes do protocolo de drivers USB"

#: book.translate.xml:22117
#, fuzzy
msgid ""
"The protocol used over pipes other than the default pipe is undefined by the USB "
"specification. Information on this can be found from various sources. The most "
"accurate source is the developer's section on the USB home pages. From these pages, "
"a growing number of deviceclass specifications are available. These specifications "
"specify what a compliant device should look like from a driver perspective, basic "
"functionality it needs to provide and the protocol that is to be used over the "
"communication channels. The USB specification includes the description of the Hub "
"Class. A class specification for Human Interface Devices (HID) has been created to "
"cater for keyboards, tablets, bar-code readers, buttons, knobs, switches, etc. A "
"third example is the class specification for mass storage devices. For a full list "
"of device classes see the developers section on the USB home pages."
msgstr ""
"O protocolo usado em outros pipes alÈm do pipe padr„o È indefinido pela "
"especificaÁ„o USB. InformaÁÌµes sobre isso podem ser encontradas em v·rias fontes. A "
"fonte mais precisa È a seÁ„o do desenvolvedor nas home pages USB. A partir dessas "
"p·ginas, um n˙mero crescente de Est„o disponÌ≠veis especificaÁÌµes deviceclass Estas "
"especificaÁÌµes especificam como deve ser um dispositivo compatÌ≠vel do ponto de "
"vista do driver, a funcionalidade b·sica que ele precisa fornecer e o protocolo que "
"deve ser usado nos canais de comunicaÁ„o.A especificaÁ„o USB inclui a descriÁ„o da "
"Classe Hub. Uma especificaÁ„o de classe para dispositivos de interface humana (HID) "
"foi criada para atender a teclados, tablets, leitores de cÛdigo de barras, botÌµes, "
"botÌµes, switches, etc. Um terceiro exemplo È a especificaÁ„o de classe para "
"dispositivos de armazenamento em massa. classes de dispositivos, consulte a seÁ„o de "
"desenvolvedores nas p·ginas iniciais do USB. "

#: book.translate.xml:22133
#, fuzzy
msgid ""
"For many devices the protocol information has not yet been published however. "
"Information on the protocol being used might be available from the company making "
"the device. Some companies will require you to sign a Non -Disclosure Agreement "
"(NDA) before giving you the specifications. This in most cases precludes making the "
"driver open source."
msgstr ""
"Para muitos dispositivos, as informaÁÌµes do protocolo ainda n„o foram publicadas. "
"InformaÁÌµes sobre o protocolo usado podem estar disponÌ≠veis na empresa que faz o "
"dispositivo. Algumas empresas exigir„o que vocÍ assine um Acordo de N„o-DivulgaÁ„o "
"(NDA) antes de fornecer as especificaÁÌµes. Isso, na maioria dos casos, impede que o "
"driver seja open source. "

#: book.translate.xml:22140
#, fuzzy
msgid ""
"Another good source of information is the Linux driver sources, as a number of "
"companies have started to provide drivers for Linux for their devices. It is always "
"a good idea to contact the authors of those drivers for their source of information."
msgstr ""
"Outra boa fonte de informaÁ„o s„o as fontes de drivers do Linux, j· que v·rias "
"empresas comeÁaram a fornecer drivers para o Linux em seus dispositivos. Ìâ sempre "
"uma boa idÈia entrar em contato com os autores desses drivers para obter "
"informaÁÌµes."

#: book.translate.xml:22146
#, fuzzy
msgid ""
"Example: Human Interface Devices The specification for the Human Interface Devices "
"like keyboards, mice, tablets, buttons, dials,etc. is referred to in other device "
"class specifications and is used in many devices."
msgstr ""
"Exemplo: dispositivos de interface humana A especificaÁ„o para dispositivos de "
"interface humana como teclados, mouses, tablets, botÌµes, dials, etc. È referida em "
"outras especificaÁÌµes de classe de dispositivo e È usada em muitos dispositivos."

#: book.translate.xml:22151
#, fuzzy
msgid ""
"For example audio speakers provide endpoints to the digital to analogue converters "
"and possibly an extra pipe for a microphone. They also provide a HID endpoint in a "
"separate interface for the buttons and dials on the front of the device. The same is "
"true for the monitor control class. It is straightforward to build support for these "
"interfaces through the available kernel and userland libraries together with the HID "
"class driver or the generic driver. Another device that serves as an example for "
"interfaces within one configuration driven by different device drivers is a cheap "
"keyboard with built-in legacy mouse port. To avoid having the cost of including the "
"hardware for a USB hub in the device, manufacturers combined the mouse data received "
"from the PS/2 port on the back of the keyboard and the key presses from the keyboard "
"into two separate interfaces in the same configuration. The mouse and keyboard "
"drivers each attach to the appropriate interface and allocate the pipes to the two "
"independent endpoints."
msgstr ""
"Por exemplo, os alto-falantes de ·udio fornecem pontos finais para os conversores "
"digitais para analÛgicos e possivelmente um tubo extra para um microfone. Eles "
"tambÈm fornecem um ponto de extremidade HID em uma interface separada para os "
"botÌµes e mostradores na frente do dispositivo. O mesmo vale para o Ìâ f·cil criar "
"suporte para essas interfaces por meio das bibliotecas kernel e userland disponÌ≠"
"veis, juntamente com o driver de classe HID ou o driver genÈrico.Um outro "
"dispositivo que serve como exemplo para interfaces dentro de uma configuraÁ„o "
"controlada por drivers de dispositivo diferentes È um Teclado barato com porta de "
"mouse legado integrada Para evitar o custo de incluir o hardware de um hub USB no "
"dispositivo, os fabricantes combinaram os dados do mouse recebidos da porta PS / 2 "
"na parte de tr·s do teclado e as teclas pressionadas de o teclado em duas interfaces "
"separadas na mesma configuraÁ„o.Os drivers de mouse e teclado cada um anexar Ì† "
"interface apropriada e alocar os tubos para os dois endpoints independentes. "

#: book.translate.xml:22170
#, fuzzy
msgid "<primary>USB</primary><secondary>firmware</secondary>"
msgstr " <primary> USB </primary><secondary> firmware </secondary> "

#: book.translate.xml:22171
#, fuzzy
msgid ""
"Example: Firmware download Many devices that have been developed are based on a "
"general purpose processor with an additional USB core added to it. Because the "
"development of drivers and firmware for USB devices is still very new, many devices "
"require the downloading of the firmware after they have been connected."
msgstr ""
"Exemplo: download de firmware Muitos dispositivos que foram desenvolvidos s„o "
"baseados em um processador de uso geral com um n˙cleo USB adicional. Como o "
"desenvolvimento de drivers e firmware para dispositivos USB ainda È muito novo, "
"muitos dispositivos exigem o download do firmware depois de terem sido conectados \""

#: book.translate.xml:22178
#, fuzzy
msgid ""
"The procedure followed is straightforward. The device identifies itself through a "
"vendor and product Id. The first driver probes and attaches to it and downloads the "
"firmware into it. After that the device soft resets itself and the driver is "
"detached. After a short pause the device announces its presence on the bus. The "
"device will have changed its vendor/product/revision Id to reflect the fact that it "
"has been supplied with firmware and as a consequence a second driver will probe it "
"and attach to it."
msgstr ""
"O procedimento seguido È direto. O dispositivo se identifica por meio de um "
"fornecedor e um ID do produto. O primeiro driver detecta e anexa a ele e faz o "
"download do firmware. Depois disso, o dispositivo È reiniciado e o driver È "
"desconectado. ApÛs uma breve pausa o dispositivo anuncia sua presenÁa no barramento. "
"O dispositivo ter· mudado seu ID de fornecedor / produto / revis„o para refletir o "
"fato de que ele foi fornecido com firmware e, como conseqÌºÍncia, um segundo driver "
"ir· sond·-lo e anex·-lo. "

#: book.translate.xml:22188
#, fuzzy
msgid ""
"An example of these types of devices is the ActiveWire I/O board, based on the EZ-"
"USB chip. For this chip a generic firmware downloader is available. The firmware "
"downloaded into the ActiveWire board changes the revision Id. It will then perform a "
"soft reset of the USB part of the EZ-USB chip to disconnect from the USB bus and "
"again reconnect."
msgstr ""
"Um exemplo desses tipos de dispositivos È a placa de E / S do ActiveWire, baseada no "
"chip EZ-USB. Para este chip, um downloader de firmware genÈrico est· disponÌ≠vel. O "
"firmware baixado no quadro do ActiveWire altera o ID da revis„o. uma reinicializaÁ„o "
"suave da parte USB do chip EZ-USB para desconectar do barramento USB e reconectar "
"novamente. "

#: book.translate.xml:22195
#, fuzzy
msgid ""
"Example: Mass Storage Devices Support for mass storage devices is mainly built "
"around existing protocols. The Iomega USB Zipdrive is based on the SCSI version of "
"their drive. The SCSI commands and status messages are wrapped in blocks and "
"transferred over the bulk pipes to and from the device, emulating a SCSI controller "
"over the USB wire. ATAPI and UFI commands are supported in a similar fashion."
msgstr ""
"Exemplo: Dispositivos de armazenamento em massa O suporte para dispositivos de "
"armazenamento em massa È construÌ≠do principalmente em torno dos protocolos "
"existentes. O Iomega USB Zipdrive È baseado na vers„o SCSI da unidade. Os comandos "
"SCSI e as mensagens de status s„o agrupados em blocos e transferidos para a partir "
"do dispositivo, emulando um controlador SCSI atravÈs do cabo USB. Os comandos ATAPI "
"e UFI s„o suportados de forma semelhante. "

#: book.translate.xml:22203
#, fuzzy
msgid "<primary>ATAPI</primary>"
msgstr " <primary> ATAPI </primary> "

#: book.translate.xml:22205
#, fuzzy
msgid ""
"The Mass Storage Specification supports 2 different types of wrapping of the command "
"block.The initial attempt was based on sending the command and status through the "
"default pipe and using bulk transfers for the data to be moved between the host and "
"the device. Based on experience a second approach was designed that was based on "
"wrapping the command and status blocks and sending them over the bulk out and in "
"endpoint. The specification specifies exactly what has to happen when and what has "
"to be done in case an error condition is encountered. The biggest challenge when "
"writing drivers for these devices is to fit USB based protocol into the existing "
"support for mass storage devices. CAM provides hooks to do this in a fairly straight "
"forward way. ATAPI is less simple as historically the IDE interface has never had "
"many different appearances."
msgstr ""
"A especificaÁ„o de armazenamento em massa suporta dois tipos diferentes de quebra "
"autom·tica do bloco de comando. A tentativa inicial foi baseada no envio do comando "
"e status atravÈs do pipe padr„o e usando transferÍncias em massa para os dados a "
"serem movidos entre o host e o dispositivo. experiÍncia uma segunda abordagem foi "
"projetada com base em agrupar os blocos de comando e status e envi·-los pelo bulk "
"out e no endpoint.A especificaÁ„o especifica exatamente o que deve acontecer quando "
"e o que deve ser feito no caso de uma condiÁ„o de erro ser encontrada. O maior "
"desafio ao escrever drivers para esses dispositivos È adequar o protocolo baseado em "
"USB ao suporte existente para dispositivos de armazenamento em massa.AMPI È mais "
"simples, j· que historicamente a interface IDE nunca teve muitos recursos. "
"aparÍncias diferentes \""

#: book.translate.xml:22220
#, fuzzy
msgid ""
"The support for the USB floppy from Y-E Data is again less straightforward as a new "
"command set has been designed."
msgstr ""
"O suporte para o disquete USB da YE Data È novamente menos simples, j· que um novo "
"conjunto de comandos foi projetado."

#: book.translate.xml:22252
#, fuzzy
msgid "Newbus"
msgstr "Newbus"

#: book.translate.xml:22254
#, fuzzy
msgid ""
"<personname><firstname>Jeroen</firstname><surname>Ruigrok van der Werven (asmodai)</"
"surname></personname><affiliation> <_:address-1/> </affiliation><contrib>Written by "
"</contrib>"
msgstr ""
" <personname><firstname> Jeroen </firstname><surname> Ruigrok van der Werven "
"(asmodai) </surname></personname><affiliation> <_: endereÁo-1 /> </"
"affiliation><contrib> Escrito por </contrib> "

#: book.translate.xml:22257
#, fuzzy
msgid ""
"<personname><firstname>Hiten</firstname><surname>Pandya</surname></"
"personname><affiliation> <_:address-1/> </affiliation>"
msgstr ""
" <personname><firstname> Hiten </firstname><surname> Pandya </surname></"
"personname><affiliation> <_: endereÁo-1 /> </affiliation> "

#: book.translate.xml:22264
#, fuzzy
msgid ""
"<emphasis>Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug Rabson, "
"Mike Smith, Peter Wemm and Scott Long</emphasis>."
msgstr ""
" <emphasis> Agradecimentos especiais a Matthew N. Dodd, Warner Losh, Bill Paul, Doug "
"Rabson, Mike Smith, Peter Wemm e Scott Long </emphasis> "

#: book.translate.xml:22268
#, fuzzy
msgid "This chapter explains the Newbus device framework in detail."
msgstr "Este capÌ≠tulo explica a estrutura do dispositivo Newbus em detalhes."

#: book.translate.xml:22275
#, fuzzy
msgid "Purpose of a Device Driver"
msgstr "PropÛsito de um driver de dispositivo"

#: book.translate.xml:22279
#, fuzzy
msgid "<primary>device driver</primary><secondary>introduction</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> introduÁ„o </secondary> "

#: book.translate.xml:22282
#, fuzzy
msgid ""
"A device driver is a software component which provides the interface between the "
"kernel's generic view of a peripheral (e.g., disk, network adapter) and the actual "
"implementation of the peripheral. The <emphasis>device driver interface (DDI)</"
"emphasis> is the defined interface between the kernel and the device driver "
"component."
msgstr ""
"Um driver de dispositivo È um componente de software que fornece a interface entre a "
"vis„o genÈrica do kernel de um perifÈrico (por exemplo, disco, adaptador de rede) ea "
"implementaÁ„o real do perifÈrico. <emphasis> interface de driver de dispositivo "
"(DDI) </emphasis> È a interface definida entre o kernel e o componente do driver de "
"dispositivo. "

#: book.translate.xml:22291
#, fuzzy
msgid "Types of Device Drivers"
msgstr "Tipos de drivers de dispositivos"

#: book.translate.xml:22293
#, fuzzy
msgid ""
"There used to be days in <trademark class=\"registered\">UNIX</trademark>, and thus "
"FreeBSD, in which there were four types of devices defined:"
msgstr ""
"Costumava haver dias em <trademark class=\"registered\"> UNIX </trademark> e, "
"portanto, FreeBSD, em que havia quatro tipos de dispositivos definidos: "

#: book.translate.xml:22297
#, fuzzy
msgid "block device drivers"
msgstr "bloquear drivers de dispositivo"

#: book.translate.xml:22298
#, fuzzy
msgid "character device drivers"
msgstr "drivers de dispositivo de caractere"

#: book.translate.xml:22299
#, fuzzy
msgid "network device drivers"
msgstr "drivers de dispositivo de rede"

#: book.translate.xml:22300
#, fuzzy
msgid "pseudo-device drivers"
msgstr "drivers de pseudo-dispositivo"

#: book.translate.xml:22305
#, fuzzy
msgid ""
"<emphasis>Block devices</emphasis> performed in a way that used fixed size blocks "
"[of data]. This type of driver depended on the so-called <emphasis>buffer cache</"
"emphasis>, which had cached accessed blocks of data in a dedicated part of memory. "
"Often this buffer cache was based on write-behind, which meant that when data was "
"modified in memory it got synced to disk whenever the system did its periodical disk "
"flushing, thus optimizing writes."
msgstr ""
" <emphasis> Dispositivos de bloco </emphasis> realizada de maneira que usasse blocos "
"de tamanho fixo [de dados]. Este tipo de driver dependia do chamado <emphasis> cache "
"de buffer </emphasis> , que armazenou em cache blocos de dados acessados ‚Äã‚Äãem uma "
"parte dedicada da memÛria. Muitas vezes, esse cache de buffer era baseado em write-"
"behind, o que significava que quando os dados eram modificados na memÛria, ele era "
"sincronizado com o disco sempre que o sistema fazia a limpeza periÛdica do disco, "
"otimizando as gravaÁÌµes. "

#: book.translate.xml:22320
#, fuzzy
msgid ""
"However, in the versions of FreeBSD 4.0 and onward the distinction between block and "
"character devices became non-existent."
msgstr ""
"No entanto, nas versÌµes do FreeBSD 4.0 e em diante a distinÁ„o entre os "
"dispositivos de bloco e de caractere tornou-se inexistente."

#: book.translate.xml:22331
#, fuzzy
msgid "Overview of Newbus"
msgstr "Vis„o geral do Newbus"

#: book.translate.xml:22335
#, fuzzy
msgid ""
"<emphasis>Newbus</emphasis> is the implementation of a new bus architecture based on "
"abstraction layers which saw its introduction in FreeBSD 3.0 when the Alpha port was "
"imported into the source tree. It was not until 4.0 before it became the default "
"system to use for device drivers. Its goals are to provide a more object-oriented "
"means of interconnecting the various busses and devices which a host system provides "
"to the <emphasis>Operating System</emphasis>."
msgstr ""
" <emphasis> Newbus </emphasis> È a implementaÁ„o de uma nova arquitetura de "
"barramento baseada em camadas de abstraÁ„o que viu sua introduÁ„o no FreeBSD 3.0 "
"quando a porta Alpha foi importada para a ·rvore de fontes. N„o era atÈ 4.0 antes de "
"se tornar o sistema padr„o para usar drivers de dispositivo. Seus objetivos s„o "
"fornecer meios mais orientados a objeto de interconectar os v·rios barramentos e "
"dispositivos que um sistema host fornece ao <emphasis> Sistema operacional </"
"emphasis> "

#: book.translate.xml:22344
#, fuzzy
msgid "Its main features include amongst others:"
msgstr "Suas principais caracterÌ≠sticas incluem entre outras:"

#: book.translate.xml:22347
#, fuzzy
msgid "dynamic attaching"
msgstr "anexaÁ„o dinÌ¢mica"

#: book.translate.xml:22348
#, fuzzy
msgid "easy modularization of drivers"
msgstr "modularizaÁ„o f·cil de drivers"

#: book.translate.xml:22349
#, fuzzy
msgid "pseudo-busses"
msgstr "pseudo-Ì¥nibus"

#: book.translate.xml:22352
#, fuzzy
msgid ""
"One of the most prominent changes is the migration from the flat and ad-hoc system "
"to a device tree layout."
msgstr ""
"Uma das mudanÁas mais proeminentes È a migraÁ„o do sistema plano e ad-hoc para o "
"layout de uma ·rvore de dispositivos."

#: book.translate.xml:22355
#, fuzzy
msgid ""
"At the top level resides the <emphasis><quote>root</quote></emphasis> device which "
"is the parent to hang all other devices on. For each architecture, there is "
"typically a single child of <quote>root</quote> which has such things as "
"<emphasis>host-to-PCI bridges</emphasis>, etc. attached to it. For x86, this "
"<quote>root</quote> device is the <emphasis><quote>nexus</quote></emphasis> device. "
"For Alpha, various different models of Alpha have different top-level devices "
"corresponding to the different hardware chipsets, including <emphasis>lca</"
"emphasis>, <emphasis>apecs</emphasis>, <emphasis>cia</emphasis> and "
"<emphasis>tsunami</emphasis>."
msgstr ""
"No nÌ≠vel superior reside o <emphasis><quote> raiz </quote></emphasis> dispositivo "
"que È o pai para pendurar todos os outros dispositivos. Para cada arquitetura, "
"normalmente h· um ˙nico filho de <quote> raiz </quote> que tem coisas como "
"<emphasis> pontes host-para-PCI </emphasis> , etc. anexado a ele. Para x86, isso "
"<quote> raiz </quote> dispositivo È o <emphasis><quote> nexo </quote></emphasis> "
"dispositivo. Para Alpha, v·rios modelos diferentes de Alpha tÍm diferentes "
"dispositivos de nÌ≠vel superior correspondentes aos diferentes chipsets de hardware, "
"incluindo <emphasis> lca </emphasis> , <emphasis> apecs </emphasis> , <emphasis> cia "
"</emphasis> e <emphasis> tsunami </emphasis> "

#: book.translate.xml:22368
#, fuzzy
msgid ""
"A device in the Newbus context represents a single hardware entity in the system. "
"For instance each PCI device is represented by a Newbus device. Any device in the "
"system can have children; a device which has children is often called a "
"<emphasis><quote>bus</quote></emphasis>. Examples of common busses in the system are "
"ISA and PCI, which manage lists of devices attached to ISA and PCI busses "
"respectively."
msgstr ""
"Um dispositivo no contexto Newbus representa uma ˙nica entidade de hardware no "
"sistema. Por exemplo, cada dispositivo PCI È representado por um dispositivo Newbus. "
"Qualquer dispositivo no sistema pode ter filhos; um dispositivo que tem filhos È "
"muitas vezes chamado de <emphasis><quote> Ì¥nibus </quote></emphasis> . Exemplos de "
"barramentos comuns no sistema s„o ISA e PCI, que gerenciam listas de dispositivos "
"conectados aos barramentos ISA e PCI, respectivamente. "

#: book.translate.xml:22376
#, fuzzy
msgid ""
"Often, a connection between different kinds of bus is represented by a "
"<emphasis><quote>bridge</quote></emphasis> device, which normally has one child for "
"the attached bus. An example of this is a <emphasis>PCI-to-PCI bridge</emphasis> "
"which is represented by a device <emphasis><filename>pcibN</filename></emphasis> on "
"the parent PCI bus and has a child <emphasis><filename>pciN</filename></emphasis> "
"for the attached bus. This layout simplifies the implementation of the PCI bus tree, "
"allowing common code to be used for both top-level and bridged busses."
msgstr ""
"Muitas vezes, uma conex„o entre diferentes tipos de Ì¥nibus È representada por um "
"<emphasis><quote> ponte </quote></emphasis> dispositivo, que normalmente tem um "
"filho para o barramento conectado. Um exemplo disso È um <emphasis> Ponte PCI-para-"
"PCI </emphasis> que È representado por um dispositivo <emphasis><filename> pcibN </"
"filename></emphasis> no barramento PCI pai e tem um filho <emphasis><filename> pciN "
"</filename></emphasis> para o barramento anexado. Esse layout simplifica a "
"implementaÁ„o da ·rvore de barramento PCI, permitindo que cÛdigo comum seja usado "
"para barramentos de nÌ≠vel superior e em ponte. "

#: book.translate.xml:22388
#, fuzzy
msgid ""
"Each device in the Newbus architecture asks its parent to map its resources. The "
"parent then asks its own parent until the nexus is reached. So, basically the nexus "
"is the only part of the Newbus system which knows about all resources."
msgstr ""
"Cada dispositivo na arquitetura Newbus pede ao seu pai para mapear seus recursos. O "
"pai ent„o pergunta ao seu prÛprio pai atÈ que o nexo seja alcanÁado. Ent„o, "
"basicamente, o nexo È a ˙nica parte do sistema Newbus que conhece todos os recursos."

#: book.translate.xml:22393
#, fuzzy
msgid ""
"An ISA device might want to map its IO port at <literal>0x230</literal>, so it asks "
"its parent, in this case the ISA bus. The ISA bus hands it over to the PCI-to-ISA "
"bridge which in its turn asks the PCI bus, which reaches the host-to-PCI bridge and "
"finally the nexus. The beauty of this transition upwards is that there is room to "
"translate the requests. For example, the <literal>0x230</literal> IO port request "
"might become memory-mapped at <literal>0xb0000230</literal> on a <acronym>MIPS</"
"acronym> box by the PCI bridge."
msgstr ""
"Um dispositivo ISA pode querer mapear sua porta IO em <literal> 0x230 </literal> , "
"ent„o ele pergunta a seus pais, neste caso, o barramento ISA. O barramento ISA passa "
"para a ponte PCI-para-ISA, que, por sua vez, solicita o barramento PCI, que alcanÁa "
"a ponte host-para-PCI e, finalmente, o nexus. A beleza dessa transiÁ„o para cima È "
"que h· espaÁo para traduzir os pedidos. Por exemplo, o <literal> 0x230 </literal> A "
"solicitaÁ„o de porta IO pode se tornar mapeada na memÛria em <literal> 0xb0000230 </"
"literal> em uma caixa <acronym>MIPS</acronym> pela ponte PCI \""

#: book.translate.xml:22404
#, fuzzy
msgid ""
"Resource allocation can be controlled at any place in the device tree. For instance "
"on many Alpha platforms, ISA interrupts are managed separately from PCI interrupts "
"and resource allocations for ISA interrupts are managed by the Alpha's ISA bus "
"device. On IA-32, ISA and PCI interrupts are both managed by the top-level nexus "
"device. For both ports, memory and port address space is managed by a single entity "
"- nexus for IA-32 and the relevant chipset driver on Alpha (e.g., CIA or tsunami)."
msgstr ""
"A alocaÁ„o de recursos pode ser controlada em qualquer lugar na ·rvore de "
"dispositivos. Por exemplo, em muitas plataformas Alpha, as interrupÁÌµes do ISA s„o "
"gerenciadas separadamente das interrupÁÌµes PCI e as alocaÁÌµes de recursos para as "
"interrupÁÌµes do ISA s„o gerenciadas pelo dispositivo de barramento ISA do Alpha. e "
"interrupÁÌµes PCI s„o gerenciadas pelo dispositivo nexus de nÌ≠vel superior.Para as "
"duas portas, memÛria e espaÁo de endereÁo de porta s„o gerenciados por uma ˙nica "
"entidade - nexo para IA-32 e o driver do chipset relevante em Alpha (por exemplo, "
"CIA ou tsunami). "

#: book.translate.xml:22414
#, fuzzy
msgid ""
"In order to normalize access to memory and port mapped resources, Newbus integrates "
"the <literal>bus_space</literal> APIs from NetBSD. These provide a single API to "
"replace inb/outb and direct memory reads/writes. The advantage of this is that a "
"single driver can easily use either memory-mapped registers or port-mapped registers "
"(some hardware supports both)."
msgstr ""
"Para normalizar o acesso Ì† memÛria e aos recursos mapeados pela porta, o Newbus "
"integra <literal> bus_space </literal> APIs do NetBSD. Eles fornecem uma ˙nica API "
"para substituir leituras / gravaÁÌµes de memÛria inb / outb e direta. A vantagem "
"disso È que um ˙nico driver pode facilmente usar registradores mapeados na memÛria "
"ou registradores mapeados pela porta (alguns suportam hardware ambos). "

#: book.translate.xml:22421
#, fuzzy
msgid ""
"This support is integrated into the resource allocation mechanism. When a resource "
"is allocated, a driver can retrieve the associated <varname remap=\"structfield"
"\">bus_space_tag_t</varname> and <varname remap=\"structfield\">bus_space_handle_t</"
"varname> from the resource."
msgstr ""
"Esse suporte È integrado ao mecanismo de alocaÁ„o de recursos. Quando um recurso È "
"alocado, um driver pode recuperar <varname remap=\"structfield\"> bus_space_tag_t </"
"varname> e <varname remap=\"structfield\"> bus_space_handle_t </varname> do recurso "
"\""

#: book.translate.xml:22427
#, fuzzy
msgid ""
"Newbus also allows for definitions of interface methods in files dedicated to this "
"purpose. These are the <filename>.m</filename> files that are found under the "
"<filename>src/sys</filename> hierarchy."
msgstr ""
"O Newbus tambÈm permite definiÁÌµes de mÈtodos de interface em arquivos dedicados a "
"este propÛsito. Estes s„o os <filename> .m </filename> arquivos que s„o encontrados "
"sob o <filename> src / sys </filename> hierarquia."

#: book.translate.xml:22432
#, fuzzy
msgid ""
"The core of the Newbus system is an extensible <quote>object-based programming</"
"quote> model. Each device in the system has a table of methods which it supports. "
"The system and other devices uses those methods to control the device and request "
"services. The different methods supported by a device are defined by a number of "
"<quote>interfaces</quote>. An <quote>interface</quote> is simply a group of related "
"methods which can be implemented by a device."
msgstr ""
"O n˙cleo do sistema Newbus È um extensÌ≠vel <quote> programaÁ„o baseada em objetos </"
"quote> modelo. Cada dispositivo no sistema possui uma tabela de mÈtodos que ele "
"suporta. O sistema e outros dispositivos usam esses mÈtodos para controlar o "
"dispositivo e solicitar serviÁos. Os diferentes mÈtodos suportados por um "
"dispositivo s„o definidos por um n˙mero de <quote> interfaces </quote> . A <quote> "
"interface </quote> È simplesmente um grupo de mÈtodos relacionados que podem ser "
"implementados por um dispositivo \""

#: book.translate.xml:22441
#, fuzzy
msgid ""
"In the Newbus system, the methods for a device are provided by the various device "
"drivers in the system. When a device is attached to a driver during <emphasis>auto-"
"configuration</emphasis>, it uses the method table declared by the driver. A device "
"can later <emphasis>detach</emphasis> from its driver and <emphasis>re-attach</"
"emphasis> to a new driver with a new method table. This allows dynamic replacement "
"of drivers which can be useful for driver development."
msgstr ""
"No sistema Newbus, os mÈtodos para um dispositivo s„o fornecidos pelos v·rios "
"drivers de dispositivo no sistema. Quando um dispositivo È conectado a um driver "
"durante <emphasis> configuraÁ„o autom·tica </emphasis> , ele usa a tabela de mÈtodos "
"declarada pelo driver. Um dispositivo pode mais tarde <emphasis> desanexar </"
"emphasis> do seu motorista e <emphasis> re-anexar </emphasis> para um novo driver "
"com uma nova tabela de mÈtodos. Isso permite a substituiÁ„o dinÌ¢mica de drivers, o "
"que pode ser ˙til para o desenvolvimento de drivers. "

#: book.translate.xml:22451
#, fuzzy
msgid ""
"The interfaces are described by an interface definition language similar to the "
"language used to define vnode operations for file systems. The interface would be "
"stored in a methods file (which would normally be named <filename>foo_if.m</"
"filename>)."
msgstr ""
"As interfaces s„o descritas por uma linguagem de definiÁ„o de interface semelhante "
"Ì† linguagem usada para definir operaÁÌµes de vnode para sistemas de arquivos. A "
"interface seria armazenada em um arquivo de mÈtodos (que normalmente seria nomeado "
"<filename> foo_if.m </filename> ) "

#: book.translate.xml:22458
#, fuzzy
msgid "Newbus Methods"
msgstr "MÈtodos Newbus"

#: book.translate.xml:22477
#, fuzzy
msgid ""
"When this interface is compiled, it generates a header file <quote><filename>foo_if."
"h</filename></quote> which contains function declarations:"
msgstr ""
"Quando esta interface È compilada, ela gera um arquivo de cabeÁalho "
"<quote><filename> foo_if.h </filename></quote> que contÈm declaraÁÌµes de funÁ„o: "

#: book.translate.xml:22484
#, fuzzy
msgid ""
"A source file, <quote><filename>foo_if.c</filename></quote> is also created to "
"accompany the automatically generated header file; it contains implementations of "
"those functions which look up the location of the relevant functions in the object's "
"method table and call that function."
msgstr ""
"Um arquivo de origem, <quote><filename> foo_if.c </filename></quote> tambÈm È criado "
"para acompanhar o arquivo de cabeÁalho gerado automaticamente; contÈm "
"implementaÁÌµes dessas funÁÌµes que procuram a localizaÁ„o das funÁÌµes relevantes "
"na tabela de mÈtodos do objeto e chamam essa funÁ„o. "

#: book.translate.xml:22490
#, fuzzy
msgid ""
"The system defines two main interfaces. The first fundamental interface is called "
"<emphasis><quote>device</quote></emphasis> and includes methods which are relevant "
"to all devices. Methods in the <emphasis><quote>device</quote></emphasis> interface "
"include <emphasis><quote>probe</quote></emphasis>, <emphasis><quote>attach</quote></"
"emphasis> and <emphasis><quote>detach</quote></emphasis> to control detection of "
"hardware and <emphasis><quote>shutdown</quote></emphasis>, <emphasis><quote>suspend</"
"quote></emphasis> and <emphasis><quote>resume</quote></emphasis> for critical event "
"notification."
msgstr ""
"O sistema define duas interfaces principais. A primeira interface fundamental È "
"chamada <emphasis><quote> dispositivo </quote></emphasis> e inclui mÈtodos "
"relevantes para todos os dispositivos. MÈtodos no <emphasis><quote> dispositivo </"
"quote></emphasis> interface incluem <emphasis><quote> sonda </quote></emphasis> , "
"<emphasis><quote> anexar </quote></emphasis> e <emphasis><quote> desanexar </quote></"
"emphasis> para controlar a detecÁ„o de hardware e <emphasis><quote> desligar </"
"quote></emphasis> , <emphasis><quote> suspender </quote></emphasis> e "
"<emphasis><quote> currÌ≠culo </quote></emphasis> para notificaÁ„o de eventos crÌ≠"
"ticos. "

#: book.translate.xml:22507
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>bus_generic_read_ivar</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> and <citerefentry><refentrytitle>bus_generic_write_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
" <citerefentry><refentrytitle> bus_generic_read_ivar </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> bus_generic_write_ivar </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#: book.translate.xml:22503
#, fuzzy
msgid ""
"The second, more complex interface is <emphasis><quote>bus</quote></emphasis>. This "
"interface contains methods suitable for devices which have children, including "
"methods to access bus specific per-device information <_:footnote-1/>, event "
"notification (<emphasis><literal>child_detached</literal></emphasis>, "
"<emphasis><literal>driver_added</literal></emphasis>) and resource management "
"(<emphasis><literal>alloc_resource</literal></emphasis>, "
"<emphasis><literal>activate_resource</literal></emphasis>, "
"<emphasis><literal>deactivate_resource</literal></emphasis>, "
"<emphasis><literal>release_resource</literal></emphasis>)."
msgstr ""
"A segunda interface mais complexa È <emphasis><quote> Ì¥nibus </quote></emphasis> . "
"Essa interface contÈm mÈtodos adequados para dispositivos que tÍm filhos, incluindo "
"mÈtodos para acessar informaÁÌµes especÌ≠ficas do barramento por dispositivo <_: "
"footnote-1 />, notificaÁ„o de eventos ( <emphasis><literal> child_detached </"
"literal></emphasis> , <emphasis><literal> driver_added </literal></emphasis> ) e "
"gest„o de recursos ( <emphasis><literal> alloc_resource </literal></emphasis> , "
"<emphasis><literal> activate_resource </literal></emphasis> , <emphasis><literal> "
"deactivate_resource </literal></emphasis> , <emphasis><literal> release_resource </"
"literal></emphasis> ) "

#: book.translate.xml:22518
#, fuzzy
msgid ""
"Many methods in the <quote>bus</quote> interface are performing services for some "
"child of the bus device. These methods would normally use the first two arguments to "
"specify the bus providing the service and the child device which is requesting the "
"service. To simplify driver code, many of these methods have accessor functions "
"which lookup the parent and call a method on the parent. For instance the method "
"<literal>BUS_TEARDOWN_INTR(device_t dev, device_t child, ...)</literal> can be "
"called using the function <literal>bus_teardown_intr(device_t child, ...)</literal>."
msgstr ""
"Muitos mÈtodos no <quote> Ì¥nibus </quote> interface est„o executando serviÁos para "
"algum filho do dispositivo de barramento. Esses mÈtodos normalmente usariam os dois "
"primeiros argumentos para especificar o barramento que fornece o serviÁo e o "
"dispositivo filho que est· solicitando o serviÁo. Para simplificar o cÛdigo do "
"driver, muitos desses mÈtodos tÍm funÁÌµes de acesso que procuram o pai e chamam um "
"mÈtodo no pai. Por exemplo, o mÈtodo <literal> BUS_TEARDOWN_INTR (device_t dev, "
"device_t filho, ...) </literal> pode ser chamado usando a funÁ„o <literal> "
"bus_teardown_intr (filho device_t, ...) </literal> "

#: book.translate.xml:22530
#, fuzzy
msgid ""
"Some bus types in the system define additional interfaces to provide access to bus-"
"specific functionality. For instance, the PCI bus driver defines the <quote>pci</"
"quote> interface which has two methods <emphasis><literal>read_config</literal></"
"emphasis> and <emphasis><literal>write_config</literal></emphasis> for accessing the "
"configuration registers of a PCI device."
msgstr ""
"Alguns tipos de barramento no sistema definem interfaces adicionais para fornecer "
"acesso Ì† funcionalidade especÌ≠fica do barramento. Por exemplo, o driver de "
"barramento PCI define <quote> pci </quote> interface que tem dois mÈtodos "
"<emphasis><literal> read_config </literal></emphasis> e <emphasis><literal> "
"write_config </literal></emphasis> para acessar os registros de configuraÁ„o de um "
"dispositivo PCI. "

#: book.translate.xml:22540
#, fuzzy
msgid "Newbus API"
msgstr "Newbus API"

#: book.translate.xml:22542
#, fuzzy
msgid ""
"As the Newbus API is huge, this section makes some effort at documenting it. More "
"information to come in the next revision of this document."
msgstr ""
"Como a API Newbus È enorme, esta seÁ„o faz algum esforÁo para document·-la. Mais "
"informaÁÌµes est„o na prÛxima revis„o deste documento."

#: book.translate.xml:22547
#, fuzzy
msgid "Important Locations in the Source Hierarchy"
msgstr "Locais importantes na hierarquia de origem"

#: book.translate.xml:22549
#, fuzzy
msgid ""
"<filename>src/sys/[arch]/[arch]</filename> - Kernel code for a specific machine "
"architecture resides in this directory. For example, the <literal>i386</literal> "
"architecture, or the <literal>SPARC64</literal> architecture."
msgstr ""
" <filename> src / sys / [arco] / [arco] </filename> - O cÛdigo do kernel para uma "
"arquitetura de m·quina especÌ≠fica reside neste diretÛrio. Por exemplo, o <literal> "
"i386 </literal> arquitetura, ou o <literal> SPARC64 </literal> arquitetura."

#: book.translate.xml:22554
#, fuzzy
msgid ""
"<filename>src/sys/dev/[bus]</filename> - device support for a specific "
"<literal>[bus]</literal> resides in this directory."
msgstr ""
" <filename> src / sys / dev / [barramento] </filename> - suporte de dispositivo para "
"um especÌ≠fico <literal> [Ì¥nibus] </literal> reside neste diretÛrio. "

#: book.translate.xml:22558
#, fuzzy
msgid ""
"<filename>src/sys/dev/pci</filename> - PCI bus support code resides in this "
"directory."
msgstr ""
" <filename> src / sys / dev / pci </filename> - O cÛdigo de suporte do barramento "
"PCI reside neste diretÛrio. "

#: book.translate.xml:22561
#, fuzzy
msgid ""
"<filename>src/sys/[isa|pci]</filename> - PCI/ISA device drivers reside in this "
"directory. The PCI/ISA bus support code used to exist in this directory in FreeBSD "
"version <literal>4.0</literal>."
msgstr ""
" <filename> src / sys / [isa | pci] </filename> - Os drivers de dispositivos PCI / "
"ISA residem nesse diretÛrio. O cÛdigo de suporte do barramento PCI / ISA costumava "
"existir neste diretÛrio na vers„o FreeBSD <literal> 4,0 </literal> "

#: book.translate.xml:22568
#, fuzzy
msgid "Important Structures and Type Definitions"
msgstr "Estruturas importantes e definiÁÌµes de tipo"

#: book.translate.xml:22570
#, fuzzy
msgid ""
"<literal>devclass_t</literal> - This is a type definition of a pointer to a "
"<literal>struct devclass</literal>."
msgstr ""
" <literal> devclass_t </literal> - Esta È uma definiÁ„o de tipo de um ponteiro para "
"um <literal> struct devclass </literal> "

#: book.translate.xml:22573
#, fuzzy
msgid ""
"<literal>device_method_t</literal> - This is the same as <literal>kobj_method_t</"
"literal> (see <filename>src/sys/kobj.h</filename>)."
msgstr ""
" <literal> device_method_t </literal> - Isso È o mesmo que <literal> kobj_method_t </"
"literal> (Vejo <filename> src / sys / kobj.h </filename> ) "

#: book.translate.xml:22577
#, fuzzy
msgid ""
"<literal>device_t</literal> - This is a type definition of a pointer to a "
"<literal>struct device</literal>. <literal>device_t</literal> represents a device in "
"the system. It is a kernel object. See <filename>src/sys/sys/bus_private.h</"
"filename> for implementation details."
msgstr ""
" <literal> device_t </literal> - Esta È uma definiÁ„o de tipo de um ponteiro para um "
"<literal> dispositivo struct </literal> . <literal> device_t </literal> representa "
"um dispositivo no sistema. Ìâ um objeto do kernel. Vejo <filename> src / sys / sys / "
"bus_private.h </filename> para detalhes de implementaÁ„o. "

#: book.translate.xml:22584
#, fuzzy
msgid ""
"<literal>driver_t</literal> - This is a type definition which references "
"<literal>struct driver</literal>. The <literal>driver</literal> struct is a class of "
"the <literal>device</literal> kernel object; it also holds data private to the "
"driver."
msgstr ""
" <literal> driver_t </literal> - Esta È uma definiÁ„o de tipo que referencia "
"<literal> driver struct </literal> . o <literal> motorista </literal> struct È uma "
"classe do <literal> dispositivo </literal> objeto do kernel; ele tambÈm mantÈm dados "
"privados para o driver \""

#: book.translate.xml:22591
#, fuzzy
msgid "<emphasis>driver_t</emphasis> Implementation"
msgstr " <emphasis> driver_t </emphasis> ImplementaÁ„o"

#: book.translate.xml:22599
#, fuzzy
msgid ""
"A <literal>device_state_t</literal> type, which is an enumeration, "
"<literal>device_state</literal>. It contains the possible states of a Newbus device "
"before and after the autoconfiguration process."
msgstr ""
"UMA <literal> device_state_t </literal> tipo, que È uma enumeraÁ„o, <literal> "
"device_state </literal> . Ele contÈm os estados possÌ≠veis de um dispositivo Newbus "
"antes e depois do processo de configuraÁ„o autom·tica. "

#: book.translate.xml:22605
#, fuzzy
msgid "Device States <emphasis>device_state_t</emphasis>"
msgstr "Estados do dispositivo <emphasis> device_state_t </emphasis> "

#: book.translate.xml:22630
#, fuzzy
msgid "Sound Subsystem"
msgstr "Subsistema de Som"

#: book.translate.xml:22632
#, fuzzy
msgid ""
"<personname><firstname>Jean-Francois</firstname><surname>Dockes</surname></"
"personname><contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Jean-FranÁois </firstname><surname> Dockes </surname></"
"personname><contrib> ContribuÌ≠ram por </contrib> "

#: book.translate.xml:22642
#, fuzzy
msgid "<primary>sound subsystem</primary>"
msgstr " <primary> subsistema de som </primary> "

#: book.translate.xml:22644
#, fuzzy
msgid ""
"The FreeBSD sound subsystem cleanly separates generic sound handling issues from "
"device-specific ones. This makes it easier to add support for new hardware."
msgstr ""
"O subsistema de som do FreeBSD separa de forma limpa os problemas genÈricos de "
"manipulaÁ„o de som dos especÌ≠ficos do dispositivo. Isso facilita a adiÁ„o de suporte "
"para novo hardware."

#: book.translate.xml:22648
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>pcm</refentrytitle><manvolnum>4</manvolnum></"
"citerefentry> framework is the central piece of the sound subsystem. It mainly "
"implements the following elements:"
msgstr ""
"O <citerefentry><refentrytitle> pcm </refentrytitle><manvolnum> 4 </manvolnum></"
"citerefentry> framework È a peÁa central do subsistema de som. Ele implementa "
"principalmente os seguintes elementos: "

#: book.translate.xml:22651
#, fuzzy
msgid "<primary>system call interface</primary>"
msgstr " <primary> interface de chamada do sistema </primary> "

#: book.translate.xml:22655
#, fuzzy
msgid ""
"A system call interface (read, write, ioctls) to digitized sound and mixer "
"functions. The ioctl command set is compatible with the legacy <emphasis>OSS</"
"emphasis> or <emphasis>Voxware</emphasis> interface, allowing common multimedia "
"applications to be ported without modification."
msgstr ""
"Uma interface de chamada do sistema (leitura, gravaÁ„o, ioctls) para funÁÌµes de som "
"e mixer digitalizadas. O conjunto de comandos ioctl È compatÌ≠vel com o legado "
"<emphasis> OSS </emphasis> ou <emphasis> Voxware </emphasis> interface, permitindo "
"que aplicaÁÌµes multimÌ≠dia comuns sejam portadas sem modificaÁ„o. "

#: book.translate.xml:22664
#, fuzzy
msgid "Common code for processing sound data (format conversions, virtual channels)."
msgstr ""
"CÛdigo comum para processamento de dados sonoros (conversÌµes de formato, canais "
"virtuais)."

#: book.translate.xml:22669
#, fuzzy
msgid "A uniform software interface to hardware-specific audio interface modules."
msgstr ""
"Uma interface de software uniforme para mÛdulos de interface de ·udio especÌ≠ficos de "
"hardware."

#: book.translate.xml:22674
#, fuzzy
msgid ""
"Additional support for some common hardware interfaces (ac97), or shared hardware-"
"specific code (ex: ISA DMA routines)."
msgstr ""
"Suporte adicional para algumas interfaces comuns de hardware (ac97), ou cÛdigo especÌ≠"
"fico de hardware compartilhado (ex: rotinas ISA DMA)."

#: book.translate.xml:22680
#, fuzzy
msgid ""
"The support for specific sound cards is implemented by hardware-specific drivers, "
"which provide channel and mixer interfaces to plug into the generic <filename>pcm</"
"filename> code."
msgstr ""
"O suporte para placas de som especÌ≠ficas È implementado por drivers especÌ≠ficos de "
"hardware, que fornecem interfaces de canal e mixer para serem plugados no genÈrico. "
"<filename> pcm </filename> cÛdigo."

#: book.translate.xml:22685
#, fuzzy
msgid ""
"In this chapter, the term <filename>pcm</filename> will refer to the central, common "
"part of the sound driver, as opposed to the hardware-specific modules."
msgstr ""
"Neste capÌ≠tulo, o termo <filename> pcm </filename> referir-se-· Ì† parte central e "
"comum do driver de som, ao contr·rio dos mÛdulos especÌ≠ficos de hardware. "

#: book.translate.xml:22689
#, fuzzy
msgid ""
"The prospective driver writer will of course want to start from an existing module "
"and use the code as the ultimate reference. But, while the sound code is nice and "
"clean, it is also mostly devoid of comments. This document tries to give an overview "
"of the framework interface and answer some questions that may arise while adapting "
"the existing code."
msgstr ""
"Naturalmente, o candidato a driver dever· iniciar a partir de um mÛdulo existente e "
"usar o cÛdigo como a referÍncia final. Mas, embora o cÛdigo de som seja bom e limpo, "
"ele tambÈm È desprovido de coment·rios. Este documento tenta fornecer uma vis„o "
"geral. da interface do framework e responder a algumas perguntas que possam surgir "
"durante a adaptaÁ„o do cÛdigo existente. "

#: book.translate.xml:22696
#, fuzzy
msgid ""
"As an alternative, or in addition to starting from a working example, you can find a "
"commented driver template at <link xlink:href=\"https://people.FreeBSD.org/~cg/"
"template.c\"> https://people.FreeBSD.org/~cg/template.c</link>"
msgstr ""
"Como alternativa, ou alÈm de partir de um exemplo de trabalho, vocÍ pode encontrar "
"um modelo de driver <link xlink:href=\"https://people.FreeBSD.org/~cg/template.c\"> "
"https://people.FreeBSD.org/~cg/template.c </link> "

#: book.translate.xml:22703
#, fuzzy
msgid "Files"
msgstr "Arquivos"

#: book.translate.xml:22705
#, fuzzy
msgid ""
"All the relevant code lives in <filename>/usr/src/sys/dev/sound/</filename>, except "
"for the public ioctl interface definitions, found in <filename>/usr/src/sys/sys/"
"soundcard.h</filename>"
msgstr ""
"Todo o cÛdigo relevante vive em <filename> / usr / src / sys / dev / sound / </"
"filename> , exceto para as definiÁÌµes de interface p˙blica do ioctl, encontradas em "
"<filename> /usr/src/sys/sys/soundcard.h </filename> "

#: book.translate.xml:22710
#, fuzzy
msgid ""
"Under <filename>/usr/src/sys/dev/sound/</filename>, the <filename>pcm/</filename> "
"directory holds the central code, while the <filename>pci/</filename>, <filename>isa/"
"</filename> and <filename>usb/</filename> directories have the drivers for PCI and "
"ISA boards, and for USB audio devices."
msgstr ""
"Sob <filename> / usr / src / sys / dev / sound / </filename> , a <filename> pcm / </"
"filename> diretÛrio mantÈm o cÛdigo central, enquanto o <filename> pci / </"
"filename> , <filename> È um/ </filename> e <filename> USB/ </filename> diretÛrios "
"tÍm os drivers para placas PCI e ISA, e para dispositivos de ·udio USB \""

#: book.translate.xml:22718
#, fuzzy
msgid "Probing, Attaching, etc."
msgstr "Sondando, Anexando, etc."

#: book.translate.xml:22720
#, fuzzy
msgid ""
"Sound drivers probe and attach in almost the same way as any hardware driver module. "
"You might want to look at the <link linkend=\"isa-driver\"> ISA</link> or <link "
"linkend=\"pci\">PCI</link> specific sections of the handbook for more information."
msgstr ""
"Drivers de som sondam e conectam quase da mesma maneira que qualquer mÛdulo de "
"driver de hardware. VocÍ pode querer <link linkend=\"isa-driver\"> Ìâ UM </link> ou "
"<link linkend=\"pci\"> PCI </link> seÁÌµes especÌ≠ficas do manual para mais "
"informaÁÌµes. "

#: book.translate.xml:22724
#, fuzzy
msgid "However, sound drivers differ in some ways:"
msgstr "No entanto, os drivers de som diferem em alguns aspectos:"

#: book.translate.xml:22728
#, fuzzy
msgid ""
"They declare themselves as <filename>pcm</filename> class devices, with a <varname "
"remap=\"structname\">struct snddev_info</varname> device private structure:"
msgstr ""
"Eles se declaram como <filename> pcm </filename> dispositivos de classe, com um "
"<varname remap=\"structname\"> struct snddev_info </varname> estrutura privada do "
"dispositivo: "

#: book.translate.xml:22742
#, fuzzy
msgid "<primary>device drivers</primary><secondary>sound</secondary>"
msgstr " <primary> drivers de dispositivo </primary><secondary> som </secondary> "

#: book.translate.xml:22742
#, fuzzy
msgid ""
"Most sound drivers<_:indexterm-1/> need to store additional private information "
"about their device. A private data structure is usually allocated in the attach "
"routine. Its address is passed to <filename>pcm</filename> by the calls to "
"<function>pcm_register()</function> and <function>mixer_init()</function>. "
"<filename>pcm</filename> later passes back this address as a parameter in calls to "
"the sound driver interfaces."
msgstr ""
"A maioria dos drivers de som <_: indexterm-1 /> precisa armazenar informaÁÌµes "
"particulares adicionais sobre o dispositivo. Geralmente, uma estrutura de dados "
"privada È alocada na rotina de anexaÁ„o. Seu endereÁo È passado para <filename> pcm "
"</filename> pelas chamadas para <function> pcm_register () </function> e <function> "
"mixer_init () </function> . <filename> pcm </filename> mais tarde passa de volta "
"este endereÁo como um parÌ¢metro em chamadas para as interfaces do driver de som. "

#: book.translate.xml:22756
#, fuzzy
msgid ""
"The sound driver attach routine should declare its MIXER or AC97 interface to "
"<filename>pcm</filename> by calling <function>mixer_init()</function>. For a MIXER "
"interface, this causes in turn a call to <link linkend=\"xxxmixer-init"
"\"><function>xxxmixer_init()</function></link>."
msgstr ""
"A rotina de anexaÁ„o do driver de som deve declarar sua interface MIXER ou AC97 "
"<filename> pcm </filename> chamando <function> mixer_init () </function> . Para uma "
"interface MIXER, isso faz com que uma chamada para <link linkend=\"xxxmixer-init"
"\"><function> xxxmixer_init () </function></link> "

#: book.translate.xml:22763
#, fuzzy
msgid ""
"The sound driver attach routine declares its general CHANNEL configuration to "
"<filename>pcm</filename> by calling <function>pcm_register(dev, sc, nplay, nrec)</"
"function>, where <varname>sc</varname> is the address for the device data structure, "
"used in further calls from <filename>pcm</filename>, and <varname>nplay</varname> "
"and <varname>nrec</varname> are the number of play and record channels."
msgstr ""
"A rotina de anexaÁ„o do driver de som declara sua configuraÁ„o geral de CHANNEL "
"<filename> pcm </filename> chamando <function> pcm_register (dev, sc, nplay, nrec) </"
"function> , Onde <varname> sc </varname> È o endereÁo da estrutura de dados do "
"dispositivo, usado em outras chamadas <filename> pcm </filename> e <varname> nplay </"
"varname> e <varname> nrec </varname> s„o o n˙mero de canais de reproduÁ„o e "
"gravaÁ„o. "

#: book.translate.xml:22774
#, fuzzy
msgid ""
"The sound driver attach routine declares each of its channel objects by calls to "
"<function>pcm_addchan()</function>. This sets up the channel glue in <filename>pcm</"
"filename> and causes in turn a call to <link linkend=\"xxxchannel-init\"> "
"<function>xxxchannel_init()</function></link>."
msgstr ""
"A rotina de anexaÁ„o do driver de som declara cada um dos seus objetos de canal "
"<function> pcm_addchan () </function> . Isso configura a cola do canal <filename> "
"pcm </filename> e provoca por sua vez uma chamada para <link linkend=\"xxxchannel-"
"init\"><function> xxxchannel_init () </function></link> "

#: book.translate.xml:22784
#, fuzzy
msgid ""
"The sound driver detach routine should call <function>pcm_unregister()</function> "
"before releasing its resources."
msgstr ""
"A rotina de desconex„o do driver de som deve chamar <function> pcm_unregister () </"
"function> antes de liberar seus recursos \""

#: book.translate.xml:22790
#, fuzzy
msgid "There are two possible methods to handle non-PnP devices:"
msgstr "Existem dois mÈtodos possÌ≠veis para lidar com dispositivos n„o-PnP:"

#: book.translate.xml:22795
#, fuzzy
msgid ""
"Use a <function>device_identify()</function> method (example: <filename>sound/isa/"
"es1888.c</filename>). The <function>device_identify()</function> method probes for "
"the hardware at known addresses and, if it finds a supported device, creates a new "
"pcm device which is then passed to probe/attach."
msgstr ""
"Use um <function> device_identify () </function> mÈtodo (exemplo: <filename> som / "
"isa / es1888.c </filename> ). o <function> device_identify () </function> mÈtodo "
"investiga o hardware em endereÁos conhecidos e, se encontrar um dispositivo "
"suportado, cria um novo dispositivo pcm que È ent„o passado para o probe / attach. "

#: book.translate.xml:22804
#, fuzzy
msgid ""
"Use a custom kernel configuration with appropriate hints for pcm devices (example: "
"<filename>sound/isa/mss.c</filename>)."
msgstr ""
"Use uma configuraÁ„o de kernel personalizada com dicas apropriadas para dispositivos "
"pcm (exemplo: <filename> som / isa / mss.c </filename> ) "

#: book.translate.xml:22810
#, fuzzy
msgid ""
"<filename>pcm</filename> drivers should implement <function>device_suspend</"
"function>, <function>device_resume</function> and <function>device_shutdown</"
"function> routines, so that power management and module unloading function correctly."
msgstr ""
" <filename> pcm </filename> motoristas devem implementar <function> device_suspend </"
"function> , <function> device_resume </function> e <function> device_shutdown </"
"function> rotinas, para que o gerenciamento de energia e o descarregamento do mÛdulo "
"funcionem corretamente. "

#: book.translate.xml:22818
#, fuzzy
msgid "Interfaces"
msgstr "Interfaces"

#: book.translate.xml:22820
#, fuzzy
msgid ""
"The interface between the <filename>pcm</filename> core and the sound drivers is "
"defined in terms of <link linkend=\"kernel-objects\">kernel objects</link>."
msgstr ""
"A interface entre o <filename> pcm </filename> n˙cleo e os drivers de som È definido "
"em termos de <link linkend=\"kernel-objects\"> objetos do kernel </link> "

#: book.translate.xml:22823
#, fuzzy
msgid ""
"There are two main interfaces that a sound driver will usually provide: "
"<emphasis>CHANNEL</emphasis> and either <emphasis>MIXER</emphasis> or "
"<emphasis>AC97</emphasis>."
msgstr ""
"Existem duas interfaces principais que um driver de som geralmente fornece: "
"<emphasis> CANAL </emphasis> e tambÈm <emphasis> MISTURADOR </emphasis> ou "
"<emphasis> AC97 </emphasis> "

#: book.translate.xml:22827
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is a very small hardware access (register "
"read/write) interface, implemented by drivers for hardware with an AC97 codec. In "
"this case, the actual MIXER interface is provided by the shared AC97 code in "
"<filename>pcm</filename>."
msgstr ""
"O <emphasis> AC97 </emphasis> interface È uma interface muito pequena de acesso ao "
"hardware (registra leitura / gravaÁ„o), implementada por drivers para hardware com "
"um codec AC97. Nesse caso, a interface MIXER real È fornecida pelo cÛdigo AC97 "
"compartilhado <filename> pcm </filename> "

#: book.translate.xml:22834
#, fuzzy
msgid "The CHANNEL Interface"
msgstr "A interface do canal"

#: book.translate.xml:22837
#, fuzzy
msgid "Common Notes for Function Parameters"
msgstr "Notas comuns para parÌ¢metros de funÁ„o"

#: book.translate.xml:22839
#, fuzzy
msgid ""
"Sound drivers usually have a private data structure to describe their device, and "
"one structure for each play and record data channel that it supports."
msgstr ""
"Os drivers de som geralmente tÍm uma estrutura de dados privada para descrever seu "
"dispositivo e uma estrutura para cada canal de dados de reproduÁ„o e gravaÁ„o que "
"ele suporta."

#: book.translate.xml:22843
#, fuzzy
msgid "For all CHANNEL interface functions, the first parameter is an opaque pointer."
msgstr ""
"Para todas as funÁÌµes da interface CHANNEL, o primeiro parÌ¢metro È um ponteiro "
"opaco."

#: book.translate.xml:22846
#, fuzzy
msgid ""
"The second parameter is a pointer to the private channel data structure, except for "
"<function>channel_init()</function> which has a pointer to the private device "
"structure (and returns the channel pointer for further use by <filename>pcm</"
"filename>)."
msgstr ""
"O segundo parÌ¢metro È um ponteiro para a estrutura de dados do canal privado, "
"exceto <function> channel_init () </function> que tem um ponteiro para a estrutura "
"do dispositivo privado (e retorna o ponteiro do canal para uso posterior por "
"<filename> pcm </filename> ) "

#: book.translate.xml:22855
#, fuzzy
msgid "Overview of Data Transfer Operations"
msgstr "Vis„o geral das operaÁÌµes de transferÍncia de dados"

#: book.translate.xml:22857
#, fuzzy
msgid ""
"For sound data transfers, the <filename>pcm</filename> core and the sound drivers "
"communicate through a shared memory area, described by a <varname remap=\"structname"
"\">struct snd_dbuf</varname>."
msgstr ""
"Para transferÍncias de dados de som, o <filename> pcm </filename> n˙cleo e os "
"drivers de som se comunicam atravÈs de uma ·rea de memÛria compartilhada, <varname "
"remap=\"structname\"> struct snd_dbuf </varname> "

#: book.translate.xml:22862
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct snd_dbuf</varname> is private to <filename>pcm</"
"filename>, and sound drivers obtain values of interest by calls to accessor "
"functions (<function>sndbuf_getxxx()</function>)."
msgstr ""
" <varname remap=\"structname\"> struct snd_dbuf </varname> È privado para <filename> "
"pcm </filename> , e os drivers de som obtÍm valores de interesse por chamadas para "
"funÁÌµes acessadoras ( <function> sndbuf_getxxx () </function> ) "

#: book.translate.xml:22867
#, fuzzy
msgid ""
"The shared memory area has a size of <function>sndbuf_getsize()</function> and is "
"divided into fixed size blocks of <function>sndbuf_getblksz()</function> bytes."
msgstr ""
"A ·rea de memÛria compartilhada tem um tamanho de <function> sndbuf_getsize () </"
"function> e È dividido em blocos de tamanho fixo <function> sndbuf_getblksz () </"
"function> bytes. "

#: book.translate.xml:22872
#, fuzzy
msgid ""
"When playing, the general transfer mechanism is as follows (reverse the idea for "
"recording):"
msgstr ""
"Ao jogar, o mecanismo geral de transferÍncia È o seguinte (inverter a ideia de "
"gravaÁ„o):"

#: book.translate.xml:22877
#, fuzzy
msgid ""
"<filename>pcm</filename> initially fills up the buffer, then calls the sound "
"driver's <link linkend=\"channel-trigger\"> <function>xxxchannel_trigger()</"
"function></link> function with a parameter of PCMTRIG_START."
msgstr ""
" <filename> pcm </filename> inicialmente preenche o buffer, em seguida, chama o "
"driver do som <link linkend=\"channel-trigger\"><function> xxxchannel_trigger () </"
"function></link> funÁ„o com um parÌ¢metro de PCMTRIG_START. "

#: book.translate.xml:22884
#, fuzzy
msgid ""
"The sound driver then arranges to repeatedly transfer the whole memory area "
"(<function>sndbuf_getbuf()</function>, <function>sndbuf_getsize()</function>) to the "
"device, in blocks of <function>sndbuf_getblksz()</function> bytes. It calls back the "
"<function>chn_intr()</function> <filename>pcm</filename> function for each "
"transferred block (this will typically happen at interrupt time)."
msgstr ""
"O driver de som ent„o organiza repetidamente a transferÍncia de toda a ·rea de "
"memÛria ( <function> sndbuf_getbuf () </function> , <function> sndbuf_getsize () </"
"function> ) ao dispositivo, em blocos de <function> sndbuf_getblksz () </function> "
"bytes. Ele chama de volta o <function> chn_intr () </function><filename> pcm </"
"filename> funÁ„o para cada bloco transferido (isso normalmente acontece no momento "
"da interrupÁ„o). "

#: book.translate.xml:22896
#, fuzzy
msgid ""
"<function>chn_intr()</function> arranges to copy new data to the area that was "
"transferred to the device (now free), and make appropriate updates to the <varname "
"remap=\"structname\">snd_dbuf</varname> structure."
msgstr ""
" <function> chn_intr () </function> organiza a cÛpia de novos dados para a ·rea que "
"foi transferida para o dispositivo (agora livre) e faz as atualizaÁÌµes apropriadas "
"<varname remap=\"structname\"> snd_dbuf </varname> estrutura."

#: book.translate.xml:22905
#, fuzzy
msgid "channel_init"
msgstr "channel_init"

#: book.translate.xml:22907
#, fuzzy
msgid ""
"<function>xxxchannel_init()</function> is called to initialize each of the play or "
"record channels. The calls are initiated from the sound driver attach routine. (See "
"the <link linkend=\"pcm-probe-and-attach\">probe and attach section</link>)."
msgstr ""
" <function> xxxchannel_init () </function> È chamado para inicializar cada um dos "
"canais de reproduÁ„o ou gravaÁ„o. As chamadas s„o iniciadas a partir da rotina de "
"anexaÁ„o do driver de som. (Veja o <link linkend=\"pcm-probe-and-attach\"> sonda e "
"anexar seÁ„o </link> ) "

#: book.translate.xml:22925
#, fuzzy
msgid ""
"<varname>b</varname> is the address for the channel <varname remap=\"structname"
"\">struct snd_dbuf</varname>. It should be initialized in the function by calling "
"<function>sndbuf_alloc()</function>. The buffer size to use is normally a small "
"multiple of the 'typical' unit transfer size for your device."
msgstr ""
" <varname> b </varname> È o endereÁo do canal <varname remap=\"structname\"> struct "
"snd_dbuf </varname> . Deve ser inicializado na funÁ„o chamando <function> "
"sndbuf_alloc () </function> . O tamanho do buffer a ser usado È normalmente um "
"pequeno m˙ltiplo do tamanho de transferÍncia da unidade ';tÌ≠pica'; para o seu "
"dispositivo. "

#: book.translate.xml:22932
#, fuzzy
msgid ""
"<varname>c</varname> is the <filename>pcm</filename> channel control structure "
"pointer. This is an opaque object. The function should store it in the local channel "
"structure, to be used in later calls to <filename>pcm</filename> (ie: "
"<function>chn_intr(c)</function>)."
msgstr ""
" <varname> c </varname> È o <filename> pcm </filename> ponteiro de estrutura de "
"controle de canal. Este È um objeto opaco. A funÁ„o deve armazen·-lo na estrutura do "
"canal local, para ser usado em chamadas posteriores <filename> pcm </filename> (ie: "
"<function> chn_intr (c) </function> ) "

#: book.translate.xml:22939
#, fuzzy
msgid ""
"<varname>dir</varname> indicates the channel direction (<literal>PCMDIR_PLAY</"
"literal> or <literal>PCMDIR_REC</literal>)."
msgstr ""
" <varname> dir </varname> indica a direÁ„o do canal ( <literal> PCMDIR_PLAY </"
"literal> ou <literal> PCMDIR_REC </literal> ) "

#: book.translate.xml:22945
#, fuzzy
msgid ""
"The function should return a pointer to the private area used to control this "
"channel. This will be passed as a parameter to other channel interface calls."
msgstr ""
"A funÁ„o deve retornar um ponteiro para a ·rea privada usada para controlar este "
"canal. Isso ser· passado como um parÌ¢metro para outras chamadas de interface de "
"canal."

#: book.translate.xml:22953
#, fuzzy
msgid "channel_setformat"
msgstr "channel_setformat"

#: book.translate.xml:22955
#, fuzzy
msgid ""
"<function>xxxchannel_setformat()</function> should set up the hardware for the "
"specified channel for the specified sound format."
msgstr ""
" <function> xxxchannel_setformat () </function> deve configurar o hardware para o "
"canal especificado para o formato de som especificado. "

#: book.translate.xml:22969
#, fuzzy
msgid ""
"<varname>format</varname> is specified as an <literal>AFMT_XXX value</literal> "
"(<filename>soundcard.h</filename>)."
msgstr ""
" <varname> formato </varname> È especificado como um <literal> Valor AFMT_XXX </"
"literal> ( <filename> soundcard.h </filename> ) "

#: book.translate.xml:22977
#, fuzzy
msgid "channel_setspeed"
msgstr "channel_setspeed"

#: book.translate.xml:22979
#, fuzzy
msgid ""
"<function>xxxchannel_setspeed()</function> sets up the channel hardware for the "
"specified sampling speed, and returns the possibly adjusted speed."
msgstr ""
" <function> xxxchannel_setspeed () </function> configura o hardware do canal para a "
"velocidade de amostragem especificada e retorna a velocidade possivelmente ajustada. "

#: book.translate.xml:22993
#, fuzzy
msgid "channel_setblocksize"
msgstr "channel_setblocksize"

#: book.translate.xml:22995
#, fuzzy
msgid ""
"<function>xxxchannel_setblocksize()</function> sets the block size, which is the "
"size of unit transactions between <filename>pcm</filename> and the sound driver, and "
"between the sound driver and the device. Typically, this would be the number of "
"bytes transferred before an interrupt occurs. During a transfer, the sound driver "
"should call <filename>pcm</filename>'s <function>chn_intr()</function> every time "
"this size has been transferred."
msgstr ""
" <function> xxxchannel_setblocksize () </function> define o tamanho do bloco, que È "
"o tamanho das transaÁÌµes unit·rias entre <filename> pcm </filename> e o driver de "
"som e entre o driver de som e o dispositivo. Normalmente, isso seria o n˙mero de "
"bytes transferidos antes de ocorrer uma interrupÁ„o. Durante uma transferÍncia, o "
"driver de som deve ligar <filename> pcm </filename> ';s <function> chn_intr () </"
"function> cada vez que esse tamanho foi transferido. "

#: book.translate.xml:23005
#, fuzzy
msgid ""
"Most sound drivers only take note of the block size here, to be used when an actual "
"transfer will be started."
msgstr ""
"A maioria dos drivers de som sÛ toma nota do tamanho do bloco aqui, para ser usado "
"quando uma transferÍncia real for iniciada."

#: book.translate.xml:23019
#, fuzzy
msgid ""
"The function returns the possibly adjusted block size. In case the block size is "
"indeed changed, <function>sndbuf_resize()</function> should be called to adjust the "
"buffer."
msgstr ""
"A funÁ„o retorna o tamanho do bloco possivelmente ajustado. Caso o tamanho do bloco "
"seja realmente alterado, <function> sndbuf_resize () </function> deve ser chamado "
"para ajustar o buffer \""

#: book.translate.xml:23028
#, fuzzy
msgid "channel_trigger"
msgstr "channel_trigger"

#: book.translate.xml:23030
#, fuzzy
msgid ""
"<function>xxxchannel_trigger()</function> is called by <filename>pcm</filename> to "
"control data transfer operations in the driver."
msgstr ""
" <function> xxxchannel_trigger () </function> È chamado por <filename> pcm </"
"filename> para controlar as operaÁÌµes de transferÍncia de dados no driver \""

#: book.translate.xml:23044
#, fuzzy
msgid ""
"<varname>go</varname> defines the action for the current call. The possible values "
"are:"
msgstr ""
" <varname> ir </varname> define a aÁ„o para a chamada atual. Os valores possÌ≠veis "
"s„o: "

#: book.translate.xml:23049
#, fuzzy
msgid ""
"<literal>PCMTRIG_START</literal>: the driver should start a data transfer from or to "
"the channel buffer. If needed, the buffer base and size can be retrieved through "
"<function>sndbuf_getbuf()</function> and <function>sndbuf_getsize()</function>."
msgstr ""
" <literal> PCMTRIG_START </literal> : o driver deve iniciar uma transferÍncia de "
"dados de ou para o buffer do canal. Se necess·rio, a base e o tamanho do buffer "
"podem ser recuperados <function> sndbuf_getbuf () </function> e <function> "
"sndbuf_getsize () </function> "

#: book.translate.xml:23058
#, fuzzy
msgid ""
"<literal>PCMTRIG_EMLDMAWR</literal> / <literal>PCMTRIG_EMLDMARD</literal>: this "
"tells the driver that the input or output buffer may have been updated. Most drivers "
"just ignore these calls."
msgstr ""
" <literal> PCMTRIG_EMLDMAWR </literal> / <literal> PCMTRIG_EMLDMARD </literal> : diz "
"ao driver que o buffer de entrada ou saÌ≠da pode ter sido atualizado. A maioria dos "
"motoristas simplesmente ignora essas chamadas. "

#: book.translate.xml:23066
#, fuzzy
msgid ""
"<literal>PCMTRIG_STOP</literal> / <literal>PCMTRIG_ABORT</literal>: the driver "
"should stop the current transfer."
msgstr ""
" <literal> PCMTRIG_STOP </literal> / <literal> PCMTRIG_ABORT </literal> : o "
"motorista deve parar a transferÍncia atual \""

#: book.translate.xml:23075
#, fuzzy
msgid ""
"If the driver uses ISA DMA, <function>sndbuf_isadma()</function> should be called "
"before performing actions on the device, and will take care of the DMA chip side of "
"things."
msgstr ""
"Se o driver usa o ISA DMA, <function> sndbuf_isadma () </function> deve ser chamado "
"antes de executar aÁÌµes no dispositivo, e vai cuidar do lado do chip DMA das coisas "
"\""

#: book.translate.xml:23083
#, fuzzy
msgid "channel_getptr"
msgstr "channel_getptr"

#: book.translate.xml:23085
#, fuzzy
msgid ""
"<function>xxxchannel_getptr()</function> returns the current offset in the transfer "
"buffer. This will typically be called by <function>chn_intr()</function>, and this "
"is how <filename>pcm</filename> knows where it can transfer new data."
msgstr ""
" <function> xxxchannel_getptr () </function> retorna o deslocamento atual no buffer "
"de transferÍncia. Isso normalmente ser· chamado por <function> chn_intr () </"
"function> e È assim <filename> pcm </filename> sabe onde pode transferir novos "
"dados. "

#: book.translate.xml:23093
#, fuzzy
msgid "channel_free"
msgstr "channel_free"

#: book.translate.xml:23095
#, fuzzy
msgid ""
"<function>xxxchannel_free()</function> is called to free up channel resources, for "
"example when the driver is unloaded, and should be implemented if the channel data "
"structures are dynamically allocated or if <function>sndbuf_alloc()</function> was "
"not used for buffer allocation."
msgstr ""
" <function> xxxchannel_free () </function> È chamado para liberar recursos do canal, "
"por exemplo, quando o driver È descarregado, e deve ser implementado se as "
"estruturas de dados do canal forem alocadas dinamicamente ou se <function> "
"sndbuf_alloc () </function> n„o foi usado para alocaÁ„o de buffer. "

#: book.translate.xml:23104
#, fuzzy
msgid "channel_getcaps"
msgstr "channel_getcaps"

#: book.translate.xml:23115
#, fuzzy
msgid ""
"The routine returns a pointer to a (usually statically-defined) <varname remap="
"\"structname\">pcmchan_caps</varname> structure (defined in <filename>sound/pcm/"
"channel.h</filename>. The structure holds the minimum and maximum sampling "
"frequencies, and the accepted sound formats. Look at any sound driver for an example."
msgstr ""
"A rotina retorna um ponteiro para um (geralmente definido estaticamente) <varname "
"remap=\"structname\"> pcmchan_caps </varname> estrutura (definida em <filename> "
"som / pcm / channel.h </filename> . A estrutura contÈm as freqÌºÍncias de amostragem "
"mÌ≠nima e m·xima e os formatos de som aceitos. Olhe para qualquer driver de som como "
"exemplo. "

#: book.translate.xml:23127
#, fuzzy
msgid "More Functions"
msgstr "Mais funÁÌµes"

#: book.translate.xml:23129
#, fuzzy
msgid ""
"<function>channel_reset()</function>, <function>channel_resetdone()</function>, and "
"<function>channel_notify()</function> are for special purposes and should not be "
"implemented in a driver without discussing it on the <link xlink:href=\"http://lists."
"FreeBSD.org/mailman/listinfo/freebsd-multimedia\">FreeBSD multimedia mailing list</"
"link>."
msgstr ""
" <function> channel_reset () </function> , <function> channel_resetdone () </"
"function> e <function> channel_notify () </function> s„o para fins especiais e n„o "
"devem ser implementados em um driver sem discuti-lo no <link xlink:href=\"http://"
"lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia\"> Lista de discuss„o multimÌ≠"
"dia do FreeBSD </link> "

#: book.translate.xml:23135
#, fuzzy
msgid "<function>channel_setdir()</function> is deprecated."
msgstr " <function> channel_setdir () </function> est· obsoleto. "

#: book.translate.xml:23141
#, fuzzy
msgid "The MIXER Interface"
msgstr "A interface MIXER"

#: book.translate.xml:23144
#, fuzzy
msgid "mixer_init"
msgstr "mixer_init"

#: book.translate.xml:23146
#, fuzzy
msgid ""
"<function>xxxmixer_init()</function> initializes the hardware and tells "
"<filename>pcm</filename> what mixer devices are available for playing and recording"
msgstr ""
" <function> xxxmixer_init () </function> inicializa o hardware e informa <filename> "
"pcm </filename> quais dispositivos de mixagem est„o disponÌ≠veis para tocar e gravar "

#: book.translate.xml:23168
#, fuzzy
msgid ""
"Set bits in an integer value and call <function>mix_setdevs()</function> and "
"<function>mix_setrecdevs()</function> to tell <filename>pcm</filename> what devices "
"exist."
msgstr ""
"Definir bits em um valor inteiro e chamar <function> mix_setdevs () </function> e "
"<function> mix_setrecdevs () </function> contar <filename> pcm </filename> quais "
"dispositivos existem \""

#: book.translate.xml:23175
#, fuzzy
msgid ""
"Mixer bits definitions can be found in <filename>soundcard.h</filename> "
"(<literal>SOUND_MASK_XXX</literal> values and <literal>SOUND_MIXER_XXX</literal> bit "
"shifts)."
msgstr ""
"As definiÁÌµes dos misturadores podem ser encontradas em <filename> soundcard.h </"
"filename> ( <literal> SOUND_MASK_XXX </literal> valores e <literal> SOUND_MIXER_XXX "
"</literal> mudanÁas de bit). "

#: book.translate.xml:23182
#, fuzzy
msgid "mixer_set"
msgstr "mixer_set"

#: book.translate.xml:23184
#, fuzzy
msgid "<function>xxxmixer_set()</function> sets the volume level for one mixer device."
msgstr ""
" <function> xxxmixer_set () </function> define o nÌ≠vel de volume para um dispositivo "
"de mixagem. "

#: book.translate.xml:23198
#, fuzzy
msgid "The device is specified as a <literal>SOUND_MIXER_XXX</literal> value"
msgstr "O dispositivo È especificado como <literal> SOUND_MIXER_XXX </literal> valor"

#: book.translate.xml:23201
#, fuzzy
msgid ""
"The volume values are specified in range [0-100]. A value of zero should mute the "
"device."
msgstr ""
"Os valores de volume s„o especificados no intervalo [0-100]. Um valor de zero deve "
"silenciar o dispositivo."

#: book.translate.xml:23206
#, fuzzy
msgid ""
"As the hardware levels probably will not match the input scale, and some rounding "
"will occur, the routine returns the actual level values (in range 0-100) as shown."
msgstr ""
"Como os nÌ≠veis de hardware provavelmente n„o corresponder„o Ì† escala de entrada, e "
"algum arredondamento ocorrer·, a rotina retornar· os valores reais de nÌ≠vel (no "
"intervalo de 0 a 100), como mostrado."

#: book.translate.xml:23216
#, fuzzy
msgid "mixer_setrecsrc"
msgstr "mixer_setrecsrc"

#: book.translate.xml:23218
#, fuzzy
msgid "<function>xxxmixer_setrecsrc()</function> sets the recording source device."
msgstr ""
" <function> xxxmixer_setrecsrc () </function> define o dispositivo de origem de "
"gravaÁ„o. "

#: book.translate.xml:23234
#, fuzzy
msgid "The desired recording devices are specified as a bit field"
msgstr "Os dispositivos de gravaÁ„o desejados s„o especificados como um campo de bits"

#: book.translate.xml:23239
#, fuzzy
msgid ""
"The actual devices set for recording are returned. Some drivers can only set one "
"device for recording. The function should return -1 if an error occurs."
msgstr ""
"Os dispositivos atuais configurados para gravaÁ„o s„o retornados. Alguns drivers "
"podem apenas configurar um dispositivo para gravaÁ„o. A funÁ„o deve retornar -1 se "
"ocorrer um erro."

#: book.translate.xml:23247
#, fuzzy
msgid "mixer_uninit, mixer_reinit"
msgstr "mixer_uninit, mixer_reinit"

#: book.translate.xml:23249
#, fuzzy
msgid ""
"<function>xxxmixer_uninit()</function> should ensure that all sound is muted and if "
"possible mixer hardware should be powered down"
msgstr ""
" <function> xxxmixer_uninit () </function> deve garantir que todo o som seja "
"silenciado e, se possÌ≠vel, o hardware do mixer deve ser desligado "

#: book.translate.xml:23253
#, fuzzy
msgid ""
"<function>xxxmixer_reinit()</function> should ensure that the mixer hardware is "
"powered up and any settings not controlled by <function>mixer_set()</function> or "
"<function>mixer_setrecsrc()</function> are restored."
msgstr ""
" <function> xxxmixer_reinit () </function> deve garantir que o hardware do mixer "
"esteja ligado e quaisquer configuraÁÌµes n„o <function> mixer_set () </function> ou "
"<function> mixer_setrecsrc () </function> s„o restaurados \""

#: book.translate.xml:23261
#, fuzzy
msgid "The AC97 Interface"
msgstr "A interface do AC97"

#: book.translate.xml:23263
#, fuzzy
msgid "<primary>AC97</primary>"
msgstr " <primary> AC97 </primary> "

#: book.translate.xml:23265
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is implemented by drivers with an AC97 "
"codec. It only has three methods:"
msgstr ""
"O <emphasis> AC97 </emphasis> A interface È implementada por drivers com um codec "
"AC97. Tem apenas trÍs mÈtodos: "

#: book.translate.xml:23271
#, fuzzy
msgid "<function>xxxac97_init()</function> returns the number of ac97 codecs found."
msgstr ""
" <function> xxxac97_init () </function> retorna o n˙mero de codecs ac97 encontrados. "

#: book.translate.xml:23276
#, fuzzy
msgid ""
"<function>ac97_read()</function> and <function>ac97_write()</function> read or write "
"a specified register."
msgstr ""
" <function> ac97_read () </function> e <function> ac97_write () </function> ler ou "
"escrever um registro especificado. "

#: book.translate.xml:23282
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is used by the AC97 code in <filename>pcm</"
"filename> to perform higher level operations. Look at <filename>sound/pci/maestro3."
"c</filename> or many others under <filename>sound/pci/</filename> for an example."
msgstr ""
"O <emphasis> AC97 </emphasis> interface È usada pelo cÛdigo AC97 em <filename> pcm </"
"filename> para executar operaÁÌµes de nÌ≠vel superior. Olhe para <filename> som / "
"pci / maestro3.c </filename> ou muitos outros sob <filename> som / pci / </filename> "
"Por exemplo."

#: book.translate.xml:23298
#, fuzzy
msgid "PC Card"
msgstr "PC Card"

#: book.translate.xml:23300
#, fuzzy
msgid "<primary>PC Card</primary>"
msgstr " <primary> Cart„o PC </primary> "

#: book.translate.xml:23301
#, fuzzy
msgid "<primary>CardBus</primary>"
msgstr " <primary> CardBus </primary> "

#: book.translate.xml:23303
#, fuzzy
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device driver for "
"a PC Card or CardBus device. However, at present it just documents how to add a new "
"device to an existing pccard driver."
msgstr ""
"Este capÌ≠tulo vai falar sobre os mecanismos do FreeBSD para escrever um driver de "
"dispositivo para um PC Card ou um dispositivo CardBus. No entanto, no momento ele "
"apenas documenta como adicionar um novo dispositivo a um driver de placa pc "
"existente."

#: book.translate.xml:23309
#, fuzzy
msgid "Adding a Device"
msgstr "Adicionando um dispositivo"

#: book.translate.xml:23311
#, fuzzy
msgid ""
"Device drivers know what devices they support. There is a table of supported devices "
"in the kernel that drivers use to attach to a device."
msgstr ""
"Os drivers de dispositivos sabem quais dispositivos eles suportam. H· uma tabela de "
"dispositivos suportados no kernel que os drivers usam para conectar a um dispositivo."

#: book.translate.xml:23318
#, fuzzy
msgid "<primary>CIS</primary>"
msgstr " <primary> CIS </primary> "

#: book.translate.xml:23319
#, fuzzy
msgid ""
"PC Cards are identified in one of two ways, both based on the <firstterm>Card "
"Information Structure</firstterm> (<acronym role=\"Card Information Structure\">CIS</"
"acronym>) stored on the card. The first method is to use numeric manufacturer and "
"product numbers. The second method is to use the human readable strings that are "
"also contained in the CIS. The PC Card bus uses a centralized database and some "
"macros to facilitate a design pattern to help the driver writer match devices to his "
"driver."
msgstr ""
"PC Cards s„o identificados de duas maneiras, ambas baseadas no <firstterm> Estrutura "
"de informaÁÌµes do cart„o </firstterm> ( <acronym role=\"Card Information Structure"
"\">CIS</acronym> ) armazenado no cart„o. O primeiro mÈtodo È usar n˙meros numÈricos "
"de fabricantes e produtos. O segundo mÈtodo È usar as cadeias humanas legÌ≠veis que "
"tambÈm est„o contidas no CIS. O barramento da placa de PC usa um banco de dados "
"centralizado e algumas macros para facilitar um padr„o de projeto para ajudar o "
"gravador do driver a combinar os dispositivos com o driver. "

#: book.translate.xml:23330
#, fuzzy
msgid ""
"Original equipment manufacturers (<acronym>OEM</acronym>s) often develop a reference "
"design for a PC Card product, then sell this design to other companies to market. "
"Those companies refine the design, market the product to their target audience or "
"geographic area, and put their own name plate onto the card. The refinements to the "
"physical card are typically very minor, if any changes are made at all. To "
"strengthen their brand, these vendors place their company name in the human readable "
"strings in the CIS space, but leave the manufacturer and product IDs unchanged."
msgstr ""
"Fabricantes de equipamentos originais ( <acronym>OEMs</acronym> ) frequentemente "
"desenvolvem um design de referÍncia para um produto de PC Card e vendem esse projeto "
"para outras empresas. Essas empresas refinam o design, comercializam o produto para "
"seu p˙blico-alvo ou ·rea geogr·fica e placa de identificaÁ„o para o cart„o.Os "
"refinamentos para o cart„o fÌ≠sico s„o normalmente muito pequenas, se forem feitas "
"alteraÁÌµes a todos.Para fortalecer sua marca, esses fornecedores colocam o nome da "
"empresa nas seqÌºÍncias legÌ≠veis para humanos no espaÁo CIS, mas deixam o fabricante "
"e IDs de produto inalterados. "

#: book.translate.xml:23341
#, fuzzy
msgid "<primary>NetGear</primary>"
msgstr " <primary> NetGear </primary> "

#: book.translate.xml:23342
#, fuzzy
msgid "<primary>Linksys</primary>"
msgstr " <primary> Linksys </primary> "

#: book.translate.xml:23343
#, fuzzy
msgid "<primary>D-Link</primary>"
msgstr " <primary> D-Link </primary> "

#: book.translate.xml:23345
#, fuzzy
msgid ""
"Because of this practice, FreeBSD drivers usually rely on numeric IDs for device "
"identification. Using numeric IDs and a centralized database complicates adding IDs "
"and support for cards to the system. One must carefully check to see who really made "
"the card, especially when it appears that the vendor who made the card might already "
"have a different manufacturer ID listed in the central database. Linksys, D-Link, "
"and NetGear are a number of US manufacturers of LAN hardware that often sell the "
"same design. These same designs can be sold in Japan under names such as Buffalo and "
"Corega. Often, these devices will all have the same manufacturer and product IDs."
msgstr ""
"Devido a essa pr·tica, os drivers do FreeBSD geralmente dependem de IDs numÈricos "
"para identificaÁ„o do dispositivo. O uso de IDs numÈricos e um banco de dados "
"centralizado dificulta a adiÁ„o de IDs e suporte a cartÌµes no sistema. Ìâ preciso "
"verificar cuidadosamente quem realmente fez o cart„o, especialmente quando Parece "
"que o fornecedor que fez o cart„o j· pode ter um ID de fabricante diferente listado "
"no banco de dados central.A Linksys, D-Link e NetGear s„o um n˙mero de fabricantes "
"dos EUA de hardware de rede local que muitas vezes vendem o mesmo design. vendidos "
"no Jap„o sob nomes como Buffalo e Corega. Muitas vezes, esses dispositivos ter„o "
"todos os mesmos IDs de fabricantes e produtos. "

#: book.translate.xml:23358
#, fuzzy
msgid ""
"The PC Card bus code keeps a central database of card information, but not which "
"driver is associated with them, in <filename>/sys/dev/pccard/pccarddevs</filename>. "
"It also provides a set of macros that allow one to easily construct simple entries "
"in the table the driver uses to claim devices."
msgstr ""
"O cÛdigo de barramento do PC Card mantÈm um banco de dados central de informaÁÌµes "
"do cart„o, mas n„o qual driver est· associado a eles, <filename> / sys / dev / "
"pccard / pccarddevs </filename> . Ele tambÈm fornece um conjunto de macros que "
"permitem construir facilmente entradas simples na tabela que o driver usa para "
"reivindicar dispositivos. "

#: book.translate.xml:23365
#, fuzzy
msgid ""
"Finally, some really low end devices do not contain manufacturer identification at "
"all. These devices must be detected by matching the human readable CIS strings. "
"While it would be nice if we did not need this method as a fallback, it is necessary "
"for some very low end CD-ROM players and Ethernet cards. This method should "
"generally be avoided, but a number of devices are listed in this section because "
"they were added prior to the recognition of the <acronym>OEM</acronym> nature of the "
"PC Card business. When adding new devices, prefer using the numeric method."
msgstr ""
"Finalmente, alguns dispositivos realmente low-end n„o contÍm identificaÁ„o do "
"fabricante. Esses dispositivos devem ser detectados combinando as strings CIS legÌ≠"
"veis. Embora seja bom se n„o precisarmos desse mÈtodo como um fallback, È necess·rio "
"que alguns reprodutores de CD-ROM e placas Ethernet muito low end Esse mÈtodo deve "
"ser geralmente evitado, mas v·rios dispositivos s„o listados nesta seÁ„o porque "
"foram adicionados antes do reconhecimento da natureza <acronym>OEM</acronym> do "
"negÛcio do PC Card. , prefira usar o mÈtodo numÈrico. "

#: book.translate.xml:23378
#, fuzzy
msgid "Format of <filename>pccarddevs</filename>"
msgstr "Formato de <filename> pccarddevs </filename> "

#: book.translate.xml:23380
#, fuzzy
msgid ""
"There are four sections in the <filename>pccarddevs</filename> files. The first "
"section lists the manufacturer numbers for vendors that use them. This section is "
"sorted in numerical order. The next section has all of the products that are used by "
"these vendors, along with their product ID numbers and a description string. The "
"description string typically is not used (instead we set the device's description "
"based on the human readable CIS, even if we match on the numeric version). These two "
"sections are then repeated for devices that use the string matching method. Finally, "
"C-style comments enclosed in <literal>/*</literal> and <literal>*/</literal> "
"characters are allowed anywhere in the file."
msgstr ""
"H· quatro seÁÌµes no <filename> pccarddevs </filename> arquivos. A primeira seÁ„o "
"lista os n˙meros do fabricante dos fornecedores que os utilizam. Esta seÁ„o È "
"classificada em ordem numÈrica. A prÛxima seÁ„o tem todos os produtos usados ‚Äã‚Äãpor "
"esses fornecedores, juntamente com seus n˙meros de identificaÁ„o de produto e uma "
"string de descriÁ„o. A string de descriÁ„o geralmente n„o È usada (em vez disso, "
"definimos a descriÁ„o do dispositivo com base no CIS legÌ≠vel, mesmo se "
"correspondermos Ì† vers„o numÈrica). Essas duas seÁÌµes s„o repetidas para "
"dispositivos que usam o mÈtodo de correspondÍncia de seqÌºÍncia de caracteres. "
"Finalmente, coment·rios no estilo C incluÌ≠dos <literal> / * </literal> e <literal> "
"* / </literal> caracteres s„o permitidos em qualquer lugar do arquivo. "

#: book.translate.xml:23394
#, fuzzy
msgid ""
"The first section of the file contains the vendor IDs. Please keep this list sorted "
"in numeric order. Also, please coordinate changes to this file because we share it "
"with NetBSD to help facilitate a common clearing house for this information. For "
"example, here are the first few vendor IDs:"
msgstr ""
"A primeira seÁ„o do arquivo contÈm os IDs do fornecedor. Por favor, mantenha esta "
"lista classificada em ordem numÈrica. AlÈm disso, coordene as alteraÁÌµes neste "
"arquivo, porque o compartilhamos com o NetBSD para ajudar a facilitar uma cÌ¢mara de "
"compensaÁ„o comum para essas informaÁÌµes. Por exemplo, aqui s„o os primeiros poucos "
"IDs de fornecedores: "

#: book.translate.xml:23406
#, fuzzy
msgid ""
"Chances are very good that the <literal>NETGEAR_2</literal> entry is really an OEM "
"that NETGEAR purchased cards from and the author of support for those cards was "
"unaware at the time that Netgear was using someone else's ID. These entries are "
"fairly straightforward. The vendor keyword denotes the kind of line that this is, "
"followed by the name of the vendor. This name will be repeated later in "
"<filename>pccarddevs</filename>, as well as used in the driver's match tables, so "
"keep it short and a valid C identifier. A numeric ID in hex identifies the "
"manufacturer. Do not add IDs of the form <literal>0xffffffff</literal> or "
"<literal>0xffff</literal> because these are reserved IDs (the former is <quote>no ID "
"set</quote> while the latter is sometimes seen in extremely poor quality cards to "
"try to indicate <quote>none</quote>). Finally there is a string description of the "
"company that makes the card. This string is not used in FreeBSD for anything but "
"commentary purposes."
msgstr ""
"As chances s„o muito boas que o <literal> NETGEAR_2 </literal> A entrada È realmente "
"um OEM do qual a NETGEAR comprou cartÌµes e o autor do suporte para esses cartÌµes "
"n„o sabia no momento em que a Netgear usava o ID de outra pessoa. Essas entradas s„o "
"bastante simples. A palavra-chave do fornecedor indica o tipo de linha que È seguido "
"pelo nome do fornecedor. Este nome ser· repetido mais tarde <filename> pccarddevs </"
"filename> , bem como usado nas tabelas de correspondÍncia do driver, portanto, "
"mantenha-o curto e um identificador C v·lido. Um ID numÈrico em hex identifica o "
"fabricante. N„o adicione IDs do formul·rio <literal> 0xffffffff </literal> ou "
"<literal> 0xffff </literal> porque estes s„o IDs reservados (o primeiro È <quote> "
"nenhum conjunto de ID </quote> enquanto o ˙ltimo È visto Ì†s vezes em cartÌµes de "
"extrema baixa qualidade para tentar indicar <quote> Nenhum </quote> ). Finalmente, "
"h· uma descriÁ„o da string da empresa que faz o cart„o. Esta string n„o È usada no "
"FreeBSD para fins que n„o sejam coment·rios. "

#: book.translate.xml:23425
#, fuzzy
msgid ""
"The second section of the file contains the products. As shown in this example, the "
"format is similar to the vendor lines:"
msgstr ""
"A segunda seÁ„o do arquivo contÈm os produtos. Conforme mostrado neste exemplo, o "
"formato È semelhante Ì†s linhas do fornecedor:"

#: book.translate.xml:23435
#, fuzzy
msgid ""
"The <literal>product</literal> keyword is followed by the vendor name, repeated from "
"above. This is followed by the product name, which is used by the driver and should "
"be a valid C identifier, but may also start with a number. As with the vendors, the "
"hex product ID for this card follows the same convention for <literal>0xffffffff</"
"literal> and <literal>0xffff</literal>. Finally, there is a string description of "
"the device itself. This string typically is not used in FreeBSD, since FreeBSD's "
"pccard bus driver will construct a string from the human readable CIS entries, but "
"it can be used in the rare cases where this is somehow insufficient. The products "
"are in alphabetical order by manufacturer, then numerical order by product ID. They "
"have a C comment before each manufacturer's entries and there is a blank line "
"between entries."
msgstr ""
"O <literal> produtos </literal> palavra-chave È seguida pelo nome do fornecedor, "
"repetido de cima. Isto È seguido pelo nome do produto, que È usado pelo driver e "
"deve ser um identificador C v·lido, mas tambÈm pode comeÁar com um n˙mero. Tal como "
"acontece com os fornecedores, o ID do produto hexadecimal para este cart„o segue a "
"mesma convenÁ„o para <literal> 0xffffffff </literal> e <literal> 0xffff </literal> . "
"Finalmente, h· uma descriÁ„o de string do prÛprio dispositivo. Esta string "
"normalmente n„o È usada no FreeBSD, j· que o driver de barramento de pccard do "
"FreeBSD ir· construir uma string a partir das entradas do CIS legÌ≠vel, mas pode ser "
"usado nos raros casos em que isso È de alguma forma insuficiente. Os produtos est„o "
"em ordem alfabÈtica por fabricante, em seguida, ordem numÈrica por ID do produto. "
"Eles tÍm um coment·rio C antes das entradas de cada fabricante e h· uma linha em "
"branco entre as entradas. "

#: book.translate.xml:23452
#, fuzzy
msgid ""
"The third section is like the previous vendor section, but with all of the "
"manufacturer numeric IDs set to <literal>-1</literal>, meaning <quote>match anything "
"found</quote> in the FreeBSD pccard bus code. Since these are C identifiers, their "
"names must be unique. Otherwise the format is identical to the first section of the "
"file."
msgstr ""
"A terceira seÁ„o È como a seÁ„o anterior do fornecedor, mas com todas as IDs "
"numÈricas do fabricante configuradas como <literal> -1 </literal> significado "
"<quote> coincidir com qualquer coisa encontrada </quote> no cÛdigo de barramento do "
"pccard do FreeBSD. Como esses s„o identificadores C, seus nomes devem ser "
"exclusivos. Caso contr·rio, o formato È idÍntico Ì† primeira seÁ„o do arquivo. "

#: book.translate.xml:23460
#, fuzzy
msgid ""
"The final section contains the entries for those cards that must be identified by "
"string entries. This section's format is a little different from the generic section:"
msgstr ""
"A seÁ„o final contÈm as entradas para as placas que devem ser identificadas por "
"entradas de string. O formato desta seÁ„o È um pouco diferente da seÁ„o genÈrica:"

#: book.translate.xml:23467
#, fuzzy
msgid ""
"The familiar <literal>product</literal> keyword is followed by the vendor name and "
"the card name, just as in the second section of the file. Here the format deviates "
"from that used earlier. There is a {} grouping, followed by a number of strings. "
"These strings correspond to the vendor, product, and extra information that is "
"defined in a CIS_INFO tuple. These strings are filtered by the program that "
"generates <filename>pccarddevs.h</filename> to replace &amp;sp with a real space. "
"NULL strings mean that the corresponding part of the entry should be ignored. The "
"example shown here contains a bad entry. It should not contain the version number "
"unless that is critical for the operation of the card. Sometimes vendors will have "
"many different versions of the card in the field that all work, in which case that "
"information only makes it harder for someone with a similar card to use it with "
"FreeBSD. Sometimes it is necessary when a vendor wishes to sell many different parts "
"under the same brand due to market considerations (availability, price, and so "
"forth). Then it can be critical to disambiguating the card in those rare cases where "
"the vendor kept the same manufacturer/product pair. Regular expression matching is "
"not available at this time."
msgstr ""
"O familiar <literal> produtos </literal> A palavra-chave È seguida pelo nome do "
"fornecedor e pelo nome do cart„o, assim como na segunda seÁ„o do arquivo. Aqui o "
"formato se desvia do usado anteriormente. H· um {} agrupamento, seguido por v·rias "
"sequÍncias. Essas sequÍncias correspondem ao fornecedor, ao produto e Ì†s "
"informaÁÌµes extras definidas em uma tupla CIS_INFO. Essas strings s„o filtradas "
"pelo programa que gera <filename> pccarddevs.h </filename> para substituir o sp por "
"um espaÁo real. Strings NULL significam que a parte correspondente da entrada deve "
"ser ignorada. O exemplo mostrado aqui contÈm uma entrada incorreta. Ele n„o deve "
"conter o n˙mero da vers„o, a menos que isso seja crÌ≠tico para a operaÁ„o do cart„o. "
"ÌÄs vezes, os fornecedores ter„o muitas versÌµes diferentes do cart„o no campo que "
"funcionam, e nesse caso essa informaÁ„o sÛ dificulta que alguÈm com um cart„o "
"semelhante o use com o FreeBSD. ÌÄs vezes È necess·rio quando um fornecedor deseja "
"vender muitas peÁas diferentes sob a mesma marca devido a consideraÁÌµes de mercado "
"(disponibilidade, preÁo e assim por diante). Ent„o, pode ser crÌ≠tico desambiguar o "
"cart„o nos raros casos em que o fornecedor manteve o mesmo par fabricante / produto. "
"A correspondÍncia de express„o regular n„o est· disponÌ≠vel no momento. "

#: book.translate.xml:23492
#, fuzzy
msgid "Sample Probe Routine"
msgstr "Rotina da Sonda de Amostra"

#: book.translate.xml:23494
#, fuzzy
msgid "<primary>PC Card</primary> <secondary>probe</secondary>"
msgstr " <primary> Cart„o PC </primary><secondary> sonda </secondary> "

#: book.translate.xml:23499
#, fuzzy
msgid ""
"To understand how to add a device to the list of supported devices, one must "
"understand the probe and/or match routines that many drivers have. It is complicated "
"a little in FreeBSD 5.x because there is a compatibility layer for OLDCARD present "
"as well. Since only the window-dressing is different, an idealized version will be "
"presented here."
msgstr ""
"Para entender como adicionar um dispositivo Ì† lista de dispositivos suportados, "
"deve-se entender a sonda e / ou combinar as rotinas que muitos drivers possuem. Ìâ um "
"pouco complicado no FreeBSD 5.x porque existe uma camada de compatibilidade para "
"OLDCARD presente como Bem, uma vez que apenas a janela de vestir È diferente, uma "
"vers„o idealizada ser· apresentada aqui \""

#: book.translate.xml:23529
#, fuzzy
msgid ""
"Here we have a simple pccard probe routine that matches a few devices. As stated "
"above, the name may vary (if it is not <function>foo_pccard_probe()</function> it "
"will be <function>foo_pccard_match()</function>). The function "
"<function>pccard_product_lookup()</function> is a generalized function that walks "
"the table and returns a pointer to the first entry that it matches. Some drivers may "
"use this mechanism to convey additional information about some cards to the rest of "
"the driver, so there may be some variance in the table. The only requirement is that "
"each row of the table must have a <function>struct</function> <varname remap="
"\"structname\">pccard_product</varname> as the first element."
msgstr ""
"Aqui temos uma simples rotina de teste pccard que combina com alguns dispositivos. "
"Como dito acima, o nome pode variar (se n„o for <function> foo_pccard_probe () </"
"function> ser· <function> foo_pccard_match () </function> ). A funÁ„o <function> "
"pccard_product_lookup () </function> È uma funÁ„o generalizada que percorre a tabela "
"e retorna um ponteiro para a primeira entrada correspondente. Alguns drivers podem "
"usar esse mecanismo para transmitir informaÁÌµes adicionais sobre alguns cartÌµes "
"para o restante do driver, portanto, pode haver alguma variaÁ„o na tabela. O ˙nico "
"requisito È que cada linha da tabela deve ter um <function> struct </"
"function><varname remap=\"structname\"> pccard_product </varname> como o primeiro "
"elemento \""

#: book.translate.xml:23543
#, fuzzy
msgid ""
"Looking at the table <varname remap=\"structname\">wi_pccard_products</varname>, one "
"notices that all the entries are of the form <function>PCMCIA_CARD(<replaceable>foo</"
"replaceable>, <replaceable>bar</replaceable>, <replaceable>baz</replaceable>)</"
"function>. The <replaceable>foo</replaceable> part is the manufacturer ID from "
"<filename>pccarddevs</filename>. The <replaceable>bar</replaceable> part is the "
"product ID. <replaceable>baz</replaceable> is the expected function number for this "
"card. Many pccards can have multiple functions, and some way to disambiguate "
"function 1 from function 0 is needed. You may see <literal>PCMCIA_CARD_D</literal>, "
"which includes the device description from <filename>pccarddevs</filename>. You may "
"also see <literal>PCMCIA_CARD2</literal> and <literal>PCMCIA_CARD2_D</literal> which "
"are used when you need to match both CIS strings and manufacturer numbers, in the "
"<quote>use the default description</quote> and <quote>take the description from "
"pccarddevs</quote> flavors."
msgstr ""
"Olhando para a mesa <varname remap=\"structname\"> wi_pccard_products </varname> , "
"percebe-se que todas as entradas s„o da forma <function> PCMCIA_CARD ( <replaceable> "
"foo </replaceable> , <replaceable> Barra </replaceable> , <replaceable> baz </"
"replaceable> ) </function> . o <replaceable> foo </replaceable> parte È o ID do "
"fabricante de <filename> pccarddevs </filename> . o <replaceable> Barra </"
"replaceable> parte È o ID do produto. <replaceable> baz </replaceable> È o n˙mero da "
"funÁ„o esperada para este cart„o. Muitos pccards podem ter m˙ltiplas funÁÌµes, e "
"alguma maneira de desambiguar a funÁ„o 1 da funÁ„o 0 È necess·ria. VocÍ pode ver "
"<literal> PCMCIA_CARD_D </literal> , que inclui a descriÁ„o do dispositivo de "
"<filename> pccarddevs </filename> . VocÍ tambÈm pode ver <literal> PCMCIA_CARD2 </"
"literal> e <literal> PCMCIA_CARD2_D </literal> que s„o usados ‚Äã‚Äãquando vocÍ precisa "
"combinar as seqÌºÍncias de caracteres do CIS e os n˙meros do fabricante, no <quote> "
"use a descriÁ„o padr„o </quote> e <quote> Pegue a descriÁ„o do pccarddevs </quote> "
"sabores. "

#: book.translate.xml:23566
#, fuzzy
msgid "Putting it All Together"
msgstr "Colocando tudo junto"

#: book.translate.xml:23568
#, fuzzy
msgid ""
"To add a new device, one must first obtain the identification information from the "
"device. The easiest way to do this is to insert the device into a PC Card or CF slot "
"and issue <command>devinfo -v</command>. Sample output:"
msgstr ""
"Para adicionar um novo dispositivo, È necess·rio primeiro obter as informaÁÌµes de "
"identificaÁ„o do dispositivo. A maneira mais f·cil de fazer isso È inserir o "
"dispositivo em um slot e cart„o PC Card ou CF. <command> devinfo -v </command> . "
"Exemplo de saÌ≠da: "

#: book.translate.xml:23579
#, fuzzy
msgid ""
"<literal>manufacturer</literal> and <literal>product</literal> are the numeric IDs "
"for this product, while <literal>cisvendor</literal> and <literal>cisproduct</"
"literal> are the product description strings from the CIS."
msgstr ""
" <literal> fabricante </literal> e <literal> produtos </literal> s„o os IDs "
"numÈricos para este produto, enquanto <literal> cisvendor </literal> e <literal> "
"cisproduto </literal> s„o as strings de descriÁ„o do produto do CIS. "

#: book.translate.xml:23585
#, fuzzy
msgid ""
"Since we first want to prefer the numeric option, first try to construct an entry "
"based on that. The above card has been slightly fictionalized for the purpose of "
"this example. The vendor is BUFFALO, which we see already has an entry:"
msgstr ""
"Como queremos primeiro preferir a opÁ„o numÈrica, primeiro tente construir uma "
"entrada com base nisso. O cart„o acima foi ligeiramente ficcionalizado para o "
"propÛsito deste exemplo. O fornecedor È BUFFALO, que j· vemos com uma entrada:"

#: book.translate.xml:23593
#, fuzzy
msgid "But there is no entry for this particular card. Instead we find:"
msgstr "Mas n„o h· entrada para este cart„o em particular. Em vez disso, encontramos:"

#: book.translate.xml:23602
#, fuzzy
msgid ""
"To add the device, we can just add this entry to <filename>pccarddevs</filename>:"
msgstr ""
"Para adicionar o dispositivo, podemos adicionar essa entrada para <filename> "
"pccarddevs </filename> : "

#: book.translate.xml:23607
#, fuzzy
msgid ""
"Once these steps are complete, the card can be added to the driver. That is a simple "
"operation of adding one line:"
msgstr ""
"Depois que essas etapas forem concluÌ≠das, o cart„o pode ser adicionado ao driver. "
"Essa È uma operaÁ„o simples de adicionar uma linha:"

#: book.translate.xml:23620
#, fuzzy
msgid ""
"Note that I have included a '<literal>+</literal>' in the line before the line that "
"I added, but that is simply to highlight the line. Do not add it to the actual "
"driver. Once you have added the line, you can recompile your kernel or module and "
"test it. If the device is recognized and works, please submit a patch. If it does "
"not work, please figure out what is needed to make it work and submit a patch. If "
"the device is not recognized at all, you have done something wrong and should "
"recheck each step."
msgstr ""
"Note que eu incluÌ≠ um '; <literal> + </literal> ' na linha antes da linha que eu "
"adicionei, mas isso È simplesmente para destacar a linha. N„o o adicione ao driver "
"real. Depois de adicionar a linha, vocÍ pode recompilar seu kernel ou mÛdulo e test·-"
"lo. Se o dispositivo for reconhecido e funcionar, envie um patch. Se isso n„o "
"funcionar, descubra o que È necess·rio para que funcione e envie um patch. Se o "
"dispositivo n„o for reconhecido, vocÍ fez algo errado e deve verificar novamente "
"cada etapa. "

#: book.translate.xml:23630
#, fuzzy
msgid ""
"If you are a FreeBSD src committer, and everything appears to be working, then you "
"can commit the changes to the tree. However, there are some minor tricky things to "
"be considered. <filename>pccarddevs</filename> must be committed to the tree first. "
"Then <filename>pccarddevs.h</filename> must be regenerated and committed as a second "
"step, ensuring that the right $FreeBSD$ tag is in the latter file. Finally, commit "
"the additions to the driver."
msgstr ""
"Se vocÍ È um commitcador do FreeBSD src, e tudo parece estar funcionando, ent„o vocÍ "
"pode cometer as mudanÁas na ·rvore. No entanto, existem algumas pequenas coisas "
"complicadas a serem consideradas. <filename> pccarddevs </filename> deve ser "
"comprometido com a primeira ·rvore. Ent„o <filename> pccarddevs.h </filename> deve "
"ser regenerado e confirmado como uma segunda etapa, garantindo que a tag $ FreeBSD $ "
"correta esteja no ˙ltimo arquivo. Finalmente, confirme as adiÁÌµes ao driver. "

#: book.translate.xml:23641
#, fuzzy
msgid "Submitting a New Device"
msgstr "Enviando um novo dispositivo"

#: book.translate.xml:23643
#, fuzzy
msgid ""
"Please do not send entries for new devices to the author directly. Instead, submit "
"them as a PR and send the author the PR number for his records. This ensures that "
"entries are not lost. When submitting a PR, it is unnecessary to include the "
"<filename>pccardevs.h</filename> diffs in the patch, since those will be "
"regenerated. It is necessary to include a description of the device, as well as the "
"patches to the client driver. If you do not know the name, use OEM99 as the name, "
"and the author will adjust OEM99 accordingly after investigation. Committers should "
"not commit OEM99, but instead find the highest OEM entry and commit one more than "
"that."
msgstr ""
"Por favor, n„o envie entradas para novos dispositivos para o autor diretamente. Em "
"vez disso, envie-os como um PR e envie ao autor o n˙mero PR para seus registros. "
"Isso garante que as entradas n„o sejam perdidas. Ao enviar um PR, n„o È necess·rio "
"incluir a <filename> pccardevs.h </filename> diffs no patch, desde que esses ser„o "
"regenerados. Ìâ necess·rio incluir uma descriÁ„o do dispositivo, bem como os patches "
"para o driver cliente. Se vocÍ n„o souber o nome, use OEM99 como o nome e o autor "
"ajustar· o OEM99 adequadamente apÛs a investigaÁ„o. Os committers n„o devem "
"confirmar o OEM99, mas, em vez disso, encontrar a entrada OEM mais alta e cometer um "
"a mais do que isso. "

#: book.translate.xml:23705
#, fuzzy
msgid "Appendices"
msgstr "ApÍndices"

#: book.translate.xml:23711
#, fuzzy
msgid ""
"<personname><firstname>Marshall</firstname><othername role=\"Middle\">Kirk</"
"othername><surname>McKusick</surname></personname>"
msgstr ""
" <personname><firstname> Marechal </firstname><othername role=\"Middle\"> Kirk </"
"othername><surname> McKusick </surname></personname> "

#: book.translate.xml:23712
#, fuzzy
msgid "<personname><firstname>Keith</firstname><surname>Bostic</surname></personname>"
msgstr ""
" <personname><firstname> Keith </firstname><surname> Bostic </surname></personname> "

#: book.translate.xml:23713
#, fuzzy
msgid ""
"<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
"othername><surname>Karels</surname></personname>"
msgstr ""
" <personname><firstname> Michael </firstname><othername role=\"MI\"> J </"
"othername><surname> Karels </surname></personname> "

#: book.translate.xml:23714
#, fuzzy
msgid ""
"<personname><firstname>John</firstname><othername role=\"MI\">S</"
"othername><surname>Quarterman</surname></personname>"
msgstr ""
" <personname><firstname> John </firstname><othername role=\"MI\"> S </"
"othername><surname> Quarterman </surname></personname> "

#: book.translate.xml:23717
#, fuzzy
msgid "<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"
msgstr ""
" <year> 1996 </year><holder> Addison-Wesley Publishing Company, Inc. </holder> "

#: book.translate.xml:23722
#, fuzzy
msgid "0-201-54979-4"
msgstr "0-201-54979-4"

#: book.translate.xml:23725
#, fuzzy
msgid "Addison-Wesley Publishing Company, Inc."
msgstr "Addison-Wesley Publishing Company, Inc."

#: book.translate.xml:23728
#, fuzzy
msgid "The Design and Implementation of the 4.4 BSD Operating System"
msgstr "O Design e ImplementaÁ„o do Sistema Operacional 4.4 BSD"

#: book.translate.xml:23730
#, fuzzy
msgid "1-2"
msgstr "1-2"
