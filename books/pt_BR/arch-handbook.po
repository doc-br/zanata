# Alexandre Vasconcelos <alex.vasconcelos@gmail.com>, 2018. #zanata
# André Franciosi <andre@franciosi.org>, 2018. #zanata
# Danilo G. Baio <dbaio@FreeBSD.org>, 2018. #zanata
# Edson Brandi <ebrandi@FreeBSD.org>, 2018. #zanata
# Marcos  <udialup@gmail.com>, 2018. #zanata
# Silvio Ap Silva <contato@kanazuchi.com>, 2018. #zanata
# Anderson Nunes <Marsu707@yahoo.com.br>, 2019. #zanata
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2019-03-17 16:33-0300\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"PO-Revision-Date: 2019-04-22 03:39+0000\n"
"Last-Translator: Anderson Nunes <Marsu707@yahoo.com.br>\n"
"Language-Team: \n"
"Language: pt_BR\n"
"X-Generator: Zanata 4.6.2\n"
"Plural-Forms: nplurals=2; plural=(n != 1)\n"

#. Put one translator per line, in the form NAME <EMAIL>, YEAR1, YEAR2
msgctxt "_"
msgid "translator-credits"
msgstr ""
"Edson Brandi, ebrandi@FreeBSD.org, 2018\n"
"Alexandre Vasconcelos, alex.vasconcelos@gmail.com, 2018\n"
"André Franciosi, andre@franciosi.org, 2018"

#. (itstool) path: info/title
#: book.translate.xml:140
msgid "FreeBSD Architecture Handbook"
msgstr "Handbook de Arquitetura do FreeBSD"

#. (itstool) path: info/author
#: book.translate.xml:143
msgid "<orgname>The FreeBSD Documentation Project</orgname>"
msgstr " <orgname>Projeto de Documentação do FreeBSD</orgname> "

#. (itstool) path: info/pubdate
#. (itstool) path: info/releaseinfo
#: book.translate.xml:145 book.translate.xml:224
msgid "$FreeBSD$"
msgstr ""

#. (itstool) path: info/copyright
#: book.translate.xml:147
msgid ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> "
"<year>2004</year> <year>2005</year> <year>2006</year> <year>2012</year> "
"<year>2013</year> <holder>The FreeBSD Documentation Project</holder>"
msgstr ""
"<year>2000</year> <year>2001</year> <year>2002</year> <year>2003</year> "
"<year>2004</year> <year>2005</year> <year>2006</year> <year>2012</year> "
"<year>2013</year> <holder>The FreeBSD Documentation Project</holder>"

#. (itstool) path: legalnotice/para
#: book.translate.xml:161
msgid "FreeBSD is a registered trademark of the FreeBSD Foundation."
msgstr "FreeBSD is a registered trademark of the FreeBSD Foundation."

#. (itstool) path: legalnotice/para
#: book.translate.xml:163
msgid ""
"UNIX is a registered trademark of The Open Group in the United States and "
"other countries."
msgstr ""
"UNIX is a registered trademark of The Open Group in the United States and "
"other countries."

#. (itstool) path: legalnotice/para
#: book.translate.xml:165
msgid ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, "
"Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. "
"and other countries."
msgstr ""
"Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, "
"Quicktime, and TrueType are trademarks of Apple Inc., registered in the U.S. "
"and other countries."

#. (itstool) path: legalnotice/para
#: book.translate.xml:170
msgid ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows "
"NT are either registered trademarks or trademarks of Microsoft Corporation "
"in the United States and/or other countries."
msgstr ""
"Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media and Windows "
"NT are either registered trademarks or trademarks of Microsoft Corporation "
"in the United States and/or other countries."

#. (itstool) path: legalnotice/para
#: book.translate.xml:174
msgid ""
"Many of the designations used by manufacturers and sellers to distinguish "
"their products are claimed as trademarks. Where those designations appear in "
"this document, and the FreeBSD Project was aware of the trademark claim, the "
"designations have been followed by the <quote>™</quote> or the <quote>®</"
"quote> symbol."
msgstr ""
"Many of the designations used by manufacturers and sellers to distinguish "
"their products are claimed as trademarks. Where those designations appear in "
"this document, and the FreeBSD Project was aware of the trademark claim, the "
"designations have been followed by the <quote>™</quote> or the <quote>®</"
"quote> symbol."

#. (itstool) path: legalnotice/title
#: book.translate.xml:184
msgid "Copyright"
msgstr "Copyright"

#. (itstool) path: legalnotice/para
#: book.translate.xml:186
msgid ""
"Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"
msgstr ""
"Redistribution and use in source (XML DocBook) and 'compiled' forms (XML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"

#. (itstool) path: listitem/para
#: book.translate.xml:193
msgid ""
"Redistributions of source code (XML DocBook) must retain the above copyright "
"notice, this list of conditions and the following disclaimer as the first "
"lines of this file unmodified."
msgstr ""
"Redistributions of source code (XML DocBook) must retain the above copyright "
"notice, this list of conditions and the following disclaimer as the first "
"lines of this file unmodified."

#. (itstool) path: listitem/para
#: book.translate.xml:199 book.translate.xml:4356
msgid ""
"Redistributions in compiled form (transformed to other DTDs, converted to "
"PDF, PostScript, RTF and other formats) must reproduce the above copyright "
"notice, this list of conditions and the following disclaimer in the "
"documentation and/or other materials provided with the distribution."
msgstr ""
"Redistributions in compiled form (transformed to other DTDs, converted to "
"PDF, PostScript, RTF and other formats) must reproduce the above copyright "
"notice, this list of conditions and the following disclaimer in the "
"documentation and/or other materials provided with the distribution."

#. (itstool) path: important/para
#: book.translate.xml:208
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT \"AS "
"IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, "
"THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT "
"BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"THIS DOCUMENTATION IS PROVIDED BY THE FREEBSD DOCUMENTATION PROJECT \"AS "
"IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, "
"THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE FREEBSD DOCUMENTATION PROJECT "
"BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."

#. (itstool) path: abstract/para
#: book.translate.xml:227
msgid ""
"Welcome to the FreeBSD Architecture Handbook. This manual is a "
"<emphasis>work in progress</emphasis> and is the work of many individuals. "
"Many sections do not yet exist and some of those that do exist need to be "
"updated. If you are interested in helping with this project, send email to "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-"
"doc\">FreeBSD documentation project mailing list</link>."
msgstr ""
"Welcome to the FreeBSD Architecture Handbook. This manual is a "
"<emphasis>work in progress</emphasis> and is the work of many individuals. "
"Many sections do not yet exist and some of those that do exist need to be "
"updated. If you are interested in helping with this project, send email to "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-"
"doc\">FreeBSD documentation project mailing list</link>."

#. (itstool) path: abstract/para
#: book.translate.xml:234
msgid ""
"The latest version of this document is always available from the <link xlink:"
"href=\"@@URL_RELPREFIX@@/index.html\">FreeBSD World Wide Web server</link>. "
"It may also be downloaded in a variety of formats and compression options "
"from the <link xlink:href=\"https://download.freebsd.org/ftp/doc/\">FreeBSD "
"FTP server</link> or one of the numerous <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/mirrors-ftp."
"html\">mirror sites</link>."
msgstr ""
"The latest version of this document is always available from the <link xlink:"
"href=\"@@URL_RELPREFIX@@/index.html\">FreeBSD World Wide Web server</link>. "
"It may also be downloaded in a variety of formats and compression options "
"from the <link xlink:href=\"https://download.freebsd.org/ftp/doc/\">FreeBSD "
"FTP server</link> or one of the numerous <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/handbook/mirrors-ftp."
"html\">mirror sites</link>."

#. (itstool) path: part/title
#: book.translate.xml:243
msgid "Kernel"
msgstr "Kernel"

#. (itstool) path: info/title
#: book.translate.xml:259
msgid "Bootstrapping and Kernel Initialization"
msgstr "Bootstrapping e Inicialização do Kernel"

#. (itstool) path: authorgroup/author
#: book.translate.xml:262
msgid ""
"<personname> <firstname>Sergey</firstname> <surname>Lyubka</surname> </"
"personname> <contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname>Sergey</firstname><surname> Lyubka</surname></"
"personname><contrib> Contribuíram por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:274
msgid ""
"<personname> <firstname>Sergio Andrés</firstname> <surname> Gómez del Real</"
"surname> </personname> <contrib>Updated and enhanced by </contrib>"
msgstr ""
"<personname> <firstname>Sergio Andrés</firstname> <surname> Gómez del Real</"
"surname> </personname> <contrib>Atualizado e melhorado por </contrib>"

#. (itstool) path: sect1/title
#: book.translate.xml:287 book.translate.xml:4383 book.translate.xml:16481
#: book.translate.xml:19448
msgid "Synopsis"
msgstr "Sinopse "

#. (itstool) path: sect1/indexterm
#. (itstool) path: para/indexterm
#: book.translate.xml:289 book.translate.xml:20796
msgid "<primary>BIOS</primary>"
msgstr " <primary>BIOS</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:290
msgid "<primary>firmware</primary>"
msgstr " <primary>firmware</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:291
msgid "<primary>POST</primary>"
msgstr "<primary>POST</primary>"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:292
msgid "<primary>IA-32</primary>"
msgstr " <primary>IA-32</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:293
msgid "<primary>booting</primary>"
msgstr " <primary>inicialização</primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:294
msgid "<primary>system initialization</primary>"
msgstr " <primary>inicialização do sistema</primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:295
msgid ""
"This chapter is an overview of the boot and system initialization processes, "
"starting from the <acronym>BIOS</acronym> (firmware) <acronym>POST</"
"acronym>, to the first user process creation. Since the initial steps of "
"system startup are very architecture dependent, the IA-32 architecture is "
"used as an example."
msgstr ""
"Este capítulo é uma visão geral dos processos de inicialização e "
"inicialização do sistema, desde o <acronym>POST</acronym> da <acronym>BIOS</"
"acronym> (firmware) até a primeira criação do processo do usuário. Como as "
"etapas iniciais da inicialização do sistema são muito dependentes da "
"arquitetura, a arquitetura IA-32 é usada como um exemplo."

#. (itstool) path: sect1/para
#: book.translate.xml:301
msgid ""
"The FreeBSD boot process can be surprisingly complex. After control is "
"passed from the <acronym>BIOS</acronym>, a considerable amount of low-level "
"configuration must be done before the kernel can be loaded and executed. "
"This setup must be done in a simple and flexible manner, allowing the user a "
"great deal of customization possibilities."
msgstr ""
"O processo de inicialização do FreeBSD pode ser surpreendentemente complexo. "
"Após o controle ser passado da <acronym>BIOS</acronym>, uma quantidade "
"considerável de configuração de baixo nével deve ser feita antes que o "
"kernel possa ser carregado e executado. Essa configuração deve ser feita de "
"maneira simples e flexível, permitindo ao usuário uma grande quantidade de "
"possibilidades de personalização. "

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:310 book.translate.xml:23491
msgid "Overview"
msgstr "Visão geral"

#. (itstool) path: sect1/para
#: book.translate.xml:312
msgid ""
"The boot process is an extremely machine-dependent activity. Not only must "
"code be written for every computer architecture, but there may also be "
"multiple types of booting on the same architecture. For example, a directory "
"listing of <filename>/usr/src/sys/boot</filename> reveals a great amount of "
"architecture-dependent code. There is a directory for each of the various "
"supported architectures. In the x86-specific <filename>i386</filename> "
"directory, there are subdirectories for different boot standards like "
"<filename>mbr</filename> (Master Boot Record), <filename>gpt</filename> "
"(<acronym>GUID</acronym> Partition Table), and <filename>efi</filename> "
"(Extensible Firmware Interface). Each boot standard has its own conventions "
"and data structures. The example that follows shows booting an x86 computer "
"from an <acronym>MBR</acronym> hard drive with the FreeBSD <filename>boot0</"
"filename> multi-boot loader stored in the very first sector. That boot code "
"starts the FreeBSD three-stage boot process."
msgstr ""
"O processo de inicialização é uma atividade extremamente dependente da "
"máquina. Não sé deve ser escrito código para cada arquitetura de computador, "
"mas também pode haver vários tipos de inicialização na mesma arquitetura. "
"Por exemplo, uma lista de diretórios de <filename>/usr/src/sys/boot</"
"filename> revela uma grande quantidade de código dependente de arquitetura. "
"Existe um diretório para cada uma das várias arquiteturas suportadas. No x86-"
"specific <filename>i386</filename> diretório, existem subdiretórios para "
"diferentes padrões de inicialização, como <filename>mbr</filename> (Master "
"Boot Record), <filename>gpt</filename> (Tabela de Partição <acronym>GUID</"
"acronym> ) e <filename>efi</filename> (Interface de Firmware Extensível). "
"Cada padrão de inicialização possui suas próprias convenções e estruturas de "
"dados. O exemplo a seguir mostra a inicialização de um computador x86 de um "
"disco rígido <acronym>MBR</acronym> com o FreeBSD <filename>boot0</filename> "
"carregador multi-boot armazenado no primeiro setor. Esse código inicia o "
"processo de inicialização de três estágios do FreeBSD. "

#. (itstool) path: sect1/para
#: book.translate.xml:331
msgid ""
"The key to understanding this process is that it is a series of stages of "
"increasing complexity. These stages are <filename>boot1</filename>, "
"<filename>boot2</filename>, and <filename>loader</filename> (see "
"<citerefentry><refentrytitle>boot</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> for more detail). The boot system executes each stage in "
"sequence. The last stage, <filename>loader</filename>, is responsible for "
"loading the FreeBSD kernel. Each stage is examined in the following sections."
""
msgstr ""
"A chave para entender esse processo é que ele é uma série de estágios de "
"crescente complexidade. Esses estágios são <filename>boot1</filename> , "
"<filename>boot2</filename> e <filename>carregador</filename> (Vejo "
"<citerefentry><refentrytitle>boot</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> para mais detalhes). O sistema de inicialização executa cada "
"estágio em sequência. O último estágio <filename>carregador</filename> , é "
"responsável por carregar o kernel do FreeBSD. Cada estágio é examinado nas "
"seções seguintes. "

#. (itstool) path: sect1/para
#: book.translate.xml:340
msgid ""
"Here is an example of the output generated by the different boot stages. "
"Actual output may differ from machine to machine:"
msgstr ""
"Aqui está um exemplo da saída gerada pelos diferentes estágios de "
"inicialização. A saída real pode diferir de máquina para máquina:"

#. (itstool) path: row/entry
#: book.translate.xml:348
msgid "FreeBSD Component"
msgstr "Componente do FreeBSD"

#. (itstool) path: row/entry
#: book.translate.xml:349
msgid "Output (may vary)"
msgstr "Saída (pode variar)"

#. (itstool) path: row/entry
#: book.translate.xml:353
msgid "<literal>boot0</literal>"
msgstr " <literal>boot0</literal> "

#. (itstool) path: entry/screen
#: book.translate.xml:354
#, no-wrap
msgid "F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2"
msgstr "F1    FreeBSD\n"
"F2    BSD\n"
"F5    Disk 2"

#. (itstool) path: footnote/para
#: book.translate.xml:361
msgid ""
"This prompt will appear if the user presses a key just after selecting an OS "
"to boot at the <literal>boot0</literal> stage."
msgstr ""
"Este aviso aparecerá se o usuário pressionar uma tecla logo após selecionar "
"um SO para inicializar no <literal>boot0</literal> etapa."

#. (itstool) path: row/entry
#: book.translate.xml:360
msgid "<literal>boot2</literal> <_:footnote-1/>"
msgstr "<literal>boot2</literal> <_:footnote-1/>"

#. (itstool) path: entry/screen
#: book.translate.xml:365
#, no-wrap
msgid "&gt;&gt;FreeBSD/i386 BOOT\n"
"Default: 1:ad(1,a)/boot/loader\n"
"boot:"
msgstr "&gt;&gt;FreeBSD/i386 BOOT\n"
"Default: 1:ad(1,a)/boot/loader\n"
"boot:"

#. (itstool) path: row/entry
#: book.translate.xml:371
msgid "<filename>loader</filename>"
msgstr " <filename>carregador</filename> "

#. (itstool) path: entry/screen
#: book.translate.xml:372
#, no-wrap
msgid ""
"BTX loader 1.00 BTX version is 1.02\n"
"Consoles: internal video/keyboard\n"
"BIOS drive C: is disk0\n"
"BIOS 639kB/2096064kB available memory\n"
"\n"
"FreeBSD/x86 bootstrap loader, Revision 1.1\n"
"Console internal video/keyboard\n"
"(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)\n"
"Loading /boot/defaults/loader.conf\n"
"/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms="
"[0x8+0x137988+0x8+0x1515f8]"
msgstr ""
"BTX loader 1.00 BTX version is 1.02\n"
"Consoles: internal video/keyboard\n"
"BIOS drive C: is disk0\n"
"BIOS 639kB/2096064kB available memory\n"
"\n"
"FreeBSD/x86 bootstrap loader, Revision 1.1\n"
"Console internal video/keyboard\n"
"(root@snap.freebsd.org, Thu Jan 16 22:18:05 UTC 2014)\n"
"Loading /boot/defaults/loader.conf\n"
"/boot/kernel/kernel text=0xed9008 data=0x117d28+0x176650 syms="
"[0x8+0x137988+0x8+0x1515f8]"

#. (itstool) path: row/entry
#: book.translate.xml:385
msgid "kernel"
msgstr "núcleo"

#. (itstool) path: entry/screen
#: book.translate.xml:386
#, no-wrap
msgid ""
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610"
msgstr ""
"Copyright (c) 1992-2013 The FreeBSD Project.\n"
"Copyright (c) 1979, 1980, 1983, 1986, 1988, 1989, 1991, 1992, 1993, 1994\n"
"        The Regents of the University of California. All rights reserved.\n"
"FreeBSD is a registered trademark of The FreeBSD Foundation.\n"
"FreeBSD 10.0-RELEASE #0 r260789: Thu Jan 16 22:34:59 UTC 2014\n"
"    root@snap.freebsd.org:/usr/obj/usr/src/sys/GENERIC amd64\n"
"FreeBSD clang version 3.3 (tags/RELEASE_33/final 183502) 20130610"

#. (itstool) path: sect1/title
#: book.translate.xml:400
msgid "The <acronym>BIOS</acronym>"
msgstr "O <acronym>BIOS</acronym>"

#. (itstool) path: sect1/para
#: book.translate.xml:402
msgid ""
"When the computer powers on, the processor's registers are set to some "
"predefined values. One of the registers is the <emphasis>instruction "
"pointer</emphasis> register, and its value after a power on is well defined: "
"it is a 32-bit value of <literal>0xfffffff0</literal>. The instruction "
"pointer register (also known as the Program Counter) points to code to be "
"executed by the processor. Another important register is the <literal>cr0</"
"literal> 32-bit control register, and its value just after a reboot is "
"<literal>0</literal>. One of <literal>cr0</literal>'s bits, the PE "
"(Protection Enabled) bit, indicates whether the processor is running in 32-"
"bit protected mode or 16-bit real mode. Since this bit is cleared at boot "
"time, the processor boots in 16-bit real mode. Real mode means, among other "
"things, that linear and physical addresses are identical. The reason for the "
"processor not to start immediately in 32-bit protected mode is backwards "
"compatibility. In particular, the boot process relies on the services "
"provided by the <acronym>BIOS</acronym>, and the <acronym>BIOS</acronym> "
"itself works in legacy, 16-bit code."
msgstr ""
"Quando o computador liga, os registros do processador são ajustados para "
"alguns valores pré-definidos. Um dos registradores é o <emphasis>ponteiro de "
"instrução</emphasis> registrar, e seu valor após um power on é bem definido: "
"é um valor de 32 bits de <literal>0xfffffff0</literal> . O registrador de "
"ponteiro de instrução (também conhecido como Contador de Programa) aponta "
"para o código a ser executado pelo processador. Outro registro importante é "
"o <literal>cr0</literal> Registro de controle de 32 bits, e seu valor logo "
"após a reinicialização é <literal>0</literal>. Um de <literal>cr0</"
"literal>'s bits, o bit PE (Protection Enabled), indica se o processador está "
"sendo executado no modo protegido de 32 bits ou no modo real de 16 bits. "
"Como esse bit é limpo no momento da inicialização, o processador é "
"inicializado no modo real de 16 bits. O modo real significa, entre outras "
"coisas, que os endereços linear e físico são idênticos. O motivo para o "
"processador não iniciar imediatamente no modo protegido de 32 bits é "
"compatível com versões anteriores. Em particular, o processo de "
"inicialização depende dos serviços fornecidos pelo <acronym>BIOS</acronym>, "
"e o próprio <acronym>BIOS</acronym> funciona em código legado de 16 bits. "

#. (itstool) path: sect1/para
#: book.translate.xml:422
msgid ""
"The value of <literal>0xfffffff0</literal> is slightly less than 4 GB, so "
"unless the machine has 4 GB of physical memory, it cannot point to a valid "
"memory address. The computer's hardware translates this address so that it "
"points to a <acronym>BIOS</acronym> memory block."
msgstr ""
"O valor de <literal>0xfffffff0</literal> é um pouco menor que 4 GB, "
"portanto, a menos que a máquina tenha 4 GB de memória física, ela não pode "
"apontar para um endereço de memória válido. O hardware do computador traduz "
"esse endereço para que ele aponte para um bloco de memória da <acronym>BIOS</"
"acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:428
msgid ""
"The <acronym>BIOS</acronym> (Basic Input Output System) is a chip on the "
"motherboard that has a relatively small amount of read-only memory "
"(<acronym>ROM</acronym>). This memory contains various low-level routines "
"that are specific to the hardware supplied with the motherboard. The "
"processor will first jump to the address 0xfffffff0, which really resides in "
"the <acronym>BIOS</acronym>'s memory. Usually this address contains a jump "
"instruction to the <acronym>BIOS</acronym>'s POST routines."
msgstr ""
"O <acronym>BIOS</acronym> (Basic Input Output System) é um chip da placa-mãe "
"que tem uma quantidade relativamente pequena de memória somente leitura "
"(<acronym>ROM</acronym>). Essa memória contém várias rotinas de baixo nível "
"que são específicas para o hardware fornecido com a placa-mãe. O processador "
"irá primeiro saltar para o endereço 0xfffffff0, que realmente reside na "
"memória do <acronym>BIOS</acronym>. Normalmente, este endereço contém uma "
"instrução de salto para as rotinas de POST do <acronym>BIOS</acronym>. "

#. (itstool) path: sect1/para
#: book.translate.xml:438
msgid ""
"The <acronym>POST</acronym> (Power On Self Test) is a set of routines "
"including the memory check, system bus check, and other low-level "
"initialization so the <acronym>CPU</acronym> can set up the computer "
"properly. The important step of this stage is determining the boot device. "
"Modern <acronym>BIOS</acronym> implementations permit the selection of a "
"boot device, allowing booting from a floppy, <acronym>CD-ROM</acronym>, hard "
"disk, or other devices."
msgstr ""
"O <acronym>POST</acronym> (Power On Self Test) é um conjunto de rotinas "
"incluindo a verificação de memória, verificação do barramento do sistema e "
"outras inicializações de baixo nível para que a <acronym>CPU</acronym> possa "
"configurar o computador corretamente. A etapa importante deste estágio é "
"determinar o dispositivo de inicialização. As implementações modernas do "
"<acronym>BIOS</acronym> permitem a seleção de um dispositivo de "
"inicialização, permitindo a inicialização a partir de um disquete, "
"<acronym>CD-ROM</acronym>, disco rígido ou outros dispositivos. "

#. (itstool) path: sect1/para
#: book.translate.xml:447
msgid ""
"The very last thing in the <acronym>POST</acronym> is the <literal>INT 0x19</"
"literal> instruction. The <literal>INT 0x19</literal> handler reads 512 "
"bytes from the first sector of boot device into the memory at address "
"<literal>0x7c00</literal>. The term <emphasis>first sector</emphasis> "
"originates from hard drive architecture, where the magnetic plate is divided "
"into a number of cylindrical tracks. Tracks are numbered, and every track is "
"divided into a number (usually 64) of sectors. Track numbers start at 0, but "
"sector numbers start from 1. Track 0 is the outermost on the magnetic plate, "
"and sector 1, the first sector, has a special purpose. It is also called the "
"<acronym>MBR</acronym>, or Master Boot Record. The remaining sectors on the "
"first track are never used."
msgstr ""
"A última coisa no <acronym>POST</acronym> é a <literal>INT 0x19</literal> "
"instrução. o <literal>INT 0x19</literal> manipulador lê 512 bytes do "
"primeiro setor do dispositivo de inicialização para a memória no endereço "
"<literal>0x7c00</literal>. O termo <emphasis>primeiro setor</emphasis> "
"origina-se da arquitetura do disco rígido, onde a placa magnética é dividida "
"em vários trilhos cilíndricos. As faixas são numeradas e todas as faixas são "
"divididas em um número (geralmente 64) de setores. Os números das faixas "
"começam em 0, mas os números setoriais começam em 1. A faixa 0 é a mais "
"externa na placa magnética, e o setor 1, o primeiro setor, tem uma "
"finalidade especial. Também é chamado de <acronym>MBR</acronym> ou Master "
"Boot Record. Os setores restantes na primeira faixa nunca são usados."

#. (itstool) path: sect1/para
#: book.translate.xml:462
msgid ""
"This sector is our boot-sequence starting point. As we will see, this sector "
"contains a copy of our <filename>boot0</filename> program. A jump is made by "
"the <acronym>BIOS</acronym> to address <literal>0x7c00</literal> so it "
"starts executing."
msgstr ""
"Este setor é o nosso ponto de partida da sequência de inicialização. Como "
"veremos, este setor contém uma cópia do nosso <filename>boot0</filename> "
"programa. Um salto é feito pelo <acronym>BIOS</acronym> para endereçar "
"<literal>0x7c00</literal> então começa a execução. "

#. (itstool) path: sect1/title
#: book.translate.xml:470
msgid "The Master Boot Record (<literal>boot0</literal>)"
msgstr "O registro mestre de inicialização (<literal>boot0</literal>) "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:472
msgid "<primary>MBR</primary>"
msgstr " <primary>MBR</primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:474
msgid ""
"After control is received from the <acronym>BIOS</acronym> at memory address "
"<literal>0x7c00</literal>, <filename>boot0</filename> starts executing. It "
"is the first piece of code under FreeBSD control. The task of "
"<filename>boot0</filename> is quite simple: scan the partition table and let "
"the user choose which partition to boot from. The Partition Table is a "
"special, standard data structure embedded in the <acronym>MBR</acronym> "
"(hence embedded in <filename>boot0</filename>) describing the four standard "
"PC <quote>partitions</quote> <_:footnote-1/>. <filename>boot0</filename> "
"resides in the filesystem as <filename>/boot/boot0</filename>. It is a small "
"512-byte file, and it is exactly what FreeBSD's installation procedure wrote "
"to the hard disk's <acronym>MBR</acronym> if you chose the "
"<quote>bootmanager</quote> option at installation time. Indeed, "
"<filename>boot0</filename> <emphasis>is</emphasis> the <acronym>MBR</"
"acronym>."
msgstr ""
"Depois que o controle é recebido do <acronym>BIOS</acronym> no endereço de "
"memória <literal>0x7c00</literal>, <filename>boot0</filename> começa a "
"executar. É o primeiro pedaço de código sob controle do FreeBSD. A tarefa de "
"<filename>boot0</filename> é bastante simples: escaneie a tabela de "
"partições e deixe o usuário escolher de qual partição inicializar. A Tabela "
"de Partição é uma estrutura de dados padrão especial incorporada no "
"<acronym>MBR</acronym> (portanto, <filename>boot0</filename>) descrevendo o "
"quatro PC padrão <quote>partições</quote> <_:footnote-1/>. <filename>boot0</"
"filename> reside no sistema de arquivos como <filename>/boot/boot0</"
"filename> . É um pequeno arquivo de 512 bytes, e é exatamente o que o "
"procedimento de instalação do FreeBSD escreveu para o <acronym>MBR</acronym> "
"do disco rígido se você escolheu <quote> bootmanager </quote> opção no "
"momento da instalação. De fato, <filename>boot0</filename><emphasis> é </"
"emphasis> o <acronym>MBR</acronym>."

#. (itstool) path: sect1/para
#: book.translate.xml:494
msgid ""
"As mentioned previously, the <literal>INT 0x19</literal> instruction causes "
"the <literal>INT 0x19</literal> handler to load an <acronym>MBR</acronym> "
"(<filename>boot0</filename>) into memory at address <literal>0x7c00</"
"literal>. The source file for <filename>boot0</filename> can be found in "
"<filename>sys/boot/i386/boot0/boot0.S</filename> - which is an awesome piece "
"of code written by Robert Nordier."
msgstr ""
"Como mencionado anteriormente, o <literal>INT 0x19</literal> instrução faz "
"com que o <literal>INT 0x19</literal> manipulador para carregar um "
"<acronym>MBR</acronym> (<filename>boot0</filename>) na memória no endereço "
"<literal>0x7c00</literal> . O arquivo de origem para <filename>boot0</"
"filename> pode ser encontrado em <filename>sys/boot/i386/boot0/boot0.S</"
"filename> - que é um pedaço incrível de código escrito por Robert Nordier."

#. (itstool) path: sect1/para
#: book.translate.xml:502
msgid ""
"A special structure starting from offset <literal>0x1be</literal> in the "
"<acronym>MBR</acronym> is called the <emphasis>partition table</emphasis>. "
"It has four records of 16 bytes each, called <emphasis>partition records</"
"emphasis>, which represent how the hard disk is partitioned, or, in "
"FreeBSD's terminology, sliced. One byte of those 16 says whether a partition "
"(slice) is bootable or not. Exactly one record must have that flag set, "
"otherwise <filename>boot0</filename>'s code will refuse to proceed."
msgstr ""
"Uma estrutura especial a partir de offset <literal>0x1be</literal> no "
"<acronym>MBR</acronym> é chamado de <emphasis>tabela de partições</emphasis>."
" Tem quatro registros de 16 bytes cada, chamados <emphasis>registros de "
"partições</emphasis>, que representam como o disco rígido é particionado, "
"ou, na terminologia do FreeBSD, fatiado. Um byte desses 16 diz se uma "
"partição (fatia) é inicializável ou não. Exatamente um registro deve ter "
"esse sinalizador definido, caso contrário <filename>boot0</filename> O "
"código da empresa se recusará a prosseguir. "

#. (itstool) path: sect1/para
#: book.translate.xml:512
msgid "A partition record has the following fields:"
msgstr "Um registro de partição possui os seguintes campos:"

#. (itstool) path: listitem/para
#: book.translate.xml:516
msgid "the 1-byte filesystem type"
msgstr "o tipo de sistema de arquivos de 1 byte "

#. (itstool) path: listitem/para
#: book.translate.xml:520
msgid "the 1-byte bootable flag"
msgstr "o sinalizador de inicialização de 1 byte"

#. (itstool) path: listitem/para
#: book.translate.xml:524
msgid "the 6 byte descriptor in CHS format"
msgstr "o descritor de 6 bytes no formato CHS "

#. (itstool) path: listitem/para
#: book.translate.xml:528
msgid "the 8 byte descriptor in LBA format"
msgstr "o descritor de 8 bytes no formato do LBA "

#. (itstool) path: sect1/para
#: book.translate.xml:532
msgid ""
"A partition record descriptor contains information about where exactly the "
"partition resides on the drive. Both descriptors, <acronym>LBA</acronym> and "
"<acronym>CHS</acronym>, describe the same information, but in different ways:"
" <acronym>LBA</acronym> (Logical Block Addressing) has the starting sector "
"for the partition and the partition's length, while <acronym>CHS</acronym> "
"(Cylinder Head Sector) has coordinates for the first and last sectors of the "
"partition. The partition table ends with the special signature "
"<literal>0xaa55</literal>."
msgstr ""
"Um descritor de registro de partição contém informações sobre onde "
"exatamente a partição reside na unidade. Ambos os descritores, <acronym>LBA</"
"acronym> e <acronym>CHS</acronym>, descrevem as mesmas informações, mas de "
"maneiras diferentes: <acronym>LBA</acronym> (Logical Block Addressing) tem o "
"setor inicial da partição e da partição. comprimento, enquanto <acronym>CHS</"
"acronym> (Cylinder Head Sector) tem coordenadas para o primeiro e último "
"setores da partição.A tabela de partição termina com a assinatura especial "
"<literal>0xaa55</literal>. "

#. (itstool) path: sect1/para
#: book.translate.xml:543
msgid ""
"The <acronym>MBR</acronym> must fit into 512 bytes, a single disk sector. "
"This program uses low-level <quote>tricks</quote> like taking advantage of "
"the side effects of certain instructions and reusing register values from "
"previous operations to make the most out of the fewest possible instructions."
" Care must also be taken when handling the partition table, which is "
"embedded in the <acronym>MBR</acronym> itself. For these reasons, be very "
"careful when modifying <filename>boot0.S</filename>."
msgstr ""
"O <acronym>MBR</acronym> deve caber em 512 bytes, um único setor de disco. "
"Este programa usa baixo nível <quote>truques</quote> como aproveitar os "
"efeitos colaterais de certas instruções e reutilizar valores de registro de "
"operações anteriores para obter o máximo das instruções possíveis. Cuidado "
"também deve ser tomado ao manusear a tabela de partições, que está embutida "
"no próprio <acronym>MBR</acronym>. Por estas razões, tenha muito cuidado ao "
"modificar o <filename>boot0.S</filename>."

#. (itstool) path: sect1/para
#: book.translate.xml:553
msgid ""
"Note that the <filename>boot0.S</filename> source file is assembled "
"<quote>as is</quote>: instructions are translated one by one to binary, with "
"no additional information (no <acronym>ELF</acronym> file format, for "
"example). This kind of low-level control is achieved at link time through "
"special control flags passed to the linker. For example, the text section of "
"the program is set to be located at address <literal>0x600</literal>. In "
"practice this means that <filename>boot0</filename> must be loaded to memory "
"address <literal>0x600</literal> in order to function properly."
msgstr ""
"Note que o <filename>boot0.S</filename> arquivo de origem é montado "
"<quote>como é</quote> : instruções são traduzidas uma a uma para binário, "
"sem informações adicionais (sem formato de arquivo <acronym>ELF</acronym>, "
"por exemplo). Esse tipo de controle de baixo nível é obtido no momento do "
"link por meio de sinalizadores de controle especiais passados ​​para o "
"vinculador. Por exemplo, a seção de texto do programa está configurada para "
"estar localizada no enderço <literal>0x600</literal>. Na prática, isso "
"significa que <filename>boot0</filename> deve ser carregado no endereço de "
"memória <literal>0x600</literal> para funcionar corretamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:564
msgid ""
"It is worth looking at the <filename>Makefile</filename> for "
"<filename>boot0</filename> (<filename>sys/boot/i386/boot0/Makefile</"
"filename>), as it defines some of the run-time behavior of <filename>boot0</"
"filename>. For instance, if a terminal connected to the serial port (COM1) "
"is used for I/O, the macro <literal>SIO</literal> must be defined (<literal>-"
"DSIO</literal>). <literal>-DPXE</literal> enables boot through <acronym>PXE</"
"acronym> by pressing <keycap>F6</keycap>. Additionally, the program defines "
"a set of <emphasis>flags</emphasis> that allow further modification of its "
"behavior. All of this is illustrated in the <filename>Makefile</filename>. "
"For example, look at the linker directives which command the linker to start "
"the text section at address <literal>0x600</literal>, and to build the "
"output file <quote>as is</quote> (strip out any file formatting):"
msgstr ""
"Vale a pena olhar para o <filename>Makefile</filename> para <filename>boot0</"
"filename> (<filename>sys/boot/i386/boot0/Makefile</filename>), uma vez que "
"define um pouco do comportamento em tempo de execução de <filename>boot0</"
"filename>. Por exemplo, se um terminal conectado à porta serial (COM1) for "
"usado para E/S, a macro <literal>SIO</literal> deve ser definido (<literal>-"
"DSIO</literal>). <literal>-DPXE</literal> permite inicializar através do "
"<acronym>PXE</acronym> pressionando <keycap> F6 </keycap>. Além disso, o "
"programa define um conjunto de <emphasis>bandeiras</emphasis> que permitem "
"modificações adicionais de seu comportamento. Tudo isso é ilustrado no "
"<filename>Makefile</filename>. Por exemplo, observe as diretivas do "
"vinculador que comandam o vinculador para iniciar a seção de texto no "
"endereço <literal>0x600</literal> e para construir o arquivo de saída "
"<quote>como é</quote> (tira qualquer formatação de arquivo): "

#. (itstool) path: figure/title
#: book.translate.xml:583
msgid "<filename>sys/boot/i386/boot0/Makefile</filename>"
msgstr " <filename>sys/boot/i386/boot0/Makefile</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:585
#, no-wrap
msgid ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary"
msgstr ""
"      BOOT_BOOT0_ORG?=0x600\n"
"      LDFLAGS=-e start -Ttext ${BOOT_BOOT0_ORG} \\\n"
"      -Wl,-N,-S,--oformat,binary"

#. (itstool) path: sect1/para
#: book.translate.xml:590
msgid ""
"Let us now start our study of the <acronym>MBR</acronym>, or "
"<filename>boot0</filename>, starting where execution begins."
msgstr ""
"Vamos começar agora nosso estudo do <acronym>MBR</acronym>, ou "
"<filename>boot0</filename>, começando onde a execução começa. "

#. (itstool) path: note/para
#: book.translate.xml:595
msgid ""
"Some modifications have been made to some instructions in favor of better "
"exposition. For example, some macros are expanded, and some macro tests are "
"omitted when the result of the test is known. This applies to all of the "
"code examples shown."
msgstr ""
"Algumas modificações foram feitas em algumas instruções em favor de uma "
"melhor exposição. Por exemplo, algumas macros são expandidas e alguns testes "
"de macro são omitidos quando o resultado do teste é conhecido. Isso se "
"aplica a todos os exemplos de código mostrados."

#. (itstool) path: figure/title
#: book.translate.xml:603 book.translate.xml:631 book.translate.xml:698
#: book.translate.xml:728 book.translate.xml:756 book.translate.xml:800
#: book.translate.xml:819 book.translate.xml:837 book.translate.xml:907
msgid "<filename>sys/boot/i386/boot0/boot0.S</filename>"
msgstr " <filename>sys/boot/i386/boot0/boot0.S</filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:605
#, no-wrap
msgid ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack"
msgstr ""
"start:\n"
"      cld\t\t\t# String ops inc\n"
"      xorw %ax,%ax\t\t# Zero\n"
"      movw %ax,%es\t\t# Address\n"
"      movw %ax,%ds\t\t#  data\n"
"      movw %ax,%ss\t\t# Set up\n"
"      movw 0x7c00,%sp\t\t#  stack"

#. (itstool) path: footnote/para
#: book.translate.xml:619
msgid ""
"When in doubt, we refer the reader to the official Intel manuals, which "
"describe the exact semantics for each instruction: <link xlink:href=\"http://"
"www.intel.com/content/www/us/en/processors/architectures-software-developer-"
"manuals.html\"/>."
msgstr ""
"Em caso de dúvida, encaminhamos o leitor para os manuais oficiais da Intel, "
"que descrevem a semântica exata de cada instrução: <link xlink:href=\"http://"
"www.intel.com/content/www/us/en/processors/architectures-software-developer-"
"manuals.html\"/>."

#. (itstool) path: sect1/para
#: book.translate.xml:614
msgid ""
"This first block of code is the entry point of the program. It is where the "
"<acronym>BIOS</acronym> transfers control. First, it makes sure that the "
"string operations autoincrement its pointer operands (the <literal>cld</"
"literal> instruction) <_:footnote-1/>. Then, as it makes no assumption about "
"the state of the segment registers, it initializes them. Finally, it sets "
"the stack pointer register (<literal>%sp</literal>) to address "
"<literal>0x7c00</literal>, so we have a working stack."
msgstr ""
"Este primeiro bloco de código é o ponto de entrada do programa. É onde o "
"<acronym>BIOS</acronym> transfere o controle. Primeiro, ele garante que as "
"operações de string autoincrementem seus operandos de ponteiro (o "
"<literal>cld</literal> instrução) <_:footnote-1/>. Então, como não faz "
"nenhuma suposição sobre o estado dos registradores de segmento, ele os "
"inicializa. Finalmente, define o registrador de ponteiro da pilha "
"(<literal>%sp</literal>) endereçar <literal>0x7c00</literal> , então temos "
"uma pilha de trabalho."

#. (itstool) path: sect1/para
#: book.translate.xml:627
msgid ""
"The next block is responsible for the relocation and subsequent jump to the "
"relocated code."
msgstr ""
"O próximo bloco é responsável pela realocação e posterior salto para o "
"código realocado."

#. (itstool) path: figure/programlisting
#: book.translate.xml:633
#, no-wrap
msgid ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code"
msgstr ""
"      movw $0x7c00,%si\t# Source\n"
"      movw $0x600,%di\t\t# Destination\n"
"      movw $512,%cx\t\t# Word count\n"
"      rep\t\t\t# Relocate\n"
"      movsb\t\t\t#  code\n"
"      movw %di,%bp\t\t# Address variables\n"
"      movb $16,%cl\t\t# Words to clear\n"
"      rep\t\t\t# Zero\n"
"      stosb\t\t\t#  them\n"
"      incb -0xe(%di)\t\t# Set the S field to 1\n"
"      jmp main-0x7c00+0x600\t# Jump to relocated code"

#. (itstool) path: sect1/para
#: book.translate.xml:646
msgid ""
"Because <filename>boot0</filename> is loaded by the <acronym>BIOS</acronym> "
"to address <literal>0x7C00</literal>, it copies itself to address "
"<literal>0x600</literal> and then transfers control there (recall that it "
"was linked to execute at address <literal>0x600</literal>). The source "
"address, <literal>0x7c00</literal>, is copied to register <literal>%si</"
"literal>. The destination address, <literal>0x600</literal>, to register "
"<literal>%di</literal>. The number of bytes to copy, <literal>512</literal> "
"(the program's size), is copied to register <literal>%cx</literal>. Next, "
"the <literal>rep</literal> instruction repeats the instruction that follows, "
"that is, <literal>movsb</literal>, the number of times dictated by the "
"<literal>%cx</literal> register. The <literal>movsb</literal> instruction "
"copies the byte pointed to by <literal>%si</literal> to the address pointed "
"to by <literal>%di</literal>. This is repeated another 511 times. On each "
"repetition, both the source and destination registers, <literal>%si</"
"literal> and <literal>%di</literal>, are incremented by one. Thus, upon "
"completion of the 512-byte copy, <literal>%di</literal> has the value "
"<literal>0x600</literal>+<literal>512</literal>= <literal>0x800</literal>, "
"and <literal>%si</literal> has the value <literal>0x7c00</"
"literal>+<literal>512</literal>= <literal>0x7e00</literal>; we have thus "
"completed the code <emphasis>relocation</emphasis>."
msgstr ""
"Porque <filename>boot0</filename> é carregado pelo <acronym>BIOS</acronym> "
"para endereçar <literal>0x7C00</literal>, copia-se para endereçar "
"<literal>0x600</literal> e depois transfere o controle para lá (lembre-se de "
"que estava ligado para executar no endereço <literal>0x600</literal>. O "
"endereço de origem, <literal>0x7c00</literal>, é copiado para se registrar "
"<literal>%si</literal>. O endereço de destino, <literal>0x600</literal>, "
"registrar <literal>%di</literal>. O número de bytes para copiar, "
"<literal>512</literal> (tamanho do programa), é copiado para registrar "
"<literal>%cx</literal>. Em seguida, a instrução <literal>rep</literal> "
"repete a instrução que se segue, isto é, <literal>movsb</literal>, o número "
"de vezes ditado pelo registrador <literal>%cx</literal>. A instrução "
"<literal>movsb</literal> copia o byte apontado por <literal>%si</literal> "
"para o endereço apontado por <literal>%di</literal>. Isso é repetido mais "
"511 vezes. Em cada repetição, os registros de origem e destino, "
"<literal>%si</literal> e <literal>%di</literal>, são incrementados por um. "
"Assim, após a conclusão da cópia de 512 bytes, <literal>%di</literal> tem o "
"valor <literal>0x600</literal> + <literal>512</literal> = <literal>0x800</"
"literal> e <literal>%si</literal> tem o valor <literal>0x7c00</literal> + "
"<literal>512</literal> = <literal>0x7e00</literal>; assim, completamos o "
"código de <emphasis>relocação</emphasis>."

#. (itstool) path: sect1/para
#: book.translate.xml:672
msgid ""
"Next, the destination register <literal>%di</literal> is copied to "
"<literal>%bp</literal>. <literal>%bp</literal> gets the value "
"<literal>0x800</literal>. The value <literal>16</literal> is copied to "
"<literal>%cl</literal> in preparation for a new string operation (like our "
"previous <literal>movsb</literal>). Now, <literal>stosb</literal> is "
"executed 16 times. This instruction copies a <literal>0</literal> value to "
"the address pointed to by the destination register (<literal>%di</literal>, "
"which is <literal>0x800</literal>), and increments it. This is repeated "
"another 15 times, so <literal>%di</literal> ends up with value "
"<literal>0x810</literal>. Effectively, this clears the address range "
"<literal>0x800</literal>-<literal>0x80f</literal>. This range is used as a "
"(fake) partition table for writing the <acronym>MBR</acronym> back to disk. "
"Finally, the sector field for the <acronym>CHS</acronym> addressing of this "
"fake partition is given the value 1 and a jump is made to the main function "
"from the relocated code. Note that until this jump to the relocated code, "
"any reference to an absolute address was avoided."
msgstr ""
"Em seguida, o registro de destino <literal>%di</literal> é copiado para "
"<literal>%bp</literal>. <literal>%bp</literal> Obtém o valor <literal>0x800</"
"literal>. O valor que <literal>16</literal> é copiado para <literal>%cl</"
"literal> em preparação para uma nova operação de string (como a nossa "
"anterior <literal>movsb</literal>). Agora, <literal>stosb</literal> é "
"executado 16 vezes. Esta instrução copia um valor <literal>0</literal> para "
"o endereço indicado pelo registo de destino (<literal>%di</literal>, que é "
"<literal>0x800</literal>) e incrementa-o. Isso é repetido mais 15 vezes, "
"então <literal>%di</literal> acaba com valor <literal>0x810</literal>. "
"Efetivamente, isso limpa o intervalo de endereços <literal>0x800</literal> - "
"<literal>0x80f</literal>. Esse intervalo é usado como uma tabela de "
"partições (falsa) para gravar o <acronym>MBR de</acronym> volta no disco. "
"Finalmente, o campo setorial para o endereçamento <acronym>CHS</acronym> "
"desta partição falsa recebe o valor 1 e um salto é feito para a função "
"principal a partir do código realocado. Note que até este salto para o "
"código realocado, qualquer referência a um endereço absoluto foi evitada. "

#. (itstool) path: sect1/para
#: book.translate.xml:693
msgid ""
"The following code block tests whether the drive number provided by the "
"<acronym>BIOS</acronym> should be used, or the one stored in "
"<filename>boot0</filename>."
msgstr ""
"O bloco de código a seguir testa se o número da unidade fornecido pelo "
"<acronym>BIOS</acronym> deve ser usado ou aquele armazenado <filename>boot0</"
"filename>."

#. (itstool) path: figure/programlisting
#: book.translate.xml:700
#, no-wrap
msgid ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)"
msgstr ""
"main:\n"
"      testb $SETDRV,-69(%bp)\t# Set drive number?\n"
"      jnz disable_update\t# Yes\n"
"      testb %dl,%dl\t\t# Drive number valid?\n"
"      js save_curdrive\t\t# Possibly (0x80 set)"

#. (itstool) path: sect1/para
#: book.translate.xml:707
msgid ""
"This code tests the <literal>SETDRV</literal> bit (<literal>0x20</literal>) "
"in the <emphasis>flags</emphasis> variable. Recall that register "
"<literal>%bp</literal> points to address location <literal>0x800</literal>, "
"so the test is done to the <emphasis>flags</emphasis> variable at address "
"<literal>0x800</literal>-<literal>69</literal>= <literal>0x7bb</literal>. "
"This is an example of the type of modifications that can be done to "
"<filename>boot0</filename>. The <literal>SETDRV</literal> flag is not set by "
"default, but it can be set in the <filename>Makefile</filename>. When set, "
"the drive number stored in the <acronym>MBR</acronym> is used instead of the "
"one provided by the <acronym>BIOS</acronym>. We assume the defaults, and "
"that the <acronym>BIOS</acronym> provided a valid drive number, so we jump "
"to <literal>save_curdrive</literal>."
msgstr ""
"Este código testa o bit (<literal>0x20</literal>) de <literal>SETDRV</"
"literal> na varíavel <emphasis>flags</emphasis>. Lembre-se de que o "
"registrador <literal>%bp</literal> aponta para endereço local "
"<literal>0x800</literal>, então o teste é feito para a vairável "
"<emphasis>flags</emphasis> no endereço <literal>0x800</literal>-<literal>69</"
"literal>=<literal>0x7bb</literal>. Este é um exemplo do tipo de modificações "
"que podem ser feitas para <filename>boot0</filename>. O flag de "
"<literal>SETDRV</literal> não é definido por padrão, mas pode ser definido "
"no <filename>Makefile</filename>. Quando definido, o número da unidade "
"armazenado no <acronym>MBR</acronym> é usado em vez daquele fornecido pelo "
"<acronym>BIOS</acronym>. Nós assumimos os padrões, e que a <acronym>BIOS</"
"acronym> forneceu um número de drive válido, então pulamos para "
"<literal>save_curdrive</literal>."

#. (itstool) path: sect1/para
#: book.translate.xml:723
msgid ""
"The next block saves the drive number provided by the <acronym>BIOS</"
"acronym>, and calls <literal>putn</literal> to print a new line on the "
"screen."
msgstr ""
"O próximo bloco salva o número da unidade fornecido pelo <acronym>BIOS</"
"acronym> e as chamadas <literal>putn</literal> para imprimir uma nova linha "
"na tela."

#. (itstool) path: figure/programlisting
#: book.translate.xml:730
#, no-wrap
msgid ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline"
msgstr ""
"save_curdrive:\n"
"      movb %dl, (%bp)\t\t# Save drive number\n"
"      pushw %dx\t\t\t# Also in the stack\n"
"#ifdef\tTEST\t/* test code, print internal bios drive */\n"
"      rolb $1, %dl\n"
"      movw $drive, %si\n"
"      call putkey\n"
"#endif\n"
"      callw putn\t\t# Print a newline"

#. (itstool) path: sect1/para
#: book.translate.xml:741
msgid ""
"Note that we assume <varname>TEST</varname> is not defined, so the "
"conditional code in it is not assembled and will not appear in our "
"executable <filename>boot0</filename>."
msgstr ""
"Note que assumimos <varname>TESTE</varname> como não definida, então o "
"código condicional nele não é montado e não aparecerá em nosso executável de "
"<filename>boot0</filename>."

#. (itstool) path: sect1/para
#: book.translate.xml:745
msgid ""
"Our next block implements the actual scanning of the partition table. It "
"prints to the screen the partition type for each of the four entries in the "
"partition table. It compares each type with a list of well-known operating "
"system file systems. Examples of recognized partition types are "
"<acronym>NTFS</acronym> (<trademark class=\"registered\">Windows</"
"trademark>, ID 0x7), <literal>ext2fs</literal> (<trademark class="
"\"registered\">Linux</trademark>, ID 0x83), and, of course, <literal>ffs</"
"literal>/<literal>ufs2</literal> (FreeBSD, ID 0xa5). The implementation is "
"fairly simple."
msgstr ""
"Nosso próximo bloco implementa a varredura real da tabela de partições. Ela "
"imprime na tela o tipo de partição para cada uma das quatro entradas na "
"tabela de partições. Ele compara cada tipo com uma lista de sistemas de "
"arquivos conhecidos do sistema operacional. Exemplos de tipos de partição "
"reconhecidos são <acronym>NTFS</acronym> (<trademark class="
"\"registered\">Windows</trademark> , ID 0x7), <literal>ext2fs</literal> "
"(<trademark class=\"registered\">Linux</trademark> , ID 0x83) e, claro, "
"<literal>ffs</literal>/<literal>ufs2</literal> (FreeBSD, ID 0xa5). A "
"implementação é bastante simples."

#. (itstool) path: figure/programlisting
#: book.translate.xml:758
#, no-wrap
msgid ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
"\n"
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
"\n"
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done"
msgstr ""
"      movw $(partbl+0x4),%bx\t# Partition table (+4)\n"
"      xorw %dx,%dx\t\t# Item number\n"
"\n"
"read_entry:\n"
"      movb %ch,-0x4(%bx)\t# Zero active flag (ch == 0)\n"
"      btw %dx,_FLAGS(%bp)\t# Entry enabled?\n"
"      jnc next_entry\t\t# No\n"
"      movb (%bx),%al\t\t# Load type\n"
"      test %al, %al\t\t# skip empty partition\n"
"      jz next_entry\n"
"      movw $bootable_ids,%di\t# Lookup tables\n"
"      movb $(TLEN+1),%cl\t# Number of entries\n"
"      repne\t\t\t# Locate\n"
"      scasb\t\t\t#  type\n"
"      addw $(TLEN-1), %di\t# Adjust\n"
"      movb (%di),%cl\t\t# Partition\n"
"      addw %cx,%di\t\t#  description\n"
"      callw putx\t\t# Display it\n"
"\n"
"next_entry:\n"
"      incw %dx\t\t\t# Next item\n"
"      addb $0x10,%bl\t\t# Next entry\n"
"      jnc read_entry\t\t# Till done"

#. (itstool) path: sect1/para
#: book.translate.xml:783
msgid ""
"It is important to note that the active flag for each entry is cleared, so "
"after the scanning, <emphasis>no</emphasis> partition entry is active in our "
"memory copy of <filename>boot0</filename>. Later, the active flag will be "
"set for the selected partition. This ensures that only one active partition "
"exists if the user chooses to write the changes back to disk."
msgstr ""
"É importante observar que a flag ativa de cada entrada é apagada, portanto, "
"após a varredura, <emphasis>nenhuma</emphasis> entrada de partição está "
"ativa em nossa cópia da memória de <filename>boot0</filename>. Mais tarde, a "
"flag ativa será definida para a partição selecionada. Isso garante que "
"apenas uma partição ativa existiré se o usuário optar por gravar as "
"alterações novamente no disco. "

#. (itstool) path: sect1/para
#: book.translate.xml:791
msgid ""
"The next block tests for other drives. At startup, the <acronym>BIOS</"
"acronym> writes the number of drives present in the computer to address "
"<literal>0x475</literal>. If there are any other drives present, "
"<filename>boot0</filename> prints the current drive to screen. The user may "
"command <filename>boot0</filename> to scan partitions on another drive later."
""
msgstr ""
"O próximo bloco testa as outras unidades. Na inicialização, a <acronym>BIOS</"
"acronym> grava o número de unidades presentes no computador para o endereço "
"<literal>0x475</literal> . Se houver outras unidades presentes, "
"<filename>boot0</filename> imprime a unidade atual na tela. O usuário pode "
"comandar <filename>boot0</filename> para varrer partições em outra unidade "
"depois. "

#. (itstool) path: figure/programlisting
#: book.translate.xml:802
#, no-wrap
msgid ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes"
msgstr ""
"      popw %ax\t\t\t# Drive number\n"
"      subb $0x79,%al\t\t# Does next\n"
"      cmpb 0x475,%al\t\t#  drive exist? (from BIOS?)\n"
"      jb print_drive\t\t# Yes\n"
"      decw %ax\t\t\t# Already drive 0?\n"
"      jz print_prompt\t\t# Yes"

#. (itstool) path: sect1/para
#: book.translate.xml:810
msgid ""
"We make the assumption that a single drive is present, so the jump to "
"<literal>print_drive</literal> is not performed. We also assume nothing "
"strange happened, so we jump to <literal>print_prompt</literal>."
msgstr ""
"Supomos que uma única unidade está presente, então o salto para "
"<literal>print_drive</literal> não é executado. Nós também assumimos que "
"nada de estranho aconteceu, então nós pulamos para <literal>print_prompt</"
"literal>. "

#. (itstool) path: sect1/para
#: book.translate.xml:815
msgid ""
"This next block just prints out a prompt followed by the default option:"
msgstr ""
"Este próximo bloco apenas imprime um prompt seguido pela opção padrão:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:821
#, no-wrap
msgid ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep"
msgstr ""
"print_prompt:\n"
"      movw $prompt,%si\t\t# Display\n"
"      callw putstr\t\t#  prompt\n"
"      movb _OPT(%bp),%dl\t# Display\n"
"      decw %si\t\t\t#  default\n"
"      callw putkey\t\t#  key\n"
"      jmp start_input\t\t# Skip beep"

#. (itstool) path: sect1/para
#: book.translate.xml:830
msgid ""
"Finally, a jump is performed to <literal>start_input</literal>, where the "
"<acronym>BIOS</acronym> services are used to start a timer and for reading "
"user input from the keyboard; if the timer expires, the default option will "
"be selected:"
msgstr ""
"Finalmente, um salto é realizado para <literal>start_input</literal> , onde "
"os serviços da <acronym>BIOS</acronym> são usados ​​para iniciar um timer e "
"para ler a entrada do usuário a partir do teclado; se o temporizador "
"expirar, a opção padrão será selecionada: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:839
#, no-wrap
msgid ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No"
msgstr ""
"start_input:\n"
"      xorb %ah,%ah\t\t# BIOS: Get\n"
"      int $0x1a\t\t\t#  system time\n"
"      movw %dx,%di\t\t# Ticks when\n"
"      addw _TICKS(%bp),%di\t#  timeout\n"
"read_key:\n"
"      movb $0x1,%ah\t\t# BIOS: Check\n"
"      int $0x16\t\t\t#  for keypress\n"
"      jnz got_key\t\t# Have input\n"
"      xorb %ah,%ah\t\t# BIOS: int 0x1a, 00\n"
"      int $0x1a\t\t\t#  get system time\n"
"      cmpw %di,%dx\t\t# Timeout?\n"
"      jb read_key\t\t# No"

#. (itstool) path: sect1/para
#: book.translate.xml:854
msgid ""
"An interrupt is requested with number <literal>0x1a</literal> and argument "
"<literal>0</literal> in register <literal>%ah</literal>. The <acronym>BIOS</"
"acronym> has a predefined set of services, requested by applications as "
"software-generated interrupts through the <literal>int</literal> instruction "
"and receiving arguments in registers (in this case, <literal>%ah</literal>). "
"Here, particularly, we are requesting the number of clock ticks since last "
"midnight; this value is computed by the <acronym>BIOS</acronym> through the "
"<acronym>RTC</acronym> (Real Time Clock). This clock can be programmed to "
"work at frequencies ranging from 2 Hz to 8192 Hz. The <acronym>BIOS</"
"acronym> sets it to 18.2 Hz at startup. When the request is satisfied, a 32-"
"bit result is returned by the <acronym>BIOS</acronym> in registers "
"<literal>%cx</literal> and <literal>%dx</literal> (lower bytes in "
"<literal>%dx</literal>). This result (the <literal>%dx</literal> part) is "
"copied to register <literal>%di</literal>, and the value of the "
"<varname>TICKS</varname> variable is added to <literal>%di</literal>. This "
"variable resides in <filename>boot0</filename> at offset <literal>_TICKS</"
"literal> (a negative value) from register <literal>%bp</literal> (which, "
"recall, points to <literal>0x800</literal>). The default value of this "
"variable is <literal>0xb6</literal> (182 in decimal). Now, the idea is that "
"<filename>boot0</filename> constantly requests the time from the "
"<acronym>BIOS</acronym>, and when the value returned in register "
"<literal>%dx</literal> is greater than the value stored in <literal>%di</"
"literal>, the time is up and the default selection will be made. Since the "
"RTC ticks 18.2 times per second, this condition will be met after 10 seconds "
"(this default behavior can be changed in the <filename>Makefile</filename>). "
"Until this time has passed, <filename>boot0</filename> continually asks the "
"<acronym>BIOS</acronym> for any user input; this is done through "
"<literal>int 0x16</literal>, argument <literal>1</literal> in <literal>%ah</"
"literal>."
msgstr ""
"Uma interrupção é solicitada com o número <literal>0x1a</literal> e "
"argumento <literal> </literal> no registrador <literal>%ah</literal>. A "
"<acronym>BIOS</acronym> possui um conjunto predefinido de serviços, "
"solicitados pelos aplicativos como interrupções geradas por software através "
"de uma instrução <literal>int</literal> e receber argumentos nos "
"registradores (neste caso, <literal>%ah</literal>). Aqui, particularmente, "
"estamos solicitando o número de pulsos de clock desde a última meia-noite; "
"esse valor é computado pela <acronym>BIOS</acronym> por meio do "
"<acronym>RTC</acronym> (Real Time Clock). Este clock pode ser programado "
"para funcionar em frequências que variam de 2 Hz a 8192 Hz. A <acronym>BIOS</"
"acronym> define isso a 18,2 Hz na inicialização. Quando a solicitação é "
"satisfeita, um resultado de 32 bits é retornado pela <acronym>BIOS</acronym> "
"em registradores <literal>%cx</literal> e <literal>%dx</literal> (bytes "
"inferiores em <literal>%dx</literal> ). Este resultado (a parte "
"<literal>%dx</literal>) é copiado para registrador <literal>%di</literal> e "
"o valor das variáveis <varname>TICKS</varname>  � adicionado ao "
"<literal>%di</literal> . Esta variável reside em <filename>boot0</filename> "
"no deslocamento <literal>_TICKS</literal> (um valor negativo) do registrador "
"<literal>%pb</literal> (que, lembre-se, aponta para <literal>0x800</literal> "
"). O valor padrão desta variável é <literal>0xb6</literal> (182 em decimal). "
"Agora, a ideia é que <filename>boot0</filename> constantemente solicita o "
"tempo da <acronym>BIOS</acronym>, e quando o valor retornado no registro "
"<literal>%dx</literal> é maior que o valor armazenado em <literal>%di</"
"literal>, o tempo acabou e a seleção padrão será feita. Como o RTC é de 18,2 "
"vezes por segundo, essa condição será atendida após 10 segundos (esse "
"comportamento padrão pode ser alterado no <filename>Makefile</filename> ). "
"Até que esse tempo tenha passado <filename>boot0</filename> continuamente "
"pede à <acronym>BIOS</acronym> por qualquer entrada do usuário; isso é feito "
"através <literal>int 0x16</literal> argumento <literal>1</literal> em "
"<literal>%ah</literal>."

#. (itstool) path: sect1/para
#: book.translate.xml:891
msgid ""
"Whether a key was pressed or the time expired, subsequent code validates the "
"selection. Based on the selection, the register <literal>%si</literal> is "
"set to point to the appropriate partition entry in the partition table. This "
"new selection overrides the previous default one. Indeed, it becomes the new "
"default. Finally, the ACTIVE flag of the selected partition is set. If it "
"was enabled at compile time, the in-memory version of <filename>boot0</"
"filename> with these modified values is written back to the <acronym>MBR</"
"acronym> on disk. We leave the details of this implementation to the reader."
msgstr ""
"Se uma tecla foi pressionada ou o tempo expirou, o código subsequente valida "
"a seleção. Com base na seleção, o registro <literal>%si</literal> é definido "
"para apontar para a entrada de partição apropriada na tabela de partições. "
"Essa nova seleção substitui a padrão anterior. De fato, ele se torna a novo "
"padrão. Por fim, a flag ACTIVE da partição selecionada é definida. Se foi "
"habilitada enquanto compilava, a versão em memória do <filename>boot0</"
"filename> com esses valores modificados é gravada de volta na <acronym>MBR</"
"acronym> no disco. Deixamos os detalhes desta implementação para o leitor."

#. (itstool) path: sect1/para
#: book.translate.xml:903
msgid ""
"We now end our study with the last code block from the <filename>boot0</"
"filename> program:"
msgstr ""
"Agora terminamos nosso estudo com o último bloco de código do programa "
"<filename>boot0</filename>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:909
#, no-wrap
msgid ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap"
msgstr ""
"      movw $0x7c00,%bx\t\t# Address for read\n"
"      movb $0x2,%ah\t\t# Read sector\n"
"      callw intx13\t\t#  from disk\n"
"      jc beep\t\t\t# If error\n"
"      cmpw $0xaa55,0x1fe(%bx)\t# Bootable?\n"
"      jne beep\t\t\t# No\n"
"      pushw %si\t\t\t# Save ptr to selected part.\n"
"      callw putn\t\t# Leave some space\n"
"      popw %si\t\t\t# Restore, next stage uses it\n"
"      jmp *%bx\t\t\t# Invoke bootstrap"

#. (itstool) path: sect1/para
#: book.translate.xml:921
msgid ""
"Recall that <literal>%si</literal> points to the selected partition entry. "
"This entry tells us where the partition begins on disk. We assume, of "
"course, that the partition selected is actually a FreeBSD slice."
msgstr ""
"Lembre-se que <literal>%si</literal> aponta para a entrada da partição "
"selecionada. Esta entrada nos diz onde a partição começa no disco. Nós "
"assumimos, é claro, que a partição selecionada é na verdade uma fatia do "
"FreeBSD. "

#. (itstool) path: note/para
#: book.translate.xml:927
msgid ""
"From now on, we will favor the use of the technically more accurate term "
"<quote>slice</quote> rather than <quote>partition</quote>."
msgstr ""
"A partir de agora, favoreceremos o uso do termo tecnicamente mais preciso "
"<quote>slice</quote> ao invés de <quote>partição</quote>."

#. (itstool) path: sect1/para
#: book.translate.xml:932
msgid ""
"The transfer buffer is set to <literal>0x7c00</literal> (register "
"<literal>%bx</literal>), and a read for the first sector of the FreeBSD "
"slice is requested by calling <literal>intx13</literal>. We assume that "
"everything went okay, so a jump to <literal>beep</literal> is not performed. "
"In particular, the new sector read must end with the magic sequence "
"<literal>0xaa55</literal>. Finally, the value at <literal>%si</literal> (the "
"pointer to the selected partition table) is preserved for use by the next "
"stage, and a jump is performed to address <literal>0x7c00</literal>, where "
"execution of our next stage (the just-read block) is started."
msgstr ""
"O buffer de transferência está definido para <literal>0x7c00</literal> "
"(registrador <literal>%bx</literal> ), e uma leitura para o primeiro setor "
"da slice do FreeBSD é solicitada chamando <literal>intx13</literal> . Nós "
"assumimos que tudo correu bem, então um salto para o <literal>beep</literal> "
"não é executado. Em particular, o novo setor lido deve terminar com a "
"sequência mágica <literal>0xaa55</literal>. Finalmente, o valor em "
"<literal>%si</literal> (o ponteiro para a tabela de partições selecionada) é "
"preservado para uso pelo próximo estágio, e um salto é executado para o "
"endereço <literal>0x7c00</literal> , onde a execução do nosso próximo "
"estágio (o bloco de apenas-leitura) é iniciado. "

#. (itstool) path: sect1/title
#: book.translate.xml:946
msgid "<literal>boot1</literal> Stage"
msgstr "Etapa <literal>boot1</literal>"

#. (itstool) path: sect1/para
#: book.translate.xml:948
msgid "So far we have gone through the following sequence:"
msgstr "Até agora nós passamos pela seguinte sequência:"

#. (itstool) path: listitem/para
#: book.translate.xml:952
msgid ""
"The <acronym>BIOS</acronym> did some early hardware initialization, "
"including the <acronym>POST</acronym>. The <acronym>MBR</acronym> "
"(<filename>boot0</filename>) was loaded from absolute disk sector one to "
"address <literal>0x7c00</literal>. Execution control was passed to that "
"location."
msgstr ""
"A <acronym>BIOS</acronym> fez algumas inicializações de hardware, incluindo "
"o <acronym>POST</acronym> . O <acronym>MBR</acronym> (<filename>boot0</"
"filename>) foi carregado a partir do primeiro setor de disco absoluto para "
"endereço <literal>0x7c00</literal> . O controle de execução foi passado para "
"essa localização."

#. (itstool) path: listitem/para
#: book.translate.xml:961
msgid ""
"<filename>boot0</filename> relocated itself to the location it was linked to "
"execute (<literal>0x600</literal>), followed by a jump to continue execution "
"at the appropriate place. Finally, <filename>boot0</filename> loaded the "
"first disk sector from the FreeBSD slice to address <literal>0x7c00</"
"literal>. Execution control was passed to that location."
msgstr ""
"<filename>boot0</filename> realocado para o local que estava lincado para "
"executar (<literal>0x600</literal>), seguido por um salto para continuar a "
"execução no local apropriado. Finalmente, <filename>boot0</filename> "
"carregou o primeiro setor de disco da slice do FreeBSD para endereço "
"<literal>0x7c00</literal>. O controle de execução foi passado para essa "
"localização."

#. (itstool) path: footnote/para
#: book.translate.xml:985
#, fuzzy
msgid ""
"There is a file <filename>/boot/boot1</filename>, but it is not the written "
"to the beginning of the FreeBSD slice. Instead, it is concatenated with "
"<filename>boot2</filename> to form <filename>boot</filename>, which "
"<emphasis>is</emphasis> written to the beginning of the FreeBSD slice and "
"read at boot time."
msgstr ""
"Existe um arquivo <filename> / boot / boot1 </filename> , mas n�o � o "
"escrito para o come�o da fatia do FreeBSD. Em vez disso, � concatenado com "
"<filename> boot2 </filename> formar <filename> bota </filename> , qual "
"<emphasis> � </emphasis> escrito para o in�cio da fatia do FreeBSD e lido no "
"momento da inicializa��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:971
#, fuzzy
msgid ""
"<filename>boot1</filename> is the next step in the boot-loading sequence. It "
"is the first of three boot stages. Note that we have been dealing "
"exclusively with disk sectors. Indeed, the <acronym>BIOS</acronym> loads the "
"absolute first sector, while <filename>boot0</filename> loads the first "
"sector of the FreeBSD slice. Both loads are to address <literal>0x7c00</"
"literal>. We can conceptually think of these disk sectors as containing the "
"files <filename>boot0</filename> and <filename>boot1</filename>, "
"respectively, but in reality this is not entirely true for <filename>boot1</"
"filename>. Strictly speaking, unlike <filename>boot0</filename>, "
"<filename>boot1</filename> is not part of the boot blocks <_:footnote-1/>. "
"Instead, a single, full-blown file, <filename>boot</filename> (<filename>/"
"boot/boot</filename>), is what ultimately is written to disk. This file is a "
"combination of <filename>boot1</filename>, <filename>boot2</filename> and "
"the <literal>Boot Extender</literal> (or <acronym>BTX</acronym>). This "
"single file is greater in size than a single sector (greater than 512 bytes)."
" Fortunately, <filename>boot1</filename> occupies <emphasis>exactly</"
"emphasis> the first 512 bytes of this single file, so when <filename>boot0</"
"filename> loads the first sector of the FreeBSD slice (512 bytes), it is "
"actually loading <filename>boot1</filename> and transferring control to it."
msgstr ""
" <filename> boot1 </filename> � o pr�ximo passo na sequ�ncia de carregamento "
"de inicializa��o. � o primeiro de tr�s est�gios de inicializa��o. Observe "
"que estamos lidando exclusivamente com setores de disco. De fato, o "
"<acronym>BIOS</acronym> carrega o primeiro setor absoluto, enquanto "
"<filename> boot0 </filename> carrega o primeiro setor da fatia do FreeBSD. "
"Ambas as cargas s�o para resolver <literal> 0x7c00 </literal> . Podemos "
"conceitualmente pensar nesses setores de disco como contendo os arquivos "
"<filename> boot0 </filename> e <filename> boot1 </filename> , "
"respectivamente, mas na realidade isso n�o � inteiramente verdade para "
"<filename> boot1 </filename> . Estritamente falando, diferentemente "
"<filename> boot0 </filename> , <filename> boot1 </filename> n�o faz parte "
"dos blocos de inicializa��o <_: footnote-1 />. Em vez disso, um �nico "
"arquivo completo, <filename> bota </filename> ( <filename> / boot / boot </"
"filename> ), � o que finalmente � gravado em disco. Este arquivo � uma "
"combina��o de <filename> boot1 </filename> , <filename> boot2 </filename> e "
"a <literal> Extensor de Inicializa��o </literal> (ou <acronym>BTX</acronym> "
"). Este arquivo �nico � maior em tamanho do que um �nico setor (maior que "
"512 bytes). Felizmente, <filename> boot1 </filename> ocupa <emphasis> "
"exatamente </emphasis> os primeiros 512 bytes deste arquivo �nico, ent�o "
"quando <filename> boot0 </filename> carrega o primeiro setor da fatia do "
"FreeBSD (512 bytes), ele est� realmente carregando <filename> boot1 </"
"filename> e transferindo o controle para ele. "

#. (itstool) path: sect1/para
#: book.translate.xml:1005
#, fuzzy
msgid ""
"The main task of <filename>boot1</filename> is to load the next boot stage. "
"This next stage is somewhat more complex. It is composed of a server called "
"the <quote>Boot Extender</quote>, or <acronym>BTX</acronym>, and a client, "
"called <filename>boot2</filename>. As we will see, the last boot stage, "
"<filename>loader</filename>, is also a client of the <acronym>BTX</acronym> "
"server."
msgstr ""
"A principal tarefa de <filename> boot1 </filename> � carregar o pr�ximo "
"est�gio de inicializa��o. Este pr�ximo est�gio � um pouco mais complexo. � "
"composto por um servidor chamado <quote> Extensor de Inicializa��o </quote> "
", ou <acronym>BTX</acronym> , e um cliente, chamado <filename> boot2 </"
"filename> . Como veremos, o �ltimo est�gio de inicializa��o <filename> "
"carregador </filename> � tamb�m um cliente do servidor <acronym>BTX</"
"acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:1013
#, fuzzy
msgid ""
"Let us now look in detail at what exactly is done by <filename>boot1</"
"filename>, starting like we did for <filename>boot0</filename>, at its entry "
"point:"
msgstr ""
"Vamos agora olhar em detalhes para o que exatamente � feito por <filename> "
"boot1 </filename> , come�ando como fizemos para <filename> boot0 </filename> "
", no seu ponto de entrada: "

#. (itstool) path: figure/title
#: book.translate.xml:1018 book.translate.xml:1029 book.translate.xml:1069
#: book.translate.xml:1114 book.translate.xml:1149 book.translate.xml:1176
#: book.translate.xml:1205 book.translate.xml:1311
msgid "<filename>sys/boot/i386/boot2/boot1.S</filename>"
msgstr "<filename>sys/boot/i386/boot2/boot1.S</filename>"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1020
#, no-wrap
msgid "start:\n"
"\tjmp main"
msgstr "start:\n"
"\tjmp main"

#. (itstool) path: sect1/para
#: book.translate.xml:1024
#, fuzzy
msgid ""
"The entry point at <literal>start</literal> simply jumps past a special data "
"area to the label <literal>main</literal>, which in turn looks like this:"
msgstr ""
"O ponto de entrada em <literal> come�ar </literal> simplesmente passa por "
"uma �rea de dados especial para o r�tulo <literal> a Principal </literal> , "
"que por sua vez se parece com isso: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1031
#, no-wrap
msgid ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code"
msgstr ""
"main:\n"
"      cld\t\t\t# String ops inc\n"
"      xor %cx,%cx\t\t# Zero\n"
"      mov %cx,%es\t\t# Address\n"
"      mov %cx,%ds\t\t#  data\n"
"      mov %cx,%ss\t\t# Set up\n"
"      mov $start,%sp\t\t#  stack\n"
"      mov %sp,%si\t\t# Source\n"
"      mov $0x700,%di\t\t# Destination\n"
"      incb %ch\t\t\t# Word count\n"
"      rep\t\t\t# Copy\n"
"      movsw\t\t\t#  code"

#. (itstool) path: sect1/para
#: book.translate.xml:1045
#, fuzzy
msgid ""
"Just like <filename>boot0</filename>, this code relocates <filename>boot1</"
"filename>, this time to memory address <literal>0x700</literal>. However, "
"unlike <filename>boot0</filename>, it does not jump there. <filename>boot1</"
"filename> is linked to execute at address <literal>0x7c00</literal>, "
"effectively where it was loaded in the first place. The reason for this "
"relocation will be discussed shortly."
msgstr ""
"Assim como <filename> boot0 </filename> , este c�digo realoca <filename> "
"boot1 </filename> , desta vez para endere�o de mem�ria <literal> 0x700 </"
"literal> . No entanto, ao contr�rio <filename> boot0 </filename> , n�o salta "
"para l�. <filename> boot1 </filename> est� ligado para executar no endere�o "
"<literal> 0x7c00 </literal> , efetivamente onde foi carregado em primeiro "
"lugar. A raz�o para essa realoca��o ser� discutida em breve. "

#. (itstool) path: footnote/para
#: book.translate.xml:1058
#, fuzzy
msgid ""
"Actually we did pass a pointer to the slice entry in register <literal>%si</"
"literal>. However, <filename>boot1</filename> does not assume that it was "
"loaded by <filename>boot0</filename> (perhaps some other <acronym>MBR</"
"acronym> loaded it, and did not pass this information), so it assumes "
"nothing."
msgstr ""
"Na verdade n�s passamos um ponteiro para a entrada da fatia no registro "
"<literal> %si </literal> . Contudo, <filename> boot1 </filename> n�o assume "
"que foi carregado por <filename> boot0 </filename> (talvez algum outro "
"<acronym>MBR tenha</acronym> carregado e n�o tenha passado essa informa��o), "
"por isso n�o assume nada. "

#. (itstool) path: sect1/para
#: book.translate.xml:1054
#, fuzzy
msgid ""
"Next comes a loop that looks for the FreeBSD slice. Although "
"<filename>boot0</filename> loaded <filename>boot1</filename> from the "
"FreeBSD slice, no information was passed to it about this <_:footnote-1/>, "
"so <filename>boot1</filename> must rescan the partition table to find where "
"the FreeBSD slice starts. Therefore it rereads the <acronym>MBR</acronym>:"
msgstr ""
"Em seguida vem um loop que procura a fatia do FreeBSD. Embora <filename> "
"boot0 </filename> carregado <filename> boot1 </filename> do slice do "
"FreeBSD, nenhuma informa��o foi passada para ele sobre isso <_: footnote-1 /"
">, ent�o <filename> boot1 </filename> deve varrer novamente a tabela de "
"parti��es para encontrar onde o slice do FreeBSD � iniciado. Por isso, rel� "
"o <acronym>MBR</acronym> : "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1071
#, no-wrap
msgid ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR"
msgstr ""
"      mov $part4,%si\t\t# Partition\n"
"      cmpb $0x80,%dl\t\t# Hard drive?\n"
"      jb main.4\t\t\t# No\n"
"      movb $0x1,%dh\t\t# Block count\n"
"      callw nread\t\t# Read MBR"

#. (itstool) path: sect1/para
#: book.translate.xml:1078
msgid ""
"In the code above, register <literal>%dl</literal> maintains information "
"about the boot device. This is passed on by the <acronym>BIOS</acronym> and "
"preserved by the <acronym>MBR</acronym>. Numbers <literal>0x80</literal> and "
"greater tells us that we are dealing with a hard drive, so a call is made to "
"<literal>nread</literal>, where the <acronym>MBR</acronym> is read. "
"Arguments to <literal>nread</literal> are passed through <literal>%si</"
"literal> and <literal>%dh</literal>. The memory address at label "
"<literal>part4</literal> is copied to <literal>%si</literal>. This memory "
"address holds a <quote>fake partition</quote> to be used by <literal>nread</"
"literal>. The following is the data in the fake partition:"
msgstr ""
"No código acima, o registro <literal>%dl</literal> mantém informações sobre "
"o dispositivo de inicialização. Isso é transmitido pelo <acronym>BIOS</"
"acronym> e preservado pelo <acronym>MBR</acronym>. Os números <literal>0x80</"
"literal> e maiores nos dizem que estamos lidando com um disco rígido, então "
"uma chamada é feita para <literal>nread</literal>, onde o <acronym>MBR</"
"acronym> é lido. Argumentos para <literal>nread</literal> são passados "
"​​através de <literal>%si</literal> e <literal>%dh</literal>. O endereço de "
"memória no rótulo <literal>part4</literal> é copiado para <literal>%si</"
"literal>. Este endereço de memória contém uma <quote>partição falsa</quote> "
"a ser usada por <literal>nread</literal>. A seguir estão os dados na "
"partição falsa:"

#. (itstool) path: figure/title
#: book.translate.xml:1094 book.translate.xml:1387 book.translate.xml:1400
#: book.translate.xml:1432 book.translate.xml:1473
msgid "<filename>sys/boot/i386/boot2/Makefile</filename>"
msgstr " <filename>sys/boot/i386/boot2/Makefile</filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1096
#, no-wrap
msgid ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00"
msgstr ""
"      part4:\n"
"\t.byte 0x80, 0x00, 0x01, 0x00\n"
"\t.byte 0xa5, 0xfe, 0xff, 0xff\n"
"\t.byte 0x00, 0x00, 0x00, 0x00\n"
"\t.byte 0x50, 0xc3, 0x00, 0x00"

#. (itstool) path: sect1/para
#: book.translate.xml:1103
#, fuzzy
msgid ""
"In particular, the <acronym>LBA</acronym> for this fake partition is "
"hardcoded to zero. This is used as an argument to the <acronym>BIOS</"
"acronym> for reading absolute sector one from the hard drive. Alternatively, "
"CHS addressing could be used. In this case, the fake partition holds "
"cylinder 0, head 0 and sector 1, which is equivalent to absolute sector one."
msgstr ""
"Em particular, o <acronym>LBA</acronym> para essa parti��o falsa � "
"codificado para zero. Isso � usado como um argumento para o <acronym>BIOS</"
"acronym> para ler o setor absoluto do disco r�gido. Alternativamente, o "
"endere�amento CHS pode ser usado. Nesse caso, a parti��o falsa mant�m "
"cilindro 0, cabe�a 0 e setor 1, o que equivale ao setor absoluto um. "

#. (itstool) path: sect1/para
#: book.translate.xml:1110
#, fuzzy
msgid "Let us now proceed to take a look at <literal>nread</literal>:"
msgstr "Vamos agora dar uma olhada <literal> nread </literal> : "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1116
#, no-wrap
msgid ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return"
msgstr ""
"nread:\n"
"      mov $0x8c00,%bx\t\t# Transfer buffer\n"
"      mov 0x8(%si),%ax\t\t# Get\n"
"      mov 0xa(%si),%cx\t\t#  LBA\n"
"      push %cs\t\t\t# Read from\n"
"      callw xread.1\t\t#  disk\n"
"      jnc return\t\t# If success, return"

#. (itstool) path: footnote/para
#: book.translate.xml:1128
#, fuzzy
msgid "In the context of 16-bit real mode, a word is 2 bytes."
msgstr "No contexto do modo real de 16 bits, uma palavra � de 2 bytes."

#. (itstool) path: sect1/para
#: book.translate.xml:1125
#, fuzzy
msgid ""
"Recall that <literal>%si</literal> points to the fake partition. The word <_:"
"footnote-1/> at offset <literal>0x8</literal> is copied to register "
"<literal>%ax</literal> and word at offset <literal>0xa</literal> to "
"<literal>%cx</literal>. They are interpreted by the <acronym>BIOS</acronym> "
"as the lower 4-byte value denoting the LBA to be read (the upper four bytes "
"are assumed to be zero). Register <literal>%bx</literal> holds the memory "
"address where the <acronym>MBR</acronym> will be loaded. The instruction "
"pushing <literal>%cs</literal> onto the stack is very interesting. In this "
"context, it accomplishes nothing. However, as we will see shortly, "
"<filename>boot2</filename>, in conjunction with the <acronym>BTX</acronym> "
"server, also uses <literal>xread.1</literal>. This mechanism will be "
"discussed in the next section."
msgstr ""
"Lembre-se que <literal> %si </literal> aponta para a parti��o falsa. A "
"palavra <_: footnote-1 /> no deslocamento <literal> 0x8 </literal> � copiado "
"para registrar <literal> %machado </literal> e palavra no deslocamento "
"<literal> 0xa </literal> para <literal> % cx </literal> . Eles s�o "
"interpretados pelo <acronym>BIOS</acronym> como o valor inferior de 4 bytes "
"que indica o LBA a ser lido (os quatro bytes superiores s�o considerados "
"como zero). registo <literal> % bx </literal> mant�m o endere�o de mem�ria "
"onde o <acronym>MBR</acronym> ser� carregado. A instru��o empurrando "
"<literal> % cs </literal> na pilha � muito interessante. Neste contexto, n�o "
"realiza nada. No entanto, como veremos em breve, <filename> boot2 </"
"filename> , em conjunto com o servidor <acronym>BTX</acronym> , tamb�m usa "
"<literal> xread.1 </literal> . Esse mecanismo ser� discutido na pr�xima "
"se��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:1144
#, fuzzy
msgid ""
"The code at <literal>xread.1</literal> further calls the <literal>read</"
"literal> function, which actually calls the <acronym>BIOS</acronym> asking "
"for the disk sector:"
msgstr ""
"O c�digo em <literal> xread.1 </literal> ainda chama o <literal> ler </"
"literal> fun��o, que realmente chama o <acronym>BIOS</acronym> pedindo o "
"setor de disco: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1151
#, no-wrap
msgid ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller"
msgstr ""
"xread.1:\n"
"\tpushl $0x0\t\t#  absolute\n"
"\tpush %cx\t\t#  block\n"
"\tpush %ax\t\t#  number\n"
"\tpush %es\t\t# Address of\n"
"\tpush %bx\t\t#  transfer buffer\n"
"\txor %ax,%ax\t\t# Number of\n"
"\tmovb %dh,%al\t\t#  blocks to\n"
"\tpush %ax\t\t#  transfer\n"
"\tpush $0x10\t\t# Size of packet\n"
"\tmov %sp,%bp\t\t# Packet pointer\n"
"\tcallw read\t\t# Read from disk\n"
"\tlea 0x10(%bp),%sp\t# Clear stack\n"
"\tlret\t\t\t# To far caller"

#. (itstool) path: sect1/para
#: book.translate.xml:1167
#, fuzzy
msgid ""
"Note the long return instruction at the end of this block. This instruction "
"pops out the <literal>%cs</literal> register pushed by <literal>nread</"
"literal>, and returns. Finally, <literal>nread</literal> also returns."
msgstr ""
"Observe a instru��o de retorno longo no final deste bloco. Esta instru��o "
"mostra a <literal> % cs </literal> registrar empurrado por <literal> nread </"
"literal> e retorna. Finalmente, <literal> nread </literal> tamb�m retorna. "

#. (itstool) path: sect1/para
#: book.translate.xml:1172
#, fuzzy
msgid ""
"With the <acronym>MBR</acronym> loaded to memory, the actual loop for "
"searching the FreeBSD slice begins:"
msgstr ""
"Com o <acronym>MBR</acronym> carregado na mem�ria, o loop real para procurar "
"a fatia do FreeBSD come�a:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1178
#, no-wrap
msgid ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes"
msgstr ""
"\tmov $0x1,%cx\t\t # Two passes\n"
"main.1:\n"
"\tmov $0x8dbe,%si # Partition table\n"
"\tmovb $0x1,%dh\t\t # Partition\n"
"main.2:\n"
"\tcmpb $0xa5,0x4(%si)\t # Our partition type?\n"
"\tjne main.3\t\t # No\n"
"\tjcxz main.5\t\t # If second pass\n"
"\ttestb $0x80,(%si)\t # Active?\n"
"\tjnz main.5\t\t # Yes\n"
"main.3:\n"
"\tadd $0x10,%si\t\t # Next entry\n"
"\tincb %dh\t\t # Partition\n"
"\tcmpb $0x5,%dh\t\t # In table?\n"
"\tjb main.2\t\t # Yes\n"
"\tdec %cx\t\t\t # Do two\n"
"\tjcxz main.1\t\t #  passes"

#. (itstool) path: sect1/para
#: book.translate.xml:1197
#, fuzzy
msgid ""
"If a FreeBSD slice is identified, execution continues at <literal>main.5</"
"literal>. Note that when a FreeBSD slice is found <literal>%si</literal> "
"points to the appropriate entry in the partition table, and <literal>%dh</"
"literal> holds the partition number. We assume that a FreeBSD slice is "
"found, so we continue execution at <literal>main.5</literal>:"
msgstr ""
"Se uma fatia do FreeBSD for identificada, a execu��o continua em <literal> "
"main.5 </literal> . Note que quando uma fatia do FreeBSD � encontrada "
"<literal> %si </literal> aponta para a entrada apropriada na tabela de "
"parti��es e <literal> % dh </literal> mant�m o n�mero da parti��o. N�s "
"assumimos que uma fatia do FreeBSD � encontrada, ent�o continuamos a "
"execu��o em <literal> main.5 </literal> : "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1207
#, no-wrap
msgid ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client"
msgstr ""
"main.5:\n"
"\tmov %dx,0x900\t\t\t   # Save args\n"
"\tmovb $0x10,%dh\t\t\t   # Sector count\n"
"\tcallw nread\t\t\t   # Read disk\n"
"\tmov $0x9000,%bx\t\t\t   # BTX\n"
"\tmov 0xa(%bx),%si\t\t   # Get BTX length and set\n"
"\tadd %bx,%si\t\t\t   #  %si to start of boot2.bin\n"
"\tmov $0xc000,%di\t\t\t   # Client page 2\n"
"\tmov $0xa200,%cx\t\t\t   # Byte\n"
"\tsub %si,%cx\t\t\t   #  count\n"
"\trep\t\t\t\t   # Relocate\n"
"\tmovsb\t\t\t\t   #  client"

#. (itstool) path: sect1/para
#: book.translate.xml:1221
#, fuzzy
msgid ""
"Recall that at this point, register <literal>%si</literal> points to the "
"FreeBSD slice entry in the <acronym>MBR</acronym> partition table, so a call "
"to <literal>nread</literal> will effectively read sectors at the beginning "
"of this partition. The argument passed on register <literal>%dh</literal> "
"tells <literal>nread</literal> to read 16 disk sectors. Recall that the "
"first 512 bytes, or the first sector of the FreeBSD slice, coincides with "
"the <filename>boot1</filename> program. Also recall that the file written to "
"the beginning of the FreeBSD slice is not <filename>/boot/boot1</filename>, "
"but <filename>/boot/boot</filename>. Let us look at the size of these files "
"in the filesystem:"
msgstr ""
"Lembre-se que neste momento, registre <literal> %si </literal> aponta para a "
"entrada de fatia do FreeBSD na <acronym>tabela de</acronym> parti��o "
"<acronym>MBR</acronym> , ent�o uma chamada para <literal> nread </literal> "
"efetivamente ler� setores no in�cio desta parti��o. O argumento passou no "
"registro <literal> % dh </literal> conta <literal> nread </literal> para ler "
"16 setores de disco. Lembre-se que os primeiros 512 bytes, ou o primeiro "
"setor da fatia do FreeBSD, coincide com o <filename> boot1 </filename> "
"programa. Lembre-se tamb�m que o arquivo gravado no in�cio da fatia do "
"FreeBSD n�o � <filename> / boot / boot1 </filename> , mas <filename> / boot /"
" boot </filename> . Vamos ver o tamanho desses arquivos no sistema de "
"arquivos: "

#. (itstool) path: sect1/screen
#. (itstool) id: book.translate.xml#boot-boot1-filesize
#: book.translate.xml:1234
#, no-wrap
msgid ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot"
msgstr ""
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot0\n"
"-r--r--r--  1 root  wheel   512B Jan  8 00:15 /boot/boot1\n"
"-r--r--r--  1 root  wheel   7.5K Jan  8 00:15 /boot/boot2\n"
"-r--r--r--  1 root  wheel   8.0K Jan  8 00:15 /boot/boot"

#. (itstool) path: sect1/para
#: book.translate.xml:1239
#, fuzzy
msgid ""
"Both <filename>boot0</filename> and <filename>boot1</filename> are 512 bytes "
"each, so they fit <emphasis>exactly</emphasis> in one disk sector. "
"<filename>boot2</filename> is much bigger, holding both the <acronym>BTX</"
"acronym> server and the <filename>boot2</filename> client. Finally, a file "
"called simply <filename>boot</filename> is 512 bytes larger than "
"<filename>boot2</filename>. This file is a concatenation of <filename>boot1</"
"filename> and <filename>boot2</filename>. As already noted, <filename>boot0</"
"filename> is the file written to the absolute first disk sector (the "
"<acronym>MBR</acronym>), and <filename>boot</filename> is the file written "
"to the first sector of the FreeBSD slice; <filename>boot1</filename> and "
"<filename>boot2</filename> are <emphasis>not</emphasis> written to disk. The "
"command used to concatenate <filename>boot1</filename> and <filename>boot2</"
"filename> into a single <filename>boot</filename> is merely <command>cat "
"boot1 boot2 &gt; boot</command>."
msgstr ""
"Ambos <filename> boot0 </filename> e <filename> boot1 </filename> s�o 512 "
"bytes cada, ent�o eles se encaixam <emphasis> exatamente </emphasis> em um "
"setor de disco. <filename> boot2 </filename> � muito maior, mantendo tanto o "
"servidor <acronym>BTX</acronym> quanto o <filename> boot2 </filename> "
"cliente. Finalmente, um arquivo chamado simplesmente <filename> bota </"
"filename> � 512 bytes maior que <filename> boot2 </filename> . Este arquivo "
"� uma concatena��o de <filename> boot1 </filename> e <filename> boot2 </"
"filename> . Como j� foi dito, <filename> boot0 </filename> � o arquivo "
"gravado no primeiro setor de disco absoluto (o <acronym>MBR</acronym> ) e "
"<filename> bota </filename> � o arquivo escrito no primeiro setor da fatia "
"do FreeBSD; <filename> boot1 </filename> e <filename> boot2 </filename> "
"estamos <emphasis> n�o </emphasis> escrito em disco. O comando usado para "
"concatenar <filename> boot1 </filename> e <filename> boot2 </filename> em um "
"�nico <filename> bota </filename> � meramente <command> gato boot1 boot2&gt; "
"boot </command> "

#. (itstool) path: footnote/para
#: book.translate.xml:1266
#, fuzzy
msgid "512*16=8192 bytes, exactly the size of <filename>boot</filename>"
msgstr ""
"512 * 16 = 8192 bytes, exatamente o tamanho de <filename> bota </filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:1258
#, fuzzy
msgid ""
"So <filename>boot1</filename> occupies exactly the first 512 bytes of "
"<filename>boot</filename> and, because <filename>boot</filename> is written "
"to the first sector of the FreeBSD slice, <filename>boot1</filename> fits "
"exactly in this first sector. Because <literal>nread</literal> reads the "
"first 16 sectors of the FreeBSD slice, it effectively reads the entire "
"<filename>boot</filename> file <_:footnote-1/>. We will see more details "
"about how <filename>boot</filename> is formed from <filename>boot1</"
"filename> and <filename>boot2</filename> in the next section."
msgstr ""
"Assim <filename> boot1 </filename> ocupa exatamente os primeiros 512 bytes "
"de <filename> bota </filename> e porque <filename> bota </filename> � "
"escrito para o primeiro setor da fatia do FreeBSD, <filename> boot1 </"
"filename> cabe exatamente neste primeiro setor. Porque <literal> nread </"
"literal> l� os primeiros 16 setores da fatia do FreeBSD, l� efetivamente "
"toda a <filename> bota </filename> arquivo<_: nota de rodap�-1 />. Vamos ver "
"mais detalhes sobre como <filename> bota </filename> � formado a partir de "
"<filename> boot1 </filename> e <filename> boot2 </filename> na pr�xima se��o."
" "

#. (itstool) path: footnote/para
#: book.translate.xml:1282
#, fuzzy
msgid ""
"Historically known as <quote>disklabel</quote>. If you ever wondered where "
"FreeBSD stored this information, it is in this region. See "
"<citerefentry><refentrytitle>bsdlabel</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>"
msgstr ""
"Historicamente conhecido como <quote> disklabel </quote> . Se voc� j� se "
"perguntou onde o FreeBSD armazenou esta informa��o, est� nesta regi�o. Vejo "
"<citerefentry><refentrytitle> bsdlabel </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> "

#. (itstool) path: sect1/para
#: book.translate.xml:1272
#, fuzzy
msgid ""
"Recall that <literal>nread</literal> uses memory address <literal>0x8c00</"
"literal> as the transfer buffer to hold the sectors read. This address is "
"conveniently chosen. Indeed, because <filename>boot1</filename> belongs to "
"the first 512 bytes, it ends up in the address range <literal>0x8c00</"
"literal>-<literal>0x8dff</literal>. The 512 bytes that follows (range "
"<literal>0x8e00</literal>-<literal>0x8fff</literal>) is used to store the "
"<emphasis>bsdlabel</emphasis> <_:footnote-1/>."
msgstr ""
"Lembre-se que <literal> nread </literal> usa endere�o de mem�ria <literal> "
"0x8c00 </literal> como o buffer de transfer�ncia para manter os setores "
"lidos. Este endere�o � convenientemente escolhido. De fato, porque "
"<filename> boot1 </filename> pertence aos primeiros 512 bytes, acaba na "
"faixa de endere�os <literal> 0x8c00 </literal> - <literal> 0x8dff </literal> "
". Os 512 bytes seguintes (intervalo <literal> 0x8e00 </literal> - <literal> "
"0x8fff </literal> ) � usado para armazenar <emphasis> bsdlabel </emphasis> "
"<_: nota de rodap�-1 />. "

#. (itstool) path: sect1/para
#: book.translate.xml:1286
#, fuzzy
msgid ""
"Starting at address <literal>0x9000</literal> is the beginning of the "
"<acronym>BTX</acronym> server, and immediately following is the "
"<filename>boot2</filename> client. The <acronym>BTX</acronym> server acts as "
"a kernel, and executes in protected mode in the most privileged level. In "
"contrast, the <acronym>BTX</acronym> clients (<filename>boot2</filename>, "
"for example), execute in user mode. We will see how this is accomplished in "
"the next section. The code after the call to <literal>nread</literal> "
"locates the beginning of <filename>boot2</filename> in the memory buffer, "
"and copies it to memory address <literal>0xc000</literal>. This is because "
"the <acronym>BTX</acronym> server arranges <filename>boot2</filename> to "
"execute in a segment starting at <literal>0xa000</literal>. We explore this "
"in detail in the following section."
msgstr ""
"Come�ando no endere�o <literal> 0x9000 </literal> � o come�o do servidor "
"<acronym>BTX</acronym> , e imediatamente a seguir � <filename> boot2 </"
"filename> cliente. O servidor <acronym>BTX</acronym> atua como um kernel e � "
"executado no modo protegido no n�vel mais privilegiado. Em contraste, os "
"clientes <acronym>BTX</acronym> ( <filename> boot2 </filename> , por "
"exemplo), executar no modo de usu�rio. Vamos ver como isso � feito na "
"pr�xima se��o. O c�digo ap�s a chamada para <literal> nread </literal> "
"localiza o come�o de <filename> boot2 </filename> no buffer de mem�ria e "
"copia para o endere�o de mem�ria <literal> 0xc000 </literal> . Isso ocorre "
"porque o servidor <acronym>BTX</acronym> organiza <filename> boot2 </"
"filename> para executar em um segmento a partir de <literal> 0xa000 </"
"literal> . N�s exploramos isso em detalhes na se��o seguinte. "

#. (itstool) path: footnote/para
#: book.translate.xml:1305
#, fuzzy
msgid ""
"This is necessary for legacy reasons. Interested readers should see <link "
"xlink:href=\"http://en.wikipedia.org/wiki/A20_line\"/>."
msgstr ""
"Isso � necess�rio por raz�es de legado. Os leitores interessados ​​devem ver "
"<link xlink:href=\"http://en.wikipedia.org/wiki/A20_line\"/> "

#. (itstool) path: sect1/para
#: book.translate.xml:1302
#, fuzzy
msgid ""
"The last code block of <filename>boot1</filename> enables access to memory "
"above 1MB <_:footnote-1/> and concludes with a jump to the starting point of "
"the <acronym>BTX</acronym> server:"
msgstr ""
"O �ltimo bloco de c�digo de <filename> boot1 </filename> permite o acesso � "
"mem�ria acima de 1MB <_: footnote-1 /> e conclui com um salto para o ponto "
"de partida do servidor <acronym>BTX</acronym> : "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1313
#, no-wrap
msgid ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
"\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX"
msgstr ""
"seta20:\n"
"\tcli\t\t\t# Disable interrupts\n"
"seta20.1:\n"
"\tdec %cx\t\t\t# Timeout?\n"
"\tjz seta20.3\t\t# Yes\n"
"\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.1\t\t# Yes\n"
"\tmovb $0xd1,%al\t\t# Command: Write\n"
"\toutb %al,$0x64\t\t#  output port\n"
"seta20.2:\n"
"\tinb $0x64,%al\t\t# Get status\n"
"\ttestb $0x2,%al\t\t# Busy?\n"
"\tjnz seta20.2\t\t# Yes\n"
"\tmovb $0xdf,%al\t\t# Enable\n"
"\toutb %al,$0x60\t\t#  A20\n"
"seta20.3:\n"
"\tsti\t\t\t# Enable interrupts\n"
"\tjmp 0x9010\t\t# Start BTX"

#. (itstool) path: sect1/para
#: book.translate.xml:1335
#, fuzzy
msgid "Note that right before the jump, interrupts are enabled."
msgstr "Note que logo antes do salto, as interrup��es est�o habilitadas."

#. (itstool) path: sect1/title
#: book.translate.xml:1340
#, fuzzy
msgid "The <acronym>BTX</acronym> Server"
msgstr "O servidor <acronym>BTX</acronym> "

#. (itstool) path: sect1/para
#: book.translate.xml:1342
#, fuzzy
msgid ""
"Next in our boot sequence is the <acronym>BTX</acronym> Server. Let us "
"quickly remember how we got here:"
msgstr ""
"O pr�ximo passo na nossa seq��ncia de inicializa��o � o servidor "
"<acronym>BTX</acronym> . Vamos lembrar rapidamente como chegamos aqui:"

#. (itstool) path: listitem/para
#: book.translate.xml:1348
#, fuzzy
msgid ""
"The <acronym>BIOS</acronym> loads the absolute sector one (the <acronym>MBR</"
"acronym>, or <filename>boot0</filename>), to address <literal>0x7c00</"
"literal> and jumps there."
msgstr ""
"O <acronym>BIOS</acronym> carrega o setor absoluto (o <acronym>MBR</acronym> "
", ou <filename> boot0 </filename> ), endere�ar <literal> 0x7c00 </literal> e "
"pula l�. "

#. (itstool) path: listitem/para
#: book.translate.xml:1355
#, fuzzy
msgid ""
"<filename>boot0</filename> relocates itself to <literal>0x600</literal>, the "
"address it was linked to execute, and jumps over there. It then reads the "
"first sector of the FreeBSD slice (which consists of <filename>boot1</"
"filename>) into address <literal>0x7c00</literal> and jumps over there."
msgstr ""
" <filename> boot0 </filename> se muda para <literal> 0x600 </literal> , o "
"endere�o que estava ligado para executar e salta para l�. Ele ent�o l� o "
"primeiro setor da fatia do FreeBSD (que consiste em <filename> boot1 </"
"filename> ) no endere�o <literal> 0x7c00 </literal> e pula ali "

#. (itstool) path: listitem/para
#: book.translate.xml:1364
#, fuzzy
msgid ""
"<filename>boot1</filename> loads the first 16 sectors of the FreeBSD slice "
"into address <literal>0x8c00</literal>. This 16 sectors, or 8192 bytes, is "
"the whole file <filename>boot</filename>. The file is a concatenation of "
"<filename>boot1</filename> and <filename>boot2</filename>. <filename>boot2</"
"filename>, in turn, contains the <acronym>BTX</acronym> server and the "
"<filename>boot2</filename> client. Finally, a jump is made to address "
"<literal>0x9010</literal>, the entry point of the <acronym>BTX</acronym> "
"server."
msgstr ""
" <filename> boot1 </filename> carrega os primeiros 16 setores da fatia do "
"FreeBSD no endere�o <literal> 0x8c00 </literal> . Este 16 setores, ou 8192 "
"bytes, � o arquivo inteiro <filename> bota </filename> . O arquivo � uma "
"concatena��o de <filename> boot1 </filename> e <filename> boot2 </filename> ."
" <filename> boot2 </filename> , por sua vez, cont�m o servidor <acronym>BTX</"
"acronym> eo <filename> boot2 </filename> cliente. Finalmente, um salto � "
"feito para abordar <literal> 0x9010 </literal> , o ponto de entrada do "
"servidor <acronym>BTX</acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:1377
#, fuzzy
msgid ""
"Before studying the <acronym>BTX</acronym> Server in detail, let us further "
"review how the single, all-in-one <filename>boot</filename> file is created. "
"The way <filename>boot</filename> is built is defined in its "
"<filename>Makefile</filename> (<filename>/usr/src/sys/boot/i386/boot2/"
"Makefile</filename>). Let us look at the rule that creates the "
"<filename>boot</filename> file:"
msgstr ""
"Antes de estudar o <acronym>BTX</acronym> Server detalhadamente, vamos "
"revisar ainda mais como o single, all-in-one <filename> bota </filename> "
"arquivo � criado. O caminho <filename> bota </filename> � constru�do � "
"definido em sua <filename> Makefile </filename> ( <filename> / usr / src / "
"sys / boot / i386 / boot2 / Makefile </filename> ). Vamos olhar para a regra "
"que cria o <filename> bota </filename> Arquivo:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1389
#, no-wrap
msgid "      boot: boot1 boot2\n"
"\tcat boot1 boot2 &gt; boot"
msgstr "      boot: boot1 boot2\n"
"\tcat boot1 boot2 &gt; boot"

#. (itstool) path: sect1/para
#: book.translate.xml:1393
#, fuzzy
msgid ""
"This tells us that <filename>boot1</filename> and <filename>boot2</filename> "
"are needed, and the rule simply concatenates them to produce a single file "
"called <filename>boot</filename>. The rules for creating <filename>boot1</"
"filename> are also quite simple:"
msgstr ""
"Isso nos diz que <filename> boot1 </filename> e <filename> boot2 </filename> "
"s�o necess�rios, e a regra simplesmente concatena-os para produzir um �nico "
"arquivo chamado <filename> bota </filename> . As regras para criar "
"<filename> boot1 </filename> tamb�m s�o bastante simples: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1402
#, no-wrap
msgid ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
"\n"
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o"
msgstr ""
"      boot1: boot1.out\n"
"\tobjcopy -S -O binary boot1.out boot1\n"
"\n"
"      boot1.out: boot1.o\n"
"\tld -e start -Ttext 0x7c00 -o boot1.out boot1.o"

#. (itstool) path: sect1/para
#: book.translate.xml:1409
#, fuzzy
msgid ""
"To apply the rule for creating <filename>boot1</filename>, <filename>boot1."
"out</filename> must be resolved. This, in turn, depends on the existence of "
"<filename>boot1.o</filename>. This last file is simply the result of "
"assembling our familiar <filename>boot1.S</filename>, without linking. Now, "
"the rule for creating <filename>boot1.out</filename> is applied. This tells "
"us that <filename>boot1.o</filename> should be linked with <literal>start</"
"literal> as its entry point, and starting at address <literal>0x7c00</"
"literal>. Finally, <filename>boot1</filename> is created from "
"<filename>boot1.out</filename> applying the appropriate rule. This rule is "
"the <filename>objcopy</filename> command applied to <filename>boot1.out</"
"filename>. Note the flags passed to <filename>objcopy</filename>: <literal>-"
"S</literal> tells it to strip all relocation and symbolic information; "
"<literal>-O binary</literal> indicates the output format, that is, a simple, "
"unformatted binary file."
msgstr ""
"Para aplicar a regra para criar <filename> boot1 </filename> , <filename> "
"boot1.out </filename> deve ser resolvido. Isso, por sua vez, depende da "
"exist�ncia de <filename> boot1.o </filename> . Este �ltimo arquivo � "
"simplesmente o resultado da montagem de nosso familiar <filename> boot1.S </"
"filename> , sem vincular. Agora, a regra para criar <filename> boot1.out </"
"filename> � aplicado. Isso nos diz que <filename> boot1.o </filename> deve "
"estar ligado a <literal> come�ar </literal> como seu ponto de entrada, e "
"come�ando no endere�o <literal> 0x7c00 </literal> . Finalmente, <filename> "
"boot1 </filename> � criado a partir de <filename> boot1.out </filename> "
"aplicar a regra apropriada. Esta regra � a <filename> objcopy </filename> "
"comando aplicado a <filename> boot1.out </filename> . Observe as bandeiras "
"passadas para <filename> objcopy </filename> : <literal> -S </literal> diz "
"para remover toda a reloca��o e informa��es simb�licas; <literal> Bin�rio -O "
"</literal> indica o formato de sa�da, isto �, um arquivo bin�rio simples e "
"n�o formatado. "

#. (itstool) path: sect1/para
#: book.translate.xml:1428
#, fuzzy
msgid ""
"Having <filename>boot1</filename>, let us take a look at how "
"<filename>boot2</filename> is constructed:"
msgstr ""
"Tendo <filename> boot1 </filename> , vamos dar uma olhada em como <filename> "
"boot2 </filename> � constru�do:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1434
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
"\n"
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
"\n"
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
"\n"
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
"\n"
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
"\n"
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
"\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp &gt; boot2.s\n"
"\trm -f boot2.s.tmp\n"
"\n"
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` &gt; ${.TARGET}"
msgstr ""
"      boot2: boot2.ld\n"
"\t@set -- `ls -l boot2.ld`; x=$$((7680-$$5)); \\\n"
"\t    echo \"$$x bytes available\"; test $$x -ge 0\n"
"\tdd if=boot2.ld of=boot2 obs=7680 conv=osync\n"
"\n"
"      boot2.ld: boot2.ldr boot2.bin ../btx/btx/btx\n"
"\tbtxld -v -E 0x2000 -f bin -b ../btx/btx/btx -l boot2.ldr \\\n"
"\t    -o boot2.ld -P 1 boot2.bin\n"
"\n"
"      boot2.ldr:\n"
"\tdd if=/dev/zero of=boot2.ldr bs=512 count=1\n"
"\n"
"      boot2.bin: boot2.out\n"
"\tobjcopy -S -O binary boot2.out boot2.bin\n"
"\n"
"      boot2.out: ../btx/lib/crt0.o boot2.o sio.o\n"
"\tld -Ttext 0x2000 -o boot2.out\n"
"\n"
"      boot2.o: boot2.s\n"
"\t${CC} ${ACFLAGS} -c boot2.s\n"
"\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"\t${CC} ${CFLAGS} -S -o boot2.s.tmp ${.CURDIR}/boot2.c\n"
"\tsed -e '/align/d' -e '/nop/d' \"MISSING\" boot2.s.tmp &gt; boot2.s\n"
"\trm -f boot2.s.tmp\n"
"\n"
"      boot2.h: boot1.out\n"
"\t${NM} -t d ${.ALLSRC} | awk '/([0-9])+ T xread/ \\\n"
"\t    { x = $$1 - ORG1; \\\n"
"\t    printf(\"#define XREADORG %#x\\n\", REL1 + x) }' \\\n"
"\t    ORG1=`printf \"%d\" ${ORG1}` \\\n"
"\t    REL1=`printf \"%d\" ${REL1}` &gt; ${.TARGET}"

#. (itstool) path: sect1/para
#: book.translate.xml:1468
#, fuzzy
msgid ""
"The mechanism for building <filename>boot2</filename> is far more elaborate. "
"Let us point out the most relevant facts. The dependency list is as follows:"
msgstr ""
"O mecanismo de constru��o <filename> boot2 </filename> � muito mais "
"elaborado. Vamos mostrar os fatos mais relevantes. A lista de depend�ncias � "
"a seguinte: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1475
#, no-wrap
msgid ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out"
msgstr ""
"      boot2: boot2.ld\n"
"      boot2.ld: boot2.ldr boot2.bin ${BTXDIR}/btx/btx\n"
"      boot2.bin: boot2.out\n"
"      boot2.out: ${BTXDIR}/lib/crt0.o boot2.o sio.o\n"
"      boot2.o: boot2.s\n"
"      boot2.s: boot2.c boot2.h ${.CURDIR}/../../common/ufsread.c\n"
"      boot2.h: boot1.out"

#. (itstool) path: sect1/para
#: book.translate.xml:1484
#, fuzzy
msgid ""
"Note that initially there is no header file <filename>boot2.h</filename>, "
"but its creation depends on <filename>boot1.out</filename>, which we already "
"have. The rule for its creation is a bit terse, but the important thing is "
"that the output, <filename>boot2.h</filename>, is something like this:"
msgstr ""
"Note que inicialmente n�o h� arquivo de cabe�alho <filename> boot2.h </"
"filename> , mas a sua cria��o depende <filename> boot1.out </filename> que "
"j� temos. A regra para sua cria��o � um pouco concisa, mas o importante � "
"que a sa�da, <filename> boot2.h </filename> � algo assim: "

#. (itstool) path: figure/title
#: book.translate.xml:1492
#, fuzzy
msgid "<filename>sys/boot/i386/boot2/boot2.h</filename>"
msgstr " <filename> sys / boot / i386 / boot2 / boot2.h </filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1494
#, no-wrap
msgid "\n"
"      #define XREADORG 0x725"
msgstr "\n"
"      #define XREADORG 0x725"

#. (itstool) path: sect1/para
#: book.translate.xml:1498
#, fuzzy
msgid ""
"Recall that <filename>boot1</filename> was relocated (i.e., copied from "
"<literal>0x7c00</literal> to <literal>0x700</literal>). This relocation will "
"now make sense, because as we will see, the <acronym>BTX</acronym> server "
"reclaims some memory, including the space where <filename>boot1</filename> "
"was originally loaded. However, the <acronym>BTX</acronym> server needs "
"access to <filename>boot1</filename>'s <literal>xread</literal> function; "
"this function, according to the output of <filename>boot2.h</filename>, is "
"at location <literal>0x725</literal>. Indeed, the <acronym>BTX</acronym> "
"server uses the <literal>xread</literal> function from <filename>boot1</"
"filename>'s relocated code. This function is now accessible from within the "
"<filename>boot2</filename> client."
msgstr ""
"Lembre-se que <filename> boot1 </filename> foi realocado (ou seja, copiado "
"de <literal> 0x7c00 </literal> para <literal> 0x700 </literal> ). Essa "
"realoca��o far� agora sentido, porque, como veremos, o servidor "
"<acronym>BTX</acronym> recupera alguma mem�ria, incluindo o espa�o onde "
"<filename> boot1 </filename> foi originalmente carregado. No entanto, o "
"servidor <acronym>BTX</acronym> precisa de acesso a <filename> boot1 </"
"filename> ';s <literal> xread </literal> fun��o; esta fun��o, de acordo com "
"a sa�da de <filename> boot2.h </filename> est� no local <literal> 0x725 </"
"literal> . De fato, o servidor <acronym>BTX</acronym> usa o <literal> xread "
"</literal> fun��o de <filename> boot1 </filename> c�digo realocado. Esta "
"fun��o est� agora acess�vel a partir do <filename> boot2 </filename> cliente."
""

#. (itstool) path: sect1/para
#: book.translate.xml:1515
#, fuzzy
msgid ""
"We next build <filename>boot2.s</filename> from files <filename>boot2.h</"
"filename>, <filename>boot2.c</filename> and <filename>/usr/src/sys/boot/"
"common/ufsread.c</filename>. The rule for this is to compile the code in "
"<filename>boot2.c</filename> (which includes <filename>boot2.h</filename> "
"and <filename>ufsread.c</filename>) into assembly code. Having "
"<filename>boot2.s</filename>, the next rule assembles <filename>boot2.s</"
"filename>, creating the object file <filename>boot2.o</filename>. The next "
"rule directs the linker to link various files (<filename>crt0.o</filename>, "
"<filename>boot2.o</filename> and <filename>sio.o</filename>). Note that the "
"output file, <filename>boot2.out</filename>, is linked to execute at address "
"<literal>0x2000</literal>. Recall that <filename>boot2</filename> will be "
"executed in user mode, within a special user segment set up by the "
"<acronym>BTX</acronym> server. This segment starts at <literal>0xa000</"
"literal>. Also, remember that the <filename>boot2</filename> portion of "
"<filename>boot</filename> was copied to address <literal>0xc000</literal>, "
"that is, offset <literal>0x2000</literal> from the start of the user "
"segment, so <filename>boot2</filename> will work properly when we transfer "
"control to it. Next, <filename>boot2.bin</filename> is created from "
"<filename>boot2.out</filename> by stripping its symbols and format "
"information; boot2.bin is a <emphasis>raw</emphasis> binary. Now, note that "
"a file <filename>boot2.ldr</filename> is created as a 512-byte file full of "
"zeros. This space is reserved for the bsdlabel."
msgstr ""
"Em seguida, constru�mos <filename> boot2.s </filename> de arquivos "
"<filename> boot2.h </filename> , <filename> boot2.c </filename> e <filename> "
"/usr/src/sys/boot/common/ufsread.c </filename> . A regra para isso � "
"compilar o c�digo em <filename> boot2.c </filename> (que inclui <filename> "
"boot2.h </filename> e <filename> ufsread.c </filename> ) no c�digo de "
"montagem. Tendo <filename> boot2.s </filename> , a pr�xima regra � montada "
"<filename> boot2.s </filename> , criando o arquivo objeto <filename> boot2.o "
"</filename> . A pr�xima regra direciona o vinculador para vincular v�rios "
"arquivos ( <filename> crt0.o </filename> , <filename> boot2.o </filename> e "
"<filename> sio.o </filename> ). Note que o arquivo de sa�da, <filename> "
"boot2.out </filename> , est� ligado para executar no endere�o <literal> "
"0x2000 </literal> . Lembre-se de que <filename> boot2 </filename> ser� "
"executado no modo de usu�rio, dentro de um segmento de usu�rio especial "
"configurado pelo servidor <acronym>BTX</acronym> . Este segmento come�a em "
"<literal> 0xa000 </literal> . Al�m disso, lembre-se de que <filename> boot2 "
"</filename> por��o de <filename> bota </filename> foi copiado para endere�ar "
"<literal> 0xc000 </literal> , isto �, offset <literal> 0x2000 </literal> "
"desde o in�cio do segmento de usu�rio, ent�o <filename> boot2 </filename> "
"funcionar� corretamente quando transferirmos o controle para ele. Pr�ximo, "
"<filename> boot2.bin </filename> � criado a partir de <filename> boot2.out </"
"filename> descascando seus s�mbolos e formando informa��es; boot2.bin � um "
"<emphasis> cru </emphasis> bin�rio. Agora, observe que um arquivo <filename> "
"boot2.ldr </filename> � criado como um arquivo de 512 bytes cheio de zeros. "
"Este espa�o � reservado para o bsdlabel. "

#. (itstool) path: sect1/para
#: book.translate.xml:1544
#, fuzzy
msgid ""
"Now that we have files <filename>boot1</filename>, <filename>boot2.bin</"
"filename> and <filename>boot2.ldr</filename>, only the <acronym>BTX</"
"acronym> server is missing before creating the all-in-one <filename>boot</"
"filename> file. The <acronym>BTX</acronym> server is located in <filename>/"
"usr/src/sys/boot/i386/btx/btx</filename>; it has its own <filename>Makefile</"
"filename> with its own set of rules for building. The important thing to "
"notice is that it is also compiled as a <emphasis>raw</emphasis> binary, and "
"that it is linked to execute at address <literal>0x9000</literal>. The "
"details can be found in <filename>/usr/src/sys/boot/i386/btx/btx/Makefile</"
"filename>."
msgstr ""
"Agora que temos arquivos <filename> boot1 </filename> , <filename> boot2.bin "
"</filename> e <filename> boot2.ldr </filename> , apenas o servidor "
"<acronym>BTX</acronym> est� ausente antes de criar o all-in-one <filename> "
"bota </filename> Arquivo. O servidor <acronym>BTX</acronym> est� localizado "
"em <filename> / usr / src / sys / boot / i386 / btx / btx </filename> ; tem "
"o seu pr�prio <filename> Makefile </filename> com seu pr�prio conjunto de "
"regras para a constru��o. O importante � notar que tamb�m � compilado como "
"um <emphasis> cru </emphasis> bin�rio, e que est� ligado para executar no "
"endere�o <literal> 0x9000 </literal> . Os detalhes podem ser encontrados em "
"<filename> / usr / src / sys / boot / i386 / btx / btx / Makefile </"
"filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:1558
#, fuzzy
msgid ""
"Having the files that comprise the <filename>boot</filename> program, the "
"final step is to <emphasis>merge</emphasis> them. This is done by a special "
"program called <filename>btxld</filename> (source located in <filename>/usr/"
"src/usr.sbin/btxld</filename>). Some arguments to this program include the "
"name of the output file (<filename>boot</filename>), its entry point "
"(<literal>0x2000</literal>) and its file format (raw binary). The various "
"files are finally merged by this utility into the file <filename>boot</"
"filename>, which consists of <filename>boot1</filename>, <filename>boot2</"
"filename>, the <literal>bsdlabel</literal> and the <acronym>BTX</acronym> "
"server. This file, which takes exactly 16 sectors, or 8192 bytes, is what is "
"actually written to the beginning of the FreeBSD slice during instalation. "
"Let us now proceed to study the <acronym>BTX</acronym> server program."
msgstr ""
"Tendo os arquivos que comp�em o <filename> bota </filename> programa, o "
"passo final � <emphasis> fundir </emphasis> eles. Isso � feito por um "
"programa especial chamado <filename> btxld </filename> (fonte localizada em "
"<filename> /usr/src/usr.sbin/btxld </filename> ). Alguns argumentos para "
"este programa incluem o nome do arquivo de sa�da ( <filename> bota </"
"filename> ), o seu ponto de entrada ( <literal> 0x2000 </literal> ) e seu "
"formato de arquivo (bin�rio bruto). Os v�rios arquivos s�o finalmente "
"mesclados por esse utilit�rio no arquivo <filename> bota </filename> , que "
"consiste em <filename> boot1 </filename> , <filename> boot2 </filename> , a "
"<literal> bsdlabel </literal> e o servidor <acronym>BTX</acronym> . Este "
"arquivo, que leva exatamente 16 setores, ou 8192 bytes, � o que realmente � "
"gravado no in�cio da fatia do FreeBSD durante a instala��o. Vamos agora "
"continuar a estudar o programa do servidor <acronym>BTX</acronym> . "

#. (itstool) path: sect1/para
#: book.translate.xml:1577
#, fuzzy
msgid ""
"The <acronym>BTX</acronym> server prepares a simple environment and switches "
"from 16-bit real mode to 32-bit protected mode, right before passing control "
"to the client. This includes initializing and updating the following data "
"structures:"
msgstr ""
"O servidor <acronym>BTX</acronym> prepara um ambiente simples e alterna do "
"modo real de 16 bits para o modo protegido de 32 bits, antes de passar o "
"controle para o cliente. Isso inclui inicializar e atualizar as seguintes "
"estruturas de dados:"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:1583
#, fuzzy
msgid "<primary>virtual v86 mode</primary>"
msgstr " <primary> modo virtual v86 </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:1586
#, fuzzy
msgid ""
"Modifies the <literal>Interrupt Vector Table (IVT)</literal>. The "
"<acronym>IVT</acronym> provides exception and interrupt handlers for Real-"
"Mode code."
msgstr ""
"Modifica o <literal> Tabela de vetores de interrup��o (IVT) </literal> . O "
"<acronym>IVT</acronym> fornece manipuladores de exce��o e interrup��o para o "
"c�digo de modo real. "

#. (itstool) path: listitem/para
#: book.translate.xml:1593
#, fuzzy
msgid ""
"The <literal>Interrupt Descriptor Table (IDT)</literal> is created. Entries "
"are provided for processor exceptions, hardware interrupts, two system calls "
"and V86 interface. The IDT provides exception and interrupt handlers for "
"Protected-Mode code."
msgstr ""
"O <literal> Tabela de descritores de interrup��o (IDT) </literal> � criado. "
"Entradas s�o fornecidas para exce��es de processador, interrup��es de "
"hardware, duas chamadas de sistema e interface V86. O IDT fornece "
"manipuladores de exce��o e interrup��o para o c�digo de modo protegido. "

#. (itstool) path: listitem/para
#: book.translate.xml:1601
#, fuzzy
msgid ""
"A <literal>Task-State Segment (TSS)</literal> is created. This is necessary "
"because the processor works in the <emphasis>least</emphasis> privileged "
"level when executing the client (<filename>boot2</filename>), but in the "
"<emphasis>most</emphasis> privileged level when executing the <acronym>BTX</"
"acronym> server."
msgstr ""
"UMA <literal> Segmento Estado-tarefa (TSS) </literal> � criado. Isso � "
"necess�rio porque o processador funciona no <emphasis> menos </emphasis> "
"n�vel privilegiado ao executar o cliente ( <filename> boot2 </filename> ), "
"mas no <emphasis> a maioria </emphasis> n�vel privilegiado ao executar o "
"servidor <acronym>BTX</acronym> . "

#. (itstool) path: footnote/para
#: book.translate.xml:1615
#, fuzzy
msgid ""
"Real-mode code and data are necessary when switching back to real mode from "
"protected mode, as suggested by the Intel manuals."
msgstr ""
"C�digo e dados de modo real s�o necess�rios ao retornar ao modo real a "
"partir do modo protegido, conforme sugerido pelos manuais da Intel."

#. (itstool) path: listitem/para
#: book.translate.xml:1610
#, fuzzy
msgid ""
"The <acronym>GDT</acronym> (Global Descriptor Table) is set up. Entries "
"(descriptors) are provided for supervisor code and data, user code and data, "
"and real-mode code and data. <_:footnote-1/>"
msgstr ""
"A <acronym>GDT</acronym> (Global Descriptor Table) est� configurada. "
"Entradas (descritores) s�o fornecidas para c�digo de supervisor e dados, "
"c�digo de usu�rio e dados, e c�digo e dados em modo real. <_: Footnote-1 />"

#. (itstool) path: sect1/para
#: book.translate.xml:1621
#, fuzzy
msgid ""
"Let us now start studying the actual implementation. Recall that "
"<filename>boot1</filename> made a jump to address <literal>0x9010</literal>, "
"the <acronym>BTX</acronym> server's entry point. Before studying program "
"execution there, note that the <acronym>BTX</acronym> server has a special "
"header at address range <literal>0x9000-0x900f</literal>, right before its "
"entry point. This header is defined as follows:"
msgstr ""
"Vamos agora come�ar a estudar a implementa��o real. Lembre-se que <filename> "
"boot1 </filename> fez um salto para abordar <literal> 0x9010 </literal> , o "
"ponto de entrada do servidor <acronym>BTX</acronym> . Antes de estudar a "
"execu��o do programa, observe que o servidor <acronym>BTX</acronym> possui "
"um cabe�alho especial na faixa de endere�os <literal> 0x9000-0x900f </"
"literal> , antes do seu ponto de entrada. Esse cabe�alho � definido da "
"seguinte maneira: "

#. (itstool) path: figure/title
#: book.translate.xml:1630 book.translate.xml:1661 book.translate.xml:1690
#: book.translate.xml:1731 book.translate.xml:1759 book.translate.xml:1830
#: book.translate.xml:1855 book.translate.xml:1904
#, fuzzy
msgid "<filename>sys/boot/i386/btx/btx/btx.S</filename>"
msgstr " <filename> sys / boot / i386 / btx / btx / btx.S </filename> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1632
#, no-wrap
msgid ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG&gt;&gt;0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address"
msgstr ""
"start:\t\t\t\t\t\t# Start of code\n"
"/*\n"
" * BTX header.\n"
" */\n"
"btx_hdr:\t.byte 0xeb\t\t\t# Machine ID\n"
"\t\t.byte 0xe\t\t\t# Header size\n"
"\t\t.ascii \"BTX\"\t\t\t# Magic\n"
"\t\t.byte 0x1\t\t\t# Major version\n"
"\t\t.byte 0x2\t\t\t# Minor version\n"
"\t\t.byte BTX_FLAGS\t\t\t# Flags\n"
"\t\t.word PAG_CNT-MEM_ORG&gt;&gt;0xc\t# Paging control\n"
"\t\t.word break-start\t\t# Text size\n"
"\t\t.long 0x0\t\t\t# Entry address"

#. (itstool) path: sect1/para
#: book.translate.xml:1647
#, fuzzy
msgid ""
"Note the first two bytes are <literal>0xeb</literal> and <literal>0xe</"
"literal>. In the IA-32 architecture, these two bytes are interpreted as a "
"relative jump past the header into the entry point, so in theory, "
"<filename>boot1</filename> could jump here (address <literal>0x9000</"
"literal>) instead of address <literal>0x9010</literal>. Note that the last "
"field in the <acronym>BTX</acronym> header is a pointer to the client's "
"(<filename>boot2</filename>) entry point. This field is patched at link time."
""
msgstr ""
"Note que os dois primeiros bytes s�o <literal> 0xeb </literal> e <literal> "
"0xe </literal> . Na arquitetura IA-32, esses dois bytes s�o interpretados "
"como um salto relativo ap�s o cabe�alho para o ponto de entrada, ent�o, em "
"teoria, <filename> boot1 </filename> poderia pular aqui (endere�o <literal> "
"0x9000 </literal> ) em vez de endere�o <literal> 0x9010 </literal> . Observe "
"que o �ltimo campo no cabe�alho <acronym>BTX</acronym> � um ponteiro para o "
"cliente ( <filename> boot2 </filename> ) ponto de entrada. Este campo � "
"corrigido no momento do link. "

#. (itstool) path: sect1/para
#: book.translate.xml:1657
#, fuzzy
msgid ""
"Immediately following the header is the <acronym>BTX</acronym> server's "
"entry point:"
msgstr ""
"Imediatamente ap�s o cabe�alho � o ponto de entrada do servidor "
"<acronym>BTX</acronym> :"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1663
#, no-wrap
msgid ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags"
msgstr ""
"/*\n"
" * Initialization routine.\n"
" */\n"
"init:\t\tcli\t\t\t\t# Disable interrupts\n"
"\t\txor %ax,%ax\t\t\t# Zero/segment\n"
"\t\tmov %ax,%ss\t\t\t# Set up\n"
"\t\tmov $0x1800,%sp\t\t#  stack\n"
"\t\tmov %ax,%es\t\t\t# Address\n"
"\t\tmov %ax,%ds\t\t\t#  data\n"
"\t\tpushl $0x2\t\t\t# Clear\n"
"\t\tpopfl\t\t\t\t#  flags"

#. (itstool) path: sect1/para
#: book.translate.xml:1676
#, fuzzy
msgid ""
"This code disables interrupts, sets up a working stack (starting at address "
"<literal>0x1800</literal>) and clears the flags in the EFLAGS register. Note "
"that the <literal>popfl</literal> instruction pops out a doubleword (4 "
"bytes) from the stack and places it in the EFLAGS register. Because the "
"value actually popped is <literal>2</literal>, the EFLAGS register is "
"effectively cleared (IA-32 requires that bit 2 of the EFLAGS register always "
"be 1)."
msgstr ""
"Esse c�digo desabilita as interrup��es, configura uma pilha de trabalho "
"(iniciando no endere�o <literal> 0x1800 </literal> ) e apaga as bandeiras no "
"registro EFLAGS. Note que o <literal> popfl </literal> A instru��o extrai "
"uma palavra dupla (4 bytes) da pilha e a coloca no registro EFLAGS. Porque o "
"valor realmente estourou � <literal> 2 </literal> , o registro EFLAGS � "
"efetivamente limpo (o IA-32 requer que o bit 2 do registro EFLAGS seja "
"sempre 1). "

#. (itstool) path: sect1/para
#: book.translate.xml:1685
#, fuzzy
msgid ""
"Our next code block clears (sets to <literal>0</literal>) the memory range "
"<literal>0x5e00-0x8fff</literal>. This range is where the various data "
"structures will be created:"
msgstr ""
"Nosso pr�ximo bloco de c�digo � apagado <literal> 0 </literal> ) o intervalo "
"de mem�ria <literal> 0x5e00-0x8fff </literal> . Este intervalo � onde as "
"v�rias estruturas de dados ser�o criadas: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1692
#, no-wrap
msgid ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory"
msgstr ""
"/*\n"
" * Initialize memory.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t# Memory to initialize\n"
"\t\tmov $(0x9000-0x5e00)/2,%cx\t# Words to zero\n"
"\t\trep\t\t\t\t# Zero-fill\n"
"\t\tstosw\t\t\t\t#  memory"

#. (itstool) path: sect1/para
#: book.translate.xml:1701
#, fuzzy
msgid ""
"Recall that <filename>boot1</filename> was originally loaded to address "
"<literal>0x7c00</literal>, so, with this memory initialization, that copy "
"effectively dissapeared. However, also recall that <filename>boot1</"
"filename> was relocated to <literal>0x700</literal>, so <emphasis>that</"
"emphasis> copy is still in memory, and the <acronym>BTX</acronym> server "
"will make use of it."
msgstr ""
"Lembre-se que <filename> boot1 </filename> foi originalmente carregado para "
"resolver <literal> 0x7c00 </literal> Assim, com esta inicializa��o de "
"mem�ria, essa c�pia efetivamente desapareceu. No entanto, lembre-se tamb�m "
"que <filename> boot1 </filename> foi transferido para <literal> 0x700 </"
"literal> , assim <emphasis> aquele </emphasis> a c�pia ainda est� na "
"mem�ria, e o servidor <acronym>BTX</acronym> far� uso dela. "

#. (itstool) path: sect1/para
#: book.translate.xml:1709
msgid ""
"Next, the real-mode <acronym>IVT</acronym> (Interrupt Vector Table is "
"updated. The <acronym>IVT</acronym> is an array of segment/offset pairs for "
"exception and interrupt handlers. The <acronym>BIOS</acronym> normally maps "
"hardware interrupts to interrupt vectors <literal>0x8</literal> to "
"<literal>0xf</literal> and <literal>0x70</literal> to <literal>0x77</"
"literal> but, as will be seen, the 8259A Programmable Interrupt Controller, "
"the chip controlling the actual mapping of hardware interrupts to interrupt "
"vectors, is programmed to remap these interrupt vectors from <literal>0x8-"
"0xf</literal> to <literal>0x20-0x27</literal> and from <literal>0x70-0x77</"
"literal> to <literal>0x28-0x2f</literal>. Thus, interrupt handlers are "
"provided for interrupt vectors <literal>0x20-0x2f</literal>. The reason the "
"<acronym>BIOS</acronym>-provided handlers are not used directly is because "
"they work in 16-bit real mode, but not 32-bit protected mode. Processor mode "
"will be switched to 32-bit protected mode shortly. However, the "
"<acronym>BTX</acronym> server sets up a mechanism to effectively use the "
"handlers provided by the <acronym>BIOS</acronym>:"
msgstr ""
"Em seguida, a <acronym>IVT</acronym> em modo real (Tabela de Vetores de "
"Interrupções) é atualizado. O <acronym>IVT</acronym> é uma matriz de pares "
"de segmento/deslocamento para manipuladores de exceção e interrupções. A "
"<acronym>BIOS</acronym> normalmente mapeia interrupções de hardware para "
"vetores de interrupção <literal>0x8</literal> para <literal>0xf</literal> e "
"<literal>0x70</literal> para <literal>0x77</literal> mas, como será visto, o "
"Controlador de Interrupção Programável 8259A, o chip que controla o "
"mapeamento real de interrupções de hardware para vetores de interrupção, é "
"programado para remapear esses vetores de interrupção de <literal>0x8-0xf</"
"literal> para <literal>0x20-0x27</literal> e de <literal>0x70-0x77</literal> "
"para <literal>0x28-0x2f</literal> . Assim, manipuladores de interrupção são "
"fornecidos para vetores de interrupção <literal>0x20-0x2f</literal>. A razão "
"pela qual os manipuladores fornecidos pela <acronym>BIOS</acronym> não são "
"usados ​​diretamente é porque eles funcionam no modo real de 16 bits, mas "
"não no modo protegido de 32 bits. O modo do processador será alternado para "
"o modo protegido de 32 bits em breve. No entanto, o servidor <acronym>BTX</"
"acronym> define um mecanismo para usar efetivamente os manipuladores "
"fornecidos pela <acronym>BIOS</acronym>:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1733
#, no-wrap
msgid ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ"
msgstr ""
"/*\n"
" * Update real mode IDT for reflecting hardware interrupts.\n"
" */\n"
"\t\tmov $intr20,%bx\t\t\t# Address first handler\n"
"\t\tmov $0x10,%cx\t\t\t# Number of handlers\n"
"\t\tmov $0x20*4,%di\t\t\t# First real mode IDT entry\n"
"init.0:\t\tmov %bx,(%di)\t\t\t# Store IP\n"
"\t\tinc %di\t\t\t\t# Address next\n"
"\t\tinc %di\t\t\t\t#  entry\n"
"\t\tstosw\t\t\t\t# Store CS\n"
"\t\tadd $4,%bx\t\t\t# Next handler\n"
"\t\tloop init.0\t\t\t# Next IRQ"

#. (itstool) path: sect1/para
#: book.translate.xml:1747
msgid ""
"The next block creates the <acronym>IDT</acronym> (Interrupt Descriptor "
"Table). The <acronym>IDT</acronym> is analogous, in protected mode, to the "
"<acronym>IVT</acronym> in real mode. That is, the <acronym>IDT</acronym> "
"describes the various exception and interrupt handlers used when the "
"processor is executing in protected mode. In essence, it also consists of an "
"array of segment/offset pairs, although the structure is somewhat more "
"complex, because segments in protected mode are different than in real mode, "
"and various protection mechanisms apply:"
msgstr ""
"O próximo bloco cria o <acronym>IDT</acronym> (Interrupt Descriptor Table). "
"O <acronym>IDT</acronym> é análogo, no modo protegido, ao <acronym>IVT</"
"acronym> em modo real. Ou seja, o <acronym>IDT</acronym> descreve os vários "
"manipuladores de exceção e interrupções usados ​​quando o processador está "
"executando em modo protegido. Em essência, ele também consiste em uma matriz "
"de pares segmento/deslocadores, embora a estrutura seja um pouco mais "
"complexa, porque os segmentos no modo protegido são diferentes do modo real, "
"e vários mecanismos de proteção se aplicam: "

#. (itstool) path: figure/programlisting
#: book.translate.xml:1761
#, no-wrap
msgid ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue"
msgstr ""
"/*\n"
" * Create IDT.\n"
" */\n"
"\t\tmov $0x5e00,%di\t\t\t# IDT's address\n"
"\t\tmov $idtctl,%si\t\t\t# Control string\n"
"init.1:\t\tlodsb\t\t\t\t# Get entry\n"
"\t\tcbw\t\t\t\t#  count\n"
"\t\txchg %ax,%cx\t\t\t#  as word\n"
"\t\tjcxz init.4\t\t\t# If done\n"
"\t\tlodsb\t\t\t\t# Get segment\n"
"\t\txchg %ax,%dx\t\t\t#  P:DPL:type\n"
"\t\tlodsw\t\t\t\t# Get control\n"
"\t\txchg %ax,%bx\t\t\t#  set\n"
"\t\tlodsw\t\t\t\t# Get handler offset\n"
"\t\tmov $SEL_SCODE,%dh\t\t# Segment selector\n"
"init.2:\t\tshr %bx\t\t\t\t# Handle this int?\n"
"\t\tjnc init.3\t\t\t# No\n"
"\t\tmov %ax,(%di)\t\t\t# Set handler offset\n"
"\t\tmov %dh,0x2(%di)\t\t#  and selector\n"
"\t\tmov %dl,0x5(%di)\t\t# Set P:DPL:type\n"
"\t\tadd $0x4,%ax\t\t\t# Next handler\n"
"init.3:\t\tlea 0x8(%di),%di\t\t# Next entry\n"
"\t\tloop init.2\t\t\t# Till set done\n"
"\t\tjmp init.1\t\t\t# Continue"

#. (itstool) path: sect1/para
#: book.translate.xml:1787
msgid ""
"Each entry in the <literal>IDT</literal> is 8 bytes long. Besides the "
"segment/offset information, they also describe the segment type, privilege "
"level, and whether the segment is present in memory or not. The construction "
"is such that interrupt vectors from <literal>0</literal> to <literal>0xf</"
"literal> (exceptions) are handled by function <literal>intx00</literal>; "
"vector <literal>0x10</literal> (also an exception) is handled by "
"<literal>intx10</literal>; hardware interrupts, which are later configured "
"to start at interrupt vector <literal>0x20</literal> all the way to "
"interrupt vector <literal>0x2f</literal>, are handled by function "
"<literal>intx20</literal>. Lastly, interrupt vector <literal>0x30</literal>, "
"which is used for system calls, is handled by <literal>intx30</literal>, and "
"vectors <literal>0x31</literal> and <literal>0x32</literal> are handled by "
"<literal>intx31</literal>. It must be noted that only descriptors for "
"interrupt vectors <literal>0x30</literal>, <literal>0x31</literal> and "
"<literal>0x32</literal> are given privilege level 3, the same privilege "
"level as the <filename>boot2</filename> client, which means the client can "
"execute a software-generated interrupt to this vectors through the "
"<literal>int</literal> instruction without failing (this is the way "
"<filename>boot2</filename> use the services provided by the <acronym>BTX</"
"acronym> server). Also, note that <emphasis>only</emphasis> software-"
"generated interrupts are protected from code executing in lesser privilege "
"levels. Hardware-generated interrupts and processor-generated exceptions are "
"<emphasis>always</emphasis> handled adequately, regardless of the actual "
"privileges involved."
msgstr ""
"Cada entrada no <literal>IDT</literal> tem 8 bytes de comprimento. Além das "
"informações de segmento/deslocamento, elas também descrevem o tipo de "
"segmento, nível de privilégio e se o segmento está presente na memória ou "
"não. A construção é tal que vetores de interrupção de <literal>0</literal> "
"para <literal>0xf</literal> (exceções) são manipulados por função "
"<literal>intx00</literal>; vetor <literal>0x10</literal> (também uma "
"exceção) é manipulado por <literal>intx10</literal>; interrupções de "
"hardware, que são configuradas posteriormente para iniciar no vetor de "
"interrupção <literal>0x20</literal> de toda forma para o vetor interrupção "
"<literal>0x2f</literal> , são manipulados pela função <literal>intx20</"
"literal>. Por fim, vetor de interrupção <literal>0x30</literal>, que é usado "
"para chamadas do sistema, é manipulado por <literal>intx30</literal> e "
"vetores <literal>0x31</literal> e <literal>0x32</literal> são manipulados "
"por <literal>intx31</literal>. Deve-se notar que apenas descritores para "
"vetores de interrupção <literal>0x30</literal> , <literal>0x31</literal> e "
"<literal>0x32</literal> recebem o nível de privilégio 3, o mesmo nível de "
"privilégio que o cliente <filename>boot2</filename>, o que significa que o "
"cliente pode executar uma interrupção gerada por software para esses vetores "
"através da instrução <literal>int</literal> sem falhar (este é o modo como o "
"<filename>boot2</filename> usa os serviços fornecidos pelo servidor "
"<acronym>BTX</acronym>). Além disso, note que <emphasis>apenas</emphasis> "
"interrupções geradas por software são protegidas do código sendo executado "
"em níveis de privilégios menores. Interrupções geradas por hardware e "
"exceções geradas pelo processador <emphasis>sempre</emphasis> são manuseado "
"de forma adequada, independentemente dos privilégios reais envolvidos. "

#. (itstool) path: sect1/para
#: book.translate.xml:1817
msgid ""
"The next step is to initialize the <acronym>TSS</acronym> (Task-State "
"Segment). The <acronym>TSS</acronym> is a hardware feature that helps the "
"operating system or executive software implement multitasking functionality "
"through process abstraction. The IA-32 architecture demands the creation and "
"use of <emphasis>at least</emphasis> one <acronym>TSS</acronym> if "
"multitasking facilities are used or different privilege levels are defined. "
"Because the <filename>boot2</filename> client is executed in privilege level "
"3, but the <acronym>BTX</acronym> server does in privilege level 0, a "
"<acronym>TSS</acronym> must be defined:"
msgstr ""
"O próximo passo é inicializar o <acronym>TSS</acronym> (Task-State Segment). "
"O <acronym>TSS</acronym> é um recurso de hardware que ajuda o sistema "
"operacional ou o software executivo a implementar a funcionalidade "
"multitarefa por meio da abstração do processo. A arquitetura IA-32 exige a "
"criação e o uso de <emphasis>ao menos</emphasis> um <acronym>TSS</acronym> "
"se forem usados ​​recursos multitarefa ou se forem definidos níveis de "
"privilégios diferentes. Porque o  cliente <filename>boot2</filename> é "
"executado no nível de privilégio 3, mas o servidor <acronym>BTX</acronym> "
"executado no nível de privilégio 0, um <acronym>TSS</acronym> deve ser "
"definido:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1832
#, no-wrap
msgid ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base"
msgstr ""
"/*\n"
" * Initialize TSS.\n"
" */\n"
"init.4:\t\tmovb $_ESP0H,TSS_ESP0+1(%di)\t# Set ESP0\n"
"\t\tmovb $SEL_SDATA,TSS_SS0(%di)\t# Set SS0\n"
"\t\tmovb $_TSSIO,TSS_MAP(%di)\t# Set I/O bit map base"

#. (itstool) path: sect1/para
#: book.translate.xml:1840
msgid ""
"Note that a value is given for the Privilege Level 0 stack pointer and stack "
"segment in the <acronym>TSS</acronym>. This is needed because, if an "
"interrupt or exception is received while executing <filename>boot2</"
"filename> in Privilege Level 3, a change to Privilege Level 0 is "
"automatically performed by the processor, so a new working stack is needed. "
"Finally, the I/O Map Base Address field of the <acronym>TSS</acronym> is "
"given a value, which is a 16-bit offset from the beginning of the "
"<acronym>TSS</acronym> to the I/O Permission Bitmap and the Interrupt "
"Redirection Bitmap."
msgstr ""
"Note que um valor é dado para o ponteiro da pilha de Privilégio de Nível 0 e "
"segmento da pilha no <acronym>TSS</acronym> . Isso é necessário porque, se "
"uma interrupção ou exceção for recebida durante o <filename>boot2</filename> "
"estiver executando no Privilege de Nível 3, uma alteração no Privilege de "
"Nível 0 é executada automaticamente pelo processador, portanto, é necessária "
"uma nova pilha de trabalho. Finalmente, o campo Map Base Addess de I/O do "
"<acronym>TSS</acronym> recebe um valor, que é um deslocamento de 16 bits "
"desde o início do <acronym>TSS</acronym> até o Bitmap de Permissão de I/O e "
"o Bitmap de Redirecionamento de Interrupções. "

#. (itstool) path: sect1/para
#: book.translate.xml:1850
msgid ""
"After the <acronym>IDT</acronym> and <acronym>TSS</acronym> are created, the "
"processor is ready to switch to protected mode. This is done in the next "
"block:"
msgstr ""
"Depois que o <acronym>IDT</acronym> e o <acronym>TSS</acronym> são criados, "
"o processador está pronto para mudar para o modo protegido. Isso é feito no "
"próximo bloco:"

#. (itstool) path: figure/programlisting
#: book.translate.xml:1857
#, no-wrap
msgid ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack"
msgstr ""
"/*\n"
" * Bring up the system.\n"
" */\n"
"\t\tmov $0x2820,%bx\t\t\t# Set protected mode\n"
"\t\tcallw setpic\t\t\t#  IRQ offsets\n"
"\t\tlidt idtdesc\t\t\t# Set IDT\n"
"\t\tlgdt gdtdesc\t\t\t# Set GDT\n"
"\t\tmov %cr0,%eax\t\t\t# Switch to protected\n"
"\t\tinc %ax\t\t\t\t#  mode\n"
"\t\tmov %eax,%cr0\t\t\t#\n"
"\t\tljmp $SEL_SCODE,$init.8\t\t# To 32-bit code\n"
"\t\t.code32\n"
"init.8:\t\txorl %ecx,%ecx\t\t\t# Zero\n"
"\t\tmovb $SEL_SDATA,%cl\t\t# To 32-bit\n"
"\t\tmovw %cx,%ss\t\t\t#  stack"

#. (itstool) path: sect1/para
#: book.translate.xml:1874
#, fuzzy
msgid ""
"First, a call is made to <literal>setpic</literal> to program the 8259A "
"<acronym>PIC</acronym> (Programmable Interrupt Controller). This chip is "
"connected to multiple hardware interrupt sources. Upon receiving an "
"interrupt from a device, it signals the processor with the appropriate "
"interrupt vector. This can be customized so that specific interrupts are "
"associated with specific interrupt vectors, as explained before. Next, the "
"<acronym>IDTR</acronym> (Interrupt Descriptor Table Register) and "
"<acronym>GDTR</acronym> (Global Descriptor Table Register) are loaded with "
"the instructions <literal>lidt</literal> and <literal>lgdt</literal>, "
"respectively. These registers are loaded with the base address and limit "
"address for the <acronym>IDT</acronym> and <acronym>GDT</acronym>. The "
"following three instructions set the Protection Enable (PE) bit of the "
"<literal>%cr0</literal> register. This effectively switches the processor to "
"32-bit protected mode. Next, a long jump is made to <literal>init.8</"
"literal> using segment selector SEL_SCODE, which selects the Supervisor Code "
"Segment. The processor is effectively executing in CPL 0, the most "
"privileged level, after this jump. Finally, the Supervisor Data Segment is "
"selected for the stack by assigning the segment selector SEL_SDATA to the "
"<literal>%ss</literal> register. This data segment also has a privilege "
"level of <literal>0</literal>."
msgstr ""
"Primeiro, uma chamada � feita para <literal> setpic </literal> para "
"programar o 8259A <acronym>PIC</acronym> (Programmable Interrupt Controller)."
" Este chip est� conectado a v�rias fontes de interrup��o de hardware. Ao "
"receber uma interrup��o de um dispositivo, ele sinaliza ao processador o "
"vetor de interrup��o apropriado. Isso pode ser personalizado para que "
"interrup��es espec�ficas sejam associadas a vetores de interrup��o "
"espec�ficos, conforme explicado anteriormente. Em seguida, o <acronym>IDTR</"
"acronym> (Registro da Tabela de Descritores de Interrup��es) e o "
"<acronym>GDTR</acronym> (Registro da Tabela de Descritores Globais) s�o "
"carregados com as instru��es <literal> lidt </literal> e <literal> lgdt </"
"literal> , respectivamente. Esses registros s�o carregados com o endere�o "
"base e o endere�o limite para o <acronym>IDT</acronym> e o <acronym>GDT</"
"acronym> . As tr�s instru��es a seguir definem o bit Protection Enable (PE) "
"do <literal> % cr0 </literal> registo. Isso efetivamente alterna o "
"processador para o modo protegido de 32 bits. Em seguida, um longo salto � "
"feito para <literal> init.8 </literal> usando o seletor de segmento "
"SEL_SCODE, que seleciona o segmento de c�digo de supervisor. O processador "
"est� efetivamente executando em CPL 0, o n�vel mais privilegiado, ap�s esse "
"salto. Finalmente, o Segmento de Dados do Supervisor � selecionado para a "
"pilha, atribuindo o seletor de segmento SEL_SDATA <literal> % ss </literal> "
"registo. Esse segmento de dados tamb�m tem um n�vel de privil�gio de "
"<literal> 0 </literal> "

#. (itstool) path: sect1/para
#: book.translate.xml:1897
#, fuzzy
msgid ""
"Our last code block is responsible for loading the <acronym>TR</acronym> "
"(Task Register) with the segment selector for the <acronym>TSS</acronym> we "
"created earlier, and setting the User Mode environment before passing "
"execution control to the <filename>boot2</filename> client."
msgstr ""
"Nosso �ltimo bloco de c�digo � respons�vel por carregar o <acronym>TR</"
"acronym> (Task Register) com o seletor de segmento para o <acronym>TSS</"
"acronym> que criamos anteriormente e configurar o ambiente do Modo de "
"Usu�rio antes de passar o controle de execu��o para o <filename> boot2 </"
"filename> cliente."

#. (itstool) path: figure/programlisting
#: book.translate.xml:1906
#, no-wrap
msgid ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode"
msgstr ""
"/*\n"
" * Launch user task.\n"
" */\n"
"\t\tmovb $SEL_TSS,%cl\t\t# Set task\n"
"\t\tltr %cx\t\t\t\t#  register\n"
"\t\tmovl $0xa000,%edx\t\t# User base address\n"
"\t\tmovzwl %ss:BDA_MEM,%eax\t\t# Get free memory\n"
"\t\tshll $0xa,%eax\t\t\t# To bytes\n"
"\t\tsubl $ARGSPACE,%eax\t\t# Less arg space\n"
"\t\tsubl %edx,%eax\t\t\t# Less base\n"
"\t\tmovb $SEL_UDATA,%cl\t\t# User data selector\n"
"\t\tpushl %ecx\t\t\t# Set SS\n"
"\t\tpushl %eax\t\t\t# Set ESP\n"
"\t\tpush $0x202\t\t\t# Set flags (IF set)\n"
"\t\tpush $SEL_UCODE\t\t\t# Set CS\n"
"\t\tpushl btx_hdr+0xc\t\t# Set EIP\n"
"\t\tpushl %ecx\t\t\t# Set GS\n"
"\t\tpushl %ecx\t\t\t# Set FS\n"
"\t\tpushl %ecx\t\t\t# Set DS\n"
"\t\tpushl %ecx\t\t\t# Set ES\n"
"\t\tpushl %edx\t\t\t# Set EAX\n"
"\t\tmovb $0x7,%cl\t\t\t# Set remaining\n"
"init.9:\t\tpush $0x0\t\t\t#  general\n"
"\t\tloop init.9\t\t\t#  registers\n"
"\t\tpopa\t\t\t\t#  and initialize\n"
"\t\tpopl %es\t\t\t# Initialize\n"
"\t\tpopl %ds\t\t\t#  user\n"
"\t\tpopl %fs\t\t\t#  segment\n"
"\t\tpopl %gs\t\t\t#  registers\n"
"\t\tiret\t\t\t\t# To user mode"

#. (itstool) path: sect1/para
#: book.translate.xml:1938
#, fuzzy
msgid ""
"Note that the client's environment include a stack segment selector and "
"stack pointer (registers <literal>%ss</literal> and <literal>%esp</literal>)."
" Indeed, once the <acronym>TR</acronym> is loaded with the appropriate stack "
"segment selector (instruction <literal>ltr</literal>), the stack pointer is "
"calculated and pushed onto the stack along with the stack's segment selector."
" Next, the value <literal>0x202</literal> is pushed onto the stack; it is "
"the value that the EFLAGS will get when control is passed to the client. "
"Also, the User Mode code segment selector and the client's entry point are "
"pushed. Recall that this entry point is patched in the <acronym>BTX</"
"acronym> header at link time. Finally, segment selectors (stored in register "
"<literal>%ecx</literal>) for the segment registers <literal>%gs, %fs, %ds "
"and %es</literal> are pushed onto the stack, along with the value at "
"<literal>%edx</literal> (<literal>0xa000</literal>). Keep in mind the "
"various values that have been pushed onto the stack (they will be popped out "
"shortly). Next, values for the remaining general purpose registers are also "
"pushed onto the stack (note the <literal>loop</literal> that pushes the "
"value <literal>0</literal> seven times). Now, values will be started to be "
"popped out of the stack. First, the <literal>popa</literal> instruction pops "
"out of the stack the latest seven values pushed. They are stored in the "
"general purpose registers in order <literal>%edi, %esi, %ebp, %ebx, %edx, "
"%ecx, %eax</literal>. Then, the various segment selectors pushed are popped "
"into the various segment registers. Five values still remain on the stack. "
"They are popped when the <literal>iret</literal> instruction is executed. "
"This instruction first pops the value that was pushed from the <acronym>BTX</"
"acronym> header. This value is a pointer to <filename>boot2</filename>'s "
"entry point. It is placed in the register <literal>%eip</literal>, the "
"instruction pointer register. Next, the segment selector for the User Code "
"Segment is popped and copied to register <literal>%cs</literal>. Remember "
"that this segment's privilege level is 3, the least privileged level. This "
"means that we must provide values for the stack of this privilege level. "
"This is why the processor, besides further popping the value for the EFLAGS "
"register, does two more pops out of the stack. These values go to the stack "
"pointer (<literal>%esp</literal>) and the stack segment (<literal>%ss</"
"literal>). Now, execution continues at <literal>boot0</literal>'s entry "
"point."
msgstr ""
"Note que o ambiente do cliente inclui um seletor de segmento de pilha e "
"ponteiro de pilha (registros <literal> % ss </literal> e <literal> % esp </"
"literal> ). Na verdade, uma vez que o <acronym>TR</acronym> � carregado com "
"o seletor de segmento de pilha apropriado (instru��o <literal> ltr </"
"literal> ), o ponteiro da pilha � calculado e colocado na pilha junto com o "
"seletor de segmento da pilha. Em seguida, o valor <literal> 0x202 </literal> "
"� empurrado para a pilha; � o valor que o EFLAGS obter� quando o controle "
"for passado para o cliente. Al�m disso, o seletor de segmento de c�digo do "
"modo de usu�rio e o ponto de entrada do cliente s�o pressionados. Lembre-se "
"de que esse ponto de entrada � corrigido no cabe�alho <acronym>BTX</acronym> "
"no momento do link. Finalmente, os seletores de segmento (armazenados no "
"registrador <literal> % ecx </literal> ) para os registros de segmento "
"<literal> % gs,% fs,% ds e% es </literal> s�o empurrados para a pilha, "
"juntamente com o valor em <literal> % edx </literal> ( <literal> 0xa000 </"
"literal> ). Tenha em mente os v�rios valores que foram colocados na pilha "
"(eles ser�o exibidos em breve). Em seguida, os valores dos demais "
"registradores de prop�sito geral tamb�m s�o colocados na pilha (observe "
"<literal> la�o </literal> que empurra o valor <literal> 0 </literal> sete "
"vezes). Agora, os valores ser�o iniciados para serem removidos da pilha. "
"Primeiro, o <literal> popa </literal> instru��o sai da pilha os �ltimos sete "
"valores empurrados. Eles s�o armazenados nos registros de prop�sito geral "
"para <literal> % edi,% esi,% ebp,% ebx,% edx,% ecx,% eax </literal> . Em "
"seguida, os v�rios seletores de segmento pressionados s�o exibidos nos "
"v�rios registros de segmento. Cinco valores ainda permanecem na pilha. Eles "
"s�o popped quando o <literal> iret </literal> instru��o � executada. Esta "
"instru��o primeiro mostra o valor que foi empurrado do cabe�alho "
"<acronym>BTX</acronym> . Este valor � um ponteiro para <filename> boot2 </"
"filename> ponto de entrada. Ele � colocado no registro <literal> % eip </"
"literal> , o registrador de ponteiros de instru��o. Em seguida, o seletor de "
"segmento do segmento de c�digo do usu�rio � exibido e copiado para registro "
"<literal> % cs </literal> . Lembre-se de que o n�vel de privil�gio deste "
"segmento � 3, o n�vel menos privilegiado. Isso significa que devemos "
"fornecer valores para a pilha desse n�vel de privil�gio. � por isso que o "
"processador, al�m de aumentar o valor do registrador EFLAGS, faz mais dois "
"pops da pilha. Esses valores v�o para o ponteiro da pilha ( <literal> % esp "
"</literal> ) e o segmento da pilha ( <literal> % ss </literal> ). Agora, a "
"execu��o continua em <literal> boot0 </literal> ponto de entrada. "

#. (itstool) path: sect1/para
#: book.translate.xml:1983
#, fuzzy
msgid ""
"It is important to note how the User Code Segment is defined. This segment's "
"<emphasis>base address</emphasis> is set to <literal>0xa000</literal>. This "
"means that code memory addresses are <emphasis>relative</emphasis> to "
"address 0xa000; if code being executed is fetched from address "
"<literal>0x2000</literal>, the <emphasis>actual</emphasis> memory addressed "
"is <literal>0xa000+0x2000=0xc000</literal>."
msgstr ""
"� importante observar como o segmento de c�digo do usu�rio � definido. Esse "
"segmento � <emphasis> endere�o base </emphasis> est� configurado para "
"<literal> 0xa000 </literal> . Isso significa que os endere�os de mem�ria de "
"c�digo s�o <emphasis> relativo </emphasis> para endere�ar 0xa000; se o "
"c�digo que est� sendo executado for buscado no endere�o <literal> 0x2000 </"
"literal> , a <emphasis> real </emphasis> mem�ria endere�ada � <literal> "
"0xa000 + 0x2000 = 0xc000 </literal> "

#. (itstool) path: sect1/title
#: book.translate.xml:1994
msgid "<application>boot2</application> Stage"
msgstr "Etapa <application>boot2</application>"

#. (itstool) path: sect1/para
#: book.translate.xml:1996
#, fuzzy
msgid ""
"<literal>boot2</literal> defines an important structure, <literal>struct "
"bootinfo</literal>. This structure is initialized by <literal>boot2</"
"literal> and passed to the loader, and then further to the kernel. Some "
"nodes of this structures are set by <literal>boot2</literal>, the rest by "
"the loader. This structure, among other information, contains the kernel "
"filename, <acronym>BIOS</acronym> harddisk geometry, <acronym>BIOS</acronym> "
"drive number for boot device, physical memory available, <literal>envp</"
"literal> pointer etc. The definition for it is:"
msgstr ""
" <literal> boot2 </literal> define uma estrutura importante, <literal> "
"struct bootinfo </literal> . Essa estrutura � inicializada por <literal> "
"boot2 </literal> e passou para o carregador e depois para o kernel. Alguns "
"n�s desta estrutura s�o definidos por <literal> boot2 </literal> , o resto "
"pelo carregador. Esta estrutura, entre outras informa��es, cont�m o nome do "
"arquivo do kernel, <acronym>BIOS</acronym> geometria disco r�gido, n�mero da "
"unidade <acronym>BIOS</acronym> para dispositivo de inicializa��o, mem�ria "
"f�sica dispon�vel, <literal> envp </literal> ponteiro etc. A defini��o para "
"isso �: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2006
#, no-wrap
msgid ""
"<filename>/usr/include/machine/bootinfo.h:</filename>\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};"
msgstr ""
"<filename>/usr/include/machine/bootinfo.h:</filename>\n"
"struct bootinfo {\n"
"\tu_int32_t\tbi_version;\n"
"\tu_int32_t\tbi_kernelname;\t\t/* represents a char * */\n"
"\tu_int32_t\tbi_nfs_diskless;\t/* struct nfs_diskless * */\n"
"\t\t\t\t/* End of fields that are always present. */\n"
"#define\tbi_endcommon\tbi_n_bios_used\n"
"\tu_int32_t\tbi_n_bios_used;\n"
"\tu_int32_t\tbi_bios_geom[N_BIOS_GEOM];\n"
"\tu_int32_t\tbi_size;\n"
"\tu_int8_t\tbi_memsizes_valid;\n"
"\tu_int8_t\tbi_bios_dev;\t\t/* bootdev BIOS unit number */\n"
"\tu_int8_t\tbi_pad[2];\n"
"\tu_int32_t\tbi_basemem;\n"
"\tu_int32_t\tbi_extmem;\n"
"\tu_int32_t\tbi_symtab;\t\t/* struct symtab * */\n"
"\tu_int32_t\tbi_esymtab;\t\t/* struct symtab * */\n"
"\t\t\t\t/* Items below only from advanced bootloader */\n"
"\tu_int32_t\tbi_kernend;\t\t/* end of kernel space */\n"
"\tu_int32_t\tbi_envp;\t\t/* environment */\n"
"\tu_int32_t\tbi_modulep;\t\t/* preloaded modules */\n"
"};\n"

#. (itstool) path: sect1/para
#: book.translate.xml:2029
#, fuzzy
msgid ""
"<literal>boot2</literal> enters into an infinite loop waiting for user "
"input, then calls <function>load()</function>. If the user does not press "
"anything, the loop breaks by a timeout, so <function>load()</function> will "
"load the default file (<filename>/boot/loader</filename>). Functions "
"<function>ino_t lookup(char *filename)</function> and <function>int "
"xfsread(ino_t inode, void *buf, size_t nbyte)</function> are used to read "
"the content of a file into memory. <filename>/boot/loader</filename> is an "
"<acronym>ELF</acronym> binary, but where the <acronym>ELF</acronym> header "
"is prepended with <filename>a.out</filename>'s <literal>struct exec</"
"literal> structure. <function>load()</function> scans the loader's ELF "
"header, loading the content of <filename>/boot/loader</filename> into "
"memory, and passing the execution to the loader's entry:"
msgstr ""
" <literal> boot2 </literal> entra em um loop infinito esperando por entrada "
"do usu�rio, ent�o chama <function> carga() </function> . Se o usu�rio n�o "
"pressionar nada, o loop ser� interrompido por um tempo limite, <function> "
"carga() </function> ir� carregar o arquivo padr�o ( <filename> / boot / "
"loader </filename> ). Fun��es <function> pesquisa ino_t (char * filename) </"
"function> e <function> int xfsread (inodo_t inode, void * buf, tamanho_t "
"nbyte) </function> s�o usados ​​para ler o conte�do de um arquivo na mem�ria."
" <filename> / boot / loader </filename> � um bin�rio <acronym>ELF</acronym> "
", mas onde o cabe�alho <acronym>ELF</acronym> � prefixado com <filename> a."
"out </filename> ';s <literal> struct exec </literal> estrutura. <function> "
"carga() </function> varre o cabe�alho ELF do carregador, carregando o "
"conte�do do <filename> / boot / loader </filename> na mem�ria e passando a "
"execu��o para a entrada do carregador: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2044
#, no-wrap
msgid ""
"<filename>sys/boot/i386/boot2/boot2.c:</filename>\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&amp;bootinfo));"
msgstr ""
"<filename>sys/boot/i386/boot2/boot2.c:</filename>\n"
"    __exec((caddr_t)addr, RB_BOOTINFO | (opts &amp; RBX_MASK),\n"
"\t   MAKEBOOTDEV(dev_maj[dsk.type], 0, dsk.slice, dsk.unit, dsk.part),\n"
"\t   0, 0, 0, VTOP(&amp;bootinfo));"

#. (itstool) path: sect1/title
#: book.translate.xml:2051
msgid "<application>loader</application> Stage"
msgstr "<application>loader</application> Stage"

#. (itstool) path: sect1/para
#: book.translate.xml:2053
#, fuzzy
msgid ""
"<application>loader</application> is a <acronym>BTX</acronym> client as well."
" I will not describe it here in detail, there is a comprehensive manpage "
"written by Mike Smith, <citerefentry><refentrytitle>loader</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>. The underlying "
"mechanisms and <acronym>BTX</acronym> were discussed above."
msgstr ""
" <application> carregador </application> � um cliente <acronym>BTX</acronym> "
"tamb�m. Eu n�o vou descrev�-lo aqui em detalhes, h� uma manpage abrangente "
"escrito por Mike Smith, <citerefentry><refentrytitle> carregador </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> . Os mecanismos "
"subjacentes e <acronym>BTX</acronym> foram discutidos acima \""

#. (itstool) path: sect1/para
#: book.translate.xml:2058
#, fuzzy
msgid ""
"The main task for the loader is to boot the kernel. When the kernel is "
"loaded into memory, it is being called by the loader:"
msgstr ""
"A tarefa principal do carregador � inicializar o kernel. Quando o kernel � "
"carregado na mem�ria, ele est� sendo chamado pelo carregador:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2062
#, no-wrap
msgid ""
"<filename>sys/boot/common/boot.c:</filename>\n"
"    /* Call the exec handler from the loader matching the kernel */\n"
"    module_formats[km-&gt;m_loader]-&gt;l_exec(km);"
msgstr ""
"<filename>sys/boot/common/boot.c:</filename>\n"
"    /* Call the exec handler from the loader matching the kernel */\n"
"    module_formats[km-&gt;m_loader]-&gt;l_exec(km);"

#. (itstool) path: sect1/title
#: book.translate.xml:2068
msgid "Kernel Initialization"
msgstr "Inicialização do Kernel"

#. (itstool) path: sect1/para
#: book.translate.xml:2070
#, fuzzy
msgid ""
"Let us take a look at the command that links the kernel. This will help "
"identify the exact location where the loader passes execution to the kernel. "
"This location is the kernel's actual entry point."
msgstr ""
"Vamos dar uma olhada no comando que liga o kernel. Isso ajudar� a "
"identificar a localiza��o exata onde o carregador passa a execu��o para o "
"kernel. Esta localiza��o � o ponto de entrada real do kernel."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2075
#, no-wrap
msgid ""
"<filename>sys/conf/Makefile.i386:</filename>\n"
"ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \\\n"
"-dynamic-linker /red/herring -o kernel -X locore.o \\\n"
"&lt;lots of kernel .o files&gt;"
msgstr ""
"<filename>sys/conf/Makefile.i386:</filename>\n"
"ld -elf -Bdynamic -T /usr/src/sys/conf/ldscript.i386  -export-dynamic \\\n"
"-dynamic-linker /red/herring -o kernel -X locore.o \\\n"
"&lt;lots of kernel .o files&gt;"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2080
msgid "<primary>ELF</primary>"
msgstr "<primary>ELF</primary>"

#. (itstool) path: sect1/para
#: book.translate.xml:2081
#, fuzzy
msgid ""
"A few interesting things can be seen here. First, the kernel is an ELF "
"dynamically linked binary, but the dynamic linker for kernel is <filename>/"
"red/herring</filename>, which is definitely a bogus file. Second, taking a "
"look at the file <filename>sys/conf/ldscript.i386</filename> gives an idea "
"about what <application>ld</application> options are used when compiling a "
"kernel. Reading through the first few lines, the string"
msgstr ""
"Algumas coisas interessantes podem ser vistas aqui. Primeiro, o kernel � um "
"bin�rio ELF dinamicamente vinculado, mas o vinculador din�mico para o kernel "
"� <filename> / vermelho / arenque </filename> , que � definitivamente um "
"arquivo falso. Em segundo lugar, dando uma olhada no arquivo <filename> sys /"
" conf / ldscript.i386 </filename> d� uma ideia sobre o que <application> ld "
"</application> op��es s�o usadas ao compilar um kernel. Lendo as primeiras "
"linhas, a string "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2090
#, no-wrap
msgid "<filename>sys/conf/ldscript.i386:</filename>\n"
"ENTRY(btext)"
msgstr "<filename>sys/conf/ldscript.i386:</filename>\n"
"ENTRY(btext)"

#. (itstool) path: sect1/para
#: book.translate.xml:2093
#, fuzzy
msgid ""
"says that a kernel's entry point is the symbol `btext'. This symbol is "
"defined in <filename>locore.s</filename>:"
msgstr ""
"diz que o ponto de entrada de um kernel � o s�mbolo\" btext \". Este s�mbolo "
"� definido em <filename> locore.s </filename> : "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2096
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\t.text\n"
"/**********************************************************************\n"
" *\n"
" * This is where the bootblocks start us, set the ball rolling...\n"
" *\n"
" */\n"
"NON_GPROF_ENTRY(btext)"

#. (itstool) path: sect1/para
#: book.translate.xml:2105
#, fuzzy
msgid ""
"First, the register EFLAGS is set to a predefined value of 0x00000002. Then "
"all the segment registers are initialized:"
msgstr ""
"Primeiro, o registrador EFLAGS � configurado para um valor predefinido de "
"0x00000002. Ent�o todos os registradores de segmento s�o inicializados:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2109
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
"\n"
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"/* Don't trust what the BIOS gives for eflags. */\n"
"\tpushl\t$PSL_KERNEL\n"
"\tpopfl\n"
"\n"
"/*\n"
" * Don't trust what the BIOS gives for %fs and %gs.  Trust the bootstrap\n"
" * to set %cs, %ds, %es and %ss.\n"
" */\n"
"\tmov\t%ds, %ax\n"
"\tmov\t%ax, %fs\n"
"\tmov\t%ax, %gs"

#. (itstool) path: sect1/para
#: book.translate.xml:2122
#, fuzzy
msgid ""
"btext calls the routines <function>recover_bootinfo()</function>, "
"<function>identify_cpu()</function>, <function>create_pagetables()</"
"function>, which are also defined in <filename>locore.s</filename>. Here is "
"a description of what they do:"
msgstr ""
"btext chama as rotinas <function> recover_bootinfo () </function> , "
"<function> identify_cpu () </function> , <function> create_pagetables () </"
"function> , que tamb�m s�o definidos em <filename> locore.s </filename> . "
"Aqui est� uma descri��o do que eles fazem: "

#. (itstool) path: row/entry
#: book.translate.xml:2133
#, fuzzy
msgid "<function>recover_bootinfo</function>"
msgstr " <function> recover_bootinfo </function> "

#. (itstool) path: row/entry
#: book.translate.xml:2134
#, fuzzy
msgid ""
"This routine parses the parameters to the kernel passed from the bootstrap. "
"The kernel may have been booted in 3 ways: by the loader, described above, "
"by the old disk boot blocks, or by the old diskless boot procedure. This "
"function determines the booting method, and stores the <literal>struct "
"bootinfo</literal> structure into the kernel memory."
msgstr ""
"Esta rotina analisa os par�metros para o kernel passado a partir do "
"bootstrap. O kernel pode ter sido inicializado de 3 maneiras: pelo "
"carregador, descrito acima, pelos blocos de inicializa��o de disco antigos "
"ou pelo antigo procedimento de inicializa��o sem disco. Essa fun��o "
"determina o m�todo de inicializa��o, e armazena o <literal> struct bootinfo "
"</literal> estrutura na mem�ria do kernel. "

#. (itstool) path: row/entry
#: book.translate.xml:2144
msgid "<function>identify_cpu</function>"
msgstr "<function>identify_cpu</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2145
#, fuzzy
msgid ""
"This functions tries to find out what CPU it is running on, storing the "
"value found in a variable <varname>_cpu</varname>."
msgstr ""
"Esta fun��o tenta descobrir em qual CPU ela est� rodando, armazenando o "
"valor encontrado em uma vari�vel <varname> _CPU </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2151
msgid "<function>create_pagetables</function>"
msgstr "<function>create_pagetables</function>"

#. (itstool) path: row/entry
#: book.translate.xml:2152
#, fuzzy
msgid ""
"This function allocates and fills out a Page Table Directory at the top of "
"the kernel memory area."
msgstr ""
"Esta fun��o aloca e preenche um Diret�rio de Tabelas de P�ginas no topo da "
"�rea de mem�ria do kernel."

#. (itstool) path: sect1/para
#: book.translate.xml:2159
#, fuzzy
msgid "The next steps are enabling VME, if the CPU supports it:"
msgstr "Os pr�ximos passos s�o habilitar o VME, se a CPU suportar:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2162
#, no-wrap
msgid ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4"
msgstr ""
"\ttestl\t$CPUID_VME, R(_cpu_feature)\n"
"\tjz\t1f\n"
"\tmovl\t%cr4, %eax\n"
"\torl\t$CR4_VME, %eax\n"
"\tmovl\t%eax, %cr4"

#. (itstool) path: sect1/para
#: book.translate.xml:2168
#, fuzzy
msgid "Then, enabling paging:"
msgstr "Ent�o, habilitando pagina��o:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2170
#, no-wrap
msgid ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */"
msgstr ""
"/* Now enable paging */\n"
"\tmovl\tR(_IdlePTD), %eax\n"
"\tmovl\t%eax,%cr3\t\t\t/* load ptd addr into mmu */\n"
"\tmovl\t%cr0,%eax\t\t\t/* get control word */\n"
"\torl\t$CR0_PE|CR0_PG,%eax\t\t/* enable paging */\n"
"\tmovl\t%eax,%cr0\t\t\t/* and let's page NOW! */"

#. (itstool) path: sect1/para
#: book.translate.xml:2177
#, fuzzy
msgid ""
"The next three lines of code are because the paging was set, so the jump is "
"needed to continue the execution in virtualized address space:"
msgstr ""
"As pr�ximas tr�s linhas de c�digo s�o porque a pagina��o foi definida, "
"portanto, o salto � necess�rio para continuar a execu��o no espa�o de "
"endere�o virtualizado:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2181
#, no-wrap
msgid ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
"\n"
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:"
msgstr ""
"\tpushl\t$begin\t\t\t\t/* jump to high virtualized address */\n"
"\tret\n"
"\n"
"/* now running relocated at KERNBASE where the system is linked to run */\n"
"begin:"

#. (itstool) path: sect1/para
#: book.translate.xml:2187
#, fuzzy
msgid ""
"The function <function>init386()</function> is called with a pointer to the "
"first free physical page, after that <function>mi_startup()</function>. "
"<function>init386</function> is an architecture dependent initialization "
"function, and <function>mi_startup()</function> is an architecture "
"independent one (the 'mi_' prefix stands for Machine Independent). The "
"kernel never returns from <function>mi_startup()</function>, and by calling "
"it, the kernel finishes booting:"
msgstr ""
"A fun��o <function> init386 () </function> � chamado com um ponteiro para a "
"primeira p�gina f�sica livre, depois disso <function> mi_startup () </"
"function> . <function> init386 </function> � uma fun��o de inicializa��o "
"dependente da arquitetura e <function> mi_startup () </function> � uma "
"arquitetura independente (o prefixo ';mi_'; significa Independente da "
"M�quina). O kernel nunca retorna de <function> mi_startup () </function> e, "
"ao cham�-lo, o kernel conclui a inicializa��o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:2196
#, no-wrap
msgid ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */"
msgstr ""
"<filename>sys/i386/i386/locore.s:</filename>\n"
"\tmovl\tphysfree, %esi\n"
"\tpushl\t%esi\t\t\t\t/* value of first for init386(first) */\n"
"\tcall\t_init386\t\t\t/* wire 386 chip for unix operation */\n"
"\tcall\t_mi_startup\t\t\t/* autoconfiguration, mountroot etc */\n"
"\thlt\t\t/* never returns to here */"

#. (itstool) path: sect2/title
#: book.translate.xml:2204
#, fuzzy
msgid "<function>init386()</function>"
msgstr " <function> init386 () </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:2206
#, fuzzy
msgid ""
"<function>init386()</function> is defined in <filename>sys/i386/i386/machdep."
"c</filename> and performs low-level initialization specific to the i386 chip."
" The switch to protected mode was performed by the loader. The loader has "
"created the very first task, in which the kernel continues to operate. "
"Before looking at the code, consider the tasks the processor must complete "
"to initialize protected mode execution:"
msgstr ""
" <function> init386 () </function> � definido em <filename> sys / i386 / "
"i386 / machdep.c </filename> e executa inicializa��o de baixo n�vel "
"espec�fica para o chip i386. A mudan�a para o modo protegido foi realizada "
"pelo carregador. O carregador criou a primeira tarefa, na qual o kernel "
"continua a operar. Antes de examinar o c�digo, considere as tarefas que o "
"processador deve concluir para inicializar a execu��o do modo protegido: "

#. (itstool) path: listitem/para
#: book.translate.xml:2217
#, fuzzy
msgid ""
"Initialize the kernel tunable parameters, passed from the bootstrapping "
"program."
msgstr ""
"Inicialize os par�metros ajust�veis ​​do kernel, passados ​​do programa de "
"bootstrapping."

#. (itstool) path: listitem/para
#: book.translate.xml:2222
#, fuzzy
msgid "Prepare the GDT."
msgstr "Prepare o GDT."

#. (itstool) path: listitem/para
#: book.translate.xml:2226
#, fuzzy
msgid "Prepare the IDT."
msgstr "Prepare o IDT."

#. (itstool) path: listitem/para
#: book.translate.xml:2230
#, fuzzy
msgid "Initialize the system console."
msgstr "Inicialize o console do sistema."

#. (itstool) path: listitem/para
#: book.translate.xml:2234
#, fuzzy
msgid "Initialize the DDB, if it is compiled into kernel."
msgstr "Inicialize o DDB, se ele for compilado no kernel."

#. (itstool) path: listitem/para
#: book.translate.xml:2239
#, fuzzy
msgid "Initialize the TSS."
msgstr "Inicialize o TSS."

#. (itstool) path: listitem/para
#: book.translate.xml:2243
#, fuzzy
msgid "Prepare the LDT."
msgstr "Prepare o LDT."

#. (itstool) path: listitem/para
#: book.translate.xml:2247
#, fuzzy
msgid "Set up proc0's pcb."
msgstr "Configure o pcb do proc0."

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2251
#, fuzzy
msgid "<primary>parameters</primary>"
msgstr " <primary> Par�metros </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:2252
#, fuzzy
msgid ""
"<function>init386()</function> initializes the tunable parameters passed "
"from bootstrap by setting the environment pointer (envp) and calling "
"<function>init_param1()</function>. The envp pointer has been passed from "
"loader in the <literal>bootinfo</literal> structure:"
msgstr ""
" <function> init386 () </function> inicializa os par�metros ajust�veis "
"​​passados ​​do bootstrap definindo o ponteiro de ambiente (envp) e chamando "
"<function> init_param1 () </function> . O ponteiro envp foi passado do "
"carregador no <literal> bootinfo </literal> estrutura:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2258
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
"\n"
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\t\tkern_envp = (caddr_t)bootinfo.bi_envp + KERNBASE;\n"
"\n"
"\t/* Init basic tunables, hz etc */\n"
"\tinit_param1();"

#. (itstool) path: sect2/para
#: book.translate.xml:2264
#, fuzzy
msgid ""
"<function>init_param1()</function> is defined in <filename>sys/kern/"
"subr_param.c</filename>. That file has a number of sysctls, and two "
"functions, <function>init_param1()</function> and <function>init_param2()</"
"function>, that are called from <function>init386()</function>:"
msgstr ""
" <function> init_param1 () </function> � definido em <filename> sys / kern / "
"subr_param.c </filename> . Esse arquivo tem um n�mero de sysctls e duas "
"fun��es, <function> init_param1 () </function> e <function> init_param2 () </"
"function> , que s�o chamados de <function> init386 () </function> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2271
#, no-wrap
msgid ""
"<filename>sys/kern/subr_param.c:</filename>\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &amp;hz);"
msgstr ""
"<filename>sys/kern/subr_param.c:</filename>\n"
"\thz = HZ;\n"
"\tTUNABLE_INT_FETCH(\"kern.hz\", &amp;hz);"

#. (itstool) path: sect2/para
#: book.translate.xml:2275
#, fuzzy
msgid ""
"TUNABLE_&lt;typename&gt;_FETCH is used to fetch the value from the "
"environment:"
msgstr ""
"TUNABLE_ &lt;typename&gt; _FETCH � usado para buscar o valor do ambiente:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2278
#, no-wrap
msgid ""
"<filename>/usr/src/sys/sys/kernel.h:</filename>\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))"
msgstr ""
"<filename>/usr/src/sys/sys/kernel.h:</filename>\n"
"#define\tTUNABLE_INT_FETCH(path, var)\tgetenv_int((path), (var))"

#. (itstool) path: sect2/para
#: book.translate.xml:2281
#, fuzzy
msgid ""
"Sysctl <literal>kern.hz</literal> is the system clock tick. Additionally, "
"these sysctls are set by <function>init_param1()</function>: <literal>kern."
"maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern.maxdsiz, kern."
"dflssiz, kern.maxssiz, kern.sgrowsiz</literal>."
msgstr ""
"Sysctl <literal> kern.hz </literal> � o tick do rel�gio do sistema. Al�m "
"disso, esses sysctls s�o definidos por <function> init_param1 () </function> "
": <literal> kern.maxswzone, kern.maxbcache, kern.maxtsiz, kern.dfldsiz, kern."
"maxdsiz, kern.dflssiz, kern.maxssiz, kern.sgrowsiz </literal> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2287
#, fuzzy
msgid "<primary>Global Descriptors Table (GDT)</primary>"
msgstr " <primary> Tabela de Descritores Globais (GDT) </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:2291
#, fuzzy
msgid ""
"Then <function>init386()</function> prepares the Global Descriptors Table "
"(GDT). Every task on an x86 is running in its own virtual address space, and "
"this space is addressed by a segment:offset pair. Say, for instance, the "
"current instruction to be executed by the processor lies at CS:EIP, then the "
"linear virtual address for that instruction would be <quote>the virtual "
"address of code segment CS</quote> + EIP. For convenience, segments begin at "
"virtual address 0 and end at a 4Gb boundary. Therefore, the instruction's "
"linear virtual address for this example would just be the value of EIP. "
"Segment registers such as CS, DS etc are the selectors, i.e., indexes, into "
"GDT (to be more precise, an index is not a selector itself, but the INDEX "
"field of a selector). FreeBSD's GDT holds descriptors for 15 selectors per "
"CPU:"
msgstr ""
"Ent�o <function> init386 () </function> prepara a Tabela de Descritores "
"Globais (GDT). Toda tarefa em um x86 est� sendo executada em seu pr�prio "
"espa�o de endere�o virtual e esse espa�o � endere�ado por um par segmento: "
"offset. Digamos, por exemplo, que a instru��o atual a ser executada pelo "
"processador esteja em CS: EIP, ent�o o endere�o virtual linear para aquela "
"instru��o seria <quote> o endere�o virtual do segmento de c�digo CS </quote> "
"+ EIP. Por conveni�ncia, os segmentos come�am no endere�o virtual 0 e "
"terminam em um limite de 4 Gb. Portanto, o endere�o virtual linear da "
"instru��o para este exemplo seria apenas o valor de EIP. Registros de "
"segmento como CS, DS etc. s�o os seletores, isto �, �ndices, em GDT (para "
"ser mais preciso, um �ndice n�o � um seletor em si, mas o campo INDEX de um "
"seletor). O GDT do FreeBSD possui descritores para 15 seletores por CPU: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2307
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
"\n"
"<filename>sys/i386/include/segments.h:</filename>\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"union descriptor gdt[NGDT * MAXCPU];\t/* global descriptor table */\n"
"\n"
"<filename>sys/i386/include/segments.h:</filename>\n"
"/*\n"
" * Entries in the Global Descriptor Table (GDT)\n"
" */\n"
"#define\tGNULL_SEL\t0\t/* Null Descriptor */\n"
"#define\tGCODE_SEL\t1\t/* Kernel Code Descriptor */\n"
"#define\tGDATA_SEL\t2\t/* Kernel Data Descriptor */\n"
"#define\tGPRIV_SEL\t3\t/* SMP Per-Processor Private Data */\n"
"#define\tGPROC0_SEL\t4\t/* Task state process slot zero and up */\n"
"#define\tGLDT_SEL\t5\t/* LDT - eventually one per process */\n"
"#define\tGUSERLDT_SEL\t6\t/* User LDT */\n"
"#define\tGTGATE_SEL\t7\t/* Process task switch gate */\n"
"#define\tGBIOSLOWMEM_SEL\t8\t/* BIOS low memory access (must be entry 8) */\n"
"#define\tGPANIC_SEL\t9\t/* Task state to consider panic from */\n"
"#define GBIOSCODE32_SEL\t10\t/* BIOS interface (32bit Code) */\n"
"#define GBIOSCODE16_SEL\t11\t/* BIOS interface (16bit Code) */\n"
"#define GBIOSDATA_SEL\t12\t/* BIOS interface (Data) */\n"
"#define GBIOSUTIL_SEL\t13\t/* BIOS interface (Utility) */\n"
"#define GBIOSARGS_SEL\t14\t/* BIOS interface (Arguments) */"

#. (itstool) path: sect2/para
#: book.translate.xml:2330
#, fuzzy
msgid ""
"Note that those #defines are not selectors themselves, but just a field "
"INDEX of a selector, so they are exactly the indices of the GDT. for "
"example, an actual selector for the kernel code (GCODE_SEL) has the value "
"0x08."
msgstr ""
"Note que esses #defines n�o s�o seletores, mas apenas um campo INDEX de um "
"seletor, ent�o eles s�o exatamente os �ndices do GDT. Por exemplo, um "
"seletor real para o c�digo do kernel (GCODE_SEL) tem o valor 0x08."

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2335
#, fuzzy
msgid "<primary>Interrupt Descriptor Table (IDT)</primary>"
msgstr " <primary> Tabela de descritores de interrup��o (IDT) </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:2337
#, fuzzy
msgid ""
"The next step is to initialize the Interrupt Descriptor Table (IDT). This "
"table is referenced by the processor when a software or hardware interrupt "
"occurs. For example, to make a system call, user application issues the "
"<literal>INT 0x80</literal> instruction. This is a software interrupt, so "
"the processor's hardware looks up a record with index 0x80 in the IDT. This "
"record points to the routine that handles this interrupt, in this particular "
"case, this will be the kernel's syscall gate. The IDT may have a maximum of "
"256 (0x100) records. The kernel allocates NIDT records for the IDT, where "
"NIDT is the maximum (256):"
msgstr ""
"O pr�ximo passo � inicializar a Tabela de Descritores de Interrup��es (IDT). "
"Essa tabela � referenciada pelo processador quando ocorre uma interrup��o de "
"software ou hardware. Por exemplo, para fazer uma chamada de sistema, o "
"aplicativo de usu�rio emite a <literal> INT 0x80 </literal> instru��o. Esta "
"� uma interrup��o de software, portanto, o hardware do processador procura "
"um registro com o �ndice 0x80 no IDT. Este registro aponta para a rotina que "
"lida com esta interrup��o, neste caso particular, este ser� o syscall do "
"kernel. O IDT pode ter um m�ximo de 256 (0x100) registros. O kernel aloca "
"registros NIDT para o IDT, onde NIDT � o m�ximo (256): "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2349
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &amp;idt0[0];\t/* interrupt descriptor table */"
""
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"static struct gate_descriptor idt0[NIDT];\n"
"struct gate_descriptor *idt = &amp;idt0[0];\t/* interrupt descriptor table */"
""

#. (itstool) path: sect2/para
#: book.translate.xml:2353
#, fuzzy
msgid ""
"For each interrupt, an appropriate handler is set. The syscall gate for "
"<literal>INT 0x80</literal> is set as well:"
msgstr ""
"Para cada interrup��o, um manipulador apropriado � definido. O syscall gate "
"para <literal> INT 0x80 </literal> est� definido tamb�m: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2357
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tsetidt(0x80, &amp;IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tsetidt(0x80, &amp;IDTVEC(int0x80_syscall),\n"
"\t\t\tSDT_SYS386TGT, SEL_UPL, GSEL(GCODE_SEL, SEL_KPL));"

#. (itstool) path: sect2/para
#: book.translate.xml:2361
#, fuzzy
msgid ""
"So when a userland application issues the <literal>INT 0x80</literal> "
"instruction, control will transfer to the function "
"<function>_Xint0x80_syscall</function>, which is in the kernel code segment "
"and will be executed with supervisor privileges."
msgstr ""
"Ent�o, quando um aplicativo userland emite o <literal> INT 0x80 </literal> "
"instru��o, controle ir� transferir para a fun��o <function> "
"_Xint0x80_syscall </function> , que est� no segmento de c�digo do kernel e "
"ser� executado com privil�gios de supervisor. "

#. (itstool) path: sect2/para
#: book.translate.xml:2367
#, fuzzy
msgid "Console and DDB are then initialized:"
msgstr "Console e DDB s�o inicializados:"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2368
#, fuzzy
msgid "<primary>DDB</primary>"
msgstr " <primary> DDB </primary> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2370
#, no-wrap
msgid ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto &amp; RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif"
msgstr ""
"<filename>sys/i386/i386/machdep.c:</filename>\n"
"\tcninit();\n"
"/* skipped */\n"
"#ifdef DDB\n"
"\tkdb_init();\n"
"\tif (boothowto &amp; RB_KDB)\n"
"\t\tDebugger(\"Boot flags requested debugger\");\n"
"#endif"

#. (itstool) path: sect2/para
#: book.translate.xml:2379
#, fuzzy
msgid ""
"The Task State Segment is another x86 protected mode structure, the TSS is "
"used by the hardware to store task information when a task switch occurs."
msgstr ""
"O segmento de estado da tarefa � outra estrutura de modo protegido x86, o "
"TSS � usado pelo hardware para armazenar informa��es de tarefa quando ocorre "
"uma altern��ncia de tarefa."

#. (itstool) path: sect2/para
#: book.translate.xml:2383
#, fuzzy
msgid ""
"The Local Descriptors Table is used to reference userland code and data. "
"Several selectors are defined to point to the LDT, they are the system call "
"gates and the user code and data selectors:"
msgstr ""
"A Tabela de Descritores Locais � usada para referenciar c�digos e dados da "
"terra do usu�rio. V�rios seletores s�o definidos para apontar para o LDT, "
"eles s�o as portas de chamada do sistema e os seletores de c�digo e dados do "
"usu�rio:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2388
#, no-wrap
msgid ""
"<filename>/usr/include/machine/segments.h:</filename>\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris &gt;= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)"
msgstr ""
"<filename>/usr/include/machine/segments.h:</filename>\n"
"#define\tLSYS5CALLS_SEL\t0\t/* forced by intel BCS */\n"
"#define\tLSYS5SIGR_SEL\t1\n"
"#define\tL43BSDCALLS_SEL\t2\t/* notyet */\n"
"#define\tLUCODE_SEL\t3\n"
"#define\tLSOL26CALLS_SEL\t4\t/* Solaris &gt;= 2.6 system call gate */\n"
"#define\tLUDATA_SEL\t5\n"
"/* separate stack, es,fs,gs sels ? */\n"
"/* #define\tLPOSIXCALLS_SEL\t5*/\t/* notyet */\n"
"#define LBSDICALLS_SEL\t16\t/* BSDI system call gate */\n"
"#define NLDT\t\t(LBSDICALLS_SEL + 1)"

#. (itstool) path: sect2/para
#: book.translate.xml:2400
#, fuzzy
msgid ""
"Next, proc0's Process Control Block (<literal>struct pcb</literal>) "
"structure is initialized. proc0 is a <literal>struct proc</literal> "
"structure that describes a kernel process. It is always present while the "
"kernel is running, therefore it is declared as global:"
msgstr ""
"Em seguida, o bloco de controle de processo do proc0 ( <literal> pcb struct "
"</literal> ) estrutura � inicializada. proc0 � um <literal> struct proc </"
"literal> estrutura que descreve um processo do kernel. Est� sempre presente "
"enquanto o kernel est� rodando, portanto � declarado como global: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2406
#, no-wrap
msgid "<filename>sys/kern/kern_init.c:</filename>\n"
"    struct\tproc proc0;"
msgstr "<filename>sys/kern/kern_init.c:</filename>\n"
"    struct\tproc proc0;"

#. (itstool) path: sect2/para
#: book.translate.xml:2409
#, fuzzy
msgid ""
"The structure <literal>struct pcb</literal> is a part of a proc structure. "
"It is defined in <filename>/usr/include/machine/pcb.h</filename> and has a "
"process's information specific to the i386 architecture, such as registers "
"values."
msgstr ""
"A estrutura <literal> pcb struct </literal> faz parte de uma estrutura proc. "
"Est� definido em <filename> /usr/include/machine/pcb.h </filename> e possui "
"uma informa��o espec�fica do processo para a arquitetura i386, como valores "
"de registros. "

#. (itstool) path: sect2/title
#: book.translate.xml:2417
#, fuzzy
msgid "<function>mi_startup()</function>"
msgstr " <function> mi_startup () </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:2419
#, fuzzy
msgid ""
"This function performs a bubble sort of all the system initialization "
"objects and then calls the entry of each object one by one:"
msgstr ""
"Esta fun��o executa um tipo de bolha de todos os objetos de inicializa��o do "
"sistema e, em seguida, chama a entrada de cada objeto, um por um:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2423
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
"\n"
"\t\t/* ... skipped ... */\n"
"\n"
"\t\t/* Call function */\n"
"\t\t(*((*sipp)-&gt;func))((*sipp)-&gt;udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"\tfor (sipp = sysinit; *sipp; sipp++) {\n"
"\n"
"\t\t/* ... skipped ... */\n"
"\n"
"\t\t/* Call function */\n"
"\t\t(*((*sipp)-&gt;func))((*sipp)-&gt;udata);\n"
"\t\t/* ... skipped ... */\n"
"\t}"

#. (itstool) path: sect2/para
#: book.translate.xml:2433
#, fuzzy
msgid ""
"Although the sysinit framework is described in the <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/developers-"
"handbook\">Developers' Handbook</link>, I will discuss the internals of it."
msgstr ""
"Embora o framework sysinit seja descrito no <link xlink:href="
"\"@@URL_RELPREFIX@@/doc/en_US.ISO8859-1/books/developers-handbook\"> Manual "
"dos Desenvolvedores </link> , Vou discutir os aspectos internos dele. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:2436
#, fuzzy
msgid "<primary>sysinit objects</primary>"
msgstr " <primary> objetos sysinit </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:2437
#, fuzzy
msgid ""
"Every system initialization object (sysinit object) is created by calling a "
"SYSINIT() macro. Let us take as example an <literal>announce</literal> "
"sysinit object. This object prints the copyright message:"
msgstr ""
"Todo objeto de inicializa��o do sistema (objeto sysinit) � criado chamando "
"uma macro SYSINIT (). Vamos tomar como exemplo <literal> anunciar </literal> "
"objeto sysinit. Este objeto imprime a mensagem de direitos autorais: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2442
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, "
"copyright)"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"print_caddr_t(void *data __unused)\n"
"{\n"
"\tprintf(\"%s\", (char *)data);\n"
"}\n"
"SYSINIT(announce, SI_SUB_COPYRIGHT, SI_ORDER_FIRST, print_caddr_t, "
"copyright)"

#. (itstool) path: sect2/para
#: book.translate.xml:2450
#, fuzzy
msgid ""
"The subsystem ID for this object is SI_SUB_COPYRIGHT (0x0800001), which "
"comes right after the SI_SUB_CONSOLE (0x0800000). So, the copyright message "
"will be printed out first, just after the console initialization."
msgstr ""
"O ID do subsistema para este objeto � SI_SUB_COPYRIGHT (0x0800001), que vem "
"logo ap�s o SI_SUB_CONSOLE (0x0800000). Assim, a mensagem de copyright ser� "
"impressa primeiro, logo ap�s a inicializa��o do console."

#. (itstool) path: sect2/para
#: book.translate.xml:2455
#, fuzzy
msgid ""
"Let us take a look at what exactly the macro <literal>SYSINIT()</literal> "
"does. It expands to a <literal>C_SYSINIT()</literal> macro. The "
"<literal>C_SYSINIT()</literal> macro then expands to a static "
"<literal>struct sysinit</literal> structure declaration with another "
"<literal>DATA_SET</literal> macro call:"
msgstr ""
"Vamos dar uma olhada no que exatamente a macro <literal> SYSINIT () </"
"literal> faz. Ele se expande para um <literal> C_SYSINIT () </literal> macro."
" o <literal> C_SYSINIT () </literal> macro, em seguida, se expande para uma "
"est�tica <literal> struct sysinit </literal> declara��o de estrutura com "
"outro <literal> DATA_SET </literal> chamada macro: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2462
#, no-wrap
msgid ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
"\n"
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"      #define C_SYSINIT(uniquifier, subsystem, order, func, ident) \\\n"
"      static struct sysinit uniquifier ## _sys_init = { \\ subsystem, \\\n"
"      order, \\ func, \\ ident \\ }; \\ DATA_SET(sysinit_set,uniquifier ##\n"
"      _sys_init);\n"
"\n"
"#define\tSYSINIT(uniquifier, subsystem, order, func, ident)\t\\\n"
"\tC_SYSINIT(uniquifier, subsystem, order,\t\t\t\\\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)func, (void *)ident)"

#. (itstool) path: sect2/para
#: book.translate.xml:2472
#, fuzzy
msgid ""
"The <literal>DATA_SET()</literal> macro expands to a <literal>MAKE_SET()</"
"literal>, and that macro is the point where all the sysinit magic is hidden:"
msgstr ""
"O <literal> DATA_SET () </literal> macro se expande para um <literal> "
"MAKE_SET () </literal> e essa macro � o ponto onde toda a magia sysinit est� "
"escondida: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2476
#, no-wrap
msgid ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = &amp;sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)"
msgstr ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"#define MAKE_SET(set, sym)\t\t\t\t\t\t\\\n"
"\tstatic void const * const __set_##set##_sym_##sym = &amp;sym;\t\\\n"
"\t__asm(\".section .set.\" #set \",\\\"aw\\\"\");\t\t\t\t\\\n"
"\t__asm(\".long \" #sym);\t\t\t\t\t\t\\\n"
"\t__asm(\".previous\")\n"
"#endif\n"
"#define TEXT_SET(set, sym) MAKE_SET(set, sym)\n"
"#define DATA_SET(set, sym) MAKE_SET(set, sym)"

#. (itstool) path: sect2/para
#: book.translate.xml:2486
#, fuzzy
msgid "In our case, the following declaration will occur:"
msgstr "No nosso caso, a seguinte declara��o ir� ocorrer:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2488
#, no-wrap
msgid ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
"\n"
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    &amp;announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");"
msgstr ""
"static struct sysinit announce_sys_init = {\n"
"\tSI_SUB_COPYRIGHT,\n"
"\tSI_ORDER_FIRST,\n"
"\t(sysinit_cfunc_t)(sysinit_nfunc_t)  print_caddr_t,\n"
"\t(void *) copyright\n"
"};\n"
"\n"
"static void const *const __set_sysinit_set_sym_announce_sys_init =\n"
"    &amp;announce_sys_init;\n"
"__asm(\".section .set.sysinit_set\" \",\\\"aw\\\"\");\n"
"__asm(\".long \" \"announce_sys_init\");\n"
"__asm(\".previous\");"

#. (itstool) path: sect2/para
#: book.translate.xml:2501
#, fuzzy
msgid ""
"The first <literal>__asm</literal> instruction will create an ELF section "
"within the kernel's executable. This will happen at kernel link time. The "
"section will have the name <literal>.set.sysinit_set</literal>. The content "
"of this section is one 32-bit value, the address of announce_sys_init "
"structure, and that is what the second <literal>__asm</literal> is. The "
"third <literal>__asm</literal> instruction marks the end of a section. If a "
"directive with the same section name occurred before, the content, i.e., the "
"32-bit value, will be appended to the existing section, so forming an array "
"of 32-bit pointers."
msgstr ""
"O primeiro <literal> __asm </literal> instru��o ir� criar uma se��o ELF "
"dentro do execut�vel do kernel. Isso acontecer� no momento do link do kernel."
" A se��o ter� o nome <literal> .set.sysinit_set </literal> . O conte�do "
"desta se��o � um valor de 32 bits, o endere�o da estrutura "
"announce_sys_init, e � isso que o segundo <literal> __asm </literal> �. O "
"terceiro <literal> __asm </literal> instru��o marca o fim de uma se��o. Se "
"uma diretiva com o mesmo nome de se��o ocorreu antes, o conte�do, ou seja, o "
"valor de 32 bits, ser� anexado � se��o existente, formando assim uma matriz "
"de ponteiros de 32 bits. "

#. (itstool) path: sect2/para
#: book.translate.xml:2514
#, fuzzy
msgid ""
"Running <application>objdump</application> on a kernel binary, you may "
"notice the presence of such small sections:"
msgstr ""
"Corrida <application> objdump </application> em um bin�rio do kernel, voc� "
"pode notar a presen�a de se��es t�o pequenas: "

#. (itstool) path: sect2/screen
#: book.translate.xml:2518
#, no-wrap
msgid ""
"<prompt>%</prompt> <userinput>objdump -h /kernel</userinput>\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA"
msgstr ""
"<prompt>%</prompt> <userinput>objdump -h /kernel</userinput>\n"
"  7 .set.cons_set 00000014  c03164c0  c03164c0  002154c0  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  8 .set.kbddriver_set 00000010  c03164d4  c03164d4  002154d4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
"  9 .set.scrndr_set 00000024  c03164e4  c03164e4  002154e4  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 10 .set.scterm_set 0000000c  c0316508  c0316508  00215508  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 11 .set.sysctl_set 0000097c  c0316514  c0316514  00215514  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA\n"
" 12 .set.sysinit_set 00000664  c0316e90  c0316e90  00215e90  2**2\n"
"                  CONTENTS, ALLOC, LOAD, DATA"

#. (itstool) path: sect2/para
#: book.translate.xml:2532
#, fuzzy
msgid ""
"This screen dump shows that the size of .set.sysinit_set section is 0x664 "
"bytes, so <literal>0x664/sizeof(void *)</literal> sysinit objects are "
"compiled into the kernel. The other sections such as <literal>.set."
"sysctl_set</literal> represent other linker sets."
msgstr ""
"Este dump de tela mostra que o tamanho da se��o .set.sysinit_set � 0x664 "
"bytes, ent�o <literal> 0x664 / sizeof (void *) </literal> objetos sysinit "
"s�o compilados no kernel. As outras se��es, como <literal> .set.sysctl_set </"
"literal> representam outros conjuntos de linkers. "

#. (itstool) path: sect2/para
#: book.translate.xml:2538
#, fuzzy
msgid ""
"By defining a variable of type <literal>struct linker_set</literal> the "
"content of <literal>.set.sysinit_set</literal> section will be "
"<quote>collected</quote> into that variable:"
msgstr ""
"Definindo uma vari�vel do tipo <literal> struct linker_set </literal> o "
"conte�do de <literal> .set.sysinit_set </literal> se��o ser� <quote> "
"coletado </quote> para essa vari�vel: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2543
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"      extern struct linker_set sysinit_set; /* XXX */"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"      extern struct linker_set sysinit_set; /* XXX */"

#. (itstool) path: sect2/para
#: book.translate.xml:2546
#, fuzzy
msgid "The <literal>struct linker_set</literal> is defined as follows:"
msgstr ""
"O <literal> struct linker_set </literal> � definido da seguinte forma: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2549
#, no-wrap
msgid ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};"
msgstr ""
"<filename>/usr/include/linker_set.h:</filename>\n"
"  struct linker_set {\n"
"\tint\tls_length;\n"
"\tvoid\t*ls_items[1];\t\t/* really ls_length of them, trailing NULL */\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:2555
#, fuzzy
msgid ""
"The first node will be equal to the number of a sysinit objects, and the "
"second node will be a NULL-terminated array of pointers to them."
msgstr ""
"O primeiro n� ser� igual ao n�mero de objetos sysinit, e o segundo n� ser� "
"uma matriz terminada em NULL de ponteiros para eles."

#. (itstool) path: sect2/para
#: book.translate.xml:2559
#, fuzzy
msgid ""
"Returning to the <function>mi_startup()</function> discussion, it is must be "
"clear now, how the sysinit objects are being organized. The "
"<function>mi_startup()</function> function sorts them and calls each. The "
"very last object is the system scheduler:"
msgstr ""
"Voltando ao <function> mi_startup () </function> discuss�o, � preciso estar "
"claro agora, como os objetos sysinit est�o sendo organizados. o <function> "
"mi_startup () </function> fun��o classifica-los e chama cada um. O �ltimo "
"objeto � o agendador do sistema: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2565
#, no-wrap
msgid ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};"
msgstr ""
"<filename>/usr/include/sys/kernel.h:</filename>\n"
"enum sysinit_sub_id {\n"
"\tSI_SUB_DUMMY\t\t= 0x0000000,\t/* not executed; for linker*/\n"
"\tSI_SUB_DONE\t\t= 0x0000001,\t/* processed*/\n"
"\tSI_SUB_CONSOLE\t\t= 0x0800000,\t/* console*/\n"
"\tSI_SUB_COPYRIGHT\t= 0x0800001,\t/* first use of console*/\n"
"...\n"
"\tSI_SUB_RUN_SCHEDULER\t= 0xfffffff\t/* scheduler: no return*/\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:2575
#, fuzzy
msgid ""
"The system scheduler sysinit object is defined in the file <filename>sys/vm/"
"vm_glue.c</filename>, and the entry point for that object is "
"<function>scheduler()</function>. That function is actually an infinite "
"loop, and it represents a process with PID 0, the swapper process. The proc0 "
"structure, mentioned before, is used to describe it."
msgstr ""
"O objeto sysinit do planejador do sistema � definido no arquivo <filename> "
"sys / vm / vm_glue.c </filename> , e o ponto de entrada para esse objeto � "
"<function> Agendador() </function> . Essa fun��o � na verdade um loop "
"infinito e representa um processo com PID 0, o processo de swapper. A "
"estrutura proc0, mencionada anteriormente, � usada para descrev�-la. "

#. (itstool) path: sect2/para
#: book.translate.xml:2582
#, fuzzy
msgid ""
"The first user process, called <emphasis>init</emphasis>, is created by the "
"sysinit object <literal>init</literal>:"
msgstr ""
"O primeiro processo do usu�rio, chamado <emphasis> nisso </emphasis> , � "
"criado pelo objeto sysinit <literal> nisso </literal> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2586
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
"\n"
"\ts = splhigh();\n"
"\terror = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-&gt;p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static void\n"
"create_init(const void *udata __unused)\n"
"{\n"
"\tint error;\n"
"\tint s;\n"
"\n"
"\ts = splhigh();\n"
"\terror = fork1(&amp;proc0, RFFDG | RFPROC, &amp;initproc);\n"
"\tif (error)\n"
"\t\tpanic(\"cannot fork init: %d\\n\", error);\n"
"\tinitproc-&gt;p_flag |= P_INMEM | P_SYSTEM;\n"
"\tcpu_set_fork_handler(initproc, start_init, NULL);\n"
"\tremrunqueue(initproc);\n"
"\tsplx(s);\n"
"}\n"
"SYSINIT(init,SI_SUB_CREATE_INIT, SI_ORDER_FIRST, create_init, NULL)"

#. (itstool) path: sect2/para
#: book.translate.xml:2604
#, fuzzy
msgid ""
"The <function>create_init()</function> allocates a new process by calling "
"<function>fork1()</function>, but does not mark it runnable. When this new "
"process is scheduled for execution by the scheduler, the "
"<function>start_init()</function> will be called. That function is defined "
"in <filename>init_main.c</filename>. It tries to load and exec the "
"<filename>init</filename> binary, probing <filename>/sbin/init</filename> "
"first, then <filename>/sbin/oinit</filename>, <filename>/sbin/init.bak</"
"filename>, and finally <filename>/stand/sysinstall</filename>:"
msgstr ""
"O <function> create_init () </function> aloca um novo processo chamando "
"<function> fork1 () </function> , mas n�o o marca execut�vel. Quando este "
"novo processo � agendado para execu��o pelo agendador, o <function> "
"start_init () </function> ser� chamado. Essa fun��o � definida em <filename> "
"init_main.c </filename> . Ele tenta carregar e executar o <filename> nisso </"
"filename> bin�rio, sondando <filename> / sbin / init </filename> primeiro, "
"ent�o <filename> / sbin / oinit </filename> , <filename> /sbin/init.bak </"
"filename> , e finalmente <filename> / stand / sysinstall </filename> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:2616
#, no-wrap
msgid ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif"
msgstr ""
"<filename>sys/kern/init_main.c:</filename>\n"
"static char init_path[MAXPATHLEN] =\n"
"#ifdef\tINIT_PATH\n"
"    __XSTRING(INIT_PATH);\n"
"#else\n"
"    \"/sbin/init:/sbin/oinit:/sbin/init.bak:/stand/sysinstall\";\n"
"#endif"

#. (itstool) path: chapter/title
#: book.translate.xml:2635
#, fuzzy
msgid "Locking Notes"
msgstr "Notas de Bloqueio"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2637
#, fuzzy
msgid "<primary>SMP Next Generation Project</primary>"
msgstr " <primary> Projeto SMP Next Generation </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:2638
#, fuzzy
msgid ""
"<emphasis>This chapter is maintained by the FreeBSD SMP Next Generation "
"Project.</emphasis>"
msgstr ""
" <emphasis> Este cap�tulo � mantido pelo projeto FreeBSD SMP Next Generation."
" </emphasis> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2641
#, fuzzy
msgid "<primary>locking</primary>"
msgstr " <primary> bloqueio </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2642
#, fuzzy
msgid "<primary>multi-processing</primary>"
msgstr " <primary> multiprocessamento </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2643
#, fuzzy
msgid "<primary>mutexes</primary>"
msgstr " <primary> mutexes </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2644
#, fuzzy
msgid "<primary>lockmgr</primary>"
msgstr " <primary> lockmgr </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2645
#, fuzzy
msgid "<primary>atomic operations</primary>"
msgstr " <primary> opera��es at�micas </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:2646
#, fuzzy
msgid ""
"This document outlines the locking used in the FreeBSD kernel to permit "
"effective multi-processing within the kernel. Locking can be achieved via "
"several means. Data structures can be protected by mutexes or "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> locks. A few variables are protected simply by "
"always using atomic operations to access them."
msgstr ""
"Este documento descreve o bloqueio usado no kernel do FreeBSD para permitir "
"um multiprocessamento efetivo dentro do kernel. O bloqueio pode ser "
"alcan�ado atrav�s de v�rios meios. As estruturas de dados podem ser "
"protegidas por mutexes ou <citerefentry><refentrytitle> lockmgr </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> fechaduras. Algumas "
"vari�veis ​​s�o protegidas simplesmente por usar sempre opera��es at�micas "
"para acess�-las. "

#. (itstool) path: sect1/title
#: book.translate.xml:2654
#, fuzzy
msgid "Mutexes"
msgstr "Mutexes"

#. (itstool) path: sect1/para
#: book.translate.xml:2656
#, fuzzy
msgid ""
"A mutex is simply a lock used to guarantee mutual exclusion. Specifically, a "
"mutex may only be owned by one entity at a time. If another entity wishes to "
"obtain a mutex that is already owned, it must wait until the mutex is "
"released. In the FreeBSD kernel, mutexes are owned by processes."
msgstr ""
"Um mutex � simplesmente um bloqueio usado para garantir a exclus�o m�tua. "
"Especificamente, um mutex s� pode pertencer a uma entidade por vez. Se outra "
"entidade desejar obter um mutex que j� � de propriedade, ele deve aguardar "
"at� que o mutex seja liberado. No kernel do FreeBSD, os mutexes s�o de "
"propriedade de processos. "

#. (itstool) path: sect1/para
#: book.translate.xml:2662
#, fuzzy
msgid ""
"Mutexes may be recursively acquired, but they are intended to be held for a "
"short period of time. Specifically, one may not sleep while holding a mutex. "
"If you need to hold a lock across a sleep, use a "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> lock."
msgstr ""
"Mutexes podem ser recursivamente adquiridos, mas eles devem ser mantidos por "
"um curto per�odo de tempo. Especificamente, um n�o pode dormir enquanto "
"segura um mutex. Se voc� precisar segurar uma trava atrav�s de um sono, use "
"um <citerefentry><refentrytitle> lockmgr </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> bloqueio \""

#. (itstool) path: sect1/para
#: book.translate.xml:2667
#, fuzzy
msgid "Each mutex has several properties of interest:"
msgstr "Cada mutex tem v�rias propriedades de interesse:"

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2671 book.translate.xml:2758 book.translate.xml:2918
#, fuzzy
msgid "Variable Name"
msgstr "Nome vari�vel"

#. (itstool) path: listitem/para
#: book.translate.xml:2673
#, fuzzy
msgid "The name of the <type>struct mtx</type> variable in the kernel source."
msgstr "O nome do <type> struct mtx </type> vari�vel na fonte do kernel. "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2679 book.translate.xml:2759
#, fuzzy
msgid "Logical Name"
msgstr "Nome l�gico"

#. (itstool) path: listitem/para
#: book.translate.xml:2681
#, fuzzy
msgid ""
"The name of the mutex assigned to it by <function>mtx_init</function>. This "
"name is displayed in KTR trace messages and witness errors and warnings and "
"is used to distinguish mutexes in the witness code."
msgstr ""
"O nome do mutex atribu�do a ele por <function> mtx_init </function> . Esse "
"nome � exibido em mensagens de rastreamento KTR e testemunha de erros e "
"avisos e � usado para distinguir mutexes no c�digo da testemunha. "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2689 book.translate.xml:2760
#, fuzzy
msgid "Type"
msgstr "Tipo"

#. (itstool) path: listitem/para
#: book.translate.xml:2691
#, fuzzy
msgid ""
"The type of the mutex in terms of the <constant>MTX_*</constant> flags. The "
"meaning for each flag is related to its meaning as documented in "
"<citerefentry><refentrytitle>mutex</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry>."
msgstr ""
"O tipo do mutex em termos de <constant> MTX_ * </constant> bandeiras. O "
"significado para cada bandeira est� relacionado ao seu significado conforme "
"documentado em <citerefentry><refentrytitle> mutex </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2698 book.translate.xml:2851
#, fuzzy
msgid "<constant>MTX_DEF</constant>"
msgstr " <constant> MTX_DEF </constant> "

#. (itstool) path: listitem/para
#: book.translate.xml:2700
#, fuzzy
msgid "A sleep mutex"
msgstr "Um mutex do sono"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2705
#, fuzzy
msgid "<constant>MTX_SPIN</constant>"
msgstr " <constant> MTX_SPIN </constant> "

#. (itstool) path: listitem/para
#: book.translate.xml:2707
#, fuzzy
msgid "A spin mutex"
msgstr "Um mutex spin"

#. (itstool) path: varlistentry/term
#: book.translate.xml:2712
#, fuzzy
msgid "<constant>MTX_RECURSE</constant>"
msgstr " <constant> MTX_RECURSE </constant> "

#. (itstool) path: listitem/para
#: book.translate.xml:2714
#, fuzzy
msgid "This mutex is allowed to recurse."
msgstr "Esse mutex pode recorrer."

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2722 book.translate.xml:2761 book.translate.xml:2919
#, fuzzy
msgid "Protectees"
msgstr "Protegidos"

#. (itstool) path: listitem/para
#: book.translate.xml:2724
#, fuzzy
msgid ""
"A list of data structures or data structure members that this entry protects."
" For data structure members, the name will be in the form of <varname remap="
"\"structname\">structure name</varname>.<varname remap="
"\"structfield\">member name</varname>."
msgstr ""
"Uma lista de estruturas de dados ou membros da estrutura de dados que esta "
"entrada protege. Para membros da estrutura de dados, o nome estar� na forma "
"de <varname remap=\"structname\"> nome da estrutura </varname> . <varname "
"remap=\"structfield\"> nome do membro </varname> "

#. (itstool) path: varlistentry/term
#. (itstool) path: row/entry
#: book.translate.xml:2732 book.translate.xml:2762
#, fuzzy
msgid "Dependent Functions"
msgstr "Fun��es dependentes"

#. (itstool) path: listitem/para
#: book.translate.xml:2734
#, fuzzy
msgid "Functions that can only be called if this mutex is held."
msgstr "Fun��es que s� podem ser chamadas se este mutex for mantido."

#. (itstool) path: table/title
#: book.translate.xml:2741
#, fuzzy
msgid "Mutex List"
msgstr "Lista Mutex"

#. (itstool) path: table/indexterm
#: book.translate.xml:2743
#, fuzzy
msgid "<primary>locks</primary> <secondary>sched_lock</secondary>"
msgstr " <primary> fechaduras </primary><secondary> sched_lock </secondary> "

#. (itstool) path: table/indexterm
#: book.translate.xml:2746
#, fuzzy
msgid "<primary>locks</primary> <secondary>vm86pcb_lock</secondary>"
msgstr ""
" <primary> fechaduras </primary><secondary> vm86pcb_lock </secondary> "

#. (itstool) path: table/indexterm
#: book.translate.xml:2749
#, fuzzy
msgid "<primary>locks</primary> <secondary>Giant</secondary>"
msgstr " <primary> fechaduras </primary><secondary> Gigante </secondary> "

#. (itstool) path: table/indexterm
#: book.translate.xml:2752
#, fuzzy
msgid "<primary>locks</primary> <secondary>callout_lock</secondary>"
msgstr ""
" <primary> fechaduras </primary><secondary> callout_lock </secondary> "

#. (itstool) path: row/entry
#: book.translate.xml:2769
#, fuzzy
msgid "sched_lock"
msgstr "sched_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2770
#, fuzzy
msgid "<quote>sched lock</quote>"
msgstr " <quote> bloqueio de programa��o </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2771 book.translate.xml:2878
#, fuzzy
msgid "<constant>MTX_SPIN</constant> | <constant>MTX_RECURSE</constant>"
msgstr ""
" <constant> MTX_SPIN </constant> | <constant> MTX_RECURSE </constant> "

#. (itstool) path: row/entry
#: book.translate.xml:2775
msgid ""
"<varname>_gmonparam</varname>, <varname>cnt.v_swtch</varname>, "
"<varname>cp_time</varname>, <varname>curpriority</varname>, <varname remap="
"\"structname\">mtx</varname>.<varname remap=\"structfield\">mtx_blocked</"
"varname>, <varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_procq</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slpq</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sflag</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_stat</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_estcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_cpticks</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_pctcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_wchan</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_wmesg</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_swtime</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slptime</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_runtime</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_uu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_su</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_iu</varname>, <varname remap=\"structname\">proc</varname>."
"<varname remap=\"structfield\">p_uticks</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_sticks</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_iticks</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_oncpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_lastcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_rqindex</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_heldmtx</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_blocked</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_mtxname</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_contested</varname>, <varname "
"remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_priority</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_usrpri</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_nativepri</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_nice</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_rtprio</varname>, <varname>pscnt</"
"varname>, <varname>slpque</varname>, <varname>itqueuebits</varname>, "
"<varname>itqueues</varname>, <varname>rtqueuebits</varname>, "
"<varname>rtqueues</varname>, <varname>queuebits</varname>, <varname>queues</"
"varname>, <varname>idqueuebits</varname>, <varname>idqueues</varname>, "
"<varname>switchtime</varname>, <varname>switchticks</varname>"
msgstr ""
"<varname>_gmonparam</varname>, <varname>cnt.v_swtch</varname>, "
"<varname>cp_time</varname>, <varname>curpriority</varname>, <varname remap="
"\"structname\">mtx</varname>.<varname remap=\"structfield\">mtx_blocked</"
"varname>, <varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_contested</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_procq</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slpq</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_sflag</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_stat</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_estcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_cpticks</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_pctcpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_wchan</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_wmesg</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_swtime</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_slptime</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_runtime</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_uu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_su</varname>, "
"<varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_iu</varname>, <varname remap=\"structname\">proc</varname>."
"<varname remap=\"structfield\">p_uticks</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_sticks</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_iticks</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_oncpu</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_lastcpu</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_rqindex</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_heldmtx</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_blocked</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_mtxname</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_contested</varname>, <varname "
"remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_priority</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_usrpri</varname>, <varname remap="
"\"structname\">proc</varname>.<varname remap=\"structfield\">p_nativepri</"
"varname>, <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_nice</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_rtprio</varname>, <varname>pscnt</"
"varname>, <varname>slpque</varname>, <varname>itqueuebits</varname>, "
"<varname>itqueues</varname>, <varname>rtqueuebits</varname>, "
"<varname>rtqueues</varname>, <varname>queuebits</varname>, <varname>queues</"
"varname>, <varname>idqueuebits</varname>, <varname>idqueues</varname>, "
"<varname>switchtime</varname>, <varname>switchticks</varname>"

#. (itstool) path: row/entry
#: book.translate.xml:2825
#, fuzzy
msgid ""
"<function>setrunqueue</function>, <function>remrunqueue</function>, "
"<function>mi_switch</function>, <function>chooseproc</function>, "
"<function>schedclock</function>, <function>resetpriority</function>, "
"<function>updatepri</function>, <function>maybe_resched</function>, "
"<function>cpu_switch</function>, <function>cpu_throw</function>, "
"<function>need_resched</function>, <function>resched_wanted</function>, "
"<function>clear_resched</function>, <function>aston</function>, "
"<function>astoff</function>, <function>astpending</function>, "
"<function>calcru</function>, <function>proc_compare</function>"
msgstr ""
" <function> setrunqueue </function> , <function> remrunqueue </function> , "
"<function> mi_switch </function> , <function> chooseproc </function> , "
"<function> schedclock </function> , <function> resetpriority </function> , "
"<function> updatepri </function> , <function> maybe_resched </function> , "
"<function> cpu_switch </function> , <function> cpu_throw </function> , "
"<function> need_resched </function> , <function> resched_wanted </function> "
", <function> clear_resched </function> , <function> aston </function> , "
"<function> astoff </function> , <function> aspendendo </function> , "
"<function> calcru </function> , <function> proc_compare </function> "

#. (itstool) path: row/entry
#: book.translate.xml:2849
#, fuzzy
msgid "vm86pcb_lock"
msgstr "vm86pcb_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2850
#, fuzzy
msgid "<quote>vm86pcb lock</quote>"
msgstr " <quote> bloqueio vm86pcb </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2854
#, fuzzy
msgid "<varname>vm86pcb</varname>"
msgstr " <varname> vm86pcb </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2857
#, fuzzy
msgid "<function>vm86_bioscall</function>"
msgstr " <function> vm86_bioscall </function> "

#. (itstool) path: row/entry
#: book.translate.xml:2864
#, fuzzy
msgid "Giant"
msgstr "Gigante"

#. (itstool) path: row/entry
#: book.translate.xml:2865
#, fuzzy
msgid "<quote>Giant</quote>"
msgstr " <quote> Gigante </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2866
#, fuzzy
msgid "<constant>MTX_DEF</constant> | <constant>MTX_RECURSE</constant>"
msgstr " <constant> MTX_DEF </constant> | <constant> MTX_RECURSE </constant> "

#. (itstool) path: row/entry
#: book.translate.xml:2870
#, fuzzy
msgid "nearly everything"
msgstr "quase tudo"

#. (itstool) path: row/entry
#: book.translate.xml:2871
#, fuzzy
msgid "lots"
msgstr "grande quantidade"

#. (itstool) path: row/entry
#: book.translate.xml:2876
#, fuzzy
msgid "callout_lock"
msgstr "callout_lock"

#. (itstool) path: row/entry
#: book.translate.xml:2877
#, fuzzy
msgid "<quote>callout lock</quote>"
msgstr " <quote> bloqueio de texto explicativo </quote> "

#. (itstool) path: row/entry
#: book.translate.xml:2882
#, fuzzy
msgid ""
"<varname>callfree</varname>, <varname>callwheel</varname>, "
"<varname>nextsoftcheck</varname>, <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_itcallout</varname>, <varname "
"remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_slpcallout</varname>, <varname>softticks</varname>, "
"<varname>ticks</varname>"
msgstr ""
" <varname> callfree </varname> , <varname> volante </varname> , <varname> "
"nextsoftcheck </varname> , <varname remap=\"structname\"> proc </varname> . "
"<varname remap=\"structfield\"> p_itcallout </varname> , <varname remap="
"\"structname\"> proc </varname> . <varname remap=\"structfield\"> "
"p_slpcallout </varname> , <varname> softticks </varname> , <varname> "
"carrapatos </varname> "

#. (itstool) path: sect1/title
#: book.translate.xml:2900
#, fuzzy
msgid "Shared Exclusive Locks"
msgstr "Bloqueios exclusivos compartilhados"

#. (itstool) path: sect1/para
#: book.translate.xml:2902
#, fuzzy
msgid ""
"These locks provide basic reader-writer type functionality and may be held "
"by a sleeping process. Currently they are backed by "
"<citerefentry><refentrytitle>lockmgr</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>."
msgstr ""
"Esses bloqueios fornecem funcionalidade b�sica do tipo leitor-gravador e "
"podem ser mantidos por um processo de suspens�o. Atualmente, eles s�o "
"protegidos por <citerefentry><refentrytitle> lockmgr </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2905
#, fuzzy
msgid "<primary>locks</primary> <secondary>shared exclusive</secondary>"
msgstr ""
" <primary> fechaduras </primary><secondary> exclusivo compartilhado </"
"secondary> "

#. (itstool) path: table/title
#: book.translate.xml:2909
#, fuzzy
msgid "Shared Exclusive Lock List"
msgstr "Lista de bloqueio exclusiva compartilhada"

#. (itstool) path: table/indexterm
#: book.translate.xml:2910
#, fuzzy
msgid "<primary>locks</primary> <secondary>allproc_lock</secondary>"
msgstr ""
" <primary> fechaduras </primary><secondary> allproc_lock </secondary> "

#. (itstool) path: table/indexterm
#: book.translate.xml:2912
#, fuzzy
msgid "<primary>locks</primary> <secondary>proctree_lock</secondary>"
msgstr ""
" <primary> fechaduras </primary><secondary> proctree_lock </secondary> "

#. (itstool) path: row/entry
#: book.translate.xml:2924
#, fuzzy
msgid "<varname>allproc_lock</varname>"
msgstr " <varname> allproc_lock </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2925
#, fuzzy
msgid ""
"<varname>allproc</varname> <varname>zombproc</varname> <varname>pidhashtbl</"
"varname> <varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_list</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_hash</varname> <varname>nextpid</"
"varname>"
msgstr ""
" <varname> allproc </varname><varname> zombproc </varname><varname> "
"pidhashtbl </varname><varname remap=\"structname\"> proc </varname> . "
"<varname remap=\"structfield\"> p_list </varname><varname remap="
"\"structname\"> proc </varname> . <varname remap=\"structfield\"> p_hash </"
"varname><varname> nextpid </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2935
#, fuzzy
msgid "<varname>proctree_lock</varname>"
msgstr " <varname> proctree_lock </varname> "

#. (itstool) path: row/entry
#: book.translate.xml:2936
#, fuzzy
msgid ""
"<varname remap=\"structname\">proc</varname>.<varname remap="
"\"structfield\">p_children</varname> <varname remap=\"structname\">proc</"
"varname>.<varname remap=\"structfield\">p_sibling</varname>"
msgstr ""
" <varname remap=\"structname\"> proc </varname> . <varname remap="
"\"structfield\"> p_children </varname><varname remap=\"structname\"> proc </"
"varname> . <varname remap=\"structfield\"> p_sibling </varname> "

#. (itstool) path: sect1/title
#: book.translate.xml:2947
#, fuzzy
msgid "Atomically Protected Variables"
msgstr "Vari�veis ​​Atomicamente Protegidas"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2949
#, fuzzy
msgid "<primary>atomically protected variables</primary>"
msgstr " <primary> vari�veis ​​atomicamente protegidas </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:2951
#, fuzzy
msgid ""
"An atomically protected variable is a special variable that is not protected "
"by an explicit lock. Instead, all data accesses to the variables use special "
"atomic operations as described in <citerefentry><refentrytitle>atomic</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>. Very few variables "
"are treated this way, although other synchronization primitives such as "
"mutexes are implemented with atomically protected variables."
msgstr ""
"Uma vari�vel atomicamente protegida � uma vari�vel especial que n�o � "
"protegida por um bloqueio expl�cito. Em vez disso, todos os acessos a dados "
"para as vari�veis ​​usam opera��es at�micas especiais, como descrito em "
"<citerefentry><refentrytitle> at�mico </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> . Muito poucas vari�veis ​​s�o tratadas dessa "
"maneira, embora outras primitivas de sincroniza��o, como mutexes, sejam "
"implementadas com vari�veis ​​protegidas atomicamente. "

#. (itstool) path: listitem/para
#: book.translate.xml:2961
msgid ""
"<varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_lock</varname>"
msgstr ""
"<varname remap=\"structname\">mtx</varname>.<varname remap="
"\"structfield\">mtx_lock</varname>"

#. (itstool) path: chapter/title
#: book.translate.xml:2974
#, fuzzy
msgid "Kernel Objects"
msgstr "Kernel Objects"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2976
#, fuzzy
msgid "<primary>Kernel Objects</primary>"
msgstr "<primary>Kernel Objects</primary>"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2977
#, fuzzy
msgid "<primary>Object-Oriented</primary>"
msgstr " <primary> Orientado a Objeto </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:2978
#, fuzzy
msgid "<primary>binary compatibility</primary>"
msgstr " <primary> compatibilidade bin�ria </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:2979
#, fuzzy
msgid ""
"Kernel Objects, or <firstterm>Kobj</firstterm> provides an object-oriented C "
"programming system for the kernel. As such the data being operated on "
"carries the description of how to operate on it. This allows operations to "
"be added and removed from an interface at run time and without breaking "
"binary compatibility."
msgstr ""
"Objetos do Kernel, ou <firstterm> Kobj </firstterm> fornece um sistema de "
"programa��o C orientado a objeto para o kernel. Como tal, os dados que est�o "
"sendo operados cont�m a descri��o de como oper�-lo. Isso permite que as "
"opera��es sejam adicionadas e removidas de uma interface em tempo de "
"execu��o e sem quebrar a compatibilidade bin�ria. "

#. (itstool) path: sect1/title
#: book.translate.xml:2987 book.translate.xml:4094
#, fuzzy
msgid "Terminology"
msgstr "Terminologia"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2989
#, fuzzy
msgid "<primary>object</primary>"
msgstr " <primary> objeto </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2990
#, fuzzy
msgid "<primary>method</primary>"
msgstr " <primary> m�todo </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2991
#, fuzzy
msgid "<primary>class</primary>"
msgstr " <primary> classe </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:2992
#, fuzzy
msgid "<primary>interface</primary>"
msgstr " <primary> interface </primary> "

#. (itstool) path: varlistentry/term
#: book.translate.xml:2996
#, fuzzy
msgid "Object"
msgstr "Objeto"

#. (itstool) path: listitem/para
#: book.translate.xml:2997
#, fuzzy
msgid "A set of data - data structure - data allocation."
msgstr "Um conjunto de dados - estrutura de dados - aloca��o de dados."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3002
#, fuzzy
msgid "Method"
msgstr "M�todo"

#. (itstool) path: listitem/para
#: book.translate.xml:3004
#, fuzzy
msgid "An operation - function."
msgstr "Uma opera��o - fun��o."

#. (itstool) path: varlistentry/term
#: book.translate.xml:3008
#, fuzzy
msgid "Class"
msgstr "Classe"

#. (itstool) path: listitem/para
#: book.translate.xml:3010
#, fuzzy
msgid "One or more methods."
msgstr "Um ou mais m�todos."

#. (itstool) path: varlistentry/term
#. (itstool) path: sect2/title
#: book.translate.xml:3014 book.translate.xml:4155
#, fuzzy
msgid "Interface"
msgstr "Interface"

#. (itstool) path: listitem/para
#: book.translate.xml:3016
#, fuzzy
msgid "A standard set of one or more methods."
msgstr "Um conjunto padr�o de um ou mais m�todos."

#. (itstool) path: sect1/title
#: book.translate.xml:3023
#, fuzzy
msgid "Kobj Operation"
msgstr "Opera��o Kobj"

#. (itstool) path: sect1/para
#: book.translate.xml:3025
#, fuzzy
msgid ""
"Kobj works by generating descriptions of methods. Each description holds a "
"unique id as well as a default function. The description's address is used "
"to uniquely identify the method within a class' method table."
msgstr ""
"O Kobj funciona gerando descri��es de m�todos. Cada descri��o possui um ID "
"�nico, bem como uma fun��o padr�o. O endere�o da descri��o � usado para "
"identificar exclusivamente o m�todo dentro da tabela de m�todos de uma "
"classe."

#. (itstool) path: sect1/para
#: book.translate.xml:3030
#, fuzzy
msgid ""
"A class is built by creating a method table associating one or more "
"functions with method descriptions. Before use the class is compiled. The "
"compilation allocates a cache and associates it with the class. A unique id "
"is assigned to each method description within the method table of the class "
"if not already done so by another referencing class compilation. For every "
"method to be used a function is generated by script to qualify arguments and "
"automatically reference the method description for a lookup. The generated "
"function looks up the method by using the unique id associated with the "
"method description as a hash into the cache associated with the object's "
"class. If the method is not cached the generated function proceeds to use "
"the class' table to find the method. If the method is found then the "
"associated function within the class is used; otherwise, the default "
"function associated with the method description is used."
msgstr ""
"Uma classe � constru�da criando uma tabela de m�todos associando uma ou mais "
"fun��es com descri��es de m�todos. Antes de usar, a classe � compilada. A "
"compila��o aloca um cache e o associa � classe. Um ID �nico � atribu�do a "
"cada descri��o de m�todo dentro do m�todo. tabela da classe, se ainda n�o "
"tiver sido feita por outra compila��o de classe de refer�ncia.Para cada "
"m�todo a ser usado, uma fun��o � gerada pelo script para qualificar "
"argumentos e automaticamente referenciar a descri��o do m�todo para uma "
"pesquisa.A fun��o gerada procura o m�todo usando a ID �nico associado � "
"descri��o do m�todo como um hash no cache associado � classe do objeto.Se o "
"m�todo n�o � armazenado em cache, a fun��o gerada continua a usar a tabela "
"da classe para localizar o m�todo.Se o m�todo for encontrado, a fun��o "
"associada a classe � usada, caso contr�rio, a fun��o padr�o associada � "
"descri��o do m�todo � usada. "

#. (itstool) path: sect1/para
#: book.translate.xml:3047
#, fuzzy
msgid "These indirections can be visualized as the following:"
msgstr "Essas indire��es podem ser visualizadas da seguinte forma:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:3050
#, no-wrap
msgid "object-&gt;cache&lt;-&gt;class"
msgstr "object-&gt;cache&lt;-&gt;class"

#. (itstool) path: sect1/title
#: book.translate.xml:3055
#, fuzzy
msgid "Using Kobj"
msgstr "Usando o Kobj"

#. (itstool) path: sect2/title
#: book.translate.xml:3058
#, fuzzy
msgid "Structures"
msgstr "Estruturas"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3060
#, no-wrap
msgid "struct kobj_method"
msgstr "struct kobj_method"

#. (itstool) path: sect2/title
#: book.translate.xml:3064
#, fuzzy
msgid "Functions"
msgstr "Fun��es"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3066
#, no-wrap
msgid ""
"void kobj_class_compile(kobj_class_t cls);\n"
"void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);\n"
"void kobj_class_free(kobj_class_t cls);\n"
"kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);\n"
"void kobj_init(kobj_t obj, kobj_class_t cls);\n"
"void kobj_delete(kobj_t obj, struct malloc_type *mtype);"
msgstr ""
"void kobj_class_compile(kobj_class_t cls);\n"
"void kobj_class_compile_static(kobj_class_t cls, kobj_ops_t ops);\n"
"void kobj_class_free(kobj_class_t cls);\n"
"kobj_t kobj_create(kobj_class_t cls, struct malloc_type *mtype, int mflags);\n"
"void kobj_init(kobj_t obj, kobj_class_t cls);\n"
"void kobj_delete(kobj_t obj, struct malloc_type *mtype);"

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: book.translate.xml:3075 book.translate.xml:4164
#, fuzzy
msgid "Macros"
msgstr "Macros"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3077
#, no-wrap
msgid ""
"KOBJ_CLASS_FIELDS\n"
"KOBJ_FIELDS\n"
"DEFINE_CLASS(name, methods, size)\n"
"KOBJMETHOD(NAME, FUNC)"
msgstr ""
"KOBJ_CLASS_FIELDS\n"
"KOBJ_FIELDS\n"
"DEFINE_CLASS(name, methods, size)\n"
"KOBJMETHOD(NAME, FUNC)"

#. (itstool) path: sect2/title
#. (itstool) path: sect3/title
#: book.translate.xml:3084 book.translate.xml:4158
#, fuzzy
msgid "Headers"
msgstr "Cabe�alhos"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3086
#, no-wrap
msgid "&lt;sys/param.h&gt;\n"
"&lt;sys/kobj.h&gt;"
msgstr "&lt;sys/param.h&gt;\n"
"&lt;sys/kobj.h&gt;"

#. (itstool) path: sect2/title
#: book.translate.xml:3091
#, fuzzy
msgid "Creating an Interface Template"
msgstr "Criando um modelo de interface"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3093
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>interface</secondary>"
msgstr ""
" <primary> Objetos do Kernel </primary><secondary> interface </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3096
#, fuzzy
msgid ""
"The first step in using Kobj is to create an Interface. Creating the "
"interface involves creating a template that the script <filename>src/sys/"
"kern/makeobjops.pl</filename> can use to generate the header and code for "
"the method declarations and method lookup functions."
msgstr ""
"O primeiro passo para usar o Kobj � criar uma interface. Criar a interface "
"envolve criar um modelo que o script <filename> src / sys / kern / "
"makeobjops.pl </filename> pode usar para gerar o cabe�alho e c�digo para as "
"declara��es de m�todo e fun��es de pesquisa de m�todo. "

#. (itstool) path: sect2/para
#: book.translate.xml:3103
#, fuzzy
msgid ""
"Within this template the following keywords are used: <literal>#include</"
"literal>, <literal>INTERFACE</literal>, <literal>CODE</literal>, "
"<literal>METHOD</literal>, <literal>STATICMETHOD</literal>, and "
"<literal>DEFAULT</literal>."
msgstr ""
"Nesse modelo, as seguintes palavras-chave s�o usadas: <literal> #incluir </"
"literal> , <literal> INTERFACE </literal> , <literal> C�DIGO </literal> , "
"<literal> M�TODO </literal> , <literal> STATICMETHOD </literal> e <literal> "
"PADR�O </literal> "

#. (itstool) path: sect2/para
#: book.translate.xml:3109
#, fuzzy
msgid ""
"The <literal>#include</literal> statement and what follows it is copied "
"verbatim to the head of the generated code file."
msgstr ""
"O <literal> #incluir </literal> declara��o e o que se segue � copiado "
"textualmente para a cabe�a do arquivo de c�digo gerado. "

#. (itstool) path: sect2/para
#: book.translate.xml:3113 book.translate.xml:3122 book.translate.xml:3130
#: book.translate.xml:3143 book.translate.xml:3159 book.translate.xml:3196
#, fuzzy
msgid "For example:"
msgstr "Por exemplo:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3115
#, no-wrap
msgid "#include &lt;sys/foo.h&gt;"
msgstr "#include &lt;sys/foo.h&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:3117
#, fuzzy
msgid ""
"The <literal>INTERFACE</literal> keyword is used to define the interface "
"name. This name is concatenated with each method name as [interface "
"name]_[method name]. Its syntax is INTERFACE [interface name];."
msgstr ""
"O <literal> INTERFACE </literal> palavra-chave � usada para definir o nome "
"da interface. Este nome � concatenado com cada nome de m�todo como [nome da "
"interface] _ [nome do m�todo]. Sua sintaxe � INTERFACE [nome da interface] ;"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3124
#, no-wrap
msgid "INTERFACE foo;"
msgstr "INTERFACE foo;"

#. (itstool) path: sect2/para
#: book.translate.xml:3126
#, fuzzy
msgid ""
"The <literal>CODE</literal> keyword copies its arguments verbatim into the "
"code file. Its syntax is <literal>CODE { [whatever] };</literal>"
msgstr ""
"O <literal> C�DIGO </literal> A palavra-chave copia seus argumentos "
"literalmente no arquivo de c�digo. Sua sintaxe � <literal> CODE {[qualquer "
"que seja]}; </literal> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3132
#, no-wrap
msgid ""
"CODE {\n"
"\tstruct foo * foo_alloc_null(struct bar *)\n"
"\t{\n"
"\t\treturn NULL;\n"
"}\n"
"};"
msgstr ""
"CODE {\n"
"\tstruct foo * foo_alloc_null(struct bar *)\n"
"\t{\n"
"\t\treturn NULL;\n"
"}\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3139
#, fuzzy
msgid ""
"The <literal>METHOD</literal> keyword describes a method. Its syntax is "
"<literal>METHOD [return type] [method name] { [object [, arguments]] };</"
"literal>"
msgstr ""
"O <literal> M�TODO </literal> palavra-chave descreve um m�todo. Sua sintaxe "
"� <literal> M�TODO [tipo de retorno] [nome do m�todo] {[objeto [, "
"argumentos]]}; </literal> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3145
#, no-wrap
msgid "METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tstruct bar;\n"
"};"
msgstr "METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tstruct bar;\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3151
#, fuzzy
msgid ""
"The <literal>DEFAULT</literal> keyword may follow the <literal>METHOD</"
"literal> keyword. It extends the <literal>METHOD</literal> key word to "
"include the default function for method. The extended syntax is "
"<literal>METHOD [return type] [method name] { [object; [other arguments]] "
"}DEFAULT [default function];</literal>"
msgstr ""
"O <literal> PADR�O </literal> palavra-chave pode seguir o <literal> M�TODO </"
"literal> palavra chave. Estende o <literal> M�TODO </literal> palavra-chave "
"para incluir a fun��o padr�o para o m�todo. A sintaxe estendida � <literal> "
"M�TODO [tipo de retorno] [nome do m�todo] {[objeto; [outros argumentos]]} "
"PADR�O [fun��o padr�o]; </literal> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3161
#, no-wrap
msgid ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tint bar;\n"
"} DEFAULT foo_hack;"
msgstr ""
"METHOD int bar {\n"
"\tstruct object *;\n"
"\tstruct foo *;\n"
"\tint bar;\n"
"} DEFAULT foo_hack;"

#. (itstool) path: sect2/para
#: book.translate.xml:3167
#, fuzzy
msgid ""
"The <literal>STATICMETHOD</literal> keyword is used like the "
"<literal>METHOD</literal> keyword except the kobj data is not at the head of "
"the object structure so casting to kobj_t would be incorrect. Instead "
"<literal>STATICMETHOD</literal> relies on the Kobj data being referenced as "
"'ops'. This is also useful for calling methods directly out of a class's "
"method table."
msgstr ""
"O <literal> STATICMETHOD </literal> palavra-chave � usada como o <literal> "
"M�TODO </literal> a palavra-chave, exceto os dados do kobj, n�o est� na "
"cabe�a da estrutura do objeto, portanto, converter para kobj_t seria "
"incorreto. Em vez de <literal> STATICMETHOD </literal> depende dos dados do "
"Kobj sendo referenciados como ';ops';. Isso tamb�m � �til para chamar "
"m�todos diretamente da tabela de m�todos de uma classe. "

#. (itstool) path: sect2/para
#: book.translate.xml:3174
#, fuzzy
msgid "Other complete examples:"
msgstr "Outros exemplos completos:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3176
#, no-wrap
msgid "src/sys/kern/bus_if.m\n"
"src/sys/kern/device_if.m"
msgstr "src/sys/kern/bus_if.m\n"
"src/sys/kern/device_if.m"

#. (itstool) path: sect2/title
#: book.translate.xml:3182
#, fuzzy
msgid "Creating a Class"
msgstr "Criando uma classe"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3184
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>class</secondary>"
msgstr ""
" <primary> Objetos do Kernel </primary><secondary> classe </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3187
#, fuzzy
msgid ""
"The second step in using Kobj is to create a class. A class consists of a "
"name, a table of methods, and the size of objects if Kobj's object handling "
"facilities are used. To create the class use the macro "
"<function>DEFINE_CLASS()</function>. To create the method table create an "
"array of kobj_method_t terminated by a NULL entry. Each non-NULL entry may "
"be created using the macro <function>KOBJMETHOD()</function>."
msgstr ""
"O segundo passo para usar o Kobj � criar uma classe. Uma classe consiste em "
"um nome, uma tabela de m�todos e o tamanho dos objetos se os recursos de "
"manipula��o de objetos do Kobj forem usados. Para criar a classe use a macro "
"<function> DEFINE_CLASS () </function> . Para criar a tabela de m�todos, "
"crie uma matriz de kobj_method_t terminada por uma entrada NULL. Cada "
"entrada n�o-NULL pode ser criada usando a macro <function> KOBJMETHOD () </"
"function> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3198
#, no-wrap
msgid ""
"DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));\n"
"\n"
"kobj_method_t foomethods[] = {\n"
"\tKOBJMETHOD(bar_doo, foo_doo),\n"
"\tKOBJMETHOD(bar_foo, foo_foo),\n"
"\t{ NULL, NULL}\n"
"};"
msgstr ""
"DEFINE_CLASS(fooclass, foomethods, sizeof(struct foodata));\n"
"\n"
"kobj_method_t foomethods[] = {\n"
"\tKOBJMETHOD(bar_doo, foo_doo),\n"
"\tKOBJMETHOD(bar_foo, foo_foo),\n"
"\t{ NULL, NULL}\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:3206
#, fuzzy
msgid ""
"The class must be <quote>compiled</quote>. Depending on the state of the "
"system at the time that the class is to be initialized a statically "
"allocated cache, <quote>ops table</quote> have to be used. This can be "
"accomplished by declaring a <varname remap=\"structname\">struct kobj_ops</"
"varname> and using <function>kobj_class_compile_static();</function> "
"otherwise, <function>kobj_class_compile()</function> should be used."
msgstr ""
"A aula deve ser <quote> compilado </quote> . Dependendo do estado do sistema "
"no momento em que a classe ser� inicializada, um cache alocado "
"estaticamente, <quote> mesa de opera��es </quote> tem que ser usado. Isso "
"pode ser feito declarando um <varname remap=\"structname\"> struct kobj_ops "
"</varname> e usando <function> kobj_class_compile_static (); </function> de "
"outra forma, <function> kobj_class_compile () </function> deve ser usado."

#. (itstool) path: sect2/title
#: book.translate.xml:3216
#, fuzzy
msgid "Creating an Object"
msgstr "Criando um Objeto"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3218
#, fuzzy
msgid "<primary>Kernel Objects</primary> <secondary>object</secondary>"
msgstr ""
" <primary> Objetos do Kernel </primary><secondary> objeto </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3221
#, fuzzy
msgid ""
"The third step in using Kobj involves how to define the object. Kobj object "
"creation routines assume that Kobj data is at the head of an object. If this "
"in not appropriate you will have to allocate the object yourself and then "
"use <function>kobj_init()</function> on the Kobj portion of it; otherwise, "
"you may use <function>kobj_create()</function> to allocate and initialize "
"the Kobj portion of the object automatically. <function>kobj_init()</"
"function> may also be used to change the class that an object uses."
msgstr ""
"A terceira etapa no uso do Kobj envolve como definir o objeto. As rotinas de "
"cria��o de objetos do Kobj assumem que os dados do Kobj est�o na cabe�a de "
"um objeto. Se isso n�o for apropriado, voc� ter� que alocar o objeto e usar "
"<function> kobj_init () </function> na por��o de Kobj; caso contr�rio, voc� "
"pode usar <function> kobj_create () </function> para alocar e inicializar a "
"parte Kobj do objeto automaticamente. <function> kobj_init () </function> "
"tamb�m pode ser usado para alterar a classe que um objeto usa. "

#. (itstool) path: sect2/para
#: book.translate.xml:3231
#, fuzzy
msgid ""
"To integrate Kobj into the object you should use the macro KOBJ_FIELDS."
msgstr "Para integrar o Kobj no objeto voc� deve usar a macro KOBJ_FIELDS."

#. (itstool) path: sect2/para
#: book.translate.xml:3234
#, fuzzy
msgid "For example"
msgstr "Por exemplo"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3236
#, no-wrap
msgid "struct foo_data {\n"
"\tKOBJ_FIELDS;\n"
"\tfoo_foo;\n"
"\tfoo_bar;\n"
"};"
msgstr "struct foo_data {\n"
"\tKOBJ_FIELDS;\n"
"\tfoo_foo;\n"
"\tfoo_bar;\n"
"};"

#. (itstool) path: sect2/title
#: book.translate.xml:3244
#, fuzzy
msgid "Calling Methods"
msgstr "M�todos de Chamada"

#. (itstool) path: sect2/para
#: book.translate.xml:3246
#, fuzzy
msgid ""
"The last step in using Kobj is to simply use the generated functions to use "
"the desired method within the object's class. This is as simple as using the "
"interface name and the method name with a few modifications. The interface "
"name should be concatenated with the method name using a '_' between them, "
"all in upper case."
msgstr ""
"O �ltimo passo para usar o Kobj � simplesmente usar as fun��es geradas para "
"usar o m�todo desejado dentro da classe do objeto. Isso � t�o simples quanto "
"usar o nome da interface e o nome do m�todo com algumas modifica��es. O nome "
"da interface deve ser concatenado com o nome do m�todo usando um ';_'; entre "
"eles, tudo em mai�sculas. "

#. (itstool) path: sect2/para
#: book.translate.xml:3253
#, fuzzy
msgid ""
"For example, if the interface name was foo and the method was bar then the "
"call would be:"
msgstr ""
"Por exemplo, se o nome da interface fosse foo e o m�todo fosse bar, a "
"chamada seria:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3256
#, no-wrap
msgid "[return value = ] FOO_BAR(object [, other parameters]);"
msgstr "[return value = ] FOO_BAR(object [, other parameters]);"

#. (itstool) path: sect2/title
#: book.translate.xml:3261
#, fuzzy
msgid "Cleaning Up"
msgstr "Limpando"

#. (itstool) path: sect2/para
#: book.translate.xml:3263
#, fuzzy
msgid ""
"When an object allocated through <function>kobj_create()</function> is no "
"longer needed <function>kobj_delete()</function> may be called on it, and "
"when a class is no longer being used <function>kobj_class_free()</function> "
"may be called on it."
msgstr ""
"Quando um objeto alocado atrav�s <function> kobj_create () </function> n�o � "
"mais necess�rio <function> kobj_delete () </function> pode ser chamado, e "
"quando uma aula n�o est� mais sendo usada <function> kobj_class_free () </"
"function> pode ser chamado. "

#. (itstool) path: info/title
#: book.translate.xml:3280
#, fuzzy
msgid "The Jail Subsystem"
msgstr "O Subsistema da Cadeia"

#. (itstool) path: affiliation/address
#: book.translate.xml:3288
#, fuzzy, no-wrap
msgid "\n"
"\t  <email>evms@cs.bu.edu</email>\n"
"\t"
msgstr "<email>evms@cs.bu.edu</email>"

#. (itstool) path: info/author
#: book.translate.xml:3282
#, fuzzy
msgid ""
"<personname> <firstname>Evan</firstname> <surname>Sarmiento</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
" <personname><firstname> Evan </firstname><surname> Sarmiento </surname></"
"personname><affiliation> <_: endere�o-1 /> </affiliation> "

#. (itstool) path: info/copyright
#: book.translate.xml:3293
#, fuzzy
msgid ""
"<year>2001</year> <holder role=\"mailto:evms@cs.bu.edu\">Evan Sarmiento</"
"holder>"
msgstr ""
" <year> 2001 </year><holder role=\"mailto:evms@cs.bu.edu\"> Evan Sarmiento </"
"holder> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:3299
#, fuzzy
msgid "<primary>security</primary>"
msgstr " <primary> seguran�a </primary> "

#. (itstool) path: chapter/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:3300 book.translate.xml:15439
#, fuzzy
msgid "<primary>Jail</primary>"
msgstr " <primary> Cadeia </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:3301
#, fuzzy
msgid "<primary>root</primary>"
msgstr " <primary> raiz </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:3303
#, fuzzy
msgid ""
"On most <trademark class=\"registered\">UNIX</trademark> systems, "
"<literal>root</literal> has omnipotent power. This promotes insecurity. If "
"an attacker gained <literal>root</literal> on a system, he would have every "
"function at his fingertips. In FreeBSD there are sysctls which dilute the "
"power of <literal>root</literal>, in order to minimize the damage caused by "
"an attacker. Specifically, one of these functions is called <literal>secure "
"levels</literal>. Similarly, another function which is present from FreeBSD "
"4.0 and onward, is a utility called <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>. <application>Jail</"
"application> chroots an environment and sets certain restrictions on "
"processes which are forked within the <application>jail</application>. For "
"example, a jailed process cannot affect processes outside the "
"<application>jail</application>, utilize certain system calls, or inflict "
"any damage on the host environment."
msgstr ""
"Na maioria <trademark class=\"registered\"> UNIX </trademark> sistemas, "
"<literal> raiz </literal> tem poder onipotente. Isso promove inseguran�a. Se "
"um atacante ganhou <literal> raiz </literal> em um sistema, ele teria todas "
"as fun��es na ponta dos dedos. No FreeBSD existem sysctls que diluem o poder "
"de <literal> raiz </literal> , a fim de minimizar os danos causados ​​por um "
"invasor. Especificamente, uma dessas fun��es � chamada <literal> n�veis "
"seguros </literal> . Similarmente, outra fun��o presente no FreeBSD 4.0 e em "
"diante, � um utilit�rio chamado <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> . <application> "
"Cadeia </application> chroots um ambiente e define certas restri��es em "
"processos que s�o bifurcados dentro do <application> cadeia </application> . "
"Por exemplo, um processo preso n�o pode afetar processos fora do "
"<application> cadeia </application> , utilizar determinadas chamadas do "
"sistema ou causar danos ao ambiente do host. "

#. (itstool) path: chapter/para
#: book.translate.xml:3318
#, fuzzy
msgid ""
"<application>Jail</application> is becoming the new security model. People "
"are running potentially vulnerable servers such as <application>Apache</"
"application>, <application>BIND</application>, and <application>sendmail</"
"application> within jails, so that if an attacker gains <literal>root</"
"literal> within the <application>jail</application>, it is only an "
"annoyance, and not a devastation. This article mainly focuses on the "
"internals (source code) of <application>jail</application>. For information "
"on how to set up a jail see the <link xlink:href=\"@@URL_RELPREFIX@@/doc/"
"en_US.ISO8859-1/books/handbook/jails.html\">handbook entry on jails</link>."
msgstr ""
" <application> Cadeia </application> est� se tornando o novo modelo de "
"seguran�a. As pessoas est�o executando servidores potencialmente "
"vulner�veis, como <application> Apache </application> , <application> LIGAR "
"</application> e <application> enviar correio </application> dentro de "
"cadeias, de modo que se um atacante ganha <literal> raiz </literal> dentro "
"do <application> cadeia </application> , � apenas um aborrecimento e n�o uma "
"devasta��o. Este artigo foca principalmente os internos (c�digo fonte) de "
"<application> cadeia </application> . Para obter informa��es sobre como "
"configurar uma cadeia, consulte o <link xlink:href=\"@@URL_RELPREFIX@@/doc/"
"en_US.ISO8859-1/books/handbook/jails.html\"> entrada do manual nas cadeias </"
"link> "

#. (itstool) path: sect1/title
#: book.translate.xml:3331
#, fuzzy
msgid "Architecture"
msgstr "Arquitetura"

#. (itstool) path: sect1/para
#: book.translate.xml:3333
#, fuzzy
msgid ""
"<application>Jail</application> consists of two realms: the userland "
"program, <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, and the code implemented within the kernel: the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and associated restrictions. I will be discussing "
"the userland program and then how <application>jail</application> is "
"implemented within the kernel."
msgstr ""
" <application> Cadeia </application> consiste em dois reinos: o programa "
"userland, <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 "
"</manvolnum></citerefentry> , eo c�digo implementado dentro do kernel: o "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada do sistema e restri��es associadas. Eu "
"estarei discutindo o programa userland e, em seguida, como <application> "
"cadeia </application> � implementado dentro do kernel. "

#. (itstool) path: sect2/title
#: book.translate.xml:3341
#, fuzzy
msgid "Userland Code"
msgstr "C�digo da Terra de Usu�rio"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3343
#, fuzzy
msgid "<primary>Jail</primary> <secondary>Userland Program</secondary>"
msgstr ""
" <primary> Cadeia </primary><secondary> Programa Userland </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3346
#, fuzzy
msgid ""
"The source for the userland <application>jail</application> is located in "
"<filename>/usr/src/usr.sbin/jail</filename>, consisting of one file, "
"<filename>jail.c</filename>. The program takes these arguments: the path of "
"the <application>jail</application>, hostname, IP address, and the command "
"to be executed."
msgstr ""
"A fonte para a terra do usu�rio <application> cadeia </application> est� "
"localizado em <filename> /usr/src/usr.sbin/jail </filename> , consistindo de "
"um arquivo, <filename> jail.c </filename> . O programa pega esses argumentos:"
" o caminho do <application> cadeia </application> , hostname, endere�o IP e "
"o comando a ser executado. "

#. (itstool) path: sect3/title
#: book.translate.xml:3354
#, fuzzy
msgid "Data Structures"
msgstr "Estruturas de dados"

#. (itstool) path: sect3/para
#: book.translate.xml:3356
#, fuzzy
msgid ""
"In <filename>jail.c</filename>, the first thing I would note is the "
"declaration of an important structure <literal>struct jail j;</literal> "
"which was included from <filename>/usr/include/sys/jail.h</filename>."
msgstr ""
"Dentro <filename> jail.c </filename> , a primeira coisa que eu gostaria de "
"observar � a declara��o de uma estrutura importante <literal> struct jail j; "
"</literal> que foi inclu�do a partir de <filename> /usr/include/sys/jail.h </"
"filename> "

#. (itstool) path: sect3/para
#: book.translate.xml:3361
#, fuzzy
msgid "The definition of the <literal>jail</literal> structure is:"
msgstr "A defini��o do <literal> cadeia </literal> estrutura �: "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3364
#, no-wrap
msgid ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"\n"
"struct jail {\n"
"        u_int32_t       version;\n"
"        char            *path;\n"
"        char            *hostname;\n"
"        u_int32_t       ip_number;\n"
"};"
msgstr ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"\n"
"struct jail {\n"
"        u_int32_t       version;\n"
"        char            *path;\n"
"        char            *hostname;\n"
"        u_int32_t       ip_number;\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3373
#, fuzzy
msgid ""
"As you can see, there is an entry for each of the arguments passed to the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program, and indeed, they are set during its execution."
msgstr ""
"Como voc� pode ver, h� uma entrada para cada um dos argumentos passados "
"​​para o <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 8 "
"</manvolnum></citerefentry> programa, e, de fato, eles s�o definidos durante "
"a sua execu��o \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3377
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"char path[PATH_MAX];\n"
"...\n"
"if (realpath(argv[0], path) == NULL)\n"
"    err(1, \"realpath: %s\", argv[0]);\n"
"if (chdir(path) != 0)\n"
"    err(1, \"chdir: %s\", path);\n"
"memset(&amp;j, 0, sizeof(j));\n"
"j.version = 0;\n"
"j.path = path;\n"
"j.hostname = argv[1];"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"char path[PATH_MAX];\n"
"...\n"
"if (realpath(argv[0], path) == NULL)\n"
"    err(1, \"realpath: %s\", argv[0]);\n"
"if (chdir(path) != 0)\n"
"    err(1, \"chdir: %s\", path);\n"
"memset(&amp;j, 0, sizeof(j));\n"
"j.version = 0;\n"
"j.path = path;\n"
"j.hostname = argv[1];"

#. (itstool) path: sect3/title
#: book.translate.xml:3391
#, fuzzy
msgid "Networking"
msgstr "Networking"

#. (itstool) path: sect3/para
#: book.translate.xml:3393
#, fuzzy
msgid ""
"One of the arguments passed to the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> program is an IP "
"address with which the <application>jail</application> can be accessed over "
"the network. <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry> translates the IP address given into host byte "
"order and then stores it in <literal>j</literal> (the <literal>jail</"
"literal> structure)."
msgstr ""
"Um dos argumentos passou para o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> programa � um "
"endere�o IP com o qual o <application> cadeia </application> pode ser "
"acessado pela rede. <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> traduz o endere�o IP "
"dado em ordem de byte host e, em seguida, armazena em <literal> j </literal> "
"(a <literal> cadeia </literal> estrutura)."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3400
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>:\n"
"struct in_addr in;\n"
"...\n"
"if (inet_aton(argv[2], &amp;in) == 0)\n"
"    errx(1, \"Could not make sense of ip-number: %s\", argv[2]);\n"
"j.ip_number = ntohl(in.s_addr);"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>:\n"
"struct in_addr in;\n"
"...\n"
"if (inet_aton(argv[2], &amp;in) == 0)\n"
"    errx(1, \"Could not make sense of ip-number: %s\", argv[2]);\n"
"j.ip_number = ntohl(in.s_addr);"

#. (itstool) path: sect3/para
#: book.translate.xml:3407
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>inet_aton</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> function \"interprets the specified character "
"string as an Internet address, placing the address into the structure "
"provided.\" The <literal>ip_number</literal> member in the <literal>jail</"
"literal> structure is set only when the IP address placed onto the "
"<literal>in</literal> structure by <citerefentry><refentrytitle>inet_aton</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry> is translated into "
"host byte order by <citerefentry><refentrytitle>ntohl</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>."
msgstr ""
"O <citerefentry><refentrytitle> inet_aton </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> A fun��o \\ \"interpreta a cadeia de caracteres "
"especificada como um endere�o da Internet, colocando o endere�o na estrutura "
"fornecida. \" <literal> ip_number </literal> membro no <literal> cadeia </"
"literal> estrutura � definida apenas quando o endere�o IP colocado no "
"<literal> dentro </literal> estrutura por <citerefentry><refentrytitle> "
"inet_aton </refentrytitle><manvolnum> 3 </manvolnum></citerefentry> � "
"traduzido em ordem de byte host por <citerefentry><refentrytitle> ntohl </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#. (itstool) path: sect3/title
#: book.translate.xml:3418
#, fuzzy
msgid "Jailing the Process"
msgstr "Prendendo o Processo"

#. (itstool) path: sect3/para
#: book.translate.xml:3420
#, fuzzy
msgid ""
"Finally, the userland program jails the process. <application>Jail</"
"application> now becomes an imprisoned process itself and then executes the "
"command given using <citerefentry><refentrytitle>execv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>."
msgstr ""
"Finalmente, o programa userland reprime o processo. <application> Cadeia </"
"application> agora se torna um processo preso em si e, em seguida, executa o "
"comando dado usando <citerefentry><refentrytitle> execv </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3425
#, no-wrap
msgid ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"i = jail(&amp;j);\n"
"...\n"
"if (execv(argv[3], argv + 3) != 0)\n"
"    err(1, \"execv: %s\", argv[3]);"
msgstr ""
"<filename>/usr/src/usr.sbin/jail/jail.c</filename>\n"
"i = jail(&amp;j);\n"
"...\n"
"if (execv(argv[3], argv + 3) != 0)\n"
"    err(1, \"execv: %s\", argv[3]);"

#. (itstool) path: sect3/para
#: book.translate.xml:3431
#, fuzzy
msgid ""
"As you can see, the <literal>jail()</literal> function is called, and its "
"argument is the <literal>jail</literal> structure which has been filled with "
"the arguments given to the program. Finally, the program you specify is "
"executed. I will now discuss how <application>jail</application> is "
"implemented within the kernel."
msgstr ""
"Como voc� pode ver, o <literal> cadeia() </literal> fun��o � chamada, e seu "
"argumento � o <literal> cadeia </literal> estrutura que foi preenchida com "
"os argumentos dados ao programa. Finalmente, o programa que voc� especifica "
"� executado. Agora vou discutir como <application> cadeia </application> � "
"implementado dentro do kernel. "

#. (itstool) path: sect2/title
#: book.translate.xml:3441
#, fuzzy
msgid "Kernel Space"
msgstr "Espa�o do Kernel"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3443
#, fuzzy
msgid "<primary>Jail</primary> <secondary>Kernel Architecture</secondary>"
msgstr ""
" <primary> Cadeia </primary><secondary> Arquitetura do Kernel </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3446
#, fuzzy
msgid ""
"We will now be looking at the file <filename>/usr/src/sys/kern/kern_jail.c</"
"filename>. This is the file where the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call, "
"appropriate sysctls, and networking functions are defined."
msgstr ""
"Vamos agora olhar para o arquivo <filename> /usr/src/sys/kern/kern_jail.c </"
"filename> . Este � o arquivo onde o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema, "
"sysctls apropriados e fun��es de rede s�o definidos. "

#. (itstool) path: sect3/title
#: book.translate.xml:3452
#, fuzzy
msgid "Sysctls"
msgstr "Sysctl"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:3454
#, fuzzy
msgid "<primary>sysctl</primary>"
msgstr " <primary> sysctl </primary> "

#. (itstool) path: sect3/para
#: book.translate.xml:3456
#, fuzzy
msgid ""
"In <filename>kern_jail.c</filename>, the following sysctls are defined:"
msgstr ""
"Dentro <filename> kern_jail.c </filename> , os seguintes sysctls s�o "
"definidos: "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3459
#, fuzzy, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int     jail_set_hostname_allowed = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,\n"
"    &amp;jail_set_hostname_allowed, 0,\n"
"    \"Processes in jail can set their hostnames\");\n"
"\n"
"int     jail_socket_unixiproute_only = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,\n"
"    &amp;jail_socket_unixiproute_only, 0,\n"
"    \"Processes in jail are limited to creating UNIX/IPv4/route sockets "
"only\");\n"
"\n"
"int     jail_sysvipc_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,\n"
"    &amp;jail_sysvipc_allowed, 0,\n"
"    \"Processes in jail can use System V IPC primitives\");\n"
"\n"
"static int jail_enforce_statfs = 2;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,\n"
"    &amp;jail_enforce_statfs, 0,\n"
"    \"Processes in jail cannot see all mounted file systems\");\n"
"\n"
"int    jail_allow_raw_sockets = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,\n"
"    &amp;jail_allow_raw_sockets, 0,\n"
"    \"Prison root can create raw sockets\");\n"
"\n"
"int    jail_chflags_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,\n"
"    &amp;jail_chflags_allowed, 0,\n"
"    \"Processes in jail can alter system file flags\");\n"
"\n"
"int     jail_mount_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,\n"
"    &amp;jail_mount_allowed, 0,\n"
"    \"Processes in jail can mount/unmount jail-friendly file systems\");"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"\n"
"int     jail_set_hostname_allowed = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, set_hostname_allowed, CTLFLAG_RW,\n"
"    &amp;jail_set_hostname_allowed, 0,\n"
"    \"Processes in jail can set their hostnames\");\n"
"\n"
"int     jail_socket_unixiproute_only = 1;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, socket_unixiproute_only, CTLFLAG_RW,\n"
"    &amp;jail_socket_unixiproute_only, 0,\n"
"    \"Processes in jail are limited to creating UNIX/IPv4/route sockets "
"only\");\n"
"\n"
"int     jail_sysvipc_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, sysvipc_allowed, CTLFLAG_RW,\n"
"    &amp;jail_sysvipc_allowed, 0,\n"
"    \"Processes in jail can use System V IPC primitives\");\n"
"\n"
"static int jail_enforce_statfs = 2;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, enforce_statfs, CTLFLAG_RW,\n"
"    &amp;jail_enforce_statfs, 0,\n"
"    \"Processes in jail cannot see all mounted file systems\");\n"
"\n"
"int    jail_allow_raw_sockets = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, allow_raw_sockets, CTLFLAG_RW,\n"
"    &amp;jail_allow_raw_sockets, 0,\n"
"    \"Prison root can create raw sockets\");\n"
"\n"
"int    jail_chflags_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, chflags_allowed, CTLFLAG_RW,\n"
"    &amp;jail_chflags_allowed, 0,\n"
"    \"Processes in jail can alter system file flags\");\n"
"\n"
"int     jail_mount_allowed = 0;\n"
"SYSCTL_INT(_security_jail, OID_AUTO, mount_allowed, CTLFLAG_RW,\n"
"    &amp;jail_mount_allowed, 0,\n"
"    \"Processes in jail can mount/unmount jail-friendly file systems\");"

#. (itstool) path: sect3/para
#: book.translate.xml:3495
#, fuzzy
msgid ""
"Each of these sysctls can be accessed by the user through the "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> program. Throughout the kernel, these specific sysctls are "
"recognized by their name. For example, the name of the first sysctl is "
"<literal>security.jail.set_hostname_allowed</literal>."
msgstr ""
"Cada um desses sysctls pode ser acessado pelo usu�rio atrav�s do "
"<citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> programa. Em todo o kernel, esses sysctls "
"espec�ficos s�o reconhecidos pelo nome. Por exemplo, o nome do primeiro "
"sysctl � <literal> security.jail.set_hostname_allowed </literal> "

#. (itstool) path: sect3/title
#: book.translate.xml:3503
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> System Call"
msgstr ""
" <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> Chamada de sistema "

#. (itstool) path: sect3/para
#: book.translate.xml:3505
#, fuzzy
msgid ""
"Like all system calls, the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call takes two "
"arguments, <literal>struct thread *td</literal> and <literal>struct "
"jail_args *uap</literal>. <literal>td</literal> is a pointer to the "
"<literal>thread</literal> structure which describes the calling thread. In "
"this context, <literal>uap</literal> is a pointer to the structure in which "
"a pointer to the <literal>jail</literal> structure passed by the userland "
"<filename>jail.c</filename> is contained. When I described the userland "
"program before, you saw that the <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> system call was given "
"a <literal>jail</literal> structure as its own argument."
msgstr ""
"Como todas as chamadas do sistema, o <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema "
"leva dois argumentos, <literal> struct thread * td </literal> e <literal> "
"struct jail_args * uap </literal> . <literal> td </literal> � um ponteiro "
"para o <literal> fio </literal> estrutura que descreve o segmento de chamada."
" Neste contexto, <literal> uap </literal> � um ponteiro para a estrutura em "
"que um ponteiro para o <literal> cadeia </literal> estrutura passada pelo "
"userland <filename> jail.c </filename> Est� contido. Quando eu descrevi o "
"programa userland antes, voc� viu que o <citerefentry><refentrytitle> cadeia "
"</refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de sistema "
"foi dada uma <literal> cadeia </literal> estrutura como seu pr�prio "
"argumento \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3518
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"/*\n"
" * struct jail_args {\n"
" *  struct jail *jail;\n"
" * };\n"
" */\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"/*\n"
" * struct jail_args {\n"
" *  struct jail *jail;\n"
" * };\n"
" */\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)"

#. (itstool) path: sect3/para
#: book.translate.xml:3527
#, fuzzy
msgid ""
"Therefore, <literal>uap-&gt;jail</literal> can be used to access the "
"<literal>jail</literal> structure which was passed to the system call. Next, "
"the system call copies the <literal>jail</literal> structure into kernel "
"space using the <citerefentry><refentrytitle>copyin</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> function. "
"<citerefentry><refentrytitle>copyin</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> takes three arguments: the address of the data which is to be "
"copied into kernel space, <literal>uap-&gt;jail</literal>, where to store "
"it, <literal>j</literal> and the size of the storage. The <literal>jail</"
"literal> structure pointed by <literal>uap-&gt;jail</literal> is copied into "
"kernel space and is stored in another <literal>jail</literal> structure, "
"<literal>j</literal>."
msgstr ""
"Assim sendo, <literal> uap-&gt; cadeia </literal> pode ser usado para "
"acessar o <literal> cadeia </literal> estrutura que foi passada para a "
"chamada do sistema. Em seguida, a chamada do sistema copia <literal> cadeia "
"</literal> estrutura no espa�o do kernel usando o "
"<citerefentry><refentrytitle> copiando </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> fun��o. <citerefentry><refentrytitle> copiando </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> leva tr�s argumentos:"
" o endere�o dos dados que devem ser copiados no espa�o do kernel, <literal> "
"uap-&gt; cadeia </literal> , onde armazen�-lo <literal> j </literal> e o "
"tamanho do armazenamento. o <literal> cadeia </literal> estrutura apontada "
"por <literal> uap-&gt; cadeia </literal> � copiado para o espa�o do kernel e "
"� armazenado em outro <literal> cadeia </literal> estrutura, <literal> j </"
"literal> "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3540
#, fuzzy, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"error = copyin(uap-&gt;jail, &amp;j, sizeof(j));"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c: </filename>\n"
"error = copyin(uap-&gt;jail, &amp;j, sizeof(j));"

#. (itstool) path: sect3/para
#: book.translate.xml:3543
#, fuzzy
msgid ""
"There is another important structure defined in <filename>jail.h</filename>. "
"It is the <literal>prison</literal> structure. The <literal>prison</literal> "
"structure is used exclusively within kernel space. Here is the definition of "
"the <literal>prison</literal> structure."
msgstr ""
"Existe outra estrutura importante definida em <filename> jail.h </filename> ."
" � o <literal> pris�o </literal> estrutura. o <literal> pris�o </literal> "
"estrutura � usada exclusivamente dentro do espa�o do kernel. Aqui est� a "
"defini��o do <literal> pris�o </literal> estrutura."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3550
#, no-wrap
msgid ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"struct prison {\n"
"        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */"
"\n"
"        int              pr_id;                         /* (c) prison id */\n"
"        int              pr_ref;                        /* (p) refcount */\n"
"        char             pr_path[MAXPATHLEN];           /* (c) chroot path */"
"\n"
"        struct vnode    *pr_root;                       /* (c) vnode to rdir "
"*/\n"
"        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname "
"*/\n"
"        u_int32_t        pr_ip;                         /* (c) ip addr host "
"*/\n"
"        void            *pr_linux;                      /* (p) linux abi */\n"
"        int              pr_securelevel;                /* (p) securelevel */"
"\n"
"        struct task      pr_task;                       /* (d) destroy task "
"*/\n"
"        struct mtx       pr_mtx;\n"
"      void            **pr_slots;                     /* (p) additional data "
"*/\n"
"};"
msgstr ""
"<filename>/usr/include/sys/jail.h</filename>:\n"
"struct prison {\n"
"        LIST_ENTRY(prison) pr_list;                     /* (a) all prisons */"
"\n"
"        int              pr_id;                         /* (c) prison id */\n"
"        int              pr_ref;                        /* (p) refcount */\n"
"        char             pr_path[MAXPATHLEN];           /* (c) chroot path */"
"\n"
"        struct vnode    *pr_root;                       /* (c) vnode to rdir "
"*/\n"
"        char             pr_host[MAXHOSTNAMELEN];       /* (p) jail hostname "
"*/\n"
"        u_int32_t        pr_ip;                         /* (c) ip addr host "
"*/\n"
"        void            *pr_linux;                      /* (p) linux abi */\n"
"        int              pr_securelevel;                /* (p) securelevel */"
"\n"
"        struct task      pr_task;                       /* (d) destroy task "
"*/\n"
"        struct mtx       pr_mtx;\n"
"      void            **pr_slots;                     /* (p) additional data "
"*/\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3566
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> system call then allocates memory for a "
"<literal>prison</literal> structure and copies data between the "
"<literal>jail</literal> and <literal>prison</literal> structure."
msgstr ""
"O <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada de sistema, em seguida, aloca mem�ria para "
"um <literal> pris�o </literal> estrutura e copia dados entre o <literal> "
"cadeia </literal> e <literal> pris�o </literal> estrutura."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3571
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);\n"
"...\n"
"error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);\n"
"if (error)\n"
"    goto e_killmtx;\n"
"...\n"
"error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), "
"0);\n"
"if (error)\n"
"     goto e_dropvnref;\n"
"pr-&gt;pr_ip = j.ip_number;"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"MALLOC(pr, struct prison *, sizeof(*pr), M_PRISON, M_WAITOK | M_ZERO);\n"
"...\n"
"error = copyinstr(j.path, &amp;pr-&gt;pr_path, sizeof(pr-&gt;pr_path), 0);\n"
"if (error)\n"
"    goto e_killmtx;\n"
"...\n"
"error = copyinstr(j.hostname, &amp;pr-&gt;pr_host, sizeof(pr-&gt;pr_host), "
"0);\n"
"if (error)\n"
"     goto e_dropvnref;\n"
"pr-&gt;pr_ip = j.ip_number;"

#. (itstool) path: sect3/para
#: book.translate.xml:3583
#, fuzzy
msgid ""
"Next, we will discuss another important system call "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>, which implements the function to put a process "
"into the <application>jail</application>."
msgstr ""
"Em seguida, discutiremos outra importante chamada do sistema "
"<citerefentry><refentrytitle> jail_attach </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , que implementa a fun��o de colocar um processo "
"no <application> cadeia </application> "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3587
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"/*\n"
" * struct jail_attach_args {\n"
" *      int jid;\n"
" * };\n"
" */\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>:\n"
"/*\n"
" * struct jail_attach_args {\n"
" *      int jid;\n"
" * };\n"
" */\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)"

#. (itstool) path: sect3/para
#: book.translate.xml:3596
#, fuzzy
msgid ""
"This system call makes the changes that can distinguish a jailed process "
"from those unjailed ones. To understand what "
"<citerefentry><refentrytitle>jail_attach</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> does for us, certain background information is "
"needed."
msgstr ""
"Esta chamada de sistema faz as mudan�as que podem distinguir um processo "
"preso daqueles que foram desencadeados. Para entender o que "
"<citerefentry><refentrytitle> jail_attach </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> para n�s, certas informa��es b�sicas s�o "
"necess�rias \""

#. (itstool) path: sect3/para
#: book.translate.xml:3601
#, fuzzy
msgid ""
"On FreeBSD, each kernel visible thread is identified by its <literal>thread</"
"literal> structure, while the processes are described by their "
"<literal>proc</literal> structures. You can find the definitions of the "
"<literal>thread</literal> and <literal>proc</literal> structure in "
"<filename>/usr/include/sys/proc.h</filename>. For example, the <literal>td</"
"literal> argument in any system call is actually a pointer to the calling "
"thread's <literal>thread</literal> structure, as stated before. The "
"<literal>td_proc</literal> member in the <literal>thread</literal> structure "
"pointed by <literal>td</literal> is a pointer to the <literal>proc</literal> "
"structure which represents the process that contains the thread represented "
"by <literal>td</literal>. The <literal>proc</literal> structure contains "
"members which can describe the owner's identity(<literal>p_ucred</literal>), "
"the process resource limits(<literal>p_limit</literal>), and so on. In the "
"<literal>ucred</literal> structure pointed by <literal>p_ucred</literal> "
"member in the <literal>proc</literal> structure, there is a pointer to the "
"<literal>prison</literal> structure(<literal>cr_prison</literal>)."
msgstr ""
"No FreeBSD, cada thread vis�vel do kernel � identificado por sua <literal> "
"fio </literal> estrutura, enquanto os processos s�o descritos por seus "
"<literal> proc </literal> estruturas. Voc� pode encontrar as defini��es do "
"<literal> fio </literal> e <literal> proc </literal> estrutura em <filename> "
"/usr/include/sys/proc.h </filename> . Por exemplo, o <literal> td </literal> "
"argumento em qualquer chamada do sistema � realmente um ponteiro para o "
"segmento de chamada <literal> fio </literal> estrutura, como dito "
"anteriormente. o <literal> td_proc </literal> membro no <literal> fio </"
"literal> estrutura apontada por <literal> td </literal> � um ponteiro para o "
"<literal> proc </literal> estrutura que representa o processo que cont�m o "
"segmento representado por <literal> td </literal> . o <literal> proc </"
"literal> estrutura cont�m membros que podem descrever a identidade do "
"propriet�rio ( <literal> p_ucred </literal> ), os limites de recursos do "
"processo ( <literal> p_limit </literal> ), e assim por diante. No <literal> "
"ucred </literal> estrutura apontada por <literal> p_ucred </literal> membro "
"no <literal> proc </literal> estrutura, h� um ponteiro para o <literal> "
"pris�o </literal> estrutura( <literal> cr_prison </literal> ) "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3625
#, fuzzy, no-wrap
msgid ""
"<filename>/usr/include/sys/proc.h:</filename>\n"
"struct thread {\n"
"    ...\n"
"    struct proc *td_proc;\n"
"    ...\n"
"};\n"
"struct proc {\n"
"    ...\n"
"    struct ucred *p_ucred;\n"
"    ...\n"
"};\n"
"<filename>/usr/include/sys/ucred.h</filename>\n"
"struct ucred {\n"
"    ...\n"
"    struct prison *cr_prison;\n"
"    ...\n"
"};"
msgstr ""
"<filename>/usr/include/sys/proc.h: </filename>\n"
"struct thread {\n"
"    ...\n"
"    struct proc *td_proc;\n"
"    ...\n"
"};\n"
"struct proc {\n"
"    ...\n"
"    struct ucred *p_ucred;\n"
"    ...\n"
"};\n"
"<filename>/usr/include/sys/ucred.h</filename>\n"
"struct ucred {\n"
"    ...\n"
"    struct prison *cr_prison;\n"
"    ...\n"
"};"

#. (itstool) path: sect3/para
#: book.translate.xml:3643
#, fuzzy
msgid ""
"In <filename>kern_jail.c</filename>, the function <literal>jail()</literal> "
"then calls function <literal>jail_attach()</literal> with a given "
"<literal>jid</literal>. And <literal>jail_attach()</literal> calls function "
"<literal>change_root()</literal> to change the root directory of the calling "
"process. The <literal>jail_attach()</literal> then creates a new "
"<literal>ucred</literal> structure, and attaches the newly created "
"<literal>ucred</literal> structure to the calling process after it has "
"successfully attached the <literal>prison</literal> structure to the "
"<literal>ucred</literal> structure. From then on, the calling process is "
"recognized as jailed. When the kernel routine <literal>jailed()</literal> is "
"called in the kernel with the newly created <literal>ucred</literal> "
"structure as its argument, it returns 1 to tell that the credential is "
"connected with a <application>jail</application>. The public ancestor "
"process of all the process forked within the <application>jail</"
"application>, is the process which runs <citerefentry><refentrytitle>jail</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, as it calls the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call. When a program is executed through "
"<citerefentry><refentrytitle>execve</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, it inherits the jailed property of its parent's "
"<literal>ucred</literal> structure, therefore it has a jailed "
"<literal>ucred</literal> structure."
msgstr ""
"Dentro <filename> kern_jail.c </filename> , a fun��o <literal> cadeia() </"
"literal> ent�o chama a fun��o <literal> jail_attach () </literal> com um "
"dado <literal> jid </literal> . E <literal> jail_attach () </literal> chama "
"a fun��o <literal> change_root () </literal> para alterar o diret�rio raiz "
"do processo de chamada. o <literal> jail_attach () </literal> ent�o cria um "
"novo <literal> ucred </literal> estrutura e anexa o rec�m-criado <literal> "
"ucred </literal> estrutura para o processo de chamada depois de ter anexado "
"com sucesso o <literal> pris�o </literal> estrutura para o <literal> ucred </"
"literal> estrutura. A partir de ent�o, o processo de chamada � reconhecido "
"como encarcerado. Quando a rotina do kernel <literal> preso () </literal> � "
"chamado no kernel com o rec�m-criado <literal> ucred </literal> estrutura "
"como seu argumento, ele retorna 1 para dizer que a credencial est� conectada "
"<application> cadeia </application> . O processo ancestral p�blico de todo o "
"processo bifurcado dentro do <application> cadeia </application> � o "
"processo que executa <citerefentry><refentrytitle> cadeia </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> como ele chama "
"<citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> chamada do sistema. Quando um programa � executado "
"atrav�s de <citerefentry><refentrytitle> execve </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> , herda a propriedade encarcerada de seus pais "
"<literal> ucred </literal> estrutura, portanto, tem uma pris�o <literal> "
"ucred </literal> estrutura."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3669
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)\n"
"{\n"
"...\n"
"    struct jail_attach_args jaa;\n"
"...\n"
"    error = jail_attach(td, &amp;jaa);\n"
"    if (error)\n"
"        goto e_dropprref;\n"
"...\n"
"}\n"
"\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)\n"
"{\n"
"    struct proc *p;\n"
"    struct ucred *newcred, *oldcred;\n"
"    struct prison *pr;\n"
"...\n"
"    p = td-&gt;td_proc;\n"
"...\n"
"    pr = prison_find(uap-&gt;jid);\n"
"...\n"
"    change_root(pr-&gt;pr_root, td);\n"
"...\n"
"    newcred-&gt;cr_prison = pr;\n"
"    p-&gt;p_ucred = newcred;\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"jail(struct thread *td, struct jail_args *uap)\n"
"{\n"
"...\n"
"    struct jail_attach_args jaa;\n"
"...\n"
"    error = jail_attach(td, &amp;jaa);\n"
"    if (error)\n"
"        goto e_dropprref;\n"
"...\n"
"}\n"
"\n"
"int\n"
"jail_attach(struct thread *td, struct jail_attach_args *uap)\n"
"{\n"
"    struct proc *p;\n"
"    struct ucred *newcred, *oldcred;\n"
"    struct prison *pr;\n"
"...\n"
"    p = td-&gt;td_proc;\n"
"...\n"
"    pr = prison_find(uap-&gt;jid);\n"
"...\n"
"    change_root(pr-&gt;pr_root, td);\n"
"...\n"
"    newcred-&gt;cr_prison = pr;\n"
"    p-&gt;p_ucred = newcred;\n"
"...\n"
"}"

#. (itstool) path: sect3/para
#: book.translate.xml:3700
#, fuzzy
msgid ""
"When a process is forked from its parent process, the "
"<citerefentry><refentrytitle>fork</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call uses <literal>crhold()</literal> to maintain the "
"credential for the newly forked process. It inherently keep the newly forked "
"child's credential consistent with its parent, so the child process is also "
"jailed."
msgstr ""
"Quando um processo � bifurcado de seu processo pai, o "
"<citerefentry><refentrytitle> garfo </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> utiliza��es de chamadas do sistema <literal> "
"crhold () </literal> para manter a credencial do processo rec�m-bifurcado. � "
"inerentemente manter a credencial da crian�a rec�m-bifurcada consistente com "
"seu pai, de modo que o processo filho tamb�m � preso \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:3707
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_fork.c</filename>:\n"
"p2-&gt;p_ucred = crhold(td-&gt;td_ucred);\n"
"...\n"
"td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);"
msgstr ""
"<filename>/usr/src/sys/kern/kern_fork.c</filename>:\n"
"p2-&gt;p_ucred = crhold(td-&gt;td_ucred);\n"
"...\n"
"td2-&gt;td_ucred = crhold(p2-&gt;p_ucred);"

#. (itstool) path: sect1/title
#: book.translate.xml:3716
#, fuzzy
msgid "Restrictions"
msgstr "Restri��es"

#. (itstool) path: sect1/para
#: book.translate.xml:3718
#, fuzzy
msgid ""
"Throughout the kernel there are access restrictions relating to jailed "
"processes. Usually, these restrictions only check whether the process is "
"jailed, and if so, returns an error. For example:"
msgstr ""
"Em todo o kernel existem restri��es de acesso relacionadas a processos "
"presos. Geralmente, essas restri��es apenas verificam se o processo est� "
"preso e, em caso afirmativo, retorna um erro. Por exemplo:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:3723
#, fuzzy, no-wrap
msgid "if (jailed(td-&gt;td_ucred))\n"
"    return (EPERM);"
msgstr "\n"
"if (jailed(td-&gt;td_ucred))\n"
"    return (EPERM);"

#. (itstool) path: sect2/title
#: book.translate.xml:3727
#, fuzzy
msgid "SysV IPC"
msgstr "SysV IPC"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3729
#, fuzzy
msgid "<primary>System V IPC</primary>"
msgstr " <primary> IPC do sistema V </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3731
#, fuzzy
msgid ""
"System V IPC is based on messages. Processes can send each other these "
"messages which tell them how to act. The functions which deal with messages "
"are: <citerefentry><refentrytitle>msgctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>msgget</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>msgsnd</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>msgrcv</"
"refentrytitle><manvolnum>3</manvolnum></citerefentry>. Earlier, I mentioned "
"that there were certain sysctls you could turn on or off in order to affect "
"the behavior of <application>jail</application>. One of these sysctls was "
"<literal>security.jail.sysvipc_allowed</literal>. By default, this sysctl is "
"set to 0. If it were set to 1, it would defeat the whole purpose of having a "
"<application>jail</application>; privileged users from the "
"<application>jail</application> would be able to affect processes outside "
"the jailed environment. The difference between a message and a signal is "
"that the message only consists of the signal number."
msgstr ""
"O IPC do sistema V � baseado em mensagens. Os processos podem enviar uns aos "
"outros mensagens que lhes dizem como agir. As fun��es que lidam com as "
"mensagens s�o: <citerefentry><refentrytitle> msgctl </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> msgget </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> msgsnd </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> msgrcv </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> . Anteriormente, mencionei que havia certos "
"sysctls que voc� podia ativar ou desativar para afetar o comportamento de "
"<application> cadeia </application> . Um desses sysctls foi <literal> "
"security.jail.sysvipc_allowed </literal> . Por padr�o, este sysctl � "
"definido como 0. Se fosse definido como 1, ele derrotaria todo o prop�sito "
"de ter um <application> cadeia </application> ; usu�rios privilegiados do "
"<application> cadeia </application> seria capaz de afetar processos fora do "
"ambiente preso. A diferen�a entre uma mensagem e um sinal � que a mensagem "
"consiste apenas no n�mero do sinal. "

#. (itstool) path: sect2/para
#: book.translate.xml:3746
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_msg.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_msg.c </filename> : "

#. (itstool) path: listitem/para
#: book.translate.xml:3750
#, fuzzy
msgid ""
"<literal>msgget(key, msgflg)</literal>: <literal>msgget</literal> returns "
"(and possibly creates) a message descriptor that designates a message queue "
"for use in other functions."
msgstr ""
" <literal> msgget (chave, msgflg) </literal> : <literal> msgget </literal> "
"retorna (e possivelmente cria) um descritor de mensagens que designa uma "
"fila de mensagens para uso em outras fun��es. "

#. (itstool) path: listitem/para
#: book.translate.xml:3757
#, fuzzy
msgid ""
"<literal>msgctl(msgid, cmd, buf)</literal>: Using this function, a process "
"can query the status of a message descriptor."
msgstr ""
" <literal> msgctl (msgid, cmd, buf) </literal> : Usando esta fun��o, um "
"processo pode consultar o status de um descritor de mensagem. "

#. (itstool) path: listitem/para
#: book.translate.xml:3763
#, fuzzy
msgid ""
"<literal>msgsnd(msgid, msgp, msgsz, msgflg)</literal>: <literal>msgsnd</"
"literal> sends a message to a process."
msgstr ""
" <literal> msgsnd (msgid, msgp, msgsz, msgflg) </literal> : <literal> msgsnd "
"</literal> envia uma mensagem para um processo \""

#. (itstool) path: listitem/para
#: book.translate.xml:3769
#, fuzzy
msgid ""
"<literal>msgrcv(msgid, msgp, msgsz, msgtyp, msgflg)</literal>: a process "
"receives messages using this function"
msgstr ""
" <literal> msgrid (msgid, msgp, msgsz, msgtyp, msgflg) </literal> : um "
"processo recebe mensagens usando esta fun��o "

#. (itstool) path: sect2/para
#: book.translate.xml:3775
#, fuzzy
msgid ""
"In each of the system calls corresponding to these functions, there is this "
"conditional:"
msgstr ""
"Em cada uma das chamadas do sistema correspondentes a estas fun��es, existe "
"esta condicional:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3778
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/sysv_msg.c</filename>:\n"
"if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))\n"
"    return (ENOSYS);"
msgstr ""
"<filename>/usr/src/sys/kern/sysv_msg.c</filename>:\n"
"if (!jail_sysvipc_allowed &amp;&amp; jailed(td-&gt;td_ucred))\n"
"    return (ENOSYS);"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3782
#, fuzzy
msgid "<primary>semaphores</primary>"
msgstr " <primary> sem�foros </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3784
#, fuzzy
msgid ""
"Semaphore system calls allow processes to synchronize execution by doing a "
"set of operations atomically on a set of semaphores. Basically semaphores "
"provide another way for processes lock resources. However, process waiting "
"on a semaphore, that is being used, will sleep until the resources are "
"relinquished. The following semaphore system calls are blocked inside a "
"<application>jail</application>: <citerefentry><refentrytitle>semget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>semctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>semop</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"Chamadas de sistema de sem�foro permitem que processos sincronizem a "
"execu��o executando um conjunto de opera��es atomicamente em um conjunto de "
"sem�foros. Basicamente, sem�foros fornecem outra maneira para recursos de "
"bloqueio de processos. No entanto, processo aguardando um sem�foro, que est� "
"sendo usado, ir� dormir at� os recursos As seguintes chamadas do sistema de "
"sem�foro est�o bloqueadas dentro <application> cadeia </application> : "
"<citerefentry><refentrytitle> semget </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> semctl </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> semop </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> "

#. (itstool) path: sect2/para
#: book.translate.xml:3793
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_sem.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_sem.c </filename> : "

#. (itstool) path: listitem/para
#: book.translate.xml:3797
#, fuzzy
msgid ""
"<literal>semctl(semid, semnum, cmd, ...)</literal>: <literal>semctl</"
"literal> does the specified <literal>cmd</literal> on the semaphore queue "
"indicated by <literal>semid</literal>."
msgstr ""
" <literal> semctl (semid, semnum, cmd, ...) </literal> : <literal> semctl </"
"literal> faz o especificado <literal> cmd </literal> na fila de sem�foros "
"indicada por <literal> semid </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3803
#, fuzzy
msgid ""
"<literal>semget(key, nsems, flag)</literal>: <literal>semget</literal> "
"creates an array of semaphores, corresponding to <literal>key</literal>."
msgstr ""
" <literal> semget (chave, nsems, bandeira) </literal> : <literal> semget </"
"literal> cria uma matriz de sem�foros, correspondente a <literal> chave </"
"literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3807
#, fuzzy
msgid ""
"<literal>key and flag take on the same meaning as they do in msgget.</"
"literal>"
msgstr ""
" <literal> key e flag assumem o mesmo significado que no msgget. </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3811
#, fuzzy
msgid ""
"<literal>semop(semid, array, nops)</literal>: <literal>semop</literal> "
"performs a group of operations indicated by <literal>array</literal>, to the "
"set of semaphores identified by <literal>semid</literal>."
msgstr ""
" <literal> semop (semid, array, nops) </literal> : <literal> semop </"
"literal> executa um grupo de opera��es indicado por <literal> array </"
"literal> , ao conjunto de sem�foros identificados por <literal> semid </"
"literal> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3818
#, fuzzy
msgid "<primary>shared memory</primary>"
msgstr " <primary> memoria compartilhada </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3820
#, fuzzy
msgid ""
"System V IPC allows for processes to share memory. Processes can communicate "
"directly with each other by sharing parts of their virtual address space and "
"then reading and writing data stored in the shared memory. These system "
"calls are blocked within a jailed environment: "
"<citerefentry><refentrytitle>shmdt</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, <citerefentry><refentrytitle>shmat</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>shmctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>shmget</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>."
msgstr ""
"O System V IPC permite que os processos compartilhem mem�ria. Os processos "
"podem se comunicar diretamente compartilhando partes de seu espa�o de "
"endere�o virtual e depois lendo e gravando dados armazenados na mem�ria "
"compartilhada. Essas chamadas de sistema s�o bloqueadas em um ambiente preso:"
" <citerefentry><refentrytitle> shmdt </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> shmat </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> shmctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> shmget </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect2/para
#: book.translate.xml:3827
#, fuzzy
msgid "<filename>/usr/src/sys/kern/sysv_shm.c</filename>:"
msgstr " <filename> /usr/src/sys/kern/sysv_shm.c </filename> : "

#. (itstool) path: listitem/para
#: book.translate.xml:3830
#, fuzzy
msgid ""
"<literal>shmctl(shmid, cmd, buf)</literal>: <literal>shmctl</literal> does "
"various control operations on the shared memory region identified by "
"<literal>shmid</literal>."
msgstr ""
" <literal> shmctl (shmid, cmd, buf) </literal> : <literal> shmctl </literal> "
"faz v�rias opera��es de controle na regi�o de mem�ria compartilhada "
"identificada por <literal> shmid </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:3836
#, fuzzy
msgid ""
"<literal>shmget(key, size, flag)</literal>: <literal>shmget</literal> "
"accesses or creates a shared memory region of <literal>size</literal> bytes."
msgstr ""
" <literal> shmget (chave, tamanho, bandeira) </literal> : <literal> shmget </"
"literal> acessa ou cria uma regi�o de mem�ria compartilhada <literal> "
"Tamanho </literal> bytes. "

#. (itstool) path: listitem/para
#: book.translate.xml:3842
#, fuzzy
msgid ""
"<literal>shmat(shmid, addr, flag)</literal>: <literal>shmat</literal> "
"attaches a shared memory region identified by <literal>shmid</literal> to "
"the address space of a process."
msgstr ""
" <literal> shmat (shmid, addr, bandeira) </literal> : <literal> shmat </"
"literal> anexa uma regi�o de mem�ria compartilhada identificada <literal> "
"shmid </literal> para o espa�o de endere�o de um processo \""

#. (itstool) path: listitem/para
#: book.translate.xml:3848
#, fuzzy
msgid ""
"<literal>shmdt(addr)</literal>: <literal>shmdt</literal> detaches the shared "
"memory region previously attached at <literal>addr</literal>."
msgstr ""
" <literal> shmdt (addr) </literal> : <literal> shmdt </literal> separa a "
"regi�o de mem�ria compartilhada anteriormente conectada <literal> addr </"
"literal> "

#. (itstool) path: sect2/title
#: book.translate.xml:3857
#, fuzzy
msgid "Sockets"
msgstr "Tomadas"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3859
#, fuzzy
msgid "<primary>sockets</primary>"
msgstr " <primary> tomadas </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3861
#, fuzzy
msgid ""
"<application>Jail</application> treats the "
"<citerefentry><refentrytitle>socket</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> system call and related lower-level socket functions in a "
"special manner. In order to determine whether a certain socket is allowed to "
"be created, it first checks to see if the sysctl <literal>security.jail."
"socket_unixiproute_only</literal> is set. If set, sockets are only allowed "
"to be created if the family specified is either <literal>PF_LOCAL</literal>, "
"<literal>PF_INET</literal> or <literal>PF_ROUTE</literal>. Otherwise, it "
"returns an error."
msgstr ""
" <application> Cadeia </application> trata o <citerefentry><refentrytitle> "
"soquete </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> chamada de "
"sistema e fun��es de soquete de n�vel inferior relacionadas de uma maneira "
"especial. Para determinar se um certo socket pode ser criado, ele primeiro "
"verifica se o sysctl <literal> security.jail.socket_unixiproute_only </"
"literal> est� definido. Se definido, os soquetes s� poder�o ser criados se a "
"fam�lia especificada for <literal> PF_LOCAL </literal> , <literal> PF_INET </"
"literal> ou <literal> PF_ROUTE </literal> . Caso contr�rio, retorna um erro. "
""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3872
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/uipc_socket.c</filename>:\n"
"int\n"
"socreate(int dom, struct socket **aso, int type, int proto,\n"
"    struct ucred *cred, struct thread *td)\n"
"{\n"
"    struct protosw *prp;\n"
"...\n"
"    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {\n"
"        return (EPROTONOSUPPORT);\n"
"    }\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/uipc_socket.c</filename>:\n"
"int\n"
"socreate(int dom, struct socket **aso, int type, int proto,\n"
"    struct ucred *cred, struct thread *td)\n"
"{\n"
"    struct protosw *prp;\n"
"...\n"
"    if (jailed(cred) &amp;&amp; jail_socket_unixiproute_only &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_LOCAL &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_INET &amp;&amp;\n"
"        prp-&gt;pr_domain-&gt;dom_family != PF_ROUTE) {\n"
"        return (EPROTONOSUPPORT);\n"
"    }\n"
"...\n"
"}"

#. (itstool) path: sect2/title
#: book.translate.xml:3890
#, fuzzy
msgid "Berkeley Packet Filter"
msgstr "Filtro de pacotes de Berkeley"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3892
#, fuzzy
msgid "<primary>Berkeley Packet Filter</primary>"
msgstr " <primary> Filtro de pacotes de Berkeley </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3893
#, fuzzy
msgid "<primary>data link layer</primary>"
msgstr " <primary> camada de enlace de dados </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3895
#, fuzzy
msgid ""
"The <application>Berkeley Packet Filter</application> provides a raw "
"interface to data link layers in a protocol independent fashion. "
"<application>BPF</application> is now controlled by the "
"<citerefentry><refentrytitle>devfs</refentrytitle><manvolnum>8</manvolnum></"
"citerefentry> whether it can be used in a jailed environment."
msgstr ""
"O <application> Filtro de pacotes de Berkeley </application> fornece uma "
"interface bruta para as camadas de enlace de dados de maneira independente "
"do protocolo. <application> BPF </application> agora � controlado pelo "
"<citerefentry><refentrytitle> devfs </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> se pode ser usado em um ambiente preso \""

#. (itstool) path: sect2/title
#: book.translate.xml:3904
#, fuzzy
msgid "Protocols"
msgstr "Protocolos"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:3906
#, fuzzy
msgid "<primary>protocols</primary>"
msgstr " <primary> protocolos </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:3908
#, fuzzy
msgid ""
"There are certain protocols which are very common, such as TCP, UDP, IP and "
"ICMP. IP and ICMP are on the same level: the network layer 2. There are "
"certain precautions which are taken in order to prevent a jailed process "
"from binding a protocol to a certain address only if the <literal>nam</"
"literal> parameter is set. <literal>nam</literal> is a pointer to a "
"<literal>sockaddr</literal> structure, which describes the address on which "
"to bind the service. A more exact definition is that <literal>sockaddr</"
"literal> \"may be used as a template for referring to the identifying tag "
"and length of each address\". In the function <literal>in_pcbbind_setup()</"
"literal>, <literal>sin</literal> is a pointer to a <literal>sockaddr_in</"
"literal> structure, which contains the port, address, length and domain "
"family of the socket which is to be bound. Basically, this disallows any "
"processes from <application>jail</application> to be able to specify the "
"address that does not belong to the <application>jail</application> in which "
"the calling process exists."
msgstr ""
"Existem certos protocolos que s�o muito comuns, como TCP, UDP, IP e ICMP. IP "
"e ICMP est�o no mesmo n�vel: a camada de rede 2. H� certas precau��es que "
"s�o tomadas para evitar que um processo preso seja vinculado. um protocolo "
"para um determinado endere�o apenas se o <literal> nam </literal> par�metro "
"est� definido. <literal> nam </literal> � um ponteiro para um <literal> "
"sockaddr </literal> estrutura, que descreve o endere�o no qual ligar o "
"servi�o. Uma defini��o mais exata � que <literal> sockaddr </literal> \\ "
"\"pode ​​ser usado como um modelo para referir-se � tag de identifica��o e "
"comprimento de cada endere�o \". Na fun��o <literal> in_pcbbind_setup () </"
"literal> , <literal> pecado </literal> � um ponteiro para um <literal> "
"sockaddr_in </literal> estrutura, que cont�m a porta, endere�o, comprimento "
"e fam�lia de dom�nio do socket que deve ser ligado. Basicamente, isso impede "
"qualquer processo de <application> cadeia </application> para poder "
"especificar o endere�o que n�o pertence ao <application> cadeia </"
"application> em que o processo de chamada existe. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3929
#, no-wrap
msgid ""
"<filename>/usr/src/sys/netinet/in_pcb.c</filename>:\n"
"int\n"
"in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,\n"
"    u_short *lportp, struct ucred *cred)\n"
"{\n"
"    ...\n"
"    struct sockaddr_in *sin;\n"
"    ...\n"
"    if (nam) {\n"
"        sin = (struct sockaddr_in *)nam;\n"
"        ...\n"
"        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return(EINVAL);\n"
"        ...\n"
"        if (lport) {\n"
"            ...\n"
"            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr."
"s_addr))\n"
"                return (EADDRNOTAVAIL);\n"
"            ...\n"
"        }\n"
"    }\n"
"    if (lport == 0) {\n"
"        ...\n"
"        if (laddr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"                return (EINVAL);\n"
"        ...\n"
"    }\n"
"...\n"
"    if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"        return (EINVAL);\n"
"...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/netinet/in_pcb.c</filename>:\n"
"int\n"
"in_pcbbind_setup(struct inpcb *inp, struct sockaddr *nam, in_addr_t *laddrp,\n"
"    u_short *lportp, struct ucred *cred)\n"
"{\n"
"    ...\n"
"    struct sockaddr_in *sin;\n"
"    ...\n"
"    if (nam) {\n"
"        sin = (struct sockaddr_in *)nam;\n"
"        ...\n"
"        if (sin-&gt;sin_addr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;sin-&gt;sin_addr.s_addr))\n"
"                return(EINVAL);\n"
"        ...\n"
"        if (lport) {\n"
"            ...\n"
"            if (prison &amp;&amp; prison_ip(cred, 0, &amp;sin-&gt;sin_addr."
"s_addr))\n"
"                return (EADDRNOTAVAIL);\n"
"            ...\n"
"        }\n"
"    }\n"
"    if (lport == 0) {\n"
"        ...\n"
"        if (laddr.s_addr != INADDR_ANY)\n"
"            if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"                return (EINVAL);\n"
"        ...\n"
"    }\n"
"...\n"
"    if (prison_ip(cred, 0, &amp;laddr.s_addr))\n"
"        return (EINVAL);\n"
"...\n"
"}"

#. (itstool) path: sect2/para
#: book.translate.xml:3964
#, fuzzy
msgid ""
"You might be wondering what function <literal>prison_ip()</literal> does. "
"<literal>prison_ip()</literal> is given three arguments, a pointer to the "
"credential(represented by <literal>cred</literal>), any flags, and an IP "
"address. It returns 1 if the IP address does NOT belong to the "
"<application>jail</application> or 0 otherwise. As you can see from the "
"code, if it is indeed an IP address not belonging to the <application>jail</"
"application>, the protocol is not allowed to bind to that address."
msgstr ""
"Voc� pode estar se perguntando que fun��o <literal> prison_ip () </literal> "
"faz. <literal> prison_ip () </literal> � dado tr�s argumentos, um ponteiro "
"para a credencial (representado por <literal> cred </literal> ), qualquer "
"sinalizador e um endere�o IP. Ele retorna 1 se o endere�o IP N�O pertencer "
"ao <application> cadeia </application> ou 0 caso contr�rio. Como voc� pode "
"ver no c�digo, se � realmente um endere�o IP n�o pertencente ao "
"<application> cadeia </application> , o protocolo n�o tem permiss�o para "
"vincular a esse endere�o \""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:3975
#, no-wrap
msgid ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int\n"
"prison_ip(struct ucred *cred, int flag, u_int32_t *ip)\n"
"{\n"
"    u_int32_t tmp;\n"
"\n"
"    if (!jailed(cred))\n"
"        return (0);\n"
"    if (flag)\n"
"        tmp = *ip;\n"
"    else\n"
"        tmp = ntohl(*ip);\n"
"    if (tmp == INADDR_ANY) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (tmp == INADDR_LOOPBACK) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)\n"
"        return (1);\n"
"    return (0);\n"
"}"
msgstr ""
"<filename>/usr/src/sys/kern/kern_jail.c:</filename>\n"
"int\n"
"prison_ip(struct ucred *cred, int flag, u_int32_t *ip)\n"
"{\n"
"    u_int32_t tmp;\n"
"\n"
"    if (!jailed(cred))\n"
"        return (0);\n"
"    if (flag)\n"
"        tmp = *ip;\n"
"    else\n"
"        tmp = ntohl(*ip);\n"
"    if (tmp == INADDR_ANY) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (tmp == INADDR_LOOPBACK) {\n"
"        if (flag)\n"
"            *ip = cred-&gt;cr_prison-&gt;pr_ip;\n"
"        else\n"
"            *ip = htonl(cred-&gt;cr_prison-&gt;pr_ip);\n"
"        return (0);\n"
"    }\n"
"    if (cred-&gt;cr_prison-&gt;pr_ip != tmp)\n"
"        return (1);\n"
"    return (0);\n"
"}"

#. (itstool) path: sect2/title
#: book.translate.xml:4008
#, fuzzy
msgid "Filesystem"
msgstr "Sistema de arquivo"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:4010
#, fuzzy
msgid "<primary>filesystem</primary>"
msgstr " <primary> sistema de arquivo </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:4012
#, fuzzy
msgid ""
"Even <literal>root</literal> users within the <application>jail</"
"application> are not allowed to unset or modify any file flags, such as "
"immutable, append-only, and undeleteable flags, if the securelevel is "
"greater than 0."
msgstr ""
"At� <literal> raiz </literal> usu�rios dentro do <application> cadeia </"
"application> n�o � permitido anular ou modificar qualquer sinalizador de "
"arquivo, como sinalizadores imut�veis, somente de anexa��o e n�o-"
"destac�veis, se o n�vel de seguran�a for maior que 0. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:4018
#, no-wrap
msgid ""
"<filename>/usr/src/sys/ufs/ufs/ufs_vnops.c:</filename>\n"
"static int\n"
"ufs_setattr(ap)\n"
"    ...\n"
"{\n"
"    ...\n"
"        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {\n"
"            if (ip-&gt;i_flags\n"
"                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {\n"
"                    error = securelevel_gt(cred, 0);\n"
"                    if (error)\n"
"                        return (error);\n"
"            }\n"
"            ...\n"
"        }\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_priv.c</filename>\n"
"int\n"
"priv_check_cred(struct ucred *cred, int priv, int flags)\n"
"{\n"
"    ...\n"
"    error = prison_priv_check(cred, priv);\n"
"    if (error)\n"
"        return (error);\n"
"    ...\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"prison_priv_check(struct ucred *cred, int priv)\n"
"{\n"
"    ...\n"
"    switch (priv) {\n"
"    ...\n"
"    case PRIV_VFS_SYSFLAGS:\n"
"        if (jail_chflags_allowed)\n"
"            return (0);\n"
"        else\n"
"            return (EPERM);\n"
"    ...\n"
"    }\n"
"    ...\n"
"}"
msgstr ""
"<filename>/usr/src/sys/ufs/ufs/ufs_vnops.c:</filename>\n"
"static int\n"
"ufs_setattr(ap)\n"
"    ...\n"
"{\n"
"    ...\n"
"        if (!priv_check_cred(cred, PRIV_VFS_SYSFLAGS, 0)) {\n"
"            if (ip-&gt;i_flags\n"
"                &amp; (SF_NOUNLINK | SF_IMMUTABLE | SF_APPEND)) {\n"
"                    error = securelevel_gt(cred, 0);\n"
"                    if (error)\n"
"                        return (error);\n"
"            }\n"
"            ...\n"
"        }\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_priv.c</filename>\n"
"int\n"
"priv_check_cred(struct ucred *cred, int priv, int flags)\n"
"{\n"
"    ...\n"
"    error = prison_priv_check(cred, priv);\n"
"    if (error)\n"
"        return (error);\n"
"    ...\n"
"}\n"
"<filename>/usr/src/sys/kern/kern_jail.c</filename>\n"
"int\n"
"prison_priv_check(struct ucred *cred, int priv)\n"
"{\n"
"    ...\n"
"    switch (priv) {\n"
"    ...\n"
"    case PRIV_VFS_SYSFLAGS:\n"
"        if (jail_chflags_allowed)\n"
"            return (0);\n"
"        else\n"
"            return (EPERM);\n"
"    ...\n"
"    }\n"
"    ...\n"
"}"

#. (itstool) path: chapter/title
#: book.translate.xml:4071
#, fuzzy
msgid "The SYSINIT Framework"
msgstr "O Framework SYSINIT"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4073
#, fuzzy
msgid "<primary>SYSINIT</primary>"
msgstr " <primary> SYSINIT </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4074
#, fuzzy
msgid "<primary>dynamic initialization</primary>"
msgstr " <primary> inicializa��o din�mica </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4075
#, fuzzy
msgid ""
"<primary>kernel initialization</primary> <secondary>dynamic</secondary>"
msgstr ""
" <primary> inicializa��o do kernel </primary><secondary> din�mico </"
"secondary> "

#. (itstool) path: chapter/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:4077 book.translate.xml:15500
#, fuzzy
msgid "<primary>kernel modules</primary>"
msgstr " <primary> m�dulos do kernel </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:4078
#, fuzzy
msgid "<primary>kernel linker</primary>"
msgstr " <primary> linker de kernel </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:4080
#, fuzzy
msgid ""
"SYSINIT is the framework for a generic call sort and dispatch mechanism. "
"FreeBSD currently uses it for the dynamic initialization of the kernel. "
"SYSINIT allows FreeBSD's kernel subsystems to be reordered, and added, "
"removed, and replaced at kernel link time when the kernel or one of its "
"modules is loaded without having to edit a statically ordered initialization "
"routing and recompile the kernel. This system also allows kernel modules, "
"currently called <firstterm>KLD's</firstterm>, to be separately compiled, "
"linked, and initialized at boot time and loaded even later while the system "
"is already running. This is accomplished using the <quote>kernel linker</"
"quote> and <quote>linker sets</quote>."
msgstr ""
"SYSINIT � o framework para um mecanismo gen�rico de ordena��o e envio de "
"chamadas. O FreeBSD atualmente o utiliza para a inicializa��o din�mica do "
"kernel. SYSINIT permite que os subsistemas de kernel do FreeBSD sejam "
"reordenados, adicionados, removidos e substitu�dos no momento do link do "
"kernel quando o kernel ou um de seus m�dulos � carregado sem ter que editar "
"um roteamento de inicializa��o ordenado estaticamente e recompilar o kernel."
"Este sistema tamb�m permite m�dulos do kernel, atualmente chamados "
"<firstterm> KLD';s </firstterm> , para ser compilado, vinculado e "
"inicializado separadamente no momento da inicializa��o e carregado ainda "
"mais tarde enquanto o sistema j� est� em execu��o. Isso � feito usando o "
"<quote> linker de kernel </quote> e <quote> conjuntos de linkers </quote> "

#. (itstool) path: varlistentry/term
#: book.translate.xml:4098
#, fuzzy
msgid "Linker Set"
msgstr "Left Set"

#. (itstool) path: listitem/para
#: book.translate.xml:4100
#, fuzzy
msgid ""
"A linker technique in which the linker gathers statically declared data "
"throughout a program's source files into a single contiguously addressable "
"unit of data."
msgstr ""
"Uma t�cnica de linker na qual o linker re�ne dados estaticamente declarados "
"atrav�s dos arquivos de c�digo-fonte de um programa em uma �nica unidade de "
"dados contiguamente endere��vel."

#. (itstool) path: sect1/title
#: book.translate.xml:4110
#, fuzzy
msgid "SYSINIT Operation"
msgstr "Opera��o SYSINIT"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:4112
#, fuzzy
msgid "<primary>linker sets</primary>"
msgstr " <primary> conjuntos de linkers </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:4114
#, fuzzy
msgid ""
"SYSINIT relies on the ability of the linker to take static data declared at "
"multiple locations throughout a program's source and group it together as a "
"single contiguous chunk of data. This linker technique is called a "
"<quote>linker set</quote>. SYSINIT uses two linker sets to maintain two data "
"sets containing each consumer's call order, function, and a pointer to the "
"data to pass to that function."
msgstr ""
"O SYSINIT depende da capacidade do vinculador de obter dados est�ticos "
"declarados em v�rios locais ao longo da origem de um programa e agrup�-los "
"como um �nico bloco cont�guo de dados. Essa t�cnica de vinculador � chamada "
"de <quote> conjunto de linker </quote> . O SYSINIT usa dois conjuntos de "
"linkers para manter dois conjuntos de dados contendo cada ordem de chamada "
"do consumidor, fun��o e um ponteiro para os dados a serem passados ​​para "
"essa fun��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:4122
#, fuzzy
msgid ""
"SYSINIT uses two priorities when ordering the functions for execution. The "
"first priority is a subsystem ID giving an overall order for SYSINIT's "
"dispatch of functions. Current predeclared ID's are in <filename>&lt;sys/"
"kernel.h&gt;</filename> in the enum list <literal>sysinit_sub_id</literal>. "
"The second priority used is an element order within the subsystem. Current "
"predeclared subsystem element orders are in <filename>&lt;sys/kernel.h&gt;</"
"filename> in the enum list <literal>sysinit_elem_order</literal>."
msgstr ""
"O SYSINIT usa duas prioridades ao ordenar as fun��es para execu��o. A "
"primeira prioridade � um ID de subsistema dando uma ordem geral para o "
"despacho de fun��es do SYSINIT. As IDs pr�-declaradas atuais est�o em "
"<filename> &lt;sys / kernel.h&gt; </filename> na lista enum <literal> "
"sysinit_sub_id </literal> . A segunda prioridade usada � uma ordem de "
"elemento no subsistema. As atuais ordens de elementos do subsistema pr�-"
"declarado est�o em <filename> &lt;sys / kernel.h&gt; </filename> na lista "
"enum <literal> sysinit_elem_order </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:4132
#, fuzzy
msgid "<primary>pseudo-devices</primary>"
msgstr " <primary> pseudo-dispositivos </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:4134
#, fuzzy
msgid ""
"There are currently two uses for SYSINIT. Function dispatch at system "
"startup and kernel module loads, and function dispatch at system shutdown "
"and kernel module unload. Kernel subsystems often use system startup "
"SYSINIT's to initialize data structures, for example the process scheduling "
"subsystem uses a SYSINIT to initialize the run queue data structure. Device "
"drivers should avoid using <literal>SYSINIT()</literal> directly. Instead "
"drivers for real devices that are part of a bus structure should use "
"<literal>DRIVER_MODULE()</literal> to provide a function that detects the "
"device and, if it is present, initializes the device. It will do a few "
"things specific to devices and then call <literal>SYSINIT()</literal> itself."
" For pseudo-devices, which are not part of a bus structure, use "
"<literal>DEV_MODULE()</literal>."
msgstr ""
"Existem atualmente dois usos para SYSINIT. O despacho de fun��es na "
"inicializa��o do sistema e do m�dulo kernel e o envio de fun��es no "
"desligamento do sistema e no m�dulo kernel descarregam. Os subsistemas "
"Kernel geralmente usam SYSINIT';s para inicializar estruturas de dados, por "
"exemplo, o subsistema de agendamento de processos SYSINIT para inicializar a "
"estrutura de dados da fila de execu��o.Os drivers de dispositivo devem "
"evitar o uso <literal> SYSINIT () </literal> diretamente. Em vez disso, os "
"drivers para dispositivos reais que fazem parte de uma estrutura de "
"barramento devem usar <literal> DRIVER_MODULE () </literal> para fornecer "
"uma fun��o que detecta o dispositivo e, se estiver presente, inicializa o "
"dispositivo. Ele far� algumas coisas espec�ficas para os dispositivos e, em "
"seguida, chamar� <literal> SYSINIT () </literal> em si. Para pseudo-"
"dispositivos, que n�o fazem parte de uma estrutura de barramento, use "
"<literal> DEV_MODULE () </literal> "

#. (itstool) path: sect1/title
#: book.translate.xml:4152
#, fuzzy
msgid "Using SYSINIT"
msgstr "Usando SYSINIT"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:4160
#, no-wrap
msgid "&lt;sys/kernel.h&gt;"
msgstr "&lt;sys/kernel.h&gt;"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:4166
#, no-wrap
msgid ""
"SYSINIT(uniquifier, subsystem, order, func, ident)\n"
"SYSUNINIT(uniquifier, subsystem, order, func, ident)"
msgstr ""
"SYSINIT(uniquifier, subsystem, order, func, ident)\n"
"SYSUNINIT(uniquifier, subsystem, order, func, ident)"

#. (itstool) path: sect2/title
#: book.translate.xml:4172
#, fuzzy
msgid "Startup"
msgstr "Comece"

#. (itstool) path: sect2/para
#: book.translate.xml:4174
#, fuzzy
msgid ""
"The <literal>SYSINIT()</literal> macro creates the necessary SYSINIT data in "
"SYSINIT's startup data set for SYSINIT to sort and dispatch a function at "
"system startup and module load. <literal>SYSINIT()</literal> takes a "
"uniquifier that SYSINIT uses to identify the particular function dispatch "
"data, the subsystem order, the subsystem element order, the function to "
"call, and the data to pass the function. All functions must take a constant "
"pointer argument."
msgstr ""
"O <literal> SYSINIT () </literal> macro cria os dados SYSINIT necess�rios no "
"conjunto de dados de inicializa��o do SYSINIT para SYSINIT para classificar "
"e despachar uma fun��o na inicializa��o do sistema e no carregamento do "
"m�dulo. <literal> SYSINIT () </literal> pega um uniquificador que SYSINIT "
"usa para identificar os dados de despacho da fun��o espec�fica, a ordem do "
"subsistema, a ordem do elemento do subsistema, a fun��o a ser chamada e os "
"dados para passar a fun��o. Todas as fun��es devem ter um argumento de "
"ponteiro constante. "

#. (itstool) path: example/title
#: book.translate.xml:4185
#, fuzzy
msgid "Example of a <literal>SYSINIT()</literal>"
msgstr "Exemplo de um <literal> SYSINIT () </literal> "

#. (itstool) path: example/programlisting
#: book.translate.xml:4187
#, no-wrap
msgid ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_null(void *unused)\n"
"{\n"
"        foo_doo();\n"
"}\n"
"SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
"\n"
"struct foo foo_voodoo = {\n"
"        FOO_VOODOO;\n"
"}\n"
"\n"
"void foo_arg(void *vdata)\n"
"{\n"
"        struct foo *foo = (struct foo *)vdata;\n"
"        foo_data(foo);\n"
"}\n"
"SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);\n"
"\t"
msgstr ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_null(void *unused)\n"
"{\n"
"        foo_doo();\n"
"}\n"
"SYSINIT(foo, SI_SUB_FOO, SI_ORDER_FOO, foo_null, NULL);\n"
"\n"
"struct foo foo_voodoo = {\n"
"        FOO_VOODOO;\n"
"}\n"
"\n"
"void foo_arg(void *vdata)\n"
"{\n"
"        struct foo *foo = (struct foo *)vdata;\n"
"        foo_data(foo);\n"
"}\n"
"SYSINIT(bar, SI_SUB_FOO, SI_ORDER_FOO, foo_arg, &amp;foo_voodoo);\n"
"\t"

#. (itstool) path: sect2/para
#: book.translate.xml:4208
#, fuzzy
msgid ""
"Note that <literal>SI_SUB_FOO</literal> and <literal>SI_ORDER_FOO</literal> "
"need to be in the <literal>sysinit_sub_id</literal> and "
"<literal>sysinit_elem_order</literal> enum's as mentioned above. Either use "
"existing ones or add your own to the enum's. You can also use math for fine-"
"tuning the order a SYSINIT will run in. This example shows a SYSINIT that "
"needs to be run just barely before the SYSINIT's that handle tuning kernel "
"parameters."
msgstr ""
"Observe que <literal> SI_SUB_FOO </literal> e <literal> SI_ORDER_FOO </"
"literal> precisa estar no <literal> sysinit_sub_id </literal> e <literal> "
"sysinit_elem_order </literal> enum como mencionado acima. Use os existentes "
"ou adicione os seus aos do enum. Voc� tamb�m pode usar matem�tica para "
"ajustar a ordem na qual um SYSINIT ser� executado. Este exemplo mostra um "
"SYSINIT que precisa ser executado logo antes do SYSINIT tratar os par�metros "
"do kernel de ajuste. "

#. (itstool) path: example/title
#: book.translate.xml:4219
#, fuzzy
msgid "Example of Adjusting <literal>SYSINIT()</literal> Order"
msgstr "Exemplo de ajuste <literal> SYSINIT () </literal> Ordem"

#. (itstool) path: example/programlisting
#: book.translate.xml:4221
#, no-wrap
msgid ""
"static void\n"
"mptable_register(void *dummy __unused)\n"
"{\n"
"\n"
"\tapic_register_enumerator(&amp;mptable_enumerator);\n"
"}\n"
"\n"
"SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,\n"
"    mptable_register, NULL);"
msgstr ""
"static void\n"
"mptable_register(void *dummy __unused)\n"
"{\n"
"\n"
"\tapic_register_enumerator(&amp;mptable_enumerator);\n"
"}\n"
"\n"
"SYSINIT(mptable_register, SI_SUB_TUNABLES - 1, SI_ORDER_FIRST,\n"
"    mptable_register, NULL);"

#. (itstool) path: sect2/title
#: book.translate.xml:4234
#, fuzzy
msgid "Shutdown"
msgstr "Desligar"

#. (itstool) path: sect2/para
#: book.translate.xml:4236
#, fuzzy
msgid ""
"The <literal>SYSUNINIT()</literal> macro behaves similarly to the "
"<literal>SYSINIT()</literal> macro except that it adds the SYSINIT data to "
"SYSINIT's shutdown data set."
msgstr ""
"O <literal> SYSUNINIT () </literal> macro se comporta de forma semelhante ao "
"<literal> SYSINIT () </literal> macro, exceto que adiciona os dados SYSINIT "
"ao conjunto de dados de desligamento do SYSINIT. "

#. (itstool) path: example/title
#: book.translate.xml:4241
#, fuzzy
msgid "Example of a <literal>SYSUNINIT()</literal>"
msgstr "Exemplo de um <literal> SYSUNINIT () </literal> "

#. (itstool) path: example/programlisting
#: book.translate.xml:4243
#, no-wrap
msgid ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_cleanup(void *unused)\n"
"{\n"
"        foo_kill();\n"
"}\n"
"SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
"\n"
"struct foo_stack foo_stack = {\n"
"        FOO_STACK_VOODOO;\n"
"}\n"
"\n"
"void foo_flush(void *vdata)\n"
"{\n"
"}\n"
"SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);\n"
"\t"
msgstr ""
"#include &lt;sys/kernel.h&gt;\n"
"\n"
"void foo_cleanup(void *unused)\n"
"{\n"
"        foo_kill();\n"
"}\n"
"SYSUNINIT(foobar, SI_SUB_FOO, SI_ORDER_FOO, foo_cleanup, NULL);\n"
"\n"
"struct foo_stack foo_stack = {\n"
"        FOO_STACK_VOODOO;\n"
"}\n"
"\n"
"void foo_flush(void *vdata)\n"
"{\n"
"}\n"
"SYSUNINIT(barfoo, SI_SUB_FOO, SI_ORDER_FOO, foo_flush, &amp;foo_stack);\n"
"\t"

#. (itstool) path: info/title
#: book.translate.xml:4301
#, fuzzy
msgid "The TrustedBSD MAC Framework"
msgstr "O framework MAC TrustedBSD"

#. (itstool) path: affiliation/address
#: book.translate.xml:4311
#, fuzzy, no-wrap
msgid "\n"
"\t    <email>chris@FreeBSD.org</email>\n"
"\t  "
msgstr "<email>chris@FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:4304
#, fuzzy
msgid ""
"<personname> <firstname>Chris</firstname> <surname>Costello</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"
msgstr ""
" <personname><firstname> Chris </firstname><surname> Costello </surname></"
"personname><affiliation><orgname> Projeto TrustedBSD </orgname> <_: endere�o-"
"1 /> </affiliation> "

#. (itstool) path: affiliation/address
#: book.translate.xml:4324
#, fuzzy, no-wrap
msgid "\n"
"\t    <email>rwatson@FreeBSD.org</email>\n"
"\t  "
msgstr "<email>rwatson@FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:4317
#, fuzzy
msgid ""
"<personname> <firstname>Robert</firstname> <surname>Watson</surname> </"
"personname> <affiliation> <orgname>TrustedBSD Project</orgname> <_:address-1/"
"> </affiliation>"
msgstr ""
" <personname><firstname> Robert </firstname><surname> Watson </surname></"
"personname><affiliation><orgname> Projeto TrustedBSD </orgname> <_: endere�o-"
"1 /> </affiliation> "

#. (itstool) path: sect1/title
#: book.translate.xml:4333
#, fuzzy
msgid "MAC Documentation Copyright"
msgstr "Direitos autorais da documenta��o do MAC"

#. (itstool) path: sect1/para
#: book.translate.xml:4335
#, fuzzy
msgid ""
"This documentation was developed for the FreeBSD Project by Chris Costello "
"at Safeport Network Services and Network Associates Laboratories, the "
"Security Research Division of Network Associates, Inc. under DARPA/SPAWAR "
"contract N66001-01-C-8035 (<quote>CBOSS</quote>), as part of the DARPA CHATS "
"research program."
msgstr ""
"Esta documenta��o foi desenvolvida para o Projeto FreeBSD por Chris Costello "
"na Safeport Network Services e Network Associates Laboratories, a Divis�o de "
"Pesquisa de Seguran�a da Network Associates, Inc. sob contrato DARPA / "
"SPAWAR N66001-01-C-8035 ( <quote> CBOSS </quote> ), como parte do programa "
"de pesquisa DARPA CHATS. "

#. (itstool) path: sect1/para
#: book.translate.xml:4342
#, fuzzy
msgid ""
"Redistribution and use in source (SGML DocBook) and 'compiled' forms (SGML, "
"HTML, PDF, PostScript, RTF and so forth) with or without modification, are "
"permitted provided that the following conditions are met:"
msgstr ""
"Redistribui��o e uso em formul�rios de origem (SGML DocBook) e "
"';compilados'; (SGML, HTML, PDF, PostScript, RTF e assim por diante) com ou "
"sem modifica��o, s�o permitidos desde que as seguintes condi��es sejam "
"atendidas:"

#. (itstool) path: listitem/para
#: book.translate.xml:4349
#, fuzzy
msgid ""
"Redistributions of source code (SGML DocBook) must retain the above "
"copyright notice, this list of conditions and the following disclaimer as "
"the first lines of this file unmodified."
msgstr ""
"As redistribui��es do c�digo-fonte (SGML DocBook) devem manter o aviso de "
"copyright acima, esta lista de condi��es e o aviso de isen��o de "
"responsabilidade a seguir, conforme as primeiras linhas deste arquivo n�o "
"sejam modificadas."

#. (itstool) path: important/para
#: book.translate.xml:4366
#, fuzzy
msgid ""
"THIS DOCUMENTATION IS PROVIDED BY THE NETWORKS ASSOCIATES TECHNOLOGY, INC "
"\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED "
"TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR "
"PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL NETWORKS ASSOCIATES TECHNOLOGY, "
"INC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR "
"CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF "
"SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS "
"INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN "
"CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) "
"ARISING IN ANY WAY OUT OF THE USE OF THIS DOCUMENTATION, EVEN IF ADVISED OF "
"THE POSSIBILITY OF SUCH DAMAGE."
msgstr ""
"ESTA DOCUMENTA��O � FORNECIDA PELA NETWORKS ASSOCIATES TECHNOLOGY, INC \" "
"COMO EST� \"\" E QUALQUER GARANTIA EXPRESSA OU IMPL�CITA, INCLUINDO, MAS N�O "
"SE LIMITANDO �S GARANTIAS IMPL�CITAS DE COMERCIALIZA��O E ADEQUA��O A UMA "
"FINALIDADE ESPEC�FICA, � REJEITADA. A NETWORKS ASSOCIATES TECHNOLOGY, INC � "
"RESPONS�VEL POR QUAISQUER DANOS DIRETOS, INDIRETOS, INCIDENTAIS, ESPECIAIS, "
"EXEMPLARES OU CONSEQ�ENCIAIS (INCLUINDO, MAS N�O SE LIMITANDO A, AQUISI��O "
"DE BENS OU SERVI�OS SUBSTITUTOS; PERDA DE USO, DADOS OU LUCROS; OU "
"INTERRUP��O DE NEG�CIOS) SEMPRE CAUSOU QUALQUER TEORIA DE RESPONSABILIDADE, "
"SEJA EM CONTRATO, RESPONSABILIDADE ESTRITA, OU DELITO (INCLUINDO NEGLIG�NCIA "
"OU DE OUTRA FORMA) DECORRENTE DE QUALQUER FORMA DO USO DESTA DOCUMENTA��O, "
"MESMO SE AVISADA DA POSSIBILIDADE DE TAIS DANOS. "

#. (itstool) path: sect1/para
#: book.translate.xml:4385
#, fuzzy
msgid ""
"FreeBSD includes experimental support for several mandatory access control "
"policies, as well as a framework for kernel security extensibility, the "
"TrustedBSD MAC Framework. The MAC Framework is a pluggable access control "
"framework, permitting new security policies to be easily linked into the "
"kernel, loaded at boot, or loaded dynamically at run-time. The framework "
"provides a variety of features to make it easier to implement new security "
"policies, including the ability to easily tag security labels (such as "
"confidentiality information) onto system objects."
msgstr ""
"O FreeBSD inclui suporte experimental para v�rias pol�ticas de controle de "
"acesso, bem como uma estrutura para extensibilidade de seguran�a do kernel, "
"o TrustedBSD MAC Framework. O MAC Framework � uma estrutura de controle de "
"acesso plug�vel, permitindo que novas pol�ticas de seguran�a sejam "
"facilmente vinculadas ao kernel na inicializa��o ou carregada dinamicamente "
"em tempo de execu��o. A estrutura fornece uma variedade de recursos para "
"facilitar a implementa��o de novas pol�ticas de seguran�a, incluindo a "
"capacidade de marcar facilmente r�tulos de seguran�a (como informa��es de "
"confidencialidade) em objetos do sistema. "

#. (itstool) path: sect1/para
#: book.translate.xml:4396
#, fuzzy
msgid ""
"This chapter introduces the MAC policy framework and provides documentation "
"for a sample MAC policy module."
msgstr ""
"Este cap�tulo apresenta a estrutura de pol�tica do MAC e fornece "
"documenta��o para um m�dulo de pol�tica MAC de amostra."

#. (itstool) path: sect1/title
#: book.translate.xml:4402 book.translate.xml:14904 book.translate.xml:16074
#: book.translate.xml:21700 book.translate.xml:22815
#, fuzzy
msgid "Introduction"
msgstr "Introdu��o"

#. (itstool) path: sect1/para
#: book.translate.xml:4404
#, fuzzy
msgid ""
"The TrustedBSD MAC framework provides a mechanism to allow the compile-time "
"or run-time extension of the kernel access control model. New system "
"policies may be implemented as kernel modules and linked to the kernel; if "
"multiple policy modules are present, their results will be composed. The MAC "
"Framework provides a variety of access control infrastructure services to "
"assist policy writers, including support for transient and persistent policy-"
"agnostic object security labels. This support is currently considered "
"experimental."
msgstr ""
"A estrutura MAC do TrustedBSD fornece um mecanismo para permitir a extens�o "
"em tempo de compila��o ou de tempo de execu��o do modelo de controle de "
"acesso do kernel. Novas pol�ticas do sistema podem ser implementadas como "
"m�dulos do kernel e vinculadas ao kernel; se houver v�rios m�dulos de "
"pol�tica, seus resultados O MAC Framework fornece uma variedade de servi�os "
"de infra-estrutura de controle de acesso para auxiliar os redatores de "
"pol�ticas, incluindo o suporte a r�tulos de seguran�a de objetos agn�sticos, "
"transit�rios e persistentes. Esse suporte � atualmente considerado "
"experimental. "

#. (itstool) path: sect1/para
#: book.translate.xml:4414
#, fuzzy
msgid ""
"This chapter provides information appropriate for developers of policy "
"modules, as well as potential consumers of MAC-enabled environments, to "
"learn about how the MAC Framework supports access control extension of the "
"kernel."
msgstr ""
"Este cap�tulo fornece informa��es apropriadas para desenvolvedores de "
"m�dulos de pol�ticas, bem como potenciais consumidores de ambientes "
"habilitados para MAC, para aprender sobre como o MAC Framework suporta a "
"extens�o de controle de acesso do kernel."

#. (itstool) path: sect1/title
#: book.translate.xml:4421
#, fuzzy
msgid "Policy Background"
msgstr "Hist�rico da Pol�tica"

#. (itstool) path: sect1/para
#: book.translate.xml:4423
#, fuzzy
msgid ""
"Mandatory Access Control (MAC), refers to a set of access control policies "
"that are mandatorily enforced on users by the operating system. MAC policies "
"may be contrasted with Discretionary Access Control (DAC) protections, by "
"which non-administrative users may (at their discretion) protect objects. In "
"traditional UNIX systems, DAC protections include file permissions and "
"access control lists; MAC protections include process controls preventing "
"inter-user debugging and firewalls. A variety of MAC policies have been "
"formulated by operating system designers and security researches, including "
"the Multi-Level Security (MLS) confidentiality policy, the Biba integrity "
"policy, Role-Based Access Control (RBAC), Domain and Type Enforcement (DTE), "
"and Type Enforcement (TE). Each model bases decisions on a variety of "
"factors, including user identity, role, and security clearance, as well as "
"security labels on objects representing concepts such as data sensitivity "
"and integrity."
msgstr ""
"Mandatory Access Control (MAC), refere-se a um conjunto de pol�ticas de "
"controle de acesso impostas obrigatoriamente aos usu�rios pelo sistema "
"operacional. As pol�ticas MAC podem ser contrastadas com as prote��es de "
"Controle de Acesso Discricion�rio (DAC), pelas quais usu�rios n�o "
"administrativos podem Em seus sistemas UNIX tradicionais, as prote��es do "
"DAC incluem permiss�es de arquivos e listas de controle de acesso, e as "
"prote��es MAC incluem controles de processo que impedem a depura��o entre "
"usu�rios e firewalls.Uma variedade de pol�ticas MAC foram formuladas por "
"projetistas de sistemas operacionais e pesquisas de seguran�a. incluindo a "
"pol�tica de confidencialidade Multi-Level Security (MLS), a pol�tica de "
"integridade Biba, RBAC (Role-Based Access Control), DTE (Domain and Type "
"Enforcement) e TE (Type Enforcement), cada modelo baseia as decis�es numa "
"variedade de fatores. , incluindo identidade de usu�rio, fun��o e "
"autoriza��o de seguran�a, bem como etiquetas de seguran�a em objetos que "
"representam conceitos como integridade e sensibilidade de dados. "

#. (itstool) path: sect1/para
#: book.translate.xml:4441
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework is capable of supporting policy modules that "
"implement all of these policies, as well as a broad class of system "
"hardening policies, which may use existing security attributes, such as user "
"and group IDs, as well as extended attributes on files, and other system "
"properties. In addition, despite the name, the MAC Framework can also be "
"used to implement purely discretionary policies, as policy modules are given "
"substantial flexibility in how they authorize protections."
msgstr ""
"O TrustedBSD MAC Framework � capaz de suportar m�dulos de pol�ticas que "
"implementam todas essas pol�ticas, bem como uma ampla classe de pol�ticas de "
"prote��o do sistema, que podem usar atributos de seguran�a existentes, como "
"IDs de usu�rios e grupos, bem como atributos estendidos em arquivos e outras "
"propriedades do sistema Al�m disso, apesar do nome, o MAC Framework tamb�m "
"pode ser usado para implementar pol�ticas puramente discricion�rias, uma vez "
"que os m�dulos de pol�ticas recebem uma flexibilidade substancial na forma "
"como autorizam prote��es \""

#. (itstool) path: sect1/title
#: book.translate.xml:4453
#, fuzzy
msgid "MAC Framework Kernel Architecture"
msgstr "Arquitetura do Kernel do MAC Framework"

#. (itstool) path: sect1/para
#: book.translate.xml:4455
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework permits kernel modules to extend the operating "
"system security policy, as well as providing infrastructure functionality "
"required by many access control modules. If multiple policies are "
"simultaneously loaded, the MAC Framework will usefully (for some definition "
"of useful) compose the results of the policies."
msgstr ""
"O TrustedBSD MAC Framework permite que os m�dulos do kernel estendam a "
"pol�tica de seguran�a do sistema operacional, bem como fornecem a "
"funcionalidade de infra-estrutura requerida por muitos m�dulos de controle "
"de acesso. Se v�rias pol�ticas forem carregadas simultaneamente, o MAC "
"Framework utilizar� (para alguma defini��o �til) resultados das pol�ticas \""

#. (itstool) path: sect2/title
#: book.translate.xml:4463
#, fuzzy
msgid "Kernel Elements"
msgstr "Elementos do Kernel"

#. (itstool) path: sect2/para
#: book.translate.xml:4465
#, fuzzy
msgid "The MAC Framework contains a number of kernel elements:"
msgstr "O MAC Framework cont�m v�rios elementos do kernel:"

#. (itstool) path: listitem/para
#: book.translate.xml:4470
#, fuzzy
msgid "Framework management interfaces"
msgstr "Interfaces de gerenciamento de estrutura"

#. (itstool) path: listitem/para
#: book.translate.xml:4473
#, fuzzy
msgid "Concurrency and synchronization primitives."
msgstr "Primitivas de sincroniza��o e simultaneidade."

#. (itstool) path: listitem/para
#: book.translate.xml:4476
#, fuzzy
msgid "Policy registration"
msgstr "Registo de pol�tica"

#. (itstool) path: listitem/para
#: book.translate.xml:4479
#, fuzzy
msgid "Extensible security label for kernel objects"
msgstr "Etiqueta de seguran�a extens�vel para objetos do kernel"

#. (itstool) path: listitem/para
#: book.translate.xml:4482
#, fuzzy
msgid "Policy entry point composition operators"
msgstr "Operadores de composi��o de ponto de entrada de pol�tica"

#. (itstool) path: listitem/para
#: book.translate.xml:4485
#, fuzzy
msgid "Label management primitives"
msgstr "Primitivos de gerenciamento de r�tulo"

#. (itstool) path: listitem/para
#: book.translate.xml:4488
#, fuzzy
msgid "Entry point API invoked by kernel services"
msgstr "API do ponto de entrada invocada pelos servi�os do kernel"

#. (itstool) path: listitem/para
#: book.translate.xml:4491
#, fuzzy
msgid "Entry point API to policy modules"
msgstr "API de ponto de entrada para m�dulos de pol�tica"

#. (itstool) path: listitem/para
#: book.translate.xml:4494
#, fuzzy
msgid ""
"Entry points implementations (policy life cycle, object life cycle/label "
"management, access control checks)."
msgstr ""
"Implementa��es de pontos de entrada (ciclo de vida da pol�tica, ciclo de "
"vida do objeto / gerenciamento de etiquetas, verifica��es de controle de "
"acesso)."

#. (itstool) path: listitem/para
#: book.translate.xml:4499
#, fuzzy
msgid "Policy-agnostic label-management system calls"
msgstr "Chamadas de sistema de gerenciamento de r�tulo agn�stico de pol�ticas"

#. (itstool) path: listitem/para
#: book.translate.xml:4502
#, fuzzy
msgid "<function>mac_syscall()</function> multiplex system call"
msgstr " <function> mac_syscall () </function> chamada do sistema multiplex "

#. (itstool) path: listitem/para
#: book.translate.xml:4506
#, fuzzy
msgid "Various security policies implemented as MAC policy modules"
msgstr ""
"V�rias pol�ticas de seguran�a implementadas como m�dulos de pol�tica MAC"

#. (itstool) path: sect2/title
#: book.translate.xml:4513
#, fuzzy
msgid "Framework Management Interfaces"
msgstr "Framework Management Interfaces"

#. (itstool) path: sect2/para
#: book.translate.xml:4515
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework may be directly managed using sysctl's, loader "
"tunables, and system calls."
msgstr ""
"O TrustedBSD MAC Framework pode ser gerenciado diretamente usando sysctl';s, "
"sintetizadores de carregador e chamadas do sistema."

#. (itstool) path: sect2/para
#: book.translate.xml:4518
#, fuzzy
msgid ""
"In most cases, sysctl's and loader tunables of the same name modify the same "
"parameters, and control behavior such as enforcement of protections relating "
"to various kernel subsystems. In addition, if MAC debugging support is "
"compiled into the kernel, several counters will be maintained tracking label "
"allocation. It is generally advisable that per-subsystem enforcement "
"controls not be used to control policy behavior in production environments, "
"as they broadly impact the operation of all active policies. Instead, per-"
"policy controls should be preferred, as they provide greater granularity and "
"greater operational consistency for policy modules."
msgstr ""
"Na maioria dos casos, sysctl';s e loaders sintoniz�veis ​​do mesmo nome "
"modificam os mesmos par�metros e controlam o comportamento, como a aplica��o "
"de prote��es relacionadas a v�rios subsistemas do kernel. Al�m disso, se o "
"suporte de depura��o MAC for compilado no kernel, v�rios contadores ser�o "
"mantidos. � geralmente aconselh�vel que os controles de fiscaliza��o por "
"subsistema n�o sejam usados ​​para controlar o comportamento de pol�ticas em "
"ambientes de produ��o, pois eles geralmente afetam a opera��o de todas as "
"pol�ticas ativas. granularidade e maior consist�ncia operacional para "
"m�dulos de pol�ticas. "

#. (itstool) path: sect2/para
#: book.translate.xml:4531
#, fuzzy
msgid ""
"Loading and unloading of policy modules is performed using the system module "
"management system calls and other system interfaces, including boot loader "
"variables; policy modules will have the opportunity to influence load and "
"unload events, including preventing undesired unloading of the policy."
msgstr ""
"O carregamento e descarregamento de m�dulos de pol�ticas � realizado usando "
"as chamadas do sistema de gerenciamento de m�dulos do sistema e outras "
"interfaces do sistema, incluindo vari�veis ​​do carregador de inicializa��o; "
"os m�dulos de pol�tica ter�o a oportunidade de influenciar a carga e "
"descarga de eventos, incluindo a preven��o de descarregamento indesejado da "
"pol�tica."

#. (itstool) path: sect2/title
#: book.translate.xml:4539
#, fuzzy
msgid "Policy List Concurrency and Synchronization"
msgstr "Concorr�ncia e Sincroniza��o da Lista de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:4541
#, fuzzy
msgid ""
"As the set of active policies may change at run-time, and the invocation of "
"entry points is non-atomic, synchronization is required to prevent loading "
"or unloading of policies while an entry point invocation is in progress, "
"freezing the set of active policies for the duration. This is accomplished "
"by means of a framework busy count: whenever an entry point is entered, the "
"busy count is incremented; whenever it is exited, the busy count is "
"decremented. While the busy count is elevated, policy list changes are not "
"permitted, and threads attempting to modify the policy list will sleep until "
"the list is not busy. The busy count is protected by a mutex, and a "
"condition variable is used to wake up sleepers waiting on policy list "
"modifications. One side effect of this synchronization model is that "
"recursion into the MAC Framework from within a policy module is permitted, "
"although not generally used."
msgstr ""
"Como o conjunto de pol�ticas ativas pode mudar em tempo de execu��o e a "
"invoca��o de pontos de entrada n�o � at�mica, a sincroniza��o � necess�ria "
"para impedir o carregamento ou descarregamento de pol�ticas enquanto uma "
"chamada de ponto de entrada est� em andamento, congelando o conjunto de "
"pol�ticas ativas Isso ocorre por meio de uma contagem ocupacional de "
"estrutura: sempre que um ponto de entrada � inserido, a contagem de ocupado "
"� incrementada e, quando ela � encerrada, a contagem de ocupado � diminu�da. "
"n�o permitido, e os segmentos que tentam modificar a lista de pol�ticas "
"ficar�o suspensos at� que a lista n�o esteja ocupada.A contagem ocupada � "
"protegida por um mutex e uma vari�vel de condi��o � usada para ativar os "
"travessas aguardando modifica��es na lista de pol�ticas. O modelo de "
"sincroniza��o � que a recurs�o no MAC Framework de dentro de um m�dulo de "
"pol�tica � permitida, embora n�o seja geralmente usada. "

#. (itstool) path: sect2/para
#: book.translate.xml:4558
#, fuzzy
msgid ""
"Various optimizations are used to reduce the overhead of the busy count, "
"including avoiding the full cost of incrementing and decrementing if the "
"list is empty or contains only static entries (policies that are loaded "
"before the system starts, and cannot be unloaded). A compile-time option is "
"also provided which prevents any change in the set of loaded policies at run-"
"time, which eliminates the mutex locking costs associated with supporting "
"dynamically loaded and unloaded policies as synchronization is no longer "
"required."
msgstr ""
"V�rias otimiza��es s�o usadas para reduzir a sobrecarga da contagem de "
"ocupa��es, evitando o custo total de incrementar e decrementar se a lista "
"estiver vazia ou contiver apenas entradas est�ticas (pol�ticas que s�o "
"carregadas antes do sistema ser iniciado e n�o podem ser descarregadas). "
"op��o de tempo de compila��o tamb�m � fornecida, o que elimina qualquer "
"altera��o no conjunto de pol�ticas carregadas em tempo de execu��o, o que "
"elimina os custos de bloqueio mutex associados ao suporte de pol�ticas "
"carregadas e descarregadas dinamicamente, j� que a sincroniza��o n�o � mais "
"necess�ria. "

#. (itstool) path: sect2/para
#: book.translate.xml:4569
#, fuzzy
msgid ""
"As the MAC Framework is not permitted to block in some entry points, a "
"normal sleep lock cannot be used; as a result, it is possible for the load "
"or unload attempt to block for a substantial period of time waiting for the "
"framework to become idle."
msgstr ""
"Como o MAC Framework n�o tem permiss�o para bloquear em alguns pontos de "
"entrada, n�o � poss�vel usar um bloqueio de sono normal; como resultado, � "
"poss�vel que a tentativa de carga ou descarga seja bloqueada por um per�odo "
"de tempo substancial esperando a estrutura se tornar ocioso \""

#. (itstool) path: sect2/title
#: book.translate.xml:4577
#, fuzzy
msgid "Label Synchronization"
msgstr "Label Synchronization"

#. (itstool) path: sect2/para
#: book.translate.xml:4579
#, fuzzy
msgid ""
"As kernel objects of interest may generally be accessed from more than one "
"thread at a time, and simultaneous entry of more than one thread into the "
"MAC Framework is permitted, security attribute storage maintained by the MAC "
"Framework is carefully synchronized. In general, existing kernel "
"synchronization on kernel object data is used to protect MAC Framework "
"security labels on the object: for example, MAC labels on sockets are "
"protected using the existing socket mutex. Likewise, semantics for "
"concurrent access are generally identical to those of the container objects: "
"for credentials, copy-on-write semantics are maintained for label contents "
"as with the remainder of the credential structure. The MAC Framework asserts "
"necessary locks on objects when invoked with an object reference. Policy "
"authors must be aware of these synchronization semantics, as they will "
"sometimes limit the types of accesses permitted on labels: for example, when "
"a read-only reference to a credential is passed to a policy via an entry "
"point, only read operations are permitted on the label state attached to the "
"credential."
msgstr ""
"Como os objetos de interesse do kernel geralmente podem ser acessados ​​de "
"mais de um thread de cada vez, e a entrada simult�nea de mais de um thread "
"no MAC Framework � permitida, o armazenamento de atributos de seguran�a "
"mantido pelo MAC Framework � cuidadosamente sincronizado. A sincroniza��o do "
"kernel nos dados do objeto kernel � usada para proteger os r�tulos de "
"seguran�a do MAC Framework no objeto: por exemplo, os r�tulos MAC nos "
"soquetes s�o protegidos usando o mutex de soquete existente Da mesma forma, "
"as sem�nticas para acesso simult�neo s�o geralmente id�nticas �quelas dos "
"objetos cont�ineres: credenciais, a sem�ntica de copy-on-write � mantida "
"para o conte�do da etiqueta como no restante da estrutura de credencial.O "
"MAC Framework afirma os bloqueios necess�rios em objetos quando invocado com "
"uma refer�ncia de objeto.Os autores da pol�tica devem estar cientes dessas "
"sem�nticas de sincroniza��o, pois elas �s vezes, limitar os tipos de acessos "
"permitidos nos r�tulos: por exemplo, quando uma refer�ncia somente leitura a "
"uma credencial � passada para uma pol�tica por meio de um ponto de entrada, "
"somente as opera��es de leitura s�o permitidas no estado da etiqueta anexado "
"� credencial. "

#. (itstool) path: sect2/title
#: book.translate.xml:4602
#, fuzzy
msgid "Policy Synchronization and Concurrency"
msgstr "Sincroniza��o e Concorr�ncia de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:4604
#, fuzzy
msgid ""
"Policy modules must be written to assume that many kernel threads may "
"simultaneously enter one more policy entry points due to the parallel and "
"preemptive nature of the FreeBSD kernel. If the policy module makes use of "
"mutable state, this may require the use of synchronization primitives within "
"the policy to prevent inconsistent views on that state resulting in "
"incorrect operation of the policy. Policies will generally be able to make "
"use of existing FreeBSD synchronization primitives for this purpose, "
"including mutexes, sleep locks, condition variables, and counting semaphores."
" However, policies should be written to employ these primitives carefully, "
"respecting existing kernel lock orders, and recognizing that some entry "
"points are not permitted to sleep, limiting the use of primitives in those "
"entry points to mutexes and wakeup operations."
msgstr ""
"Os m�dulos de pol�tica devem ser escritos para assumir que muitos "
"encadeamentos do kernel podem inserir simultaneamente mais um ponto de "
"entrada de pol�tica devido � natureza paralela e preventiva do kernel do "
"FreeBSD. Se o m�dulo de pol�tica faz uso do estado mut�vel, isso pode exigir "
"o uso de primitivas de sincroniza��o dentro da pol�tica para evitar vis�es "
"inconsistentes sobre aquele estado resultando em opera��o incorreta da "
"pol�tica, geralmente as pol�ticas poder�o fazer uso das primitivas de "
"sincroniza��o existentes do FreeBSD para este prop�sito, incluindo mutexes, "
"travas de sono, vari�veis ​​de condi��o e sem�foros de contagem. as "
"pol�ticas devem ser escritas para empregar esses primitivos cuidadosamente, "
"respeitando os pedidos de bloqueio do kernel existentes, e reconhecendo que "
"alguns pontos de entrada n�o t�m permiss�o para dormir, limitando o uso de "
"primitivos nesses pontos de entrada para mutexes e opera��es de ativa��o. "

#. (itstool) path: sect2/para
#: book.translate.xml:4620
#, fuzzy
msgid ""
"When policy modules call out to other kernel subsystems, they will generally "
"need to release any in-policy locks in order to avoid violating the kernel "
"lock order or risking lock recursion. This will maintain policy locks as "
"leaf locks in the global lock order, helping to avoid deadlock."
msgstr ""
"Quando os m�dulos de pol�tica chamam outros subsistemas do kernel, eles "
"geralmente precisam liberar qualquer bloqueio na pol�tica para evitar violar "
"a ordem de bloqueio do kernel ou arriscar a recurs�o do bloqueio. Isso "
"manter� os bloqueios de pol�tica como bloqueios de folha na ordem de "
"bloqueio global. ajudando a evitar o impasse \""

#. (itstool) path: sect2/title
#: book.translate.xml:4628
#, fuzzy
msgid "Policy Registration"
msgstr "Registro de Pol�tica"

#. (itstool) path: sect2/para
#: book.translate.xml:4630
#, fuzzy
msgid ""
"The MAC Framework maintains two lists of active policies: a static list, and "
"a dynamic list. The lists differ only with regards to their locking "
"semantics: an elevated reference count is not required to make use of the "
"static list. When kernel modules containing MAC Framework policies are "
"loaded, the policy module will use <literal>SYSINIT</literal> to invoke a "
"registration function; when a policy module is unloaded, <literal>SYSINIT</"
"literal> will likewise invoke a de-registration function. Registration may "
"fail if a policy module is loaded more than once, if insufficient resources "
"are available for the registration (for example, the policy might require "
"labeling and insufficient labeling state might be available), or other "
"policy prerequisites might not be met (some policies may only be loaded "
"prior to boot). Likewise, de-registration may fail if a policy is flagged as "
"not unloadable."
msgstr ""
"O MAC Framework mant�m duas listas de pol�ticas ativas: uma lista est�tica e "
"uma lista din�mica. As listas diferem apenas em rela��o � sem�ntica de "
"bloqueio: uma contagem de refer�ncia elevada n�o � necess�ria para fazer uso "
"da lista est�tica. Quando os m�dulos do kernel cont�m Pol�ticas do MAC "
"Framework s�o carregadas, o m�dulo de pol�tica usar� <literal> SYSINIT </"
"literal> invocar uma fun��o de registro; quando um m�dulo de pol�tica � "
"descarregado, <literal> SYSINIT </literal> Da mesma forma, invocar� uma "
"fun��o de cancelamento de registro. O registro pode falhar se um m�dulo de "
"pol�tica for carregado mais de uma vez, se recursos insuficientes estiverem "
"dispon�veis para o registro (por exemplo, a pol�tica exigir rotulagem e "
"estado de rotulagem insuficiente estiver dispon�vel) ou se outros pr�-"
"requisitos de diretiva n�o forem atendidos s� pode ser carregado antes da "
"inicializa��o). Da mesma forma, o cancelamento de registro poder� falhar se "
"uma pol�tica for sinalizada como n�o descarreg�vel. "

#. (itstool) path: sect2/title
#: book.translate.xml:4649
#, fuzzy
msgid "Entry Points"
msgstr "Pontos de entrada"

#. (itstool) path: sect2/para
#: book.translate.xml:4651
#, fuzzy
msgid ""
"Kernel services interact with the MAC Framework in two ways: they invoke a "
"series of APIs to notify the framework of relevant events, and they provide "
"a policy-agnostic label structure pointer in security-relevant objects. The "
"label pointer is maintained by the MAC Framework via label management entry "
"points, and permits the Framework to offer a labeling service to policy "
"modules through relatively non-invasive changes to the kernel subsystem "
"maintaining the object. For example, label pointers have been added to "
"processes, process credentials, sockets, pipes, vnodes, Mbufs, network "
"interfaces, IP reassembly queues, and a variety of other security-relevant "
"structures. Kernel services also invoke the MAC Framework when they perform "
"important security decisions, permitting policy modules to augment those "
"decisions based on their own criteria (possibly including data stored in "
"security labels). Most of these security critical decisions will be explicit "
"access control checks; however, some affect more general decision functions "
"such as packet matching for sockets and label transition at program "
"execution."
msgstr ""
"Os servi�os do kernel interagem com o MAC Framework de duas maneiras: eles "
"invocam uma s�rie de APIs para notificar a estrutura de eventos relevantes e "
"fornecem um ponteiro de estrutura de r�tulos agn�sticos para pol�ticas em "
"objetos relevantes para a seguran�a. O ponteiro de r�tulo � mantido pelo MAC "
"Framework via pontos de entrada de gerenciamento de r�tulos e permite que o "
"Framework ofere�a um servi�o de rotulagem aos m�dulos de pol�tica atrav�s de "
"altera��es relativamente n�o invasivas ao subsistema do kernel mantendo os "
"objetos. Por exemplo, ponteiros de r�tulo foram adicionados a processos, "
"credenciais de processo, soquetes vnodes, Mbufs, interfaces de rede, filas "
"de reagrupamento IP e uma variedade de outras estruturas relevantes para "
"seguran�a.Os servi�os de kernel tamb�m invocam o MAC Framework quando "
"executam importantes decis�es de seguran�a, permitindo que os m�dulos de "
"pol�ticas aumentem essas decis�es com base em seus pr�prios crit�rios "
"(possivelmente incluindo os dados armazenados nos r�tulos de seguran�a.) A "
"maioria dessas decis�es cr�ticas de seguran�a ser�o verifica��es expl�citas "
"de controle de acesso; afetam fun��es de decis�o mais gerais, como "
"correspond�ncia de pacotes para soquetes e transi��o de r�tulo na execu��o "
"do programa. "

#. (itstool) path: sect2/title
#: book.translate.xml:4674
#, fuzzy
msgid "Policy Composition"
msgstr "Composi��o da Pol�tica"

#. (itstool) path: sect2/para
#: book.translate.xml:4676
#, fuzzy
msgid ""
"When more than one policy module is loaded into the kernel at a time, the "
"results of the policy modules will be composed by the framework using a "
"composition operator. This operator is currently hard-coded, and requires "
"that all active policies must approve a request for it to return success. As "
"policies may return a variety of error conditions (success, access denied, "
"object does not exist, ...), a precedence operator selects the resulting "
"error from the set of errors returned by policies. In general, errors "
"indicating that an object does not exist will be preferred to errors "
"indicating that access to an object is denied. While it is not guaranteed "
"that the resulting composition will be useful or secure, we have found that "
"it is for many useful selections of policies. For example, traditional "
"trusted systems often ship with two or more policies using a similar "
"composition."
msgstr ""
"Quando mais de um m�dulo de pol�tica � carregado no kernel de cada vez, os "
"resultados dos m�dulos de pol�tica ser�o compostos pela estrutura usando um "
"operador de composi��o. Esse operador est� atualmente embutido em c�digo e "
"requer que todas as pol�ticas ativas aprovem uma pedido para que ele retorne "
"sucesso.Como as pol�ticas podem retornar uma variedade de condi��es de erro "
"(sucesso, acesso negado, objeto n�o existe, ...), um operador de preced�ncia "
"seleciona o erro resultante do conjunto de erros retornados pelas pol�ticas. "
", erros indicando que um objeto n�o existe ser�o preferidos a erros "
"indicando que o acesso a um objeto � negado.Enquanto n�o � garantido que a "
"composi��o resultante ser� �til ou segura, descobrimos que � para muitas "
"sele��es �teis de pol�ticas Por exemplo, sistemas confi�veis ​​tradicionais "
"geralmente v�m com duas ou mais pol�ticas usando uma composi��o similar. "

#. (itstool) path: sect2/title
#: book.translate.xml:4694
#, fuzzy
msgid "Labeling Support"
msgstr "Suporte de rotulagem"

#. (itstool) path: sect2/para
#: book.translate.xml:4696
#, fuzzy
msgid ""
"As many interesting access control extensions rely on security labels on "
"objects, the MAC Framework provides a set of policy-agnostic label "
"management system calls covering a variety of user-exposed objects. Common "
"label types include partition identifiers, sensitivity labels, integrity "
"labels, compartments, domains, roles, and types. By policy agnostic, we mean "
"that policy modules are able to completely define the semantics of meta-data "
"associated with an object. Policy modules participate in the internalization "
"and externalization of string-based labels provides by user applications, "
"and can expose multiple label elements to applications if desired."
msgstr ""
"Como muitas extens�es de controle de acesso interessantes dependem de "
"r�tulos de seguran�a em objetos, o MAC Framework fornece um conjunto de "
"chamadas de sistema de gerenciamento de r�tulos agn�sticos que cobrem uma "
"variedade de objetos expostos pelo usu�rio. Os tipos de r�tulos comuns "
"incluem identificadores de parti��o, r�tulos de sensibilidade e r�tulos de "
"integridade. compartimentos, dom�nios, fun��es e tipos. Por pol�tica "
"agn�stica, queremos dizer que os m�dulos de pol�tica s�o capazes de definir "
"completamente a sem�ntica de metadados associados a um objeto. M�dulos de "
"pol�ticas participam da internaliza��o e externaliza��o de r�tulos baseados "
"em strings fornecidas pelo usu�rio aplicativos e pode expor v�rios elementos "
"de r�tulo para aplicativos, se desejado. "

#. (itstool) path: sect2/para
#: book.translate.xml:4709
#, fuzzy
msgid ""
"In-memory labels are stored in slab-allocated <varname remap="
"\"structname\">struct label</varname>, which consists of a fixed-length "
"array of unions, each holding a <literal>void *</literal> pointer and a "
"<literal>long</literal>. Policies registering for label storage will be "
"assigned a \"slot\" identifier, which may be used to dereference the label "
"storage. The semantics of the storage are left entirely up to the policy "
"module: modules are provided with a variety of entry points associated with "
"the kernel object life cycle, including initialization, association/"
"creation, and destruction. Using these interfaces, it is possible to "
"implement reference counting and other storage models. Direct access to the "
"object structure is generally not required by policy modules to retrieve a "
"label, as the MAC Framework generally passes both a pointer to the object "
"and a direct pointer to the object's label into entry points. The primary "
"exception to this rule is the process credential, which must be manually "
"dereferenced to access the credential label. This may change in future "
"revisions of the MAC Framework."
msgstr ""
"Etiquetas na mem�ria s�o armazenadas em aloca��o de placas <varname remap="
"\"structname\"> r�tulo struct </varname> , que consiste em uma matriz de "
"uni�es de comprimento fixo, cada uma segurando uma <literal> void * </"
"literal> ponteiro e um <literal> longo </literal> . As pol�ticas que se "
"registram para o armazenamento de r�tulo receber�o um identificador \\ "
"\"slot \", que pode ser usado para excluir a refer�ncia do armazenamento de "
"r�tulo. A sem�ntica do armazenamento � deixada inteiramente para o m�dulo de "
"pol�tica: os m�dulos s�o fornecidos com uma variedade de pontos de entrada "
"associados ao ciclo de vida do objeto do kernel, incluindo inicializa��o, "
"associa��o / cria��o e destrui��o. Usando essas interfaces, � poss�vel "
"implementar a contagem de refer�ncia e outros modelos de armazenamento. O "
"acesso direto � estrutura do objeto geralmente n�o � exigido pelos m�dulos "
"de pol�tica para recuperar um r�tulo, j� que o MAC Framework geralmente "
"passa um ponteiro para o objeto e um ponteiro direto para o r�tulo do objeto "
"nos pontos de entrada. A principal exce��o a essa regra � a credencial do "
"processo, que deve ser manualmente referenciada para acessar o r�tulo da "
"credencial. Isso pode mudar em futuras revis�es do MAC Framework. "

#. (itstool) path: sect2/para
#: book.translate.xml:4728
#, fuzzy
msgid ""
"Initialization entry points frequently include a sleeping disposition flag "
"indicating whether or not an initialization is permitted to sleep; if "
"sleeping is not permitted, a failure may be returned to cancel allocation of "
"the label (and hence object). This may occur, for example, in the network "
"stack during interrupt handling, where sleeping is not permitted, or while "
"the caller holds a mutex. Due to the performance cost of maintaining labels "
"on in-flight network packets (Mbufs), policies must specifically declare a "
"requirement that Mbuf labels be allocated. Dynamically loaded policies "
"making use of labels must be able to handle the case where their init "
"function has not been called on an object, as objects may already exist when "
"the policy is loaded. The MAC Framework guarantees that uninitialized label "
"slots will hold a 0 or NULL value, which policies may use to detect "
"uninitialized values. However, as allocation of Mbuf labels is conditional, "
"policies must also be able to handle a NULL label pointer for Mbufs if they "
"have been loaded dynamically."
msgstr ""
"Os pontos de entrada de inicializa��o freq�entemente incluem um sinalizador "
"de disposi��o de sono indicando se uma inicializa��o � permitida ou n�o; se "
"dormir n�o for permitido, uma falha pode ser retornada para cancelar a "
"aloca��o do r�tulo (e, portanto, objeto). Isso pode ocorrer, por exemplo , "
"na pilha de rede durante o manuseio de interrup��o, onde dormir n�o � "
"permitido ou enquanto o chamador possui um mutex.Devido ao custo de "
"desempenho de manuten��o de r�tulos em pacotes de rede em tr�nsito (Mbufs), "
"diretivas devem declarar especificamente um requisito que r�tulos Mbuf "
"Pol�ticas carregadas dinamicamente que usam r�tulos devem ser capazes de "
"lidar com o caso em que sua fun��o init n�o foi chamada em um objeto, j� que "
"objetos j� podem existir quando a pol�tica � carregada. O MAC Framework "
"garante que os slots de r�tulo n�o inicializados um valor 0 ou NULL, que as "
"pol�ticas podem usar para detectar valores n�o inicializados.No entanto, "
"como a aloca��o de r�tulos Mbuf � condicional, as pol�ticas tamb�m devem ser "
"capazes de manipular Ponteiro de r�tulo NULL para Mbufs se eles foram "
"carregados dinamicamente. "

#. (itstool) path: sect2/para
#: book.translate.xml:4747
#, fuzzy
msgid ""
"In the case of file system labels, special support is provided for the "
"persistent storage of security labels in extended attributes. Where "
"available, extended attribute transactions are used to permit consistent "
"compound updates of security labels on vnodes--currently this support is "
"present only in the UFS2 file system. Policy authors may choose to implement "
"multilabel file system object labels using one (or more) extended attributes."
" For efficiency reasons, the vnode label (<literal>v_label</literal>) is a "
"cache of any on-disk label; policies are able to load values into the cache "
"when the vnode is instantiated, and update the cache as needed. As a result, "
"the extended attribute need not be directly accessed with every access "
"control check."
msgstr ""
"No caso de r�tulos de sistema de arquivos, � fornecido suporte especial para "
"o armazenamento persistente de r�tulos de seguran�a em atributos estendidos. "
"Quando dispon�veis, transa��es de atributos estendidas s�o usadas para "
"permitir atualiza��es consistentes de r�tulos de seguran�a em vnodes - "
"atualmente este suporte est� presente apenas No sistema de arquivos UFS2, os "
"autores de pol�ticas podem optar por implementar r�tulos de objeto de "
"sistema de arquivos multilabel usando um (ou mais) atributos estendidos.Por "
"raz�es de efici�ncia, o r�tulo vnode ( <literal> v_label </literal> ) � um "
"cache de qualquer r�tulo no disco; as pol�ticas podem carregar valores no "
"cache quando o vnode � instanciado e atualizar o cache conforme necess�rio. "
"Como resultado, o atributo estendido n�o precisa ser acessado diretamente "
"com todas as verifica��es de controle de acesso. "

#. (itstool) path: note/para
#: book.translate.xml:4762
#, fuzzy
msgid ""
"Currently, if a labeled policy permits dynamic unloading, its state slot "
"cannot be reclaimed, which places a strict (and relatively low) bound on the "
"number of unload-reload operations for labeled policies."
msgstr ""
"Atualmente, se uma pol�tica rotulada permite descarregamento din�mico, seu "
"slot de estado n�o pode ser recuperado, o que coloca um limite estrito (e "
"relativamente baixo) no n�mero de opera��es de descarregamento para "
"pol�ticas rotuladas."

#. (itstool) path: sect2/title
#: book.translate.xml:4770
#, fuzzy
msgid "System Calls"
msgstr "Chamadas do sistema"

#. (itstool) path: sect2/para
#: book.translate.xml:4772
#, fuzzy
msgid ""
"The MAC Framework implements a number of system calls: most of these calls "
"support the policy-agnostic label retrieval and manipulation APIs exposed to "
"user applications."
msgstr ""
"O MAC Framework implementa v�rias chamadas de sistema: a maioria dessas "
"chamadas suporta APIs de recupera��o e manipula��o de etiquetas agn�sticas "
"de pol�ticas expostas a aplicativos de usu�rios."

#. (itstool) path: sect2/para
#: book.translate.xml:4777
#, fuzzy
msgid ""
"The label management calls accept a label description structure, <varname "
"remap=\"structname\">struct mac</varname>, which contains a series of MAC "
"label elements. Each element contains a character string name, and character "
"string value. Each policy will be given the chance to claim a particular "
"element name, permitting policies to expose multiple independent elements if "
"desired. Policy modules perform the internalization and externalization "
"between kernel labels and user-provided labels via entry points, permitting "
"a variety of semantics. Label management system calls are generally wrapped "
"by user library functions to perform memory allocation and error handling, "
"simplifying user applications that must manage labels."
msgstr ""
"As chamadas de gerenciamento de etiquetas aceitam uma estrutura de descri��o "
"de r�tulo, <varname remap=\"structname\"> struct mac </varname> , que cont�m "
"uma s�rie de elementos de r�tulo MAC. Cada elemento cont�m um nome de cadeia "
"de caracteres e um valor de cadeia de caracteres. Cada pol�tica ter� a "
"chance de reivindicar um determinado nome de elemento, permitindo que as "
"pol�ticas exponham v�rios elementos independentes, se desejado. Os m�dulos "
"de pol�tica executam a internaliza��o e a externaliza��o entre os r�tulos do "
"kernel e os r�tulos fornecidos pelo usu�rio por meio de pontos de entrada, "
"permitindo uma variedade de sem�nticas. As chamadas do sistema de "
"gerenciamento de r�tulos geralmente s�o agrupadas por fun��es da biblioteca "
"do usu�rio para executar aloca��o de mem�ria e tratamento de erros, "
"simplificando os aplicativos do usu�rio que devem gerenciar r�tulos. "

#. (itstool) path: sect2/para
#: book.translate.xml:4791
#, fuzzy
msgid ""
"The following MAC-related system calls are present in the FreeBSD kernel:"
msgstr ""
"As seguintes chamadas do sistema relacionadas ao MAC est�o presentes no "
"kernel do FreeBSD:"

#. (itstool) path: listitem/para
#: book.translate.xml:4796
#, fuzzy
msgid ""
"<function>mac_get_proc()</function> may be used to retrieve the label of the "
"current process."
msgstr ""
" <function> mac_get_proc () </function> pode ser usado para recuperar o "
"r�tulo do processo atual. "

#. (itstool) path: listitem/para
#: book.translate.xml:4801
#, fuzzy
msgid ""
"<function>mac_set_proc()</function> may be used to request a change in the "
"label of the current process."
msgstr ""
" <function> mac_set_proc () </function> pode ser usado para solicitar uma "
"altera��o no r�tulo do processo atual. "

#. (itstool) path: listitem/para
#: book.translate.xml:4807
#, fuzzy
msgid ""
"<function>mac_get_fd()</function> may be used to retrieve the label of an "
"object (file, socket, pipe, ...) referenced by a file descriptor."
msgstr ""
" <function> mac_get_fd () </function> pode ser usado para recuperar o r�tulo "
"de um objeto (arquivo, socket, pipe, ...) referenciado por um descritor de "
"arquivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:4813
#, fuzzy
msgid ""
"<function>mac_get_file()</function> may be used to retrieve the label of an "
"object referenced by a file system path."
msgstr ""
" <function> mac_get_file () </function> pode ser usado para recuperar o "
"r�tulo de um objeto referenciado por um caminho do sistema de arquivos. "

#. (itstool) path: listitem/para
#: book.translate.xml:4819
#, fuzzy
msgid ""
"<function>mac_set_fd()</function> may be used to request a change in the "
"label of an object (file, socket, pipe, ...) referenced by a file descriptor."
""
msgstr ""
" <function> mac_set_fd () </function> pode ser usado para solicitar uma "
"altera��o no r�tulo de um objeto (arquivo, socket, pipe, ...) referenciado "
"por um descritor de arquivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:4825
#, fuzzy
msgid ""
"<function>mac_set_file()</function> may be used to request a change in the "
"label of an object referenced by a file system path."
msgstr ""
" <function> mac_set_file () </function> pode ser usado para solicitar uma "
"altera��o no r�tulo de um objeto referenciado por um caminho do sistema de "
"arquivos. "

#. (itstool) path: listitem/para
#: book.translate.xml:4831
#, fuzzy
msgid ""
"<function>mac_syscall()</function> permits policy modules to create new "
"system calls without modifying the system call table; it accepts a target "
"policy name, operation number, and opaque argument for use by the policy."
msgstr ""
" <function> mac_syscall () </function> permite que os m�dulos de pol�tica "
"criem novas chamadas do sistema sem modificar a tabela de chamadas do "
"sistema; aceita um nome de pol�tica de destino, n�mero de opera��o e "
"argumento opaco para uso pela pol�tica. "

#. (itstool) path: listitem/para
#: book.translate.xml:4839
#, fuzzy
msgid ""
"<function>mac_get_pid()</function> may be used to request the label of "
"another process by process id."
msgstr ""
" <function> mac_get_pid () </function> pode ser usado para solicitar o "
"r�tulo de outro processo pelo id do processo. "

#. (itstool) path: listitem/para
#: book.translate.xml:4844
#, fuzzy
msgid ""
"<function>mac_get_link()</function> is identical to "
"<function>mac_get_file()</function>, only it will not follow a symbolic link "
"if it is the final entry in the path, so may be used to retrieve the label "
"on a symlink."
msgstr ""
" <function> mac_get_link () </function> � id�ntico a <function> mac_get_file "
"() </function> , s� n�o seguir� um link simb�lico se for a entrada final no "
"caminho, ent�o pode ser usado para recuperar o r�tulo em um symlink. "

#. (itstool) path: listitem/para
#: book.translate.xml:4852
#, fuzzy
msgid ""
"<function>mac_set_link()</function> is identical to "
"<function>mac_set_file()</function>, only it will not follow a symbolic link "
"if it is the final entry in a path, so may be used to manipulate the label "
"on a symlink."
msgstr ""
" <function> mac_set_link () </function> � id�ntico a <function> mac_set_file "
"() </function> , s� n�o seguir� um link simb�lico se for a entrada final em "
"um caminho, ent�o pode ser usado para manipular o r�tulo em um symlink \""

#. (itstool) path: listitem/para
#: book.translate.xml:4860
#, fuzzy
msgid ""
"<function>mac_execve()</function> is identical to the <function>execve()</"
"function> system call, only it also accepts a requested label to set the "
"process label to when beginning execution of a new program. This change in "
"label on execution is referred to as a \"transition\"."
msgstr ""
" <function> mac_execve () </function> � id�ntico ao <function> execve () </"
"function> chamada de sistema, s� que tamb�m aceita um r�tulo solicitado para "
"definir o r�tulo do processo ao iniciar a execu��o de um novo programa. Esta "
"mudan�a na etiqueta na execu��o � referida como \\ \"transi��o \". "

#. (itstool) path: listitem/para
#: book.translate.xml:4869
#, fuzzy
msgid ""
"<function>mac_get_peer()</function>, actually implemented via a socket "
"option, retrieves the label of a remote peer on a socket, if available."
msgstr ""
" <function> mac_get_peer () </function> , na verdade, implementado por meio "
"de uma op��o de soquete, recupera o r�tulo de um ponto remoto em um soquete, "
"se dispon�vel. "

#. (itstool) path: sect2/para
#: book.translate.xml:4875
#, fuzzy
msgid ""
"In addition to these system calls, the <literal>SIOCSIGMAC</literal> and "
"<literal>SIOCSIFMAC</literal> network interface ioctls permit the labels on "
"network interfaces to be retrieved and set."
msgstr ""
"Al�m dessas chamadas de sistema, o <literal> SIOCSIGMAC </literal> e "
"<literal> SIOCSIFMAC </literal> Os ioctls da interface de rede permitem que "
"os r�tulos nas interfaces de rede sejam recuperados e definidos. "

#. (itstool) path: sect1/title
#: book.translate.xml:4884
#, fuzzy
msgid "MAC Policy Architecture"
msgstr "Arquitetura de pol�ticas MAC"

#. (itstool) path: sect1/para
#: book.translate.xml:4886
#, fuzzy
msgid ""
"Security policies are either linked directly into the kernel, or compiled "
"into loadable kernel modules that may be loaded at boot, or dynamically "
"using the module loading system calls at runtime. Policy modules interact "
"with the system through a set of declared entry points, providing access to "
"a stream of system events and permitting the policy to influence access "
"control decisions. Each policy contains a number of elements:"
msgstr ""
"As pol�ticas de seguran�a s�o ligadas diretamente ao kernel ou compiladas em "
"m�dulos do kernel carreg�veis ​​que podem ser carregados na inicializa��o ou "
"dinamicamente usando o m�dulo carregando chamadas do sistema em tempo de "
"execu��o. M�dulos de pol�ticas interagem com o sistema atrav�s de um "
"conjunto de pontos de entrada declarados, fornecendo acesso a um fluxo de "
"eventos do sistema e permitindo que a pol�tica influencie as decis�es de "
"controle de acesso. Cada pol�tica cont�m v�rios elementos: "

#. (itstool) path: listitem/para
#: book.translate.xml:4897
#, fuzzy
msgid "Optional configuration parameters for policy."
msgstr "Par�metros de configura��o opcionais para pol�tica."

#. (itstool) path: listitem/para
#: book.translate.xml:4901
#, fuzzy
msgid "Centralized implementation of the policy logic and parameters."
msgstr "Implementa��o centralizada da l�gica e par�metros da pol�tica."

#. (itstool) path: listitem/para
#: book.translate.xml:4905
#, fuzzy
msgid ""
"Optional implementation of policy life cycle events, such as initialization "
"and destruction."
msgstr ""
"Implementa��o opcional de eventos do ciclo de vida da pol�tica, como "
"inicializa��o e destrui��o."

#. (itstool) path: listitem/para
#: book.translate.xml:4909
#, fuzzy
msgid ""
"Optional support for initializing, maintaining, and destroying labels on "
"selected kernel objects."
msgstr ""
"Suporte opcional para inicializar, manter e destruir r�tulos em objetos de "
"kernel selecionados."

#. (itstool) path: listitem/para
#: book.translate.xml:4914
#, fuzzy
msgid ""
"Optional support for user process inspection and modification of labels on "
"selected objects."
msgstr ""
"Suporte opcional para inspe��o de processo do usu�rio e modifica��o de "
"r�tulos em objetos selecionados."

#. (itstool) path: listitem/para
#: book.translate.xml:4919
#, fuzzy
msgid ""
"Implementation of selected access control entry points that are of interest "
"to the policy."
msgstr ""
"Implementa��o de pontos de entrada de controle de acesso selecionados que "
"s�o de interesse para a pol�tica."

#. (itstool) path: listitem/para
#: book.translate.xml:4923
#, fuzzy
msgid ""
"Declaration of policy identity, module entry points, and policy properties."
msgstr ""
"Declara��o de identidade de pol�tica, pontos de entrada de m�dulo e "
"propriedades de pol�tica."

#. (itstool) path: sect2/title
#: book.translate.xml:4929
#, fuzzy
msgid "Policy Declaration"
msgstr "Declara��o de pol�tica"

#. (itstool) path: sect2/para
#: book.translate.xml:4931
#, fuzzy
msgid ""
"Modules may be declared using the <function>MAC_POLICY_SET()</function> "
"macro, which names the policy, provides a reference to the MAC entry point "
"vector, provides load-time flags determining how the policy framework should "
"handle the policy, and optionally requests the allocation of label state by "
"the framework."
msgstr ""
"Os m�dulos podem ser declarados usando o <function> MAC_POLICY_SET () </"
"function> macro, que nomeia a pol�tica, fornece uma refer�ncia ao vetor de "
"ponto de entrada MAC, fornece sinalizadores de tempo de carregamento "
"determinando como a estrutura de pol�tica deve manipular a pol�tica e, "
"opcionalmente, solicita a aloca��o do estado do r�tulo pela estrutura. "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:4938
#, no-wrap
msgid ""
"static struct mac_policy_ops mac_<replaceable>policy</replaceable>_ops =\n"
"{\n"
"        .mpo_destroy = mac_<replaceable>policy</replaceable>_destroy,\n"
"        .mpo_init = mac_<replaceable>policy</replaceable>_init,\n"
"        .mpo_init_bpfdesc_label = mac_<replaceable>policy</"
"replaceable>_init_bpfdesc_label,\n"
"        .mpo_init_cred_label = mac_<replaceable>policy</"
"replaceable>_init_label,\n"
"/* ... */\n"
"        .mpo_check_vnode_setutimes = mac_<replaceable>policy</"
"replaceable>_check_vnode_setutimes,\n"
"        .mpo_check_vnode_stat = mac_<replaceable>policy</"
"replaceable>_check_vnode_stat,\n"
"        .mpo_check_vnode_write = mac_<replaceable>policy</"
"replaceable>_check_vnode_write,\n"
"};"
msgstr ""
"static struct mac_policy_ops mac_<replaceable>policy</replaceable>_ops =\n"
"{\n"
"        .mpo_destroy = mac_<replaceable>policy</replaceable>_destroy,\n"
"        .mpo_init = mac_<replaceable>policy</replaceable>_init,\n"
"        .mpo_init_bpfdesc_label = mac_<replaceable>policy</"
"replaceable>_init_bpfdesc_label,\n"
"        .mpo_init_cred_label = mac_<replaceable>policy</"
"replaceable>_init_label,\n"
"/* ... */\n"
"        .mpo_check_vnode_setutimes = mac_<replaceable>policy</"
"replaceable>_check_vnode_setutimes,\n"
"        .mpo_check_vnode_stat = mac_<replaceable>policy</"
"replaceable>_check_vnode_stat,\n"
"        .mpo_check_vnode_write = mac_<replaceable>policy</"
"replaceable>_check_vnode_write,\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:4950
#, fuzzy
msgid ""
"The MAC policy entry point vector, <varname>mac_<replaceable>policy</"
"replaceable>_ops</varname> in this example, associates functions defined in "
"the module with specific entry points. A complete listing of available entry "
"points and their prototypes may be found in the MAC entry point reference "
"section. Of specific interest during module registration are the <symbol>."
"mpo_destroy</symbol> and <symbol>.mpo_init</symbol> entry points. <symbol>."
"mpo_init</symbol> will be invoked once a policy is successfully registered "
"with the module framework but prior to any other entry points becoming "
"active. This permits the policy to perform any policy-specific allocation "
"and initialization, such as initialization of any data or locks. <symbol>."
"mpo_destroy</symbol> will be invoked when a policy module is unloaded to "
"permit releasing of any allocated memory and destruction of locks. "
"Currently, these two entry points are invoked with the MAC policy list mutex "
"held to prevent any other entry points from being invoked: this will be "
"changed, but in the mean time, policies should be careful about what kernel "
"primitives they invoke so as to avoid lock ordering or sleeping problems."
msgstr ""
"O vetor do ponto de entrada da pol�tica MAC, <varname> Mac_ <replaceable> "
"pol�tica </replaceable> _ops </varname> neste exemplo, associa fun��es "
"definidas no m�dulo com pontos de entrada espec�ficos. Uma lista completa "
"dos pontos de entrada dispon�veis e seus prot�tipos podem ser encontrados na "
"se��o de refer�ncia do ponto de entrada MAC. De interesse espec�fico durante "
"o registro do m�dulo s�o os <symbol> .mpo_destroy </symbol> e <symbol> ."
"mpo_init </symbol> pontos de entrada. <symbol> .mpo_init </symbol> ser� "
"invocado assim que uma pol�tica for registrada com sucesso na estrutura do "
"m�dulo, mas antes de qualquer outro ponto de entrada se tornar ativo. Isso "
"permite que a pol�tica execute qualquer aloca��o e inicializa��o espec�ficas "
"da pol�tica, como a inicializa��o de quaisquer dados ou bloqueios. <symbol> ."
"mpo_destroy </symbol> ser� invocado quando um m�dulo de pol�tica for "
"descarregado para permitir a libera��o de qualquer mem�ria alocada e "
"destrui��o de bloqueios. Atualmente, esses dois pontos de entrada s�o "
"invocados com o mutex da lista de pol�ticas MAC mantido para evitar que "
"outros pontos de entrada sejam invocados: isso ser� alterado, mas nesse meio "
"tempo, as pol�ticas devem ter cuidado com as primitivas de kernel que "
"invocam para evitar bloquear pedidos ou problemas de sono. "

#. (itstool) path: sect2/para
#: book.translate.xml:4972
#, fuzzy
msgid ""
"The policy declaration's module name field exists so that the module may be "
"uniquely identified for the purposes of module dependencies. An appropriate "
"string should be selected. The full string name of the policy is displayed "
"to the user via the kernel log during load and unload events, and also "
"exported when providing status information to userland processes."
msgstr ""
"O campo de nome do m�dulo da declara��o de pol�tica existe para que o m�dulo "
"possa ser identificado exclusivamente para fins de depend�ncias do m�dulo. "
"Uma sequ�ncia apropriada deve ser selecionada. O nome completo da cadeia da "
"pol�tica � exibido ao usu�rio atrav�s do log do kernel durante o "
"carregamento e descarregamento eventos e tamb�m exportados ao fornecer "
"informa��es de status para os processos do usu�rio. "

#. (itstool) path: sect2/title
#: book.translate.xml:4982
#, fuzzy
msgid "Policy Flags"
msgstr "Bandeiras de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:4984
#, fuzzy
msgid ""
"The policy declaration flags field permits the module to provide the "
"framework with information about its capabilities at the time the module is "
"loaded. Currently, three flags are defined:"
msgstr ""
"O campo flags de declara��o de pol�tica permite que o m�dulo forne�a � "
"estrutura informa��es sobre suas capacidades no momento em que o m�dulo � "
"carregado. Atualmente, tr�s sinalizadores s�o definidos:"

#. (itstool) path: varlistentry/term
#: book.translate.xml:4991
#, fuzzy
msgid "MPC_LOADTIME_FLAG_UNLOADOK"
msgstr "MPC_LOADTIME_FLAG_UNLOADOK"

#. (itstool) path: listitem/para
#: book.translate.xml:4994
#, fuzzy
msgid ""
"This flag indicates that the policy module may be unloaded. If this flag is "
"not provided, then the policy framework will reject requests to unload the "
"module. This flag might be used by modules that allocate label state and are "
"unable to free that state at runtime."
msgstr ""
"Esse sinalizador indica que o m�dulo de pol�tica pode ser descarregado. Se "
"esse sinalizador n�o for fornecido, a estrutura de pol�tica rejeitar� "
"solicita��es para descarregar o m�dulo. Esse sinalizador pode ser usado por "
"m�dulos que alocam o estado de r�tulo e n�o conseguem liberar esse estado em "
"tempo de execu��o."

#. (itstool) path: varlistentry/term
#: book.translate.xml:5004
#, fuzzy
msgid "MPC_LOADTIME_FLAG_NOTLATE"
msgstr "MPC_LOADTIME_FLAG_NOTLATE"

#. (itstool) path: listitem/para
#: book.translate.xml:5007
#, fuzzy
msgid ""
"This flag indicates that the policy module must be loaded and initialized "
"early in the boot process. If the flag is specified, attempts to register "
"the module following boot will be rejected. The flag may be used by policies "
"that require pervasive labeling of all system objects, and cannot handle "
"objects that have not been properly initialized by the policy."
msgstr ""
"Este sinalizador indica que o m�dulo de pol�tica deve ser carregado e "
"inicializado no in�cio do processo de inicializa��o. Se o sinalizador for "
"especificado, tentativas de registrar o m�dulo ap�s a inicializa��o ser�o "
"rejeitadas. O sinalizador pode ser usado por pol�ticas que exigem rotulagem "
"abrangente de todo o sistema objetos e n�o podem manipular objetos que n�o "
"foram inicializados corretamente pela pol�tica. "

#. (itstool) path: varlistentry/term
#: book.translate.xml:5018
#, fuzzy
msgid "MPC_LOADTIME_FLAG_LABELMBUFS"
msgstr "MPC_LOADTIME_FLAG_LABELMBUFS"

#. (itstool) path: listitem/para
#: book.translate.xml:5021
#, fuzzy
msgid ""
"This flag indicates that the policy module requires labeling of Mbufs, and "
"that memory should always be allocated for the storage of Mbuf labels. By "
"default, the MAC Framework will not allocate label storage for Mbufs unless "
"at least one loaded policy has this flag set. This measurably improves "
"network performance when policies do not require Mbuf labeling. A kernel "
"option, <literal>MAC_ALWAYS_LABEL_MBUF</literal>, exists to force the MAC "
"Framework to allocate Mbuf label storage regardless of the setting of this "
"flag, and may be useful in some environments."
msgstr ""
"Este sinalizador indica que o m�dulo de pol�tica requer rotulagem de Mbufs, "
"e essa mem�ria sempre deve ser alocada para o armazenamento de r�tulos Mbuf. "
"Por padr�o, o MAC Framework n�o alocar� armazenamento de r�tulo para Mbufs a "
"menos que pelo menos uma diretiva carregada tenha este sinalizador definido "
"Isso aumenta consideravelmente o desempenho da rede quando as pol�ticas n�o "
"exigem rotulagem Mbuf. <literal> MAC_ALWAYS_LABEL_MBUF </literal> existe "
"para for�ar o MAC Framework a alocar o armazenamento de r�tulos Mbuf, "
"independentemente da configura��o desse sinalizador, e pode ser �til em "
"alguns ambientes. "

#. (itstool) path: note/para
#: book.translate.xml:5037
#, fuzzy
msgid ""
"Policies using the <literal>MPC_LOADTIME_FLAG_LABELMBUFS</literal> without "
"the <literal>MPC_LOADTIME_FLAG_NOTLATE</literal> flag set must be able to "
"correctly handle <literal>NULL</literal> Mbuf label pointers passed into "
"entry points. This is necessary as in-flight Mbufs without label storage may "
"persist after a policy enabling Mbuf labeling has been loaded. If a policy "
"is loaded before the network subsystem is active (i.e., the policy is not "
"being loaded late), then all Mbufs are guaranteed to have label storage."
msgstr ""
"Pol�ticas usando o <literal> MPC_LOADTIME_FLAG_LABELMBUFS </literal> sem o "
"<literal> MPC_LOADTIME_FLAG_NOTLATE </literal> conjunto de sinalizadores "
"deve ser capaz de manipular corretamente <literal> NULO </literal> Ponteiros "
"de r�tulos Mbuf passados ​​para pontos de entrada. Isso � necess�rio, pois o "
"Mbufs em andamento sem armazenamento de r�tulo pode persistir ap�s uma "
"pol�tica que permite que o r�tulo Mbuf seja carregado. Se uma pol�tica for "
"carregada antes que o subsistema de rede esteja ativo (ou seja, a pol�tica "
"n�o esteja sendo carregada com atraso), todos os Mbufs ter�o garantia de "
"armazenamento de r�tulo. "

#. (itstool) path: sect2/title
#: book.translate.xml:5051
#, fuzzy
msgid "Policy Entry Points"
msgstr "Pontos de Entrada de Pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:5053
#, fuzzy
msgid ""
"Four classes of entry points are offered to policies registered with the "
"framework: entry points associated with the registration and management of "
"policies, entry points denoting initialization, creation, destruction, and "
"other life cycle events for kernel objects, events associated with access "
"control decisions that the policy module may influence, and calls associated "
"with the management of labels on objects. In addition, a "
"<function>mac_syscall()</function> entry point is provided so that policies "
"may extend the kernel interface without registering new system calls."
msgstr ""
"Quatro classes de pontos de entrada s�o oferecidas a pol�ticas registradas "
"no framework: pontos de entrada associados ao registro e gerenciamento de "
"pol�ticas, pontos de entrada denotando inicializa��o, cria��o, destrui��o e "
"outros eventos de ciclo de vida para objetos do kernel, eventos associados a "
"decis�es de controle de acesso que o m�dulo de pol�tica pode influenciar e "
"as chamadas associadas ao gerenciamento de r�tulos em objetos. <function> "
"mac_syscall () </function> ponto de entrada � fornecido para que as "
"pol�ticas possam estender a interface do kernel sem registrar novas chamadas "
"do sistema. "

#. (itstool) path: sect2/para
#: book.translate.xml:5064
#, fuzzy
msgid ""
"Policy module writers should be aware of the kernel locking strategy, as "
"well as what object locks are available during which entry points. Writers "
"should attempt to avoid deadlock scenarios by avoiding grabbing non-leaf "
"locks inside of entry points, and also follow the locking protocol for "
"object access and modification. In particular, writers should be aware that "
"while necessary locks to access objects and their labels are generally held, "
"sufficient locks to modify an object or its label may not be present for all "
"entry points. Locking information for arguments is documented in the MAC "
"framework entry point document."
msgstr ""
"Os redatores de módulos de política devem estar cientes da estratégia de "
"bloqueio do kernel, bem como quais bloqueios de objeto estão disponíveis "
"durante os quais os pontos de entrada. Os escritores devem tentar evitar "
"cenários de impasse, evitando pegar bloqueios não-folha dentro de pontos de "
"entrada, e também seguir o protocolo de bloqueio para acesso e modificação "
"de objetos. Em particular, os escritores devem estar cientes de que, embora "
"bloqueios necessários para acessar objetos e seus rótulos sejam geralmente "
"mantidos, bloqueios suficientes para modificar um objeto ou seu rótulo podem "
"não estar presentes em todos os pontos de entrada. A informação de bloqueio "
"para argumentos é documentada no documento do ponto de entrada da estrutura "
"MAC."

#. (itstool) path: sect2/para
#: book.translate.xml:5076
#, fuzzy
msgid ""
"Policy entry points will pass a reference to the object label along with the "
"object itself. This permits labeled policies to be unaware of the internals "
"of the object yet still make decisions based on the label. The exception to "
"this is the process credential, which is assumed to be understood by "
"policies as a first class security object in the kernel."
msgstr ""
"Os pontos de entrada da pol�tica passar�o uma refer�ncia ao r�tulo do objeto "
"junto com o pr�prio objeto. Isso permite que as pol�ticas rotuladas n�o "
"estejam cientes dos componentes internos do objeto e ainda tomem decis�es "
"com base no r�tulo. A exce��o a isso � a credencial do processo, que � "
"assumido como sendo entendido pelas pol�ticas como um objeto de seguran�a de "
"primeira classe no kernel. "

#. (itstool) path: sect1/title
#: book.translate.xml:5087
#, fuzzy
msgid "MAC Policy Entry Point Reference"
msgstr "Refer�ncia do Ponto de Entrada da Pol�tica MAC"

#. (itstool) path: sect2/title
#: book.translate.xml:5090
#, fuzzy
msgid "General-Purpose Module Entry Points"
msgstr "Pontos de Entrada do M�dulo de Finalidade Geral"

#. (itstool) path: sect3/title
#: book.translate.xml:5093
#, fuzzy
msgid "<function>mpo_init</function>"
msgstr " <function> mpo_init </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5096
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init </function></funcdef><paramdef> struct "
"mac_policy_conf * <parameter> conf </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5114 book.translate.xml:5160 book.translate.xml:5203
#: book.translate.xml:5271 book.translate.xml:5335 book.translate.xml:5377
#: book.translate.xml:5419 book.translate.xml:5461 book.translate.xml:5504
#: book.translate.xml:5562 book.translate.xml:5622 book.translate.xml:5671
#: book.translate.xml:5713 book.translate.xml:5756 book.translate.xml:5807
#: book.translate.xml:5857 book.translate.xml:5900 book.translate.xml:5942
#: book.translate.xml:5986 book.translate.xml:6030 book.translate.xml:6074
#: book.translate.xml:6118 book.translate.xml:6162 book.translate.xml:6206
#: book.translate.xml:6252 book.translate.xml:6302 book.translate.xml:6346
#: book.translate.xml:6390 book.translate.xml:6433 book.translate.xml:6476
#: book.translate.xml:6522 book.translate.xml:6571 book.translate.xml:6620
#: book.translate.xml:6671 book.translate.xml:6748 book.translate.xml:6825
#: book.translate.xml:6902 book.translate.xml:6978 book.translate.xml:7055
#: book.translate.xml:7132 book.translate.xml:7207 book.translate.xml:7282
#: book.translate.xml:7357 book.translate.xml:7432 book.translate.xml:7588
#: book.translate.xml:7667 book.translate.xml:7737 book.translate.xml:7800
#: book.translate.xml:7862 book.translate.xml:7929 book.translate.xml:8012
#: book.translate.xml:8101 book.translate.xml:8167 book.translate.xml:8216
#: book.translate.xml:8282 book.translate.xml:8349 book.translate.xml:8426
#: book.translate.xml:8492 book.translate.xml:8550 book.translate.xml:8611
#: book.translate.xml:8677 book.translate.xml:8742 book.translate.xml:8808
#: book.translate.xml:8873 book.translate.xml:8943 book.translate.xml:9001
#: book.translate.xml:9058 book.translate.xml:9124 book.translate.xml:9190
#: book.translate.xml:9256 book.translate.xml:9324 book.translate.xml:9392
#: book.translate.xml:9459 book.translate.xml:9528 book.translate.xml:9608
#: book.translate.xml:9677 book.translate.xml:9754 book.translate.xml:9821
#: book.translate.xml:9888 book.translate.xml:9944 book.translate.xml:10021
#: book.translate.xml:10084 book.translate.xml:10126 book.translate.xml:10170
#: book.translate.xml:10285 book.translate.xml:10349 book.translate.xml:10392
#: book.translate.xml:10441 book.translate.xml:10489 book.translate.xml:10540
#: book.translate.xml:10593 book.translate.xml:10636 book.translate.xml:10685
#: book.translate.xml:10752 book.translate.xml:10809 book.translate.xml:10868
#: book.translate.xml:10931 book.translate.xml:10989 book.translate.xml:11048
#: book.translate.xml:11110 book.translate.xml:11179 book.translate.xml:11237
#: book.translate.xml:11293 book.translate.xml:11354 book.translate.xml:11410
#: book.translate.xml:11475 book.translate.xml:11536 book.translate.xml:11591
#: book.translate.xml:11656 book.translate.xml:11721 book.translate.xml:11782
#: book.translate.xml:11852 book.translate.xml:11914 book.translate.xml:11976
#: book.translate.xml:12058 book.translate.xml:12145 book.translate.xml:12214
#: book.translate.xml:12279 book.translate.xml:12352 book.translate.xml:12438
#: book.translate.xml:12514 book.translate.xml:12578 book.translate.xml:12638
#: book.translate.xml:12697 book.translate.xml:12766 book.translate.xml:12848
#: book.translate.xml:12931 book.translate.xml:12991 book.translate.xml:13059
#: book.translate.xml:13122 book.translate.xml:13184 book.translate.xml:13250
#: book.translate.xml:13316 book.translate.xml:13394 book.translate.xml:13480
#: book.translate.xml:13548 book.translate.xml:13617 book.translate.xml:13689
#: book.translate.xml:13759 book.translate.xml:13816 book.translate.xml:13877
#: book.translate.xml:13945 book.translate.xml:14021 book.translate.xml:14094
#: book.translate.xml:14159 book.translate.xml:14213 book.translate.xml:14256
#: book.translate.xml:14304 book.translate.xml:14350 book.translate.xml:14411
#, fuzzy
msgid "Parameter"
msgstr "Par�metro"

#. (itstool) path: row/entry
#: book.translate.xml:5115 book.translate.xml:5161 book.translate.xml:5204
#: book.translate.xml:5272 book.translate.xml:5336 book.translate.xml:5378
#: book.translate.xml:5420 book.translate.xml:5462 book.translate.xml:5505
#: book.translate.xml:5563 book.translate.xml:5623 book.translate.xml:5672
#: book.translate.xml:5714 book.translate.xml:5757 book.translate.xml:5808
#: book.translate.xml:5858 book.translate.xml:5901 book.translate.xml:5943
#: book.translate.xml:5987 book.translate.xml:6031 book.translate.xml:6075
#: book.translate.xml:6119 book.translate.xml:6163 book.translate.xml:6207
#: book.translate.xml:6253 book.translate.xml:6303 book.translate.xml:6347
#: book.translate.xml:6391 book.translate.xml:6434 book.translate.xml:6477
#: book.translate.xml:6523 book.translate.xml:6572 book.translate.xml:6621
#: book.translate.xml:6672 book.translate.xml:6749 book.translate.xml:6826
#: book.translate.xml:6903 book.translate.xml:6979 book.translate.xml:7056
#: book.translate.xml:7133 book.translate.xml:7208 book.translate.xml:7283
#: book.translate.xml:7358 book.translate.xml:7433 book.translate.xml:7589
#: book.translate.xml:7668 book.translate.xml:7738 book.translate.xml:7801
#: book.translate.xml:7863 book.translate.xml:7930 book.translate.xml:8013
#: book.translate.xml:8102 book.translate.xml:8168 book.translate.xml:8217
#: book.translate.xml:8283 book.translate.xml:8350 book.translate.xml:8427
#: book.translate.xml:8493 book.translate.xml:8551 book.translate.xml:8612
#: book.translate.xml:8678 book.translate.xml:8743 book.translate.xml:8809
#: book.translate.xml:8874 book.translate.xml:8944 book.translate.xml:9002
#: book.translate.xml:9059 book.translate.xml:9125 book.translate.xml:9191
#: book.translate.xml:9257 book.translate.xml:9325 book.translate.xml:9393
#: book.translate.xml:9460 book.translate.xml:9529 book.translate.xml:9609
#: book.translate.xml:9678 book.translate.xml:9755 book.translate.xml:9822
#: book.translate.xml:9889 book.translate.xml:9945 book.translate.xml:10022
#: book.translate.xml:10085 book.translate.xml:10127 book.translate.xml:10171
#: book.translate.xml:10286 book.translate.xml:10350 book.translate.xml:10393
#: book.translate.xml:10442 book.translate.xml:10490 book.translate.xml:10541
#: book.translate.xml:10594 book.translate.xml:10637 book.translate.xml:10686
#: book.translate.xml:10753 book.translate.xml:10810 book.translate.xml:10869
#: book.translate.xml:10932 book.translate.xml:10990 book.translate.xml:11049
#: book.translate.xml:11111 book.translate.xml:11180 book.translate.xml:11238
#: book.translate.xml:11294 book.translate.xml:11355 book.translate.xml:11411
#: book.translate.xml:11476 book.translate.xml:11537 book.translate.xml:11592
#: book.translate.xml:11657 book.translate.xml:11722 book.translate.xml:11783
#: book.translate.xml:11853 book.translate.xml:11915 book.translate.xml:11977
#: book.translate.xml:12059 book.translate.xml:12146 book.translate.xml:12215
#: book.translate.xml:12280 book.translate.xml:12353 book.translate.xml:12439
#: book.translate.xml:12515 book.translate.xml:12579 book.translate.xml:12639
#: book.translate.xml:12698 book.translate.xml:12767 book.translate.xml:12849
#: book.translate.xml:12932 book.translate.xml:12992 book.translate.xml:13060
#: book.translate.xml:13123 book.translate.xml:13185 book.translate.xml:13251
#: book.translate.xml:13317 book.translate.xml:13395 book.translate.xml:13481
#: book.translate.xml:13549 book.translate.xml:13618 book.translate.xml:13690
#: book.translate.xml:13760 book.translate.xml:13817 book.translate.xml:13878
#: book.translate.xml:13946 book.translate.xml:14022 book.translate.xml:14095
#: book.translate.xml:14160 book.translate.xml:14214 book.translate.xml:14257
#: book.translate.xml:14305 book.translate.xml:14351 book.translate.xml:14412
#, fuzzy
msgid "Description"
msgstr "Descri��o"

#. (itstool) path: row/entry
#: book.translate.xml:5116 book.translate.xml:5162 book.translate.xml:5205
#: book.translate.xml:5273 book.translate.xml:5337 book.translate.xml:5379
#: book.translate.xml:5421 book.translate.xml:5463 book.translate.xml:5506
#: book.translate.xml:5564 book.translate.xml:5624 book.translate.xml:5673
#: book.translate.xml:5715 book.translate.xml:5758 book.translate.xml:5809
#: book.translate.xml:5859 book.translate.xml:5902 book.translate.xml:5944
#: book.translate.xml:5988 book.translate.xml:6032 book.translate.xml:6076
#: book.translate.xml:6120 book.translate.xml:6164 book.translate.xml:6208
#: book.translate.xml:6254 book.translate.xml:6304 book.translate.xml:6348
#: book.translate.xml:6392 book.translate.xml:6435 book.translate.xml:6478
#: book.translate.xml:6524 book.translate.xml:6573 book.translate.xml:6622
#: book.translate.xml:6673 book.translate.xml:6750 book.translate.xml:6827
#: book.translate.xml:6904 book.translate.xml:6980 book.translate.xml:7057
#: book.translate.xml:7134 book.translate.xml:7209 book.translate.xml:7284
#: book.translate.xml:7359 book.translate.xml:7434 book.translate.xml:7590
#: book.translate.xml:7669 book.translate.xml:7739 book.translate.xml:7802
#: book.translate.xml:7864 book.translate.xml:7931 book.translate.xml:8014
#: book.translate.xml:8103 book.translate.xml:8169 book.translate.xml:8218
#: book.translate.xml:8284 book.translate.xml:8351 book.translate.xml:8428
#: book.translate.xml:8494 book.translate.xml:8552 book.translate.xml:8613
#: book.translate.xml:8679 book.translate.xml:8744 book.translate.xml:8810
#: book.translate.xml:8875 book.translate.xml:8945 book.translate.xml:9003
#: book.translate.xml:9060 book.translate.xml:9126 book.translate.xml:9192
#: book.translate.xml:9258 book.translate.xml:9326 book.translate.xml:9394
#: book.translate.xml:9461 book.translate.xml:9530 book.translate.xml:9610
#: book.translate.xml:9679 book.translate.xml:9756 book.translate.xml:9823
#: book.translate.xml:9890 book.translate.xml:9946 book.translate.xml:10023
#: book.translate.xml:10086 book.translate.xml:10128 book.translate.xml:10172
#: book.translate.xml:10287 book.translate.xml:10351 book.translate.xml:10394
#: book.translate.xml:10443 book.translate.xml:10491 book.translate.xml:10542
#: book.translate.xml:10595 book.translate.xml:10638 book.translate.xml:10687
#: book.translate.xml:10754 book.translate.xml:10811 book.translate.xml:10870
#: book.translate.xml:10933 book.translate.xml:10991 book.translate.xml:11050
#: book.translate.xml:11112 book.translate.xml:11181 book.translate.xml:11239
#: book.translate.xml:11295 book.translate.xml:11356 book.translate.xml:11412
#: book.translate.xml:11477 book.translate.xml:11538 book.translate.xml:11593
#: book.translate.xml:11658 book.translate.xml:11723 book.translate.xml:11784
#: book.translate.xml:11854 book.translate.xml:11916 book.translate.xml:11978
#: book.translate.xml:12060 book.translate.xml:12147 book.translate.xml:12216
#: book.translate.xml:12281 book.translate.xml:12354 book.translate.xml:12440
#: book.translate.xml:12516 book.translate.xml:12580 book.translate.xml:12640
#: book.translate.xml:12699 book.translate.xml:12768 book.translate.xml:12850
#: book.translate.xml:12933 book.translate.xml:12993 book.translate.xml:13061
#: book.translate.xml:13124 book.translate.xml:13186 book.translate.xml:13252
#: book.translate.xml:13318 book.translate.xml:13396 book.translate.xml:13482
#: book.translate.xml:13550 book.translate.xml:13619 book.translate.xml:13691
#: book.translate.xml:13761 book.translate.xml:13818 book.translate.xml:13879
#: book.translate.xml:13947 book.translate.xml:14023 book.translate.xml:14096
#: book.translate.xml:14161 book.translate.xml:14215 book.translate.xml:14258
#: book.translate.xml:14306 book.translate.xml:14352 book.translate.xml:14413
#, fuzzy
msgid "Locking"
msgstr "Bloqueio"

#. (itstool) path: row/entry
#: book.translate.xml:5123 book.translate.xml:5169
#, fuzzy
msgid "<parameter>conf</parameter>"
msgstr " <parameter> conf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5124 book.translate.xml:5170
#, fuzzy
msgid "MAC policy definition"
msgstr "Defini��o de pol�tica MAC"

#. (itstool) path: sect3/para
#: book.translate.xml:5130
#, fuzzy
msgid ""
"Policy load event. The policy list mutex is held, so sleep operations cannot "
"be performed, and calls out to other kernel subsystems must be made with "
"caution. If potentially sleeping memory allocations are required during "
"policy initialization, they should be made using a separate module SYSINIT()."
""
msgstr ""
"Evento de carregamento da pol�tica. O mutex da lista de pol�ticas � retido, "
"portanto opera��es de suspens�o n�o podem ser executadas e chamadas para "
"outros subsistemas do kernel devem ser feitas com cautela. Se aloca��es de "
"mem�ria potencialmente suspensas forem necess�rias durante a inicializa��o "
"da pol�tica, elas devem ser feitas usando m�dulo SYSINIT (). "

#. (itstool) path: sect3/title
#: book.translate.xml:5139
#, fuzzy
msgid "<function>mpo_destroy</function>"
msgstr " <function> mpo_destroy </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5142
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy</function></funcdef> <paramdef>struct "
"mac_policy_conf *<parameter>conf</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy </function></funcdef><paramdef> "
"struct mac_policy_conf * <parameter> conf </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5176
#, fuzzy
msgid ""
"Policy load event. The policy list mutex is held, so caution should be "
"applied."
msgstr ""
"Evento de carregamento da pol�tica. O mutex da lista de pol�ticas � mantido, "
"portanto, cuidado deve ser aplicado."

#. (itstool) path: sect3/title
#: book.translate.xml:5181
#, fuzzy
msgid "<function>mpo_syscall</function>"
msgstr " <function> mpo_syscall </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5184
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_syscall</function></funcdef> <paramdef>struct "
"thread *<parameter>td</parameter></paramdef> <paramdef>int <parameter>call</"
"parameter></paramdef> <paramdef>void *<parameter>arg</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_syscall </function></funcdef><paramdef> thread "
"de estrutura * <parameter> td </parameter></paramdef><paramdef> int "
"<parameter> ligar </parameter></paramdef><paramdef> void * <parameter> arg </"
"parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5212 book.translate.xml:5280
#, fuzzy
msgid "<parameter>td</parameter>"
msgstr " <parameter> por exemplo, </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5213
#, fuzzy
msgid "Calling thread"
msgstr "Chamada de discuss�o"

#. (itstool) path: row/entry
#: book.translate.xml:5217
#, fuzzy
msgid "<parameter>call</parameter>"
msgstr " <parameter> ligar </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5218
#, fuzzy
msgid "Policy-specific syscall number"
msgstr "N�mero de syscall espec�fico da pol�tica"

#. (itstool) path: row/entry
#: book.translate.xml:5222
#, fuzzy
msgid "<parameter>arg</parameter>"
msgstr " <parameter> arg </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5223
#, fuzzy
msgid "Pointer to syscall arguments"
msgstr "Ponteiro para argumentos syscall"

#. (itstool) path: sect3/para
#: book.translate.xml:5229
#, fuzzy
msgid ""
"This entry point provides a policy-multiplexed system call so that policies "
"may provide additional services to user processes without registering "
"specific system calls. The policy name provided during registration is used "
"to demux calls from userland, and the arguments will be forwarded to this "
"entry point. When implementing new services, security modules should be sure "
"to invoke appropriate access control checks from the MAC framework as needed."
" For example, if a policy implements an augmented signal functionality, it "
"should call the necessary signal access control checks to invoke the MAC "
"framework and other registered policies."
msgstr ""
"Esse ponto de entrada fornece uma chamada de sistema multiplexada por "
"pol�tica para que as pol�ticas possam fornecer servi�os adicionais aos "
"processos do usu�rio sem registrar chamadas espec�ficas do sistema. O nome "
"da pol�tica fornecido durante o registro � usado para desmobilizar chamadas "
"de usu�rios e os argumentos ser�o encaminhados para essa entrada. Ao "
"implementar novos servi�os, os m�dulos de seguran�a devem invocar as "
"verifica��es de controle de acesso apropriadas da estrutura do MAC, conforme "
"necess�rio.Por exemplo, se uma pol�tica implementa uma funcionalidade de "
"sinal aumentada, ela deve chamar as verifica��es de controle de acesso de "
"sinal necess�rias para invocar o MAC. estrutura e outras pol�ticas "
"registradas. "

#. (itstool) path: note/para
#: book.translate.xml:5243
#, fuzzy
msgid ""
"Modules must currently perform the <function>copyin()</function> of the "
"syscall data on their own."
msgstr ""
"Os m�dulos devem atualmente executar o <function> copyin () </function> dos "
"dados syscall por conta pr�pria. "

#. (itstool) path: sect3/title
#: book.translate.xml:5250
#, fuzzy
msgid "<function>mpo_thread_userret</function>"
msgstr " <function> mpo_thread_userret </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5253
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_thread_userret</function></funcdef> "
"<paramdef>struct thread *<parameter>td</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_thread_userret </function></"
"funcdef><paramdef> thread de estrutura * <parameter> td </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5281
#, fuzzy
msgid "Returning thread"
msgstr "T�pico de retorno"

#. (itstool) path: sect3/para
#: book.translate.xml:5288
#, fuzzy
msgid ""
"This entry point permits policy modules to perform MAC-related events when a "
"thread returns to user space, via a system call return, trap return, or "
"otherwise. This is required for policies that have floating process labels, "
"as it is not always possible to acquire the process lock at arbitrary points "
"in the stack during system call processing; process labels might represent "
"traditional authentication data, process history information, or other data. "
"To employ this mechanism, intended changes to the process credential label "
"may be stored in the <literal>p_label</literal> protected by a per-policy "
"spin lock, and then set the per-thread <literal>TDF_ASTPENDING</literal> "
"flag and per-process <literal>PS_MACPENDM</literal> flag to schedule a call "
"to the userret entry point. From this entry point, the policy may create a "
"replacement credential with less concern about the locking context. Policy "
"writers are cautioned that event ordering relating to scheduling an AST and "
"the AST being performed may be complex and interlaced in multithreaded "
"applications."
msgstr ""
"Esse ponto de entrada permite que os m�dulos de pol�tica executem eventos "
"relacionados ao MAC quando um encadeamento retorna ao espa�o do usu�rio, por "
"meio de um retorno de chamada do sistema, retorno de intercepta��o ou outro. "
"Isso � necess�rio para pol�ticas que possuem r�tulos de processo flutuantes, "
"pois nem sempre � poss�vel para adquirir o bloqueio de processo em pontos "
"arbitr�rios na pilha durante o processamento da chamada do sistema, os "
"r�tulos de processo podem representar dados de autentica��o tradicionais, "
"informa��es do hist�rico de processos ou outros dados. <literal> p_label </"
"literal> protegido por um bloqueio por rota��o por pol�tica e, em seguida, "
"defina o <literal> TDF_ASTPENDING </literal> bandeira e por processo "
"<literal> PS_MACPENDM </literal> flag para agendar uma chamada para o ponto "
"de entrada userret. A partir desse ponto de entrada, a pol�tica pode criar "
"uma credencial de substitui��o com menos preocupa��o sobre o contexto de "
"bloqueio. Escritores de pol�ticas s�o alertados que a ordena��o de eventos "
"relacionados ao planejamento de um AST e do AST sendo executado pode ser "
"complexa e entrela�ada em aplicativos multithread. "

#. (itstool) path: sect2/title
#: book.translate.xml:5311
#, fuzzy
msgid "Label Operations"
msgstr "Opera��es de etiqueta"

#. (itstool) path: sect3/title
#: book.translate.xml:5314
#, fuzzy
msgid "<function>mpo_init_bpfdesc_label</function>"
msgstr " <function> mpo_init_bpfdesc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5317
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_bpfdesc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:5344 book.translate.xml:5386 book.translate.xml:5428
#: book.translate.xml:5470 book.translate.xml:5513 book.translate.xml:5577
#: book.translate.xml:5680 book.translate.xml:5722 book.translate.xml:5765
#: book.translate.xml:5816 book.translate.xml:5866 book.translate.xml:5909
#: book.translate.xml:5951 book.translate.xml:5995 book.translate.xml:6039
#: book.translate.xml:6083 book.translate.xml:6127 book.translate.xml:6171
#: book.translate.xml:6215 book.translate.xml:6311 book.translate.xml:6399
#: book.translate.xml:6442 book.translate.xml:6485 book.translate.xml:6681
#: book.translate.xml:6758 book.translate.xml:6835 book.translate.xml:6912
#: book.translate.xml:6988 book.translate.xml:7065 book.translate.xml:7142
#: book.translate.xml:7217 book.translate.xml:7292 book.translate.xml:7367
#: book.translate.xml:7442 book.translate.xml:7820 book.translate.xml:8031
#: book.translate.xml:11801 book.translate.xml:12088 book.translate.xml:12166
#: book.translate.xml:12233 book.translate.xml:12298 book.translate.xml:12371
#: book.translate.xml:12468 book.translate.xml:12533 book.translate.xml:12596
#: book.translate.xml:12722 book.translate.xml:12796 book.translate.xml:12878
#: book.translate.xml:13078 book.translate.xml:13203 book.translate.xml:13269
#: book.translate.xml:13335 book.translate.xml:13413 book.translate.xml:13499
#: book.translate.xml:13567 book.translate.xml:13636 book.translate.xml:13708
#: book.translate.xml:13896
#, fuzzy
msgid "<parameter>label</parameter>"
msgstr " <parameter> r�tulo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5345 book.translate.xml:5429 book.translate.xml:5471
#: book.translate.xml:5514
#, fuzzy
msgid "New label to apply"
msgstr "Novo r�tulo para aplicar"

#. (itstool) path: sect3/para
#: book.translate.xml:5351
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated bpfdesc (BPF descriptor). "
"Sleeping is permitted."
msgstr ""
"Inicialize o r�tulo em um bpfdesc rec�m-instanciado (descritor BPF). Dormir "
"� permitido."

#. (itstool) path: sect3/title
#: book.translate.xml:5356
#, fuzzy
msgid "<function>mpo_init_cred_label</function>"
msgstr " <function> mpo_init_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5359
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:5387 book.translate.xml:5766 book.translate.xml:5817
#: book.translate.xml:5867 book.translate.xml:5910
#, fuzzy
msgid "New label to initialize"
msgstr "Novo r�tulo para inicializar"

#. (itstool) path: sect3/para
#: book.translate.xml:5393
#, fuzzy
msgid ""
"Initialize the label for a newly instantiated user credential. Sleeping is "
"permitted."
msgstr ""
"Inicialize o r�tulo para uma credencial de usu�rio rec�m-instanciada. A "
"suspens�o � permitida."

#. (itstool) path: sect3/title
#: book.translate.xml:5398
#, fuzzy
msgid "<function>mpo_init_devfsdirent_label</function>"
msgstr " <function> mpo_init_devfsdirent_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5401
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_devfsdirent_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:5435
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated devfs entry. Sleeping is "
"permitted."
msgstr ""
"Inicialize o r�tulo em uma entrada recentemente instanciada devfs. Dormir � "
"permitido."

#. (itstool) path: sect3/title
#: book.translate.xml:5440
#, fuzzy
msgid "<function>mpo_init_ifnet_label</function>"
msgstr " <function> mpo_init_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5443
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:5477
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated network interface. Sleeping is "
"permitted."
msgstr ""
"Inicialize o r�tulo em uma interface de rede rec�m-instanciada. � permitido "
"dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5482
#, fuzzy
msgid "<function>mpo_init_ipq_label</function>"
msgstr " <function> mpo_init_ipq_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5485
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_ipq_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5518 book.translate.xml:5571 book.translate.xml:5770
#: book.translate.xml:5821
#, fuzzy
msgid "<parameter>flag</parameter>"
msgstr " <parameter> bandeira </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5519 book.translate.xml:5572
#, fuzzy
msgid ""
"Sleeping/non-sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>; see below"
msgstr ""
"Dormir / n�o dormir <citerefentry><refentrytitle> malloc </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ; ver abaixo"

#. (itstool) path: sect3/para
#: book.translate.xml:5526
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated IP fragment reassembly queue. "
"The <parameter>flag</parameter> field may be one of <symbol>M_WAITOK</"
"symbol> and <symbol>M_NOWAIT</symbol>, and should be employed to avoid "
"performing a sleeping <citerefentry><refentrytitle>malloc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> during this "
"initialization call. IP fragment reassembly queue allocation frequently "
"occurs in performance sensitive environments, and the implementation should "
"be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the IP fragment "
"reassembly queue."
msgstr ""
"Inicialize o r�tulo em uma fila de remontagem de fragmento IP rec�m-"
"instanciada. <parameter> bandeira </parameter> campo pode ser um dos "
"<symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </symbol> , e deve ser "
"empregado para evitar a realiza��o de um sono <citerefentry><refentrytitle> "
"malloc </refentrytitle><manvolnum> 9 </manvolnum></citerefentry> durante "
"esta chamada de inicializa��o. A aloca��o de fila de remontagem de fragmento "
"de IP ocorre com frequ�ncia em ambientes sens�veis ao desempenho, e a "
"implementa��o deve ter cuidado para evitar opera��es de longa dura��o ou de "
"suspens�o. Este ponto de entrada tem permiss�o para falhar, resultando na "
"falha de alocar a fila de remontagem de fragmento de IP. "

#. (itstool) path: sect3/title
#: book.translate.xml:5540
#, fuzzy
msgid "<function>mpo_init_mbuf_label</function>"
msgstr " <function> mpo_init_mbuf_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5543
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mbuf_label</function></funcdef> "
"<paramdef>int <parameter>flag</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mbuf_label </function></"
"funcdef><paramdef> int <parameter> bandeira </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5578
#, fuzzy
msgid "Policy label to initialize"
msgstr "R�tulo de Pol�tica para Inicializar"

#. (itstool) path: sect3/para
#: book.translate.xml:5584
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated mbuf packet header "
"(<parameter>mbuf</parameter>). The <parameter>flag</parameter> field may be "
"one of <symbol>M_WAITOK</symbol> and <symbol>M_NOWAIT</symbol>, and should "
"be employed to avoid performing a sleeping "
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> during this initialization call. Mbuf allocation frequently "
"occurs in performance sensitive environments, and the implementation should "
"be careful to avoid sleeping or long-lived operations. This entry point is "
"permitted to fail resulting in the failure to allocate the mbuf header."
msgstr ""
"Inicialize o r�tulo em um cabe�alho de pacote mbuf rec�m-instanciado ( "
"<parameter> mbuf </parameter> ). o <parameter> bandeira </parameter> campo "
"pode ser um dos <symbol> M_WAITOK </symbol> e <symbol> M_NOWAIT </symbol> , "
"e deve ser empregado para evitar a realiza��o de um sono "
"<citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> durante esta chamada de inicializa��o. A aloca��o "
"de Mbuf ocorre com freq��ncia em ambientes sens�veis ao desempenho, e a "
"implementa��o deve ser cuidadosa para evitar opera��es de longa dura��o ou "
"suspensas. Este ponto de entrada tem permiss�o para falhar, resultando na "
"falha de alocar o cabe�alho mbuf. "

#. (itstool) path: sect3/title
#: book.translate.xml:5598
#, fuzzy
msgid "<function>mpo_init_mount_label</function>"
msgstr " <function> mpo_init_mount_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5601
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mount_label </function></"
"funcdef><paramdef> label struct * <parameter> mntlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5631 book.translate.xml:6261 book.translate.xml:8120
#, fuzzy
msgid "<parameter>mntlabel</parameter>"
msgstr " <parameter> mntlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5632
#, fuzzy
msgid "Policy label to be initialized for the mount itself"
msgstr "Etiqueta de pol�tica a ser inicializada para a montagem em si"

#. (itstool) path: row/entry
#: book.translate.xml:5637 book.translate.xml:6266 book.translate.xml:7602
#: book.translate.xml:7681 book.translate.xml:7751 book.translate.xml:8126
#, fuzzy
msgid "<parameter>fslabel</parameter>"
msgstr " <parameter> fslabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:5638
#, fuzzy
msgid "Policy label to be initialized for the file system"
msgstr "R�tulo de Pol�tica a Ser Inicializado para o Sistema de Arquivos"

#. (itstool) path: sect3/para
#: book.translate.xml:5645
#, fuzzy
msgid ""
"Initialize the labels on a newly instantiated mount point. Sleeping is "
"permitted."
msgstr ""
"Inicialize os r�tulos em um ponto de montagem rec�m-instanciado. � permitido "
"dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5650
#, fuzzy
msgid "<function>mpo_init_mount_fs_label</function>"
msgstr " <function> mpo_init_mount_fs_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5653
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_mount_fs_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_mount_fs_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:5681
#, fuzzy
msgid "Label to be initialized"
msgstr "R�tulo a ser inicializado"

#. (itstool) path: sect3/para
#: book.translate.xml:5687
#, fuzzy
msgid ""
"Initialize the label on a newly mounted file system. Sleeping is permitted"
msgstr ""
"Inicialize o r�tulo em um sistema de arquivos rec�m montado. � permitido "
"dormir"

#. (itstool) path: sect3/title
#: book.translate.xml:5692
#, fuzzy
msgid "<function>mpo_init_pipe_label</function>"
msgstr " <function> mpo_init_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5695
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_pipe_label</function></funcdef> "
"<paramdef>struct label*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:5723 book.translate.xml:7143 book.translate.xml:7218
#: book.translate.xml:7293 book.translate.xml:7368 book.translate.xml:7443
#, fuzzy
msgid "Label to be filled in"
msgstr "Etiqueta a ser preenchida"

#. (itstool) path: sect3/para
#: book.translate.xml:5729
#, fuzzy
msgid ""
"Initialize a label for a newly instantiated pipe. Sleeping is permitted."
msgstr ""
"Inicialize um r�tulo para um pipe rec�m-instanciado. � permitido dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5734
#, fuzzy
msgid "<function>mpo_init_socket_label</function>"
msgstr " <function> mpo_init_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5737
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:5771 book.translate.xml:5822
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</manvolnum></"
"citerefentry> flags"
msgstr ""
" <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> bandeiras"

#. (itstool) path: sect3/para
#: book.translate.xml:5777
#, fuzzy
msgid ""
"Initialize a label for a newly instantiated socket. The <parameter>flag</"
"parameter> field may be one of <symbol>M_WAITOK</symbol> and "
"<symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call."
msgstr ""
"Inicialize um r�tulo para um soquete rec�m-instanciado. <parameter> bandeira "
"</parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> e <symbol> "
"M_NOWAIT </symbol> , e deve ser empregado para evitar a realiza��o de um "
"sono <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> durante esta chamada de inicializa��o. "

#. (itstool) path: sect3/title
#: book.translate.xml:5785
#, fuzzy
msgid "<function>mpo_init_socket_peer_label</function>"
msgstr " <function> mpo_init_socket_peer_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5788
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flag</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeira </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:5828
#, fuzzy
msgid ""
"Initialize the peer label for a newly instantiated socket. The "
"<parameter>flag</parameter> field may be one of <symbol>M_WAITOK</symbol> "
"and <symbol>M_NOWAIT</symbol>, and should be employed to avoid performing a "
"sleeping <citerefentry><refentrytitle>malloc</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry> during this initialization call."
msgstr ""
"Inicialize o r�tulo peer para um soquete rec�m-instanciado. <parameter> "
"bandeira </parameter> campo pode ser um dos <symbol> M_WAITOK </symbol> e "
"<symbol> M_NOWAIT </symbol> , e deve ser empregado para evitar a realiza��o "
"de um sono <citerefentry><refentrytitle> malloc </refentrytitle><manvolnum> "
"9 </manvolnum></citerefentry> durante esta chamada de inicializa��o. "

#. (itstool) path: sect3/title
#: book.translate.xml:5836
#, fuzzy
msgid "<function>mpo_init_proc_label</function>"
msgstr " <function> mpo_init_proc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5839
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_proc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:5873
#, fuzzy
msgid ""
"Initialize the label for a newly instantiated process. Sleeping is permitted."
""
msgstr ""
"Inicialize o r�tulo para um processo rec�m-instanciado. � permitido dormir."

#. (itstool) path: sect3/title
#: book.translate.xml:5879
#, fuzzy
msgid "<function>mpo_init_vnode_label</function>"
msgstr " <function> mpo_init_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5882
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_init_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_init_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:5916
#, fuzzy
msgid ""
"Initialize the label on a newly instantiated vnode. Sleeping is permitted."
msgstr ""
"Inicialize o r�tulo em um vnode rec�m-instanciado. Dormir � permitido."

#. (itstool) path: sect3/title
#: book.translate.xml:5921
#, fuzzy
msgid "<function>mpo_destroy_bpfdesc_label</function>"
msgstr " <function> mpo_destroy_bpfdesc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5924
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_bpfdesc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_bpfdesc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:5952
#, fuzzy
msgid "bpfdesc label"
msgstr "r�tulo bpfdesc"

#. (itstool) path: sect3/para
#: book.translate.xml:5958
#, fuzzy
msgid ""
"Destroy the label on a BPF descriptor. In this entry point a policy should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um descritor BPF. Neste ponto de entrada, uma pol�tica "
"deve liberar qualquer armazenamento interno associado a <parameter> r�tulo </"
"parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:5965
#, fuzzy
msgid "<function>mpo_destroy_cred_label</function>"
msgstr " <function> mpo_destroy_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:5968
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:5996 book.translate.xml:6040 book.translate.xml:6084
#: book.translate.xml:6128 book.translate.xml:6172
#, fuzzy
msgid "Label being destroyed"
msgstr "Etiqueta sendo destru�da"

#. (itstool) path: sect3/para
#: book.translate.xml:6002
#, fuzzy
msgid ""
"Destroy the label on a credential. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma credencial. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado a <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6009
#, fuzzy
msgid "<function>mpo_destroy_devfsdirent_label</function>"
msgstr " <function> mpo_destroy_devfsdirent_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6012
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_devfsdirent_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_devfsdirent_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:6046
#, fuzzy
msgid ""
"Destroy the label on a devfs entry. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma entrada devfs. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6053
#, fuzzy
msgid "<function>mpo_destroy_ifnet_label</function>"
msgstr " <function> mpo_destroy_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6056
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:6090
#, fuzzy
msgid ""
"Destroy the label on a removed interface. In this entry point, a policy "
"module should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma interface removida. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar qualquer armazenamento interno associado a "
"<parameter> r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6097
#, fuzzy
msgid "<function>mpo_destroy_ipq_label</function>"
msgstr " <function> mpo_destroy_ipq_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6100
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_ipq_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_ipq_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:6134
#, fuzzy
msgid ""
"Destroy the label on an IP fragment queue. In this entry point, a policy "
"module should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em uma fila de fragmentos de IP. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar qualquer armazenamento interno associado a "
"<parameter> r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6141
#, fuzzy
msgid "<function>mpo_destroy_mbuf_label</function>"
msgstr " <function> mpo_destroy_mbuf_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6144
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mbuf_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:6178
#, fuzzy
msgid ""
"Destroy the label on an mbuf header. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um cabe�alho mbuf. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado a <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6185 book.translate.xml:6229
#, fuzzy
msgid "<function>mpo_destroy_mount_label</function>"
msgstr " <function> mpo_destroy_mount_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6188
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mount_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:6216 book.translate.xml:6262
#, fuzzy
msgid "Mount point label being destroyed"
msgstr "Etiqueta de ponto de montagem sendo destru�da"

#. (itstool) path: sect3/para
#: book.translate.xml:6222
#, fuzzy
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module "
"should free the internal storage associated with <parameter>mntlabel</"
"parameter> so that they may be destroyed."
msgstr ""
"Destrua os r�tulos em um ponto de montagem. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar o armazenamento interno associado "
"<parameter> mntlabel </parameter> para que eles sejam destru�dos \""

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6232
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_mount_label</function></funcdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_mount_label </function></"
"funcdef><paramdef> label struct * <parameter> mntlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6267
#, fuzzy
msgid "File system label being destroyed&gt;"
msgstr "R�tulo do sistema de arquivos sendo destru�do&gt;"

#. (itstool) path: sect3/para
#: book.translate.xml:6273
#, fuzzy
msgid ""
"Destroy the labels on a mount point. In this entry point, a policy module "
"should free the internal storage associated with <parameter>mntlabel</"
"parameter> and <parameter>fslabel</parameter> so that they may be destroyed."
msgstr ""
"Destrua os r�tulos em um ponto de montagem. Nesse ponto de entrada, um "
"m�dulo de pol�tica deve liberar o armazenamento interno associado "
"<parameter> mntlabel </parameter> e <parameter> fslabel </parameter> para "
"que eles sejam destru�dos \""

#. (itstool) path: sect3/title
#: book.translate.xml:6281
#, fuzzy
msgid "<function>mpo_destroy_socket_label</function>"
msgstr " <function> mpo_destroy_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6284
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:6312
#, fuzzy
msgid "Socket label being destroyed"
msgstr "Etiqueta de soquete sendo destru�da"

#. (itstool) path: sect3/para
#: book.translate.xml:6318
#, fuzzy
msgid ""
"Destroy the label on a socket. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um soquete. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6325
#, fuzzy
msgid "<function>mpo_destroy_socket_peer_label</function>"
msgstr " <function> mpo_destroy_socket_peer_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6328
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_socket_peer_label</function></funcdef> "
"<paramdef>struct label *<parameter>peerlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> peerlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6355
#, fuzzy
msgid "<parameter>peerlabel</parameter>"
msgstr " <parameter> peerlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6356
#, fuzzy
msgid "Socket peer label being destroyed"
msgstr "R�tulo do par de soquetes sendo destru�do"

#. (itstool) path: sect3/para
#: book.translate.xml:6362
#, fuzzy
msgid ""
"Destroy the peer label on a socket. In this entry point, a policy module "
"should free any internal storage associated with <parameter>label</"
"parameter> so that it may be destroyed."
msgstr ""
"Destrua o r�tulo peer em um soquete. Neste ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6369
#, fuzzy
msgid "<function>mpo_destroy_pipe_label</function>"
msgstr " <function> mpo_destroy_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6372
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:6400
#, fuzzy
msgid "Pipe label"
msgstr "R�tulo de tubo"

#. (itstool) path: sect3/para
#: book.translate.xml:6406
#, fuzzy
msgid ""
"Destroy the label on a pipe. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um pipe. Nesse ponto de entrada, um m�dulo de pol�tica "
"deve liberar qualquer armazenamento interno associado <parameter> r�tulo </"
"parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6413
#, fuzzy
msgid "<function>mpo_destroy_proc_label</function>"
msgstr " <function> mpo_destroy_proc_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6416
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_proc_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_proc_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: row/entry
#: book.translate.xml:6443 book.translate.xml:6486
#, fuzzy
msgid "Process label"
msgstr "R�tulo do processo"

#. (itstool) path: sect3/para
#: book.translate.xml:6449
#, fuzzy
msgid ""
"Destroy the label on a process. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um processo. Nesse ponto de entrada, um m�dulo de "
"pol�tica deve liberar qualquer armazenamento interno associado <parameter> "
"r�tulo </parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6456
#, fuzzy
msgid "<function>mpo_destroy_vnode_label</function>"
msgstr " <function> mpo_destroy_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6459
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_destroy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_destroy_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></paramdef> "
""

#. (itstool) path: sect3/para
#: book.translate.xml:6492
#, fuzzy
msgid ""
"Destroy the label on a vnode. In this entry point, a policy module should "
"free any internal storage associated with <parameter>label</parameter> so "
"that it may be destroyed."
msgstr ""
"Destrua o r�tulo em um vnode. Nesse ponto de entrada, um m�dulo de pol�tica "
"deve liberar qualquer armazenamento interno associado <parameter> r�tulo </"
"parameter> para que possa ser destru�do \""

#. (itstool) path: sect3/title
#: book.translate.xml:6499
#, fuzzy
msgid "<function>mpo_copy_mbuf_label</function>"
msgstr " <function> mpo_copy_mbuf_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6502
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_mbuf_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_mbuf_label </function></"
"funcdef><paramdef> label struct * <parameter> src </parameter></"
"paramdef><paramdef> label struct * <parameter> dest </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6531 book.translate.xml:6580 book.translate.xml:6629
#, fuzzy
msgid "<parameter>src</parameter>"
msgstr " <parameter> src </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6532 book.translate.xml:6581 book.translate.xml:6630
#, fuzzy
msgid "Source label"
msgstr "R�tulo da fonte"

#. (itstool) path: row/entry
#: book.translate.xml:6536 book.translate.xml:6585 book.translate.xml:6634
#, fuzzy
msgid "<parameter>dest</parameter>"
msgstr " <parameter> come�ou </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6537 book.translate.xml:6586 book.translate.xml:6635
#, fuzzy
msgid "Destination label"
msgstr "Etiqueta de destino"

#. (itstool) path: sect3/para
#: book.translate.xml:6543 book.translate.xml:6592 book.translate.xml:6641
#, fuzzy
msgid ""
"Copy the label information in <parameter>src</parameter> into "
"<parameter>dest</parameter>."
msgstr ""
"Copie as informa��es da etiqueta em <parameter> src </parameter> para dentro "
"<parameter> dest </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:6548
#, fuzzy
msgid "<function>mpo_copy_pipe_label</function>"
msgstr " <function> mpo_copy_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6551
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> src </parameter></"
"paramdef><paramdef> label struct * <parameter> come�ou </parameter></"
"paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6597
#, fuzzy
msgid "<function>mpo_copy_vnode_label</function>"
msgstr " <function> mpo_copy_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6600
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_copy_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>src</parameter></paramdef> "
"<paramdef>struct label *<parameter>dest</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_copy_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> src </parameter></"
"paramdef><paramdef> label struct * <parameter> dest </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6646
#, fuzzy
msgid "<function>mpo_externalize_cred_label</function>"
msgstr " <function> mpo_externalize_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6649
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:6682 book.translate.xml:6759 book.translate.xml:6836
#: book.translate.xml:6913 book.translate.xml:6989 book.translate.xml:7066
#, fuzzy
msgid "Label to be externalized"
msgstr "Etiqueta a ser externalizada"

#. (itstool) path: row/entry
#: book.translate.xml:6686 book.translate.xml:6763 book.translate.xml:6840
#: book.translate.xml:6917 book.translate.xml:6993 book.translate.xml:7070
#: book.translate.xml:7147 book.translate.xml:7222 book.translate.xml:7297
#: book.translate.xml:7372 book.translate.xml:7447
#, fuzzy
msgid "<parameter>element_name</parameter>"
msgstr " <parameter> element_name </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6687 book.translate.xml:6764 book.translate.xml:6841
#: book.translate.xml:6918 book.translate.xml:6994 book.translate.xml:7071
#, fuzzy
msgid "Name of the policy whose label should be externalized"
msgstr "Nome da pol�tica cujo r�tulo deve ser externalizado"

#. (itstool) path: row/entry
#: book.translate.xml:6691 book.translate.xml:6768 book.translate.xml:6845
#: book.translate.xml:6922 book.translate.xml:6998 book.translate.xml:7075
#, fuzzy
msgid "<parameter>sb</parameter>"
msgstr " <parameter> sb </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6692 book.translate.xml:6769 book.translate.xml:6846
#: book.translate.xml:6923 book.translate.xml:6999 book.translate.xml:7076
#, fuzzy
msgid "String buffer to be filled with a text representation of label"
msgstr ""
"Buffer de cadeia a ser preenchido com uma representa��o de texto de r�tulo"

#. (itstool) path: row/entry
#: book.translate.xml:6697 book.translate.xml:6774 book.translate.xml:6851
#: book.translate.xml:6928 book.translate.xml:7004 book.translate.xml:7081
#: book.translate.xml:7157 book.translate.xml:7232 book.translate.xml:7307
#: book.translate.xml:7382 book.translate.xml:7457
#, fuzzy
msgid "<parameter>claimed</parameter>"
msgstr " <parameter> reivindicado </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:6698 book.translate.xml:6775 book.translate.xml:6852
#: book.translate.xml:6929 book.translate.xml:7005 book.translate.xml:7082
#, fuzzy
msgid ""
"Should be incremented when <parameter>element_data</parameter> can be filled "
"in."
msgstr ""
"Deve ser incrementado quando <parameter> element_data </parameter> pode ser "
"preenchido. "

#. (itstool) path: sect3/para
#: book.translate.xml:6707 book.translate.xml:6784 book.translate.xml:6861
#: book.translate.xml:6938 book.translate.xml:7014 book.translate.xml:7091
#, fuzzy
msgid ""
"Produce an externalized label based on the label structure passed. An "
"externalized label consists of a text representation of the label contents "
"that can be used with userland applications and read by the user. Currently, "
"all policies' <function>externalize</function> entry points will be called, "
"so the implementation should check the contents of <parameter>element_name</"
"parameter> before attempting to fill in <parameter>sb</parameter>. If "
"<parameter>element_name</parameter> does not match the name of your policy, "
"simply return <returnvalue>0</returnvalue>. Only return nonzero if an error "
"occurs while externalizing the label data. Once the policy fills in "
"<parameter>element_data</parameter>, <varname>*claimed</varname> should be "
"incremented."
msgstr ""
"Produza um r�tulo externalizado com base na estrutura de r�tulo passada. Um "
"r�tulo externalizado consiste em uma representa��o de texto do conte�do do "
"r�tulo que pode ser usado com aplicativos de usu�rio final e lido pelo "
"usu�rio. Atualmente, todas as pol�ticas '; <function> externalizar </"
"function> pontos de entrada ser�o chamados, ent�o a implementa��o deve "
"verificar o conte�do de <parameter> element_name </parameter> antes de "
"tentar preencher <parameter> sb </parameter> . E se <parameter> element_name "
"</parameter> n�o corresponde ao nome da sua pol�tica, basta retornar "
"<returnvalue> 0 </returnvalue> . S� retornar� diferente de zero se ocorrer "
"um erro ao externalizar os dados da etiqueta. Quando a pol�tica preencher "
"<parameter> element_data </parameter> , <varname> * reivindicado </varname> "
"deve ser incrementado \""

#. (itstool) path: sect3/title
#: book.translate.xml:6723
#, fuzzy
msgid "<function>mpo_externalize_ifnet_label</function>"
msgstr " <function> mpo_externalize_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6726
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6800
#, fuzzy
msgid "<function>mpo_externalize_pipe_label</function>"
msgstr " <function> mpo_externalize_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6803
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6877
#, fuzzy
msgid "<function>mpo_externalize_socket_label</function>"
msgstr " <function> mpo_externalize_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6880
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:6954
#, fuzzy
msgid "<function>mpo_externalize_socket_peer_label</function>"
msgstr " <function> mpo_externalize_socket_peer_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:6957
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_socket_peer_label</function></"
"funcdef> <paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_socket_peer_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7030
#, fuzzy
msgid "<function>mpo_externalize_vnode_label</function>"
msgstr " <function> mpo_externalize_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7033
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_externalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>struct sbuf *<parameter>sb</parameter></paramdef> <paramdef>int "
"<parameter>*claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_externalize_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> struct sbuf * <parameter> sb </parameter></"
"paramdef><paramdef> int <parameter> * reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7107
#, fuzzy
msgid "<function>mpo_internalize_cred_label</function>"
msgstr " <function> mpo_internalize_cred_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7110
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_cred_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_cred_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7148 book.translate.xml:7223 book.translate.xml:7298
#: book.translate.xml:7373 book.translate.xml:7448
#, fuzzy
msgid "Name of the policy whose label should be internalized"
msgstr "Nome da pol�tica cujo r�tulo deve ser internalizado"

#. (itstool) path: row/entry
#: book.translate.xml:7152 book.translate.xml:7227 book.translate.xml:7302
#: book.translate.xml:7377 book.translate.xml:7452
#, fuzzy
msgid "<parameter>element_data</parameter>"
msgstr " <parameter> element_data </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7153 book.translate.xml:7228 book.translate.xml:7303
#: book.translate.xml:7378 book.translate.xml:7453
#, fuzzy
msgid "Text data to be internalized"
msgstr "Dados de texto a serem internalizados"

#. (itstool) path: row/entry
#: book.translate.xml:7158 book.translate.xml:7233 book.translate.xml:7308
#: book.translate.xml:7383 book.translate.xml:7458
#, fuzzy
msgid "Should be incremented when data can be successfully internalized."
msgstr ""
"Deve ser incrementado quando os dados podem ser internalizados com sucesso."

#. (itstool) path: sect3/para
#: book.translate.xml:7167 book.translate.xml:7242 book.translate.xml:7317
#: book.translate.xml:7392 book.translate.xml:7467
#, fuzzy
msgid ""
"Produce an internal label structure based on externalized label data in text "
"format. Currently, all policies' <function>internalize</function> entry "
"points are called when internalization is requested, so the implementation "
"should compare the contents of <parameter>element_name</parameter> to its "
"own name in order to be sure it should be internalizing the data in "
"<parameter>element_data</parameter>. Just as in the <function>externalize</"
"function> entry points, the entry point should return <returnvalue>0</"
"returnvalue> if <parameter>element_name</parameter> does not match its own "
"name, or when data can successfully be internalized, in which case "
"<varname>*claimed</varname> should be incremented."
msgstr ""
"Produzir uma estrutura de r�tulo interno com base em dados de r�tulo "
"externalizados em formato de texto. Atualmente, todas as pol�ticas '; "
"<function> internalizar </function> os pontos de entrada s�o chamados quando "
"a internaliza��o � solicitada, ent�o a implementa��o deve comparar o "
"conte�do de <parameter> element_name </parameter> para o seu pr�prio nome, a "
"fim de ter certeza de que deveria estar internalizando os dados em "
"<parameter> element_data </parameter> . Assim como no <function> "
"externalizar </function> pontos de entrada, o ponto de entrada deve retornar "
"<returnvalue> 0 </returnvalue> E se <parameter> element_name </parameter> "
"n�o corresponde ao seu pr�prio nome, ou quando os dados podem ser "
"internalizados com �xito, em cujo caso <varname> * reivindicado </varname> "
"deve ser incrementado \""

#. (itstool) path: sect3/title
#: book.translate.xml:7182
#, fuzzy
msgid "<function>mpo_internalize_ifnet_label</function>"
msgstr " <function> mpo_internalize_ifnet_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7185
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_ifnet_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_ifnet_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7257
#, fuzzy
msgid "<function>mpo_internalize_pipe_label</function>"
msgstr " <function> mpo_internalize_pipe_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7260
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_pipe_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_pipe_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7332
#, fuzzy
msgid "<function>mpo_internalize_socket_label</function>"
msgstr " <function> mpo_internalize_socket_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7335
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_socket_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_socket_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:7407
#, fuzzy
msgid "<function>mpo_internalize_vnode_label</function>"
msgstr " <function> mpo_internalize_vnode_label </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7410
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_internalize_vnode_label</function></funcdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>char *<parameter>element_name</parameter></paramdef> "
"<paramdef>char *<parameter>element_data</parameter></paramdef> <paramdef>int "
"*<parameter>claimed</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_internalize_vnode_label </function></"
"funcdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_name </parameter></"
"paramdef><paramdef> Caracteres * <parameter> element_data </parameter></"
"paramdef><paramdef> int * <parameter> reivindicado </parameter></paramdef> "

#. (itstool) path: sect2/title
#: book.translate.xml:7483
#, fuzzy
msgid "Label Events"
msgstr "Eventos de etiqueta"

#. (itstool) path: sect2/para
#: book.translate.xml:7485
#, fuzzy
msgid ""
"This class of entry points is used by the MAC framework to permit policies "
"to maintain label information on kernel objects. For each labeled kernel "
"object of interest to a MAC policy, entry points may be registered for "
"relevant life cycle events. All objects implement initialization, creation, "
"and destruction hooks. Some objects will also implement relabeling, allowing "
"user processes to change the labels on objects. Some objects will also "
"implement object-specific events, such as label events associated with IP "
"reassembly. A typical labeled object will have the following life cycle of "
"entry points:"
msgstr ""
"Essa classe de pontos de entrada � usada pela estrutura MAC para permitir "
"que as pol�ticas mantenham informa��es de r�tulos nos objetos do kernel. "
"Para cada objeto rotulado do kernel de interesse de uma pol�tica MAC, os "
"pontos de entrada podem ser registrados para eventos de ciclo de vida "
"relevantes. Al�m disso, alguns objetos tamb�m implementar�o a remarca��o, "
"permitindo que os processos do usu�rio alterem os r�tulos dos objetos.Alguns "
"objetos tamb�m implementar�o eventos espec�ficos do objeto, como eventos de "
"r�tulo associados � remontagem do IP.Um objeto rotulado t�pico seguinte "
"ciclo de vida dos pontos de entrada: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:7497
#, no-wrap
msgid ""
"Label initialization          o\n"
"(object-specific wait)         \\\n"
"Label creation                  o\n"
"                                 \\\n"
"Relabel events,                   o--&lt;--.\n"
"Various object-specific,          |     |\n"
"Access control events             ~--&gt;--o\n"
"                                         \\\n"
"Label destruction                         o"
msgstr ""
"Label initialization          o\n"
"(object-specific wait)         \\\n"
"Label creation                  o\n"
"                                 \\\n"
"Relabel events,                   o--&lt;--.\n"
"Various object-specific,          |     |\n"
"Access control events             ~--&gt;--o\n"
"                                         \\\n"
"Label destruction                         o"

#. (itstool) path: sect2/para
#: book.translate.xml:7507
#, fuzzy
msgid ""
"Label initialization permits policies to allocate memory and set initial "
"values for labels without context for the use of the object. The label slot "
"allocated to a policy will be zeroed by default, so some policies may not "
"need to perform initialization."
msgstr ""
"A inicializa��o do r�tulo permite que pol�ticas aloquem mem�ria e definam "
"valores iniciais para r�tulos sem contexto para o uso do objeto. O slot de "
"r�tulo alocado a uma pol�tica ser� zerado por padr�o, portanto, algumas "
"pol�ticas podem n�o precisar executar a inicializa��o."

#. (itstool) path: sect2/para
#: book.translate.xml:7513
#, fuzzy
msgid ""
"Label creation occurs when the kernel structure is associated with an actual "
"kernel object. For example, Mbufs may be allocated and remain unused in a "
"pool until they are required. mbuf allocation causes label initialization on "
"the mbuf to take place, but mbuf creation occurs when the mbuf is associated "
"with a datagram. Typically, context will be provided for a creation event, "
"including the circumstances of the creation, and labels of other relevant "
"objects in the creation process. For example, when an mbuf is created from a "
"socket, the socket and its label will be presented to registered policies in "
"addition to the new mbuf and its label. Memory allocation in creation events "
"is discouraged, as it may occur in performance sensitive ports of the "
"kernel; in addition, creation calls are not permitted to fail so a failure "
"to allocate memory cannot be reported."
msgstr ""
"A cria��o de r�tulos ocorre quando a estrutura do kernel � associada a um "
"objeto de kernel real. Por exemplo, Mbufs podem ser alocados e permanecer "
"sem uso em um conjunto at� que sejam necess�rios. A aloca��o de mbuf faz com "
"que a inicializa��o de r�tulo ocorra, mas a cria��o de mbuf ocorre Quando o "
"mbuf � associado a um datagrama.Normalmente, o contexto ser� fornecido para "
"um evento de cria��o, incluindo as circunst�ncias da cria��o, e r�tulos de "
"outros objetos relevantes no processo de cria��o.Por exemplo, quando um mbuf "
"� criado a partir de um soquete, o soquete e seu r�tulo ser�o apresentados a "
"pol�ticas registradas, al�m do novo mbuf e seu r�tulo.A aloca��o de mem�ria "
"em eventos de cria��o � desencorajada, pois pode ocorrer em portas sens�veis "
"ao desempenho do kernel, al�m disso, as chamadas de cria��o n�o t�m "
"permiss�o para falhar, portanto, uma falha na aloca��o de mem�ria n�o pode "
"ser reportada. "

#. (itstool) path: sect2/para
#: book.translate.xml:7529
#, fuzzy
msgid ""
"Object specific events do not generally fall into the other broad classes of "
"label events, but will generally provide an opportunity to modify or update "
"the label on an object based on additional context. For example, the label "
"on an IP fragment reassembly queue may be updated during the "
"<symbol>MAC_UPDATE_IPQ</symbol> entry point as a result of the acceptance of "
"an additional mbuf to that queue."
msgstr ""
"Eventos espec�ficos de objeto geralmente n�o se enquadram em outras classes "
"de eventos de r�tulo, mas geralmente fornecem uma oportunidade para "
"modificar ou atualizar o r�tulo em um objeto com base em contexto adicional. "
"Por exemplo, o r�tulo em uma fila de reagrupamento de fragmento IP pode ser "
"atualizado durante o <symbol> MAC_UPDATE_IPQ </symbol> ponto de entrada como "
"resultado da aceita��o de um mbuf adicional para essa fila. "

#. (itstool) path: sect2/para
#: book.translate.xml:7537
#, fuzzy
msgid ""
"Access control events are discussed in detail in the following section."
msgstr ""
"Os eventos de controle de acesso s�o discutidos em detalhes na se��o a "
"seguir."

#. (itstool) path: sect2/para
#: book.translate.xml:7540
#, fuzzy
msgid ""
"Label destruction permits policies to release storage or state associated "
"with a label during its association with an object so that the kernel data "
"structures supporting the object may be reused or released."
msgstr ""
"A destrui��o de etiqueta permite que pol�ticas liberem armazenamento ou "
"estado associado a um r�tulo durante sua associa��o com um objeto, de forma "
"que as estruturas de dados do kernel que suportam o objeto possam ser "
"reutilizadas ou liberadas."

#. (itstool) path: sect2/para
#: book.translate.xml:7545
#, fuzzy
msgid ""
"In addition to labels associated with specific kernel objects, an additional "
"class of labels exists: temporary labels. These labels are used to store "
"update information submitted by user processes. These labels are initialized "
"and destroyed as with other label types, but the creation event is "
"<symbol>MAC_INTERNALIZE</symbol>, which accepts a user label to be converted "
"to an in-kernel representation."
msgstr ""
"Al�m de r�tulos associados a objetos de kernel espec�ficos, existe uma "
"classe adicional de r�tulos: r�tulos tempor�rios. Esses r�tulos s�o usados "
"​​para armazenar informa��es de atualiza��o enviadas pelos processos do "
"usu�rio. Esses r�tulos s�o inicializados e destru�dos como com outros tipos "
"de r�tulo, mas o evento de cria��o � <symbol> MAC_INTERNALIZE </symbol> , "
"que aceita um r�tulo de usu�rio para ser convertido em uma representa��o no "
"kernel. "

#. (itstool) path: sect3/title
#: book.translate.xml:7554
#, fuzzy
msgid "File System Object Labeling Event Operations"
msgstr "Opera��es de eventos de rotulagem de objeto de sistema de arquivos"

#. (itstool) path: sect4/title
#: book.translate.xml:7557
#, fuzzy
msgid "<function>mpo_associate_vnode_devfs</function>"
msgstr " <function> mpo_associate_vnode_devfs </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7560
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_associate_vnode_devfs</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_associate_vnode_devfs </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> de </parameter></"
"paramdef><paramdef> label struct * <parameter> delabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7597 book.translate.xml:7676 book.translate.xml:7746
#: book.translate.xml:7943 book.translate.xml:8115 book.translate.xml:11670
#, fuzzy
msgid "<parameter>mp</parameter>"
msgstr " <parameter> pf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7598 book.translate.xml:7944
#, fuzzy
msgid "Devfs mount point"
msgstr "Devfs mount point"

#. (itstool) path: row/entry
#: book.translate.xml:7603
#, fuzzy
msgid "Devfs file system label (<varname>mp-&gt;mnt_fslabel</varname>)"
msgstr ""
"R�tulo do sistema de arquivos Devfs ( <varname> mp-&gt; mnt_fslabel </"
"varname> ) "

#. (itstool) path: row/entry
#: book.translate.xml:7608 book.translate.xml:7959
#, fuzzy
msgid "<parameter>de</parameter>"
msgstr " <parameter> de </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7609
#, fuzzy
msgid "Devfs directory entry"
msgstr "Entrada do diret�rio Devfs"

#. (itstool) path: row/entry
#: book.translate.xml:7613 book.translate.xml:7964
#, fuzzy
msgid "<parameter>delabel</parameter>"
msgstr " <parameter> delabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7614
#, fuzzy
msgid "Policy label associated with <parameter>de</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> de </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7619 book.translate.xml:7686 book.translate.xml:7756
#: book.translate.xml:8047 book.translate.xml:8230 book.translate.xml:8296
#: book.translate.xml:8370 book.translate.xml:9964 book.translate.xml:10037
#: book.translate.xml:10554 book.translate.xml:11606 book.translate.xml:11796
#: book.translate.xml:12083 book.translate.xml:12160 book.translate.xml:12228
#: book.translate.xml:12293 book.translate.xml:12366 book.translate.xml:12463
#: book.translate.xml:12528 book.translate.xml:12592 book.translate.xml:12652
#: book.translate.xml:12717 book.translate.xml:12791 book.translate.xml:12873
#: book.translate.xml:13073 book.translate.xml:13198 book.translate.xml:13264
#: book.translate.xml:13330 book.translate.xml:13408 book.translate.xml:13494
#: book.translate.xml:13562 book.translate.xml:13631 book.translate.xml:13703
#: book.translate.xml:13891 book.translate.xml:14173 book.translate.xml:14364
#, fuzzy
msgid "<parameter>vp</parameter>"
msgstr " <parameter> vp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7620
#, fuzzy
msgid "vnode associated with <parameter>de</parameter>"
msgstr "vnode associado com <parameter> de </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7625 book.translate.xml:7691 book.translate.xml:7761
#: book.translate.xml:8052 book.translate.xml:8302 book.translate.xml:10559
#: book.translate.xml:14178 book.translate.xml:14369
#, fuzzy
msgid "<parameter>vlabel</parameter>"
msgstr " <parameter> vlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7626 book.translate.xml:7692 book.translate.xml:7762
#: book.translate.xml:8053 book.translate.xml:8303 book.translate.xml:12469
#: book.translate.xml:12534 book.translate.xml:12723 book.translate.xml:12797
#: book.translate.xml:12879
#, fuzzy
msgid "Policy label associated with <parameter>vp</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> vp </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:7633
#, fuzzy
msgid ""
"Fill in the label (<parameter>vlabel</parameter>) for a newly created devfs "
"vnode based on the devfs directory entry passed in <parameter>de</parameter> "
"and its label."
msgstr ""
"Preencha o r�tulo ( <parameter> vlabel </parameter> ) para um vnode devfs "
"rec�m-criado com base na entrada de diret�rio devfs passada <parameter> de </"
"parameter> e seu r�tulo \""

#. (itstool) path: sect4/title
#: book.translate.xml:7640
#, fuzzy
msgid "<function>mpo_associate_vnode_extattr</function>"
msgstr " <function> mpo_associate_vnode_extattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7643
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_associate_vnode_extattr</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_associate_vnode_extattr </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7677 book.translate.xml:7747 book.translate.xml:8027
#, fuzzy
msgid "File system mount point"
msgstr "Ponto de montagem do sistema de arquivos"

#. (itstool) path: row/entry
#: book.translate.xml:7682 book.translate.xml:7752 book.translate.xml:8032
#, fuzzy
msgid "File system label"
msgstr "R�tulo do sistema de arquivos"

#. (itstool) path: row/entry
#: book.translate.xml:7687 book.translate.xml:7757
#, fuzzy
msgid "Vnode to label"
msgstr "Vnode para rotular"

#. (itstool) path: sect4/para
#: book.translate.xml:7699
#, fuzzy
msgid ""
"Attempt to retrieve the label for <parameter>vp</parameter> from the file "
"system extended attributes. Upon success, the value <literal>0</literal> is "
"returned. Should extended attribute retrieval not be supported, an accepted "
"fallback is to copy <parameter>fslabel</parameter> into <parameter>vlabel</"
"parameter>. In the event of an error, an appropriate value for "
"<varname>errno</varname> should be returned."
msgstr ""
"Tentativa de recuperar o r�tulo para <parameter> vp </parameter> dos "
"atributos estendidos do sistema de arquivos. Ap�s o sucesso, o valor "
"<literal> 0 </literal> � retornado. Caso a recupera��o de atributos "
"estendidos n�o seja suportada, um substituto aceito � copiar <parameter> "
"fslabel </parameter> para dentro <parameter> vlabel </parameter> . Em caso "
"de erro, um valor apropriado para <varname> errno </varname> deve ser "
"devolvido \""

#. (itstool) path: sect4/title
#: book.translate.xml:7711
#, fuzzy
msgid "<function>mpo_associate_vnode_singlelabel</function>"
msgstr " <function> mpo_associate_vnode_singlelabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7714
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_associate_vnode_singlelabel</function></funcdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
"<funcdef> vazio <function> mpo_associate_vnode_singlelabel </function></"
"funcdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef>"

#. (itstool) path: sect4/para
#: book.translate.xml:7769
#, fuzzy
msgid ""
"On non-multilabel file systems, this entry point is called to set the policy "
"label for <parameter>vp</parameter> based on the file system label, "
"<parameter>fslabel</parameter>."
msgstr ""
"Em sistemas de arquivos n�o multilabel, este ponto de entrada � chamado para "
"definir o r�tulo de pol�tica para <parameter> vp </parameter> com base no "
"r�tulo do sistema de arquivos, <parameter> fslabel </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:7776
#, fuzzy
msgid "<function>mpo_create_devfs_device</function>"
msgstr " <function> mpo_create_devfs_device </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7779
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_device</function></funcdef> "
"<paramdef>dev_t <parameter>dev</parameter></paramdef> <paramdef>struct "
"devfs_dirent *<parameter>devfs_dirent</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_device </function></"
"funcdef><paramdef> dev_t <parameter> dev </parameter></paramdef><paramdef> "
"struct devfs_dirent * <parameter> devfs_dirent </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7809
#, fuzzy
msgid "<parameter>dev</parameter>"
msgstr " <parameter> dev </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7810
#, fuzzy
msgid "Device corresponding with <parameter>devfs_dirent</parameter>"
msgstr "Dispositivo correspondente com <parameter> devfs_dirent </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7815 book.translate.xml:7882 book.translate.xml:8358
#, fuzzy
msgid "<parameter>devfs_dirent</parameter>"
msgstr " <parameter> devfs_dirent </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7816
#, fuzzy
msgid "Devfs directory entry to be labeled."
msgstr "Devfs entrada do diret�rio a ser rotulado."

#. (itstool) path: row/entry
#: book.translate.xml:7821
#, fuzzy
msgid "Label for <parameter>devfs_dirent</parameter> to be filled in."
msgstr ""
"R�tulo para <parameter> devfs_dirent </parameter> para ser preenchido. "

#. (itstool) path: sect4/para
#: book.translate.xml:7828
#, fuzzy
msgid ""
"Fill out the label on a devfs_dirent being created for the passed device. "
"This call will be made when the device file system is mounted, regenerated, "
"or a new device is made available."
msgstr ""
"Preencha o r�tulo em um devfs_dirent sendo criado para o dispositivo passado."
" Essa chamada ser� feita quando o sistema de arquivos do dispositivo for "
"montado, regenerado ou um novo dispositivo for disponibilizado."

#. (itstool) path: sect4/title
#: book.translate.xml:7835
#, fuzzy
msgid "<function>mpo_create_devfs_directory</function>"
msgstr " <function> mpo_create_devfs_directory </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7838
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_directory</function></funcdef> "
"<paramdef>char *<parameter>dirname</parameter></paramdef> <paramdef>int "
"<parameter>dirnamelen</parameter></paramdef> <paramdef>struct devfs_dirent "
"*<parameter>devfs_dirent</parameter></paramdef> <paramdef>struct label "
"*<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_directory </function></"
"funcdef><paramdef> Caracteres * <parameter> dirname </parameter></"
"paramdef><paramdef> int <parameter> dirnamelen </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> devfs_dirent </"
"parameter></paramdef><paramdef> label struct * <parameter> r�tulo </"
"parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7871
#, fuzzy
msgid "<parameter>dirname</parameter>"
msgstr " <parameter> dirname </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7872
#, fuzzy
msgid "Name of directory being created"
msgstr "Nome do diret�rio sendo criado"

#. (itstool) path: row/entry
#: book.translate.xml:7876 book.translate.xml:14430
#, fuzzy
msgid "<parameter>namelen</parameter>"
msgstr " <parameter> namelen </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7877
#, fuzzy
msgid "Length of string <parameter>dirname</parameter>"
msgstr "Comprimento da corda <parameter> dirname </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7883
#, fuzzy
msgid "Devfs directory entry for directory being created."
msgstr "Entrada do diret�rio Devfs para o diret�rio que est� sendo criado."

#. (itstool) path: sect4/para
#: book.translate.xml:7890
#, fuzzy
msgid ""
"Fill out the label on a devfs_dirent being created for the passed directory. "
"This call will be made when the device file system is mounted, regenerated, "
"or a new device requiring a specific directory hierarchy is made available."
msgstr ""
"Preencha o r�tulo em um devfs_dirent que est� sendo criado para o diret�rio "
"passado. Essa chamada ser� feita quando o sistema de arquivos do dispositivo "
"for montado, regenerado ou um novo dispositivo que exija uma hierarquia de "
"diret�rio espec�fica seja disponibilizado."

#. (itstool) path: sect4/title
#: book.translate.xml:7898
#, fuzzy
msgid "<function>mpo_create_devfs_symlink</function>"
msgstr " <function> mpo_create_devfs_symlink </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7901
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_devfs_symlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>dd</parameter></paramdef> "
"<paramdef>struct label *<parameter>ddlabel</parameter></paramdef> "
"<paramdef>struct devfs_dirent *<parameter>de</parameter></paramdef> "
"<paramdef>struct label *<parameter>delabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_devfs_symlink </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> dd </parameter></"
"paramdef><paramdef> label struct * <parameter> ddlabel </parameter></"
"paramdef><paramdef> struct devfs_dirent * <parameter> de </parameter></"
"paramdef><paramdef> label struct * <parameter> delabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:7938 book.translate.xml:8021 book.translate.xml:8110
#: book.translate.xml:8225 book.translate.xml:8291 book.translate.xml:8501
#: book.translate.xml:8559 book.translate.xml:8686 book.translate.xml:8751
#: book.translate.xml:8952 book.translate.xml:9763 book.translate.xml:10093
#: book.translate.xml:10135 book.translate.xml:10179 book.translate.xml:10358
#: book.translate.xml:10401 book.translate.xml:10450 book.translate.xml:10498
#: book.translate.xml:10549 book.translate.xml:10602 book.translate.xml:10645
#: book.translate.xml:10694 book.translate.xml:10761 book.translate.xml:10818
#: book.translate.xml:10877 book.translate.xml:10940 book.translate.xml:10998
#: book.translate.xml:11057 book.translate.xml:11119 book.translate.xml:11188
#: book.translate.xml:11246 book.translate.xml:11363 book.translate.xml:11419
#: book.translate.xml:11484 book.translate.xml:11545 book.translate.xml:11600
#: book.translate.xml:11665 book.translate.xml:11730 book.translate.xml:11791
#: book.translate.xml:11861 book.translate.xml:11923 book.translate.xml:11985
#: book.translate.xml:12067 book.translate.xml:12154 book.translate.xml:12223
#: book.translate.xml:12288 book.translate.xml:12361 book.translate.xml:12447
#: book.translate.xml:12523 book.translate.xml:12587 book.translate.xml:12647
#: book.translate.xml:12775 book.translate.xml:12857 book.translate.xml:12940
#: book.translate.xml:13000 book.translate.xml:13068 book.translate.xml:13131
#: book.translate.xml:13193 book.translate.xml:13259 book.translate.xml:13325
#: book.translate.xml:13403 book.translate.xml:13489 book.translate.xml:13557
#: book.translate.xml:13626 book.translate.xml:13698 book.translate.xml:13768
#: book.translate.xml:13825 book.translate.xml:13886 book.translate.xml:13954
#: book.translate.xml:14030 book.translate.xml:14103 book.translate.xml:14222
#: book.translate.xml:14265 book.translate.xml:14313 book.translate.xml:14359
#: book.translate.xml:14420
#, fuzzy
msgid "<parameter>cred</parameter>"
msgstr " <parameter> Eu </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7939 book.translate.xml:8022 book.translate.xml:8111
#: book.translate.xml:8226 book.translate.xml:8292 book.translate.xml:8502
#: book.translate.xml:8560 book.translate.xml:8687 book.translate.xml:8752
#: book.translate.xml:8953 book.translate.xml:9764 book.translate.xml:10180
#: book.translate.xml:10359 book.translate.xml:10402 book.translate.xml:10451
#: book.translate.xml:10499 book.translate.xml:10550 book.translate.xml:10603
#: book.translate.xml:10646 book.translate.xml:10695 book.translate.xml:10762
#: book.translate.xml:10819 book.translate.xml:10878 book.translate.xml:10941
#: book.translate.xml:10999 book.translate.xml:11058 book.translate.xml:11120
#: book.translate.xml:11189 book.translate.xml:11247 book.translate.xml:11303
#: book.translate.xml:11364 book.translate.xml:11420 book.translate.xml:11485
#: book.translate.xml:11546 book.translate.xml:11601 book.translate.xml:11666
#: book.translate.xml:11731 book.translate.xml:11792 book.translate.xml:11862
#: book.translate.xml:11924 book.translate.xml:11986 book.translate.xml:12068
#: book.translate.xml:12155 book.translate.xml:12224 book.translate.xml:12289
#: book.translate.xml:12362 book.translate.xml:12448 book.translate.xml:12524
#: book.translate.xml:12648 book.translate.xml:12707 book.translate.xml:12776
#: book.translate.xml:12858 book.translate.xml:12941 book.translate.xml:13001
#: book.translate.xml:13069 book.translate.xml:13132 book.translate.xml:13194
#: book.translate.xml:13260 book.translate.xml:13326 book.translate.xml:13404
#: book.translate.xml:13490 book.translate.xml:13558 book.translate.xml:13627
#: book.translate.xml:13699 book.translate.xml:13769 book.translate.xml:13826
#: book.translate.xml:13887 book.translate.xml:13955 book.translate.xml:14031
#: book.translate.xml:14104 book.translate.xml:14169 book.translate.xml:14223
#: book.translate.xml:14266 book.translate.xml:14314 book.translate.xml:14360
#: book.translate.xml:14421
#, fuzzy
msgid "Subject credential"
msgstr "Sujeito credencial"

#. (itstool) path: row/entry
#: book.translate.xml:7948
#, fuzzy
msgid "<parameter>dd</parameter>"
msgstr " <parameter> dd </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7949
#, fuzzy
msgid "Link destination"
msgstr "Destino do link"

#. (itstool) path: row/entry
#: book.translate.xml:7953
#, fuzzy
msgid "<parameter>ddlabel</parameter>"
msgstr " <parameter> ddlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7954
#, fuzzy
msgid "Label associated with <parameter>dd</parameter>"
msgstr "Etiqueta associada a <parameter> dd </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:7960
#, fuzzy
msgid "Symlink entry"
msgstr "Entrada no Symlink"

#. (itstool) path: row/entry
#: book.translate.xml:7965
#, fuzzy
msgid "Label associated with <parameter>de</parameter>"
msgstr "Etiqueta associada a <parameter> de </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:7972
#, fuzzy
msgid ""
"Fill in the label (<parameter>delabel</parameter>) for a newly created "
"<citerefentry vendor=\"current\"><refentrytitle>devfs</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry> symbolic link entry."
msgstr ""
"Preencha o r�tulo ( <parameter> delabel </parameter> ) para um rec�m criado "
"<citerefentry vendor=\"current\"><refentrytitle> devfs </"
"refentrytitle><manvolnum> 5 </manvolnum></citerefentry> entrada de link "
"simb�lico \""

#. (itstool) path: sect4/title
#: book.translate.xml:7977
#, fuzzy
msgid "<function>mpo_create_vnode_extattr</function>"
msgstr " <function> mpo_create_vnode_extattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:7980
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_create_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_create_vnode_extattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8026
#, fuzzy
msgid "<parameter>mount</parameter>"
msgstr " <parameter> montar </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8036 book.translate.xml:11866 book.translate.xml:11928
#: book.translate.xml:11990 book.translate.xml:12072 book.translate.xml:12452
#: book.translate.xml:12780 book.translate.xml:12862 book.translate.xml:13005
#: book.translate.xml:13136
#, fuzzy
msgid "<parameter>dvp</parameter>"
msgstr " <parameter> dvp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8037 book.translate.xml:12073
#, fuzzy
msgid "Parent directory vnode"
msgstr "Diret�rio pai vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8041 book.translate.xml:11871 book.translate.xml:11933
#: book.translate.xml:11995 book.translate.xml:12077 book.translate.xml:12457
#: book.translate.xml:12785 book.translate.xml:12867 book.translate.xml:13010
#: book.translate.xml:13141
#, fuzzy
msgid "<parameter>dlabel</parameter>"
msgstr " <parameter> dlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8042
#, fuzzy
msgid "Label associated with <parameter>dvp</parameter>"
msgstr "Etiqueta associada a <parameter> dvp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8048
#, fuzzy
msgid "Newly created vnode"
msgstr "Vnode recentemente criado"

#. (itstool) path: row/entry
#: book.translate.xml:8058 book.translate.xml:12001 book.translate.xml:12094
#: book.translate.xml:12474 book.translate.xml:12802 book.translate.xml:12890
#: book.translate.xml:13016
#, fuzzy
msgid "<parameter>cnp</parameter>"
msgstr " <parameter> CNP </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8059 book.translate.xml:12095 book.translate.xml:12803
#, fuzzy
msgid "Component name for <parameter>vp</parameter>"
msgstr "Nome do componente para <parameter> vp </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8066
#, fuzzy
msgid ""
"Write out the label for <parameter>vp</parameter> to the appropriate "
"extended attribute. If the write succeeds, fill in <parameter>vlabel</"
"parameter> with the label, and return <returnvalue>0</returnvalue>. "
"Otherwise, return an appropriate error."
msgstr ""
"Escreva o r�tulo para <parameter> vp </parameter> para o atributo estendido "
"apropriado. Se a grava��o for bem-sucedida, preencha <parameter> vlabel </"
"parameter> com o r�tulo e retornar <returnvalue> 0 </returnvalue> . Caso "
"contr�rio, retorne um erro apropriado. "

#. (itstool) path: sect4/title
#: book.translate.xml:8074
#, fuzzy
msgid "<function>mpo_create_mount</function>"
msgstr " <function> mpo_create_mount </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8077
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mnt</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mount </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> montagem "
"struct * <parameter> mp </parameter></paramdef><paramdef> label struct * "
"<parameter> mnt </parameter></paramdef><paramdef> label struct * <parameter> "
"fslabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8116
#, fuzzy
msgid "Object; file system being mounted"
msgstr "Objeto; sistema de arquivos sendo montado"

#. (itstool) path: row/entry
#: book.translate.xml:8121
#, fuzzy
msgid "Policy label to be filled in for <parameter>mp</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> mp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8127
#, fuzzy
msgid "Policy label for the file system <parameter>mp</parameter> mounts."
msgstr ""
"R�tulo de Pol�tica para o Sistema de Arquivos <parameter> mp </parameter> "
"montagens. "

#. (itstool) path: sect4/para
#: book.translate.xml:8134
#, fuzzy
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when a new file system is mounted."
msgstr ""
"Preencha os r�tulos no ponto de montagem que est� sendo criado pela "
"credencial de assunto passada. Essa chamada ser� feita quando um novo "
"sistema de arquivos for montado."

#. (itstool) path: sect4/title
#: book.translate.xml:8140
#, fuzzy
msgid "<function>mpo_create_root_mount</function>"
msgstr " <function> mpo_create_root_mount </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8143
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_root_mount</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mntlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>fslabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_root_mount </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> mntlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> fslabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8176
#, fuzzy
msgid "See <xref linkend=\"mac-mpo-create-mount\"/>."
msgstr "Vejo <xref linkend=\"mac-mpo-create-mount\"/> "

#. (itstool) path: sect4/para
#: book.translate.xml:8182
#, fuzzy
msgid ""
"Fill out the labels on the mount point being created by the passed subject "
"credential. This call will be made when the root file system is mounted, "
"after mpo_create_mount;."
msgstr ""
"Preencha os r�tulos no ponto de montagem que est� sendo criado pela "
"credencial de assunto passada. Essa chamada ser� feita quando o sistema de "
"arquivos raiz for montado, ap�s mpo_create_mount ;."

#. (itstool) path: sect4/title
#: book.translate.xml:8189
#, fuzzy
msgid "<function>mpo_relabel_vnode</function>"
msgstr " <function> mpo_relabel_vnode </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8192
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_vnode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_vnode </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8231
#, fuzzy
msgid "vnode to relabel"
msgstr "vnode para reclassificar"

#. (itstool) path: row/entry
#: book.translate.xml:8235 book.translate.xml:8376 book.translate.xml:9969
#: book.translate.xml:10042 book.translate.xml:11612
#, fuzzy
msgid "<parameter>vnodelabel</parameter>"
msgstr " <parameter> vnodelabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8236 book.translate.xml:11613
#, fuzzy
msgid "Existing policy label for <parameter>vp</parameter>"
msgstr "Etiqueta de pol�tica existente para <parameter> vp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8241 book.translate.xml:8702 book.translate.xml:8768
#: book.translate.xml:8832 book.translate.xml:9779 book.translate.xml:10184
#: book.translate.xml:10893 book.translate.xml:11435 book.translate.xml:11500
#: book.translate.xml:11550 book.translate.xml:11618
#, fuzzy
msgid "<parameter>newlabel</parameter>"
msgstr " <parameter> newlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8242
#, fuzzy
msgid ""
"New, possibly partial label to replace <parameter>vnodelabel</parameter>"
msgstr ""
"Etiqueta nova, possivelmente parcial, para substituir <parameter> vnodelabel "
"</parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8249
#, fuzzy
msgid ""
"Update the label on the passed vnode given the passed update vnode label and "
"the passed subject credential."
msgstr ""
"Atualize o r�tulo no vnode passado, dado o r�tulo vnode da atualiza��o "
"passada e a credencial de assunto passada."

#. (itstool) path: sect4/title
#: book.translate.xml:8255
#, fuzzy
msgid "<function>mpo_setlabel_vnode_extattr</function>"
msgstr " <function> mpo_setlabel_vnode_extattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8258
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_setlabel_vnode_extattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>intlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_setlabel_vnode_extattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> intlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8297
#, fuzzy
msgid "Vnode for which the label is being written"
msgstr "Vnode para o qual o r�tulo est� sendo gravado"

#. (itstool) path: row/entry
#: book.translate.xml:8308
#, fuzzy
msgid "<parameter>intlabel</parameter>"
msgstr " <parameter> louco </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8309
#, fuzzy
msgid "Label to write out"
msgstr "Etiqueta para escrever"

#. (itstool) path: sect4/para
#: book.translate.xml:8315
#, fuzzy
msgid ""
"Write out the policy from <parameter>intlabel</parameter> to an extended "
"attribute. This is called from <function>vop_stdcreatevnode_ea</function>."
msgstr ""
"Escreva a pol�tica de <parameter> intlabel </parameter> para um atributo "
"estendido. Isso � chamado de <function> vop_stdcreatevnode_ea </function> "

#. (itstool) path: sect4/title
#: book.translate.xml:8322
#, fuzzy
msgid "<function>mpo_update_devfsdirent</function>"
msgstr " <function> mpo_update_devfsdirent </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8325
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_update_devfsdirent</function></funcdef> "
"<paramdef>struct devfs_dirent *<parameter>devfs_dirent</parameter></"
"paramdef> <paramdef>struct label *<parameter>direntlabel</parameter></"
"paramdef> <paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_update_devfsdirent </function></"
"funcdef><paramdef> struct devfs_dirent * <parameter> devfs_dirent </"
"parameter></paramdef><paramdef> label struct * <parameter> direntlabel </"
"parameter></paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8359
#, fuzzy
msgid "Object; devfs directory entry"
msgstr "Objeto; entrada do diret�rio devfs"

#. (itstool) path: row/entry
#: book.translate.xml:8363
#, fuzzy
msgid "<parameter>direntlabel</parameter>"
msgstr " <parameter> direntlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8364
#, fuzzy
msgid "Policy label for <parameter>devfs_dirent</parameter> to be updated."
msgstr ""
"Etiqueta de pol�tica para <parameter> devfs_dirent </parameter> ser "
"atualizado."

#. (itstool) path: row/entry
#: book.translate.xml:8371
#, fuzzy
msgid "Parent vnode"
msgstr "Parent vnode"

#. (itstool) path: row/entry
#: book.translate.xml:8372 book.translate.xml:9965 book.translate.xml:11608
#: book.translate.xml:12162
#, fuzzy
msgid "Locked"
msgstr "Bloqueado"

#. (itstool) path: row/entry
#: book.translate.xml:8377 book.translate.xml:9970 book.translate.xml:10043
#: book.translate.xml:11802 book.translate.xml:12089 book.translate.xml:12167
#: book.translate.xml:12234 book.translate.xml:12299 book.translate.xml:12372
#: book.translate.xml:13079 book.translate.xml:13204 book.translate.xml:13270
#: book.translate.xml:13336 book.translate.xml:13414 book.translate.xml:13500
#: book.translate.xml:13568 book.translate.xml:13637 book.translate.xml:13709
#: book.translate.xml:13897
#, fuzzy
msgid "Policy label for <parameter>vp</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> vp </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8384
#, fuzzy
msgid ""
"Update the <parameter>devfs_dirent</parameter> label from the passed devfs "
"vnode label. This call will be made when a devfs vnode has been successfully "
"relabeled to commit the label change such that it lasts even if the vnode is "
"recycled. It will also be made when a symlink is created in devfs, following "
"a call to <function>mac_vnode_create_from_vnode</function> to initialize the "
"vnode label."
msgstr ""
"Atualizar o <parameter> devfs_dirent </parameter> label do r�tulo vnode "
"devfs passado. Essa chamada ser� feita quando um devfs vnode tiver sido "
"renomeado com sucesso para confirmar a mudan�a de r�tulo, de modo que ele "
"dure mesmo que o vnode seja reciclado. Tamb�m ser� feito quando um link "
"simb�lico � criado no devfs, ap�s uma chamada para <function> "
"mac_vnode_create_from_vnode </function> para inicializar o r�tulo vnode. "

#. (itstool) path: sect3/title
#: book.translate.xml:8396
#, fuzzy
msgid "IPC Object Labeling Event Operations"
msgstr "Opera��es de evento de rotulagem de objeto IPC"

#. (itstool) path: sect4/title
#: book.translate.xml:8399
#, fuzzy
msgid "<function>mpo_create_mbuf_from_socket</function>"
msgstr " <function> mpo_create_mbuf_from_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8402
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>m</parameter></paramdef> <paramdef>struct "
"label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> m </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8435 book.translate.xml:11062 book.translate.xml:11124
#: book.translate.xml:11368 book.translate.xml:11489 book.translate.xml:12945
#, fuzzy
msgid "<parameter>socket</parameter>"
msgstr " <parameter> soquete </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8436 book.translate.xml:11194 book.translate.xml:11252
#, fuzzy
msgid "Socket"
msgstr "Soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8437
#, fuzzy
msgid "Socket locking WIP"
msgstr "Socket locking WIP"

#. (itstool) path: row/entry
#: book.translate.xml:8441 book.translate.xml:8570 book.translate.xml:11067
#: book.translate.xml:11129 book.translate.xml:11198 book.translate.xml:11256
#: book.translate.xml:11373 book.translate.xml:11494 book.translate.xml:12950
#: book.translate.xml:14114
#, fuzzy
msgid "<parameter>socketlabel</parameter>"
msgstr " <parameter> socketlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8442 book.translate.xml:11068 book.translate.xml:11130
#: book.translate.xml:11374 book.translate.xml:12951
#, fuzzy
msgid "Policy label for <parameter>socket</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> soquete </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8447
#, fuzzy
msgid "<parameter>m</parameter>"
msgstr " <parameter> m </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8448
#, fuzzy
msgid "Object; mbuf"
msgstr "Objeto; mbuf"

#. (itstool) path: row/entry
#: book.translate.xml:8452 book.translate.xml:8822 book.translate.xml:9349
#: book.translate.xml:9417 book.translate.xml:9484 book.translate.xml:9835
#: book.translate.xml:13975 book.translate.xml:14051
#, fuzzy
msgid "<parameter>mbuflabel</parameter>"
msgstr " <parameter> mbuflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8453
#, fuzzy
msgid "Policy label to fill in for <parameter>m</parameter>"
msgstr "Etiqueta de pol�tica a preencher para <parameter> m </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8460
#, fuzzy
msgid ""
"Set the label on a newly created mbuf header from the passed socket label. "
"This call is made when a new datagram or message is generated by the socket "
"and stored in the passed mbuf."
msgstr ""
"Configure o r�tulo em um cabe�alho mbuf rec�m-criado a partir do r�tulo do "
"soquete passado. Essa chamada � feita quando um novo datagrama ou mensagem � "
"gerado pelo soquete e armazenado no mbuf passado."

#. (itstool) path: sect4/title
#: book.translate.xml:8467
#, fuzzy
msgid "<function>mpo_create_pipe</function>"
msgstr " <function> mpo_create_pipe </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8470
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_pipe </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de "
"estrutura * <parameter> tubo </parameter></paramdef><paramdef> label struct "
"* <parameter> pipelabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8506 book.translate.xml:8691 book.translate.xml:10699
#: book.translate.xml:10766 book.translate.xml:10823 book.translate.xml:10882
#: book.translate.xml:10945 book.translate.xml:11003
#, fuzzy
msgid "<parameter>pipe</parameter>"
msgstr " <parameter> tubo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8507 book.translate.xml:8692 book.translate.xml:10700
#: book.translate.xml:10767 book.translate.xml:10824 book.translate.xml:10883
#: book.translate.xml:10946 book.translate.xml:11004
#, fuzzy
msgid "Pipe"
msgstr "Tubo"

#. (itstool) path: row/entry
#: book.translate.xml:8511 book.translate.xml:10704 book.translate.xml:10771
#: book.translate.xml:10828 book.translate.xml:10887 book.translate.xml:10950
#: book.translate.xml:11008
#, fuzzy
msgid "<parameter>pipelabel</parameter>"
msgstr " <parameter> pipelabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8512 book.translate.xml:10705 book.translate.xml:10772
#: book.translate.xml:10829 book.translate.xml:10951 book.translate.xml:11009
#, fuzzy
msgid "Policy label associated with <parameter>pipe</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> tubo </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8519
#, fuzzy
msgid ""
"Set the label on a newly created pipe from the passed subject credential. "
"This call is made when a new pipe is created."
msgstr ""
"Configure o r�tulo em um pipe rec�m-criado a partir da credencial de assunto "
"passada. Essa chamada � feita quando um novo canal � criado."

#. (itstool) path: sect4/title
#: book.translate.xml:8525
#, fuzzy
msgid "<function>mpo_create_socket</function>"
msgstr " <function> mpo_create_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8528
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_socket </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8561 book.translate.xml:8753 book.translate.xml:8954
#: book.translate.xml:9955 book.translate.xml:10033 book.translate.xml:11602
#: book.translate.xml:11732 book.translate.xml:12156 book.translate.xml:14105
#, fuzzy
msgid "Immutable"
msgstr "Imut�vel"

#. (itstool) path: row/entry
#: book.translate.xml:8565 book.translate.xml:8757 book.translate.xml:11193
#: book.translate.xml:11251 book.translate.xml:14109
#, fuzzy
msgid "<parameter>so</parameter>"
msgstr " <parameter> assim </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8566
#, fuzzy
msgid "Object; socket to label"
msgstr "Objeto; soquete para rotular"

#. (itstool) path: row/entry
#: book.translate.xml:8571
#, fuzzy
msgid "Label to fill in for <parameter>so</parameter>"
msgstr "R�tulo para preencher para <parameter> assim </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8578
#, fuzzy
msgid ""
"Set the label on a newly created socket from the passed subject credential. "
"This call is made when a socket is created."
msgstr ""
"Configure o r�tulo em um soquete rec�m-criado a partir da credencial de "
"assunto passada. Essa chamada � feita quando um soquete � criado."

#. (itstool) path: sect4/title
#: book.translate.xml:8584
#, fuzzy
msgid "<function>mpo_create_socket_from_socket</function>"
msgstr " <function> mpo_create_socket_from_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8587
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_socket_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_socket_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> oldsocket </"
"parameter></paramdef><paramdef> label struct * <parameter> oldsocketlabel </"
"parameter></paramdef><paramdef> soquete de estrutura * <parameter> boletim "
"de not�cias </parameter></paramdef><paramdef> label struct * <parameter> "
"newsocketlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8620 book.translate.xml:8882
#, fuzzy
msgid "<parameter>oldsocket</parameter>"
msgstr " <parameter> oldsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8621
#, fuzzy
msgid "Listening socket"
msgstr "Tomada de escuta"

#. (itstool) path: row/entry
#: book.translate.xml:8625 book.translate.xml:8887
#, fuzzy
msgid "<parameter>oldsocketlabel</parameter>"
msgstr " <parameter> oldsocketlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8626
#, fuzzy
msgid "Policy label associated with <parameter>oldsocket</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> oldsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8631 book.translate.xml:8893
#, fuzzy
msgid "<parameter>newsocket</parameter>"
msgstr " <parameter> newsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8632
#, fuzzy
msgid "New socket"
msgstr "Novo soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8636
#, fuzzy
msgid "<parameter>newsocketlabel</parameter>"
msgstr " <parameter> newsocketlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8637
#, fuzzy
msgid "Policy label associated with <parameter>newsocketlabel</parameter>"
msgstr ""
"Etiqueta de pol�tica associada a <parameter> newsocketlabel </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8644
#, fuzzy
msgid ""
"Label a socket, <parameter>newsocket</parameter>, newly "
"<citerefentry><refentrytitle>accept</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>ed, based on the <citerefentry><refentrytitle>listen</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> socket, "
"<parameter>oldsocket</parameter>."
msgstr ""
"Etiquetar um soquete, <parameter> boletim de not�cias </parameter> "
"recentemente <citerefentry><refentrytitle> aceitar </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> ed, com base no "
"<citerefentry><refentrytitle> ou�o </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> soquete <parameter> oldsocket </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:8650
#, fuzzy
msgid "<function>mpo_relabel_pipe</function>"
msgstr " <function> mpo_relabel_pipe </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8653
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_pipe</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_pipe </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> pipe de "
"estrutura * <parameter> tubo </parameter></paramdef><paramdef> label struct "
"* <parameter> oldlabel </parameter></paramdef><paramdef> label struct * "
"<parameter> newlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8696 book.translate.xml:8762 book.translate.xml:8827
#, fuzzy
msgid "<parameter>oldlabel</parameter>"
msgstr " <parameter> oldlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8697 book.translate.xml:10888
#, fuzzy
msgid "Current policy label associated with <parameter>pipe</parameter>"
msgstr "Etiqueta de pol�tica atual associada a <parameter> tubo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8703
#, fuzzy
msgid "Policy label update to apply to <parameter>pipe</parameter>"
msgstr ""
"Atualiza��o de r�tulo de pol�tica a ser aplicada a <parameter> tubo </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8710
#, fuzzy
msgid ""
"Apply a new label, <parameter>newlabel</parameter>, to <parameter>pipe</"
"parameter>."
msgstr ""
"Aplique um novo r�tulo, <parameter> newlabel </parameter> , para <parameter> "
"tubo </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:8715
#, fuzzy
msgid "<function>mpo_relabel_socket</function>"
msgstr " <function> mpo_relabel_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8718
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_socket</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_socket </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> oldlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8758 book.translate.xml:11369 book.translate.xml:11490
#: book.translate.xml:12946 book.translate.xml:14110
#, fuzzy
msgid "Object; socket"
msgstr "Objeto; soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8763
#, fuzzy
msgid "Current label for <parameter>so</parameter>"
msgstr "Etiqueta atual para <parameter> assim </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8769
#, fuzzy
msgid "Label update for <parameter>so</parameter>"
msgstr "Atualiza��o de etiqueta para <parameter> assim </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8776
#, fuzzy
msgid "Update the label on a socket from the passed socket label update."
msgstr ""
"Atualize o r�tulo em um soquete da atualiza��o do r�tulo do soquete passado."

#. (itstool) path: sect4/title
#: book.translate.xml:8781
#, fuzzy
msgid "<function>mpo_set_socket_peer_from_mbuf</function>"
msgstr " <function> mpo_set_socket_peer_from_mbuf </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8784
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_set_socket_peer_from_mbuf </function></"
"funcdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef><paramdef> label struct * <parameter> oldlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8817 book.translate.xml:9344 book.translate.xml:9412
#: book.translate.xml:9479 book.translate.xml:9830 book.translate.xml:13970
#: book.translate.xml:14046
#, fuzzy
msgid "<parameter>mbuf</parameter>"
msgstr " <parameter> mbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8818
#, fuzzy
msgid "First datagram received over socket"
msgstr "Primeiro datagrama recebido por soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8823
#, fuzzy
msgid "Label for <parameter>mbuf</parameter>"
msgstr "R�tulo para <parameter> mbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8828
#, fuzzy
msgid "Current label for the socket"
msgstr "Etiqueta atual para o soquete"

#. (itstool) path: row/entry
#: book.translate.xml:8833
#, fuzzy
msgid "Policy label to be filled out for the socket"
msgstr "Etiqueta de pol�tica a ser preenchida para o socket"

#. (itstool) path: sect4/para
#: book.translate.xml:8840
#, fuzzy
msgid ""
"Set the peer label on a stream socket from the passed mbuf label. This call "
"will be made when the first datagram is received by the stream socket, with "
"the exception of Unix domain sockets."
msgstr ""
"Configure o r�tulo peer em um soquete de fluxo a partir do r�tulo mbuf "
"passado. Essa chamada ser� feita quando o primeiro datagrama for recebido "
"pelo soquete de fluxo, com a exce��o dos soquetes de dom�nio Unix."

#. (itstool) path: sect4/title
#: book.translate.xml:8847
#, fuzzy
msgid "<function>mpo_set_socket_peer_from_socket</function>"
msgstr " <function> mpo_set_socket_peer_from_socket </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8850
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_set_socket_peer_from_socket</function></funcdef> "
"<paramdef>struct socket *<parameter>oldsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldsocketlabel</parameter></paramdef> "
"<paramdef>struct socket *<parameter>newsocket</parameter></paramdef> "
"<paramdef>struct label *<parameter>newsocketpeerlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_set_socket_peer_from_socket </function></"
"funcdef><paramdef> soquete de estrutura * <parameter> oldsocket </"
"parameter></paramdef><paramdef> label struct * <parameter> oldsocketlabel </"
"parameter></paramdef><paramdef> soquete de estrutura * <parameter> boletim "
"de not�cias </parameter></paramdef><paramdef> label struct * <parameter> "
"newsocketpeerlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8883
#, fuzzy
msgid "Local socket"
msgstr "Soquete local"

#. (itstool) path: row/entry
#: book.translate.xml:8888
#, fuzzy
msgid "Policy label for <parameter>oldsocket</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> oldsocket </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8894
#, fuzzy
msgid "Peer socket"
msgstr "Soquete do par"

#. (itstool) path: row/entry
#: book.translate.xml:8898
#, fuzzy
msgid "<parameter>newsocketpeerlabel</parameter>"
msgstr " <parameter> newsocketpeerlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8899
#, fuzzy
msgid "Policy label to fill in for <parameter>newsocket</parameter>"
msgstr ""
"Etiqueta de pol�tica a preencher para <parameter> boletim de not�cias </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8907
#, fuzzy
msgid ""
"Set the peer label on a stream UNIX domain socket from the passed remote "
"socket endpoint. This call will be made when the socket pair is connected, "
"and will be made for both endpoints."
msgstr ""
"Configure o r�tulo peer em um soquete de dom�nio UNIX de fluxo a partir do "
"terminal de soquete remoto passado. Essa chamada ser� feita quando o par de "
"soquetes estiver conectado e ser� feita para os dois terminais."

#. (itstool) path: sect3/title
#: book.translate.xml:8915
#, fuzzy
msgid "Network Object Labeling Event Operations"
msgstr "Opera��es de evento de rotulagem de objeto de rede"

#. (itstool) path: sect4/title
#: book.translate.xml:8918
#, fuzzy
msgid "<function>mpo_create_bpfdesc</function>"
msgstr " <function> mpo_create_bpfdesc </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8921
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_bpfdesc</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_bpfdesc </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:8958 book.translate.xml:9401 book.translate.xml:10294
#, fuzzy
msgid "<parameter>bpf_d</parameter>"
msgstr " <parameter> bpf_d </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8959
#, fuzzy
msgid "Object; bpf descriptor"
msgstr "Objeto; descritor bpf"

#. (itstool) path: row/entry
#: book.translate.xml:8963
#, fuzzy
msgid "<parameter>bpf</parameter>"
msgstr " <parameter> bpf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:8964
#, fuzzy
msgid "Policy label to be filled in for <parameter>bpf_d</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> bpf_d </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:8971
#, fuzzy
msgid ""
"Set the label on a newly created BPF descriptor from the passed subject "
"credential. This call will be made when a BPF device node is opened by a "
"process with the passed subject credential."
msgstr ""
"Configure o r�tulo em um descritor BPF rec�m-criado a partir da credencial "
"de assunto passada. Essa chamada ser� feita quando um n� de dispositivo BPF "
"for aberto por um processo com a credencial de assunto passada."

#. (itstool) path: sect4/title
#: book.translate.xml:8978
#, fuzzy
msgid "<function>mpo_create_ifnet</function>"
msgstr " <function> mpo_create_ifnet </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:8981
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_ifnet </function></funcdef><paramdef> "
"struct ifnet * <parameter> ifnet </parameter></paramdef><paramdef> label "
"struct * <parameter> ifnetlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9010 book.translate.xml:9333 book.translate.xml:9468
#: book.translate.xml:9548 book.translate.xml:9768 book.translate.xml:10305
#: book.translate.xml:11424 book.translate.xml:13959 book.translate.xml:14035
#, fuzzy
msgid "<parameter>ifnet</parameter>"
msgstr " <parameter> ifnet </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9011 book.translate.xml:9334 book.translate.xml:9469
#: book.translate.xml:9549 book.translate.xml:13960 book.translate.xml:14036
#, fuzzy
msgid "Network interface"
msgstr "Interface de rede"

#. (itstool) path: row/entry
#: book.translate.xml:9015 book.translate.xml:9338 book.translate.xml:9473
#: book.translate.xml:9553 book.translate.xml:9773 book.translate.xml:10310
#: book.translate.xml:11429 book.translate.xml:13964 book.translate.xml:14040
#, fuzzy
msgid "<parameter>ifnetlabel</parameter>"
msgstr " <parameter> ifnetlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9016
#, fuzzy
msgid "Policy label to fill in for <parameter>ifnet</parameter>"
msgstr "Etiqueta de pol�tica a preencher para <parameter> ifnet </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9023
#, fuzzy
msgid ""
"Set the label on a newly created interface. This call may be made when a new "
"physical interface becomes available to the system, or when a pseudo-"
"interface is instantiated during the boot or as a result of a user action."
msgstr ""
"Configure o r�tulo em uma interface rec�m-criada. Essa chamada pode ser "
"feita quando uma nova interface f�sica se torna dispon�vel para o sistema ou "
"quando uma pseudo-interface � instanciada durante a inicializa��o ou como "
"resultado de uma a��o do usu�rio."

#. (itstool) path: sect4/title
#: book.translate.xml:9031
#, fuzzy
msgid "<function>mpo_create_ipq</function>"
msgstr " <function> mpo_create_ipq </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9034
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_ipq </function></funcdef><paramdef> "
"struct mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label "
"struct * <parameter> fragmento </parameter></paramdef><paramdef> struct ipq "
"* <parameter> ipq </parameter></paramdef><paramdef> label struct * "
"<parameter> ipqlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9067 book.translate.xml:9210 book.translate.xml:9686
#, fuzzy
msgid "<parameter>fragment</parameter>"
msgstr " <parameter> fragmento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9068
#, fuzzy
msgid "First received IP fragment"
msgstr "Primeiro fragmento IP recebido"

#. (itstool) path: row/entry
#: book.translate.xml:9072 book.translate.xml:9215 book.translate.xml:9691
#, fuzzy
msgid "<parameter>fragmentlabel</parameter>"
msgstr " <parameter> fragmento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9073 book.translate.xml:9692
#, fuzzy
msgid "Policy label for <parameter>fragment</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> fragmento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9078 book.translate.xml:9133 book.translate.xml:9697
#: book.translate.xml:9841
#, fuzzy
msgid "<parameter>ipq</parameter>"
msgstr " <parameter> ipq </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9079
#, fuzzy
msgid "IP reassembly queue to be labeled"
msgstr "Fila de remontagem de IP a ser rotulada"

#. (itstool) path: row/entry
#: book.translate.xml:9083 book.translate.xml:9138 book.translate.xml:9702
#: book.translate.xml:9846
#, fuzzy
msgid "<parameter>ipqlabel</parameter>"
msgstr " <parameter> ipglabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9084
#, fuzzy
msgid "Policy label to be filled in for <parameter>ipq</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> ipq </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9091
#, fuzzy
msgid ""
"Set the label on a newly created IP fragment reassembly queue from the mbuf "
"header of the first received fragment."
msgstr ""
"Configure o r�tulo em uma fila de remontagem de fragmento IP rec�m-criada a "
"partir do cabe�alho mbuf do primeiro fragmento recebido."

#. (itstool) path: sect4/title
#: book.translate.xml:9097
#, fuzzy
msgid "<function>mpo_create_datagram_from_ipq</function>"
msgstr " <function> mpo_create_datagram_from_ipq </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9100
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_create_datagram_from_ipq</function></"
"funcdef> <paramdef>struct ipq *<parameter>ipq</parameter></paramdef> "
"<paramdef>struct label *<parameter>ipqlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_create_datagram_from_ipq </function></"
"funcdef><paramdef> struct ipq * <parameter> ipq </parameter></"
"paramdef><paramdef> label struct * <parameter> ipqlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> datagrama </parameter></"
"paramdef><paramdef> label struct * <parameter> datagramlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9134
#, fuzzy
msgid "IP reassembly queue"
msgstr "Fila de remontagem de IP"

#. (itstool) path: row/entry
#: book.translate.xml:9139 book.translate.xml:9703
#, fuzzy
msgid "Policy label for <parameter>ipq</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> ipq </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9144 book.translate.xml:9199
#, fuzzy
msgid "<parameter>datagram</parameter>"
msgstr " <parameter> datagrama </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9145
#, fuzzy
msgid "Datagram to be labeled"
msgstr "Datagrama a ser rotulado"

#. (itstool) path: row/entry
#: book.translate.xml:9149 book.translate.xml:9204
#, fuzzy
msgid "<parameter>datagramlabel</parameter>"
msgstr " <parameter> etiqueta datagrama </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9150
#, fuzzy
msgid "Policy label to be filled in for <parameter>datagramlabel</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> datagramlabel </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9157
#, fuzzy
msgid ""
"Set the label on a newly reassembled IP datagram from the IP fragment "
"reassembly queue from which it was generated."
msgstr ""
"Configure o r�tulo em um datagrama IP rec�m remontado da fila de remontagem "
"de fragmento IP a partir da qual ele foi gerado."

#. (itstool) path: sect4/title
#: book.translate.xml:9163
#, fuzzy
msgid "<function>mpo_create_fragment</function>"
msgstr " <function> mpo_create_fragment </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9166
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_fragment</function></funcdef> "
"<paramdef>struct mbuf *<parameter>datagram</parameter></paramdef> "
"<paramdef>struct label *<parameter>datagramlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_fragment </function></"
"funcdef><paramdef> struct mbuf * <parameter> datagrama </parameter></"
"paramdef><paramdef> label struct * <parameter> datagramlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> fragmento </parameter></"
"paramdef><paramdef> label struct * <parameter> fragmento </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9200
#, fuzzy
msgid "Datagram"
msgstr "Datagrama"

#. (itstool) path: row/entry
#: book.translate.xml:9205
#, fuzzy
msgid "Policy label for <parameter>datagram</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> datagrama </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9211
#, fuzzy
msgid "Fragment to be labeled"
msgstr "Fragmento a ser rotulado"

#. (itstool) path: row/entry
#: book.translate.xml:9216
#, fuzzy
msgid "Policy label to be filled in for <parameter>datagram</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> datagrama </"
"parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9223
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created IP fragment from the "
"label on the mbuf header of the datagram it was generate from."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um fragmento IP rec�m-criado a "
"partir do r�tulo no cabe�alho mbuf do datagrama do qual ele foi gerado."

#. (itstool) path: sect4/title
#: book.translate.xml:9229
#, fuzzy
msgid "<function>mpo_create_mbuf_from_mbuf</function>"
msgstr " <function> mpo_create_mbuf_from_mbuf </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9232
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_mbuf</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_mbuf </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9265 book.translate.xml:9537 book.translate.xml:9617
#, fuzzy
msgid "<parameter>oldmbuf</parameter>"
msgstr " <parameter> oldmbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9266
#, fuzzy
msgid "Existing (source) mbuf"
msgstr "Existente (fonte) mbuf"

#. (itstool) path: row/entry
#: book.translate.xml:9270 book.translate.xml:9542 book.translate.xml:9622
#, fuzzy
msgid "<parameter>oldmbuflabel</parameter>"
msgstr " <parameter> oldmbuflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9271 book.translate.xml:9543 book.translate.xml:9623
#, fuzzy
msgid "Policy label for <parameter>oldmbuf</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> oldmbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9276 book.translate.xml:9559 book.translate.xml:9628
#, fuzzy
msgid "<parameter>newmbuf</parameter>"
msgstr " <parameter> newmbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9277 book.translate.xml:9413
#, fuzzy
msgid "New mbuf to be labeled"
msgstr "Novo mbuf a ser rotulado"

#. (itstool) path: row/entry
#: book.translate.xml:9281 book.translate.xml:9565 book.translate.xml:9633
#, fuzzy
msgid "<parameter>newmbuflabel</parameter>"
msgstr " <parameter> newmbuflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9282 book.translate.xml:9566
#, fuzzy
msgid "Policy label to be filled in for <parameter>newmbuf</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> newmbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9289
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram from the mbuf "
"header of an existing datagram. This call may be made in a number of "
"situations, including when an mbuf is re-allocated for alignment purposes."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado a partir "
"do cabe�alho mbuf de um datagrama existente. Essa chamada pode ser feita em "
"v�rias situa��es, inclusive quando um mbuf � realocado para fins de "
"alinhamento."

#. (itstool) path: sect4/title
#: book.translate.xml:9297
#, fuzzy
msgid "<function>mpo_create_mbuf_linklayer</function>"
msgstr " <function> mpo_create_mbuf_linklayer </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9300
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_linklayer</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_linklayer </function></"
"funcdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9339 book.translate.xml:9554 book.translate.xml:9774
#: book.translate.xml:10311 book.translate.xml:13965 book.translate.xml:14041
#, fuzzy
msgid "Policy label for <parameter>ifnet</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> ifnet </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9345 book.translate.xml:9480
#, fuzzy
msgid "mbuf header for new datagram"
msgstr "cabe�alho mbuf para novo datagrama"

#. (itstool) path: row/entry
#: book.translate.xml:9350 book.translate.xml:9485
#, fuzzy
msgid "Policy label to be filled in for <parameter>mbuf</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser preenchida para <parameter> mbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9357
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated for "
"the purposes of a link layer response for the passed interface. This call "
"may be made in a number of situations, including for ARP or ND6 responses in "
"the IPv4 and IPv6 stacks."
msgstr ""
"Defina o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado para "
"fins de uma resposta de camada de link para a interface passada. Essa "
"chamada pode ser feita em v�rias situa��es, incluindo respostas ARP ou ND6 "
"nas pilhas IPv4 e IPv6 "

#. (itstool) path: sect4/title
#: book.translate.xml:9365
#, fuzzy
msgid "<function>mpo_create_mbuf_from_bpfdesc</function>"
msgstr " <function> mpo_create_mbuf_from_bpfdesc </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9368
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_bpfdesc</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_bpfdesc </function></"
"funcdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9402
#, fuzzy
msgid "BPF descriptor"
msgstr "Descritor BPF"

#. (itstool) path: row/entry
#: book.translate.xml:9406 book.translate.xml:10299
#, fuzzy
msgid "<parameter>bpflabel</parameter>"
msgstr " <parameter> bpflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9407
#, fuzzy
msgid "Policy label for <parameter>bpflabel</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> bpflabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9418
#, fuzzy
msgid "Policy label to fill in for <parameter>mbuf</parameter>"
msgstr "Etiqueta de pol�tica a preencher para <parameter> mbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9425
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated using "
"the passed BPF descriptor. This call is made when a write is performed to "
"the BPF device associated with the passed BPF descriptor."
msgstr ""
"Definir o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado "
"usando o descritor BPF passado. Essa chamada � feita quando uma grava��o � "
"executada para o dispositivo BPF associado ao descritor BPF passado."

#. (itstool) path: sect4/title
#: book.translate.xml:9432
#, fuzzy
msgid "<function>mpo_create_mbuf_from_ifnet</function>"
msgstr " <function> mpo_create_mbuf_from_ifnet </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9435
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_from_ifnet</function></funcdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_from_ifnet </function></"
"funcdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9474
#, fuzzy
msgid "Policy label for <parameter>ifnetlabel</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> ifnetlabel </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9492
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from "
"the passed network interface."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado a "
"partir da interface de rede passada."

#. (itstool) path: sect4/title
#: book.translate.xml:9498
#, fuzzy
msgid "<function>mpo_create_mbuf_multicast_encap</function>"
msgstr " <function> mpo_create_mbuf_multicast_encap </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9501
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_multicast_encap</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_multicast_encap </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9538
#, fuzzy
msgid "mbuf header for existing datagram"
msgstr "cabe�alho mbuf para datagrama existente"

#. (itstool) path: row/entry
#: book.translate.xml:9560
#, fuzzy
msgid "mbuf header to be labeled for new datagram"
msgstr "cabe�alho mbuf a ser rotulado para novo datagrama"

#. (itstool) path: sect4/para
#: book.translate.xml:9573
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated from "
"the existing passed datagram when it is processed by the passed multicast "
"encapsulation interface. This call is made when an mbuf is to be delivered "
"using the virtual interface."
msgstr ""
"Configure o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado a "
"partir do datagrama passado existente quando ele � processado pela interface "
"de encapsulamento de difus�o m�ltipla passada. Essa chamada � feita quando "
"um mbuf deve ser entregue usando a interface virtual."

#. (itstool) path: sect4/title
#: book.translate.xml:9581
#, fuzzy
msgid "<function>mpo_create_mbuf_netlayer</function>"
msgstr " <function> mpo_create_mbuf_netlayer </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9584
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_mbuf_netlayer</function></funcdef> "
"<paramdef>struct mbuf *<parameter>oldmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>oldmbuflabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>newmbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>newmbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_mbuf_netlayer </function></"
"funcdef><paramdef> struct mbuf * <parameter> oldmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> oldmbuflabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> newmbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> newmbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9618
#, fuzzy
msgid "Received datagram"
msgstr "Recebido datagrama"

#. (itstool) path: row/entry
#: book.translate.xml:9629
#, fuzzy
msgid "Newly created datagram"
msgstr "Datagrama rec�m-criado"

#. (itstool) path: row/entry
#: book.translate.xml:9634
#, fuzzy
msgid "Policy label for <parameter>newmbuf</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> newmbuf </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9641
#, fuzzy
msgid ""
"Set the label on the mbuf header of a newly created datagram generated by "
"the IP stack in response to an existing received datagram "
"(<parameter>oldmbuf</parameter>). This call may be made in a number of "
"situations, including when responding to ICMP request datagrams."
msgstr ""
"Definir o r�tulo no cabe�alho mbuf de um datagrama rec�m-criado gerado pela "
"pilha IP em resposta a um datagrama recebido existente ( <parameter> oldmbuf "
"</parameter> ). Essa chamada pode ser feita em v�rias situa��es, inclusive "
"ao responder datagramas de solicita��o do ICMP. "

#. (itstool) path: sect4/title
#: book.translate.xml:9650
#, fuzzy
msgid "<function>mpo_fragment_match</function>"
msgstr " <function> mpo_fragment_match </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9653
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_fragment_match</function></funcdef> "
"<paramdef>struct mbuf *<parameter>fragment</parameter></paramdef> "
"<paramdef>struct label *<parameter>fragmentlabel</parameter></paramdef> "
"<paramdef>struct ipq *<parameter>ipq</parameter></paramdef> <paramdef>struct "
"label *<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_fragment_match </function></funcdef><paramdef> "
"struct mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label "
"struct * <parameter> fragmento </parameter></paramdef><paramdef> struct ipq "
"* <parameter> ipq </parameter></paramdef><paramdef> label struct * "
"<parameter> ipqlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9687
#, fuzzy
msgid "IP datagram fragment"
msgstr "Fragmento de datagrama IP"

#. (itstool) path: row/entry
#: book.translate.xml:9698 book.translate.xml:9842
#, fuzzy
msgid "IP fragment reassembly queue"
msgstr "Fila de remontagem de fragmento de IP"

#. (itstool) path: sect4/para
#: book.translate.xml:9710
#, fuzzy
msgid ""
"Determine whether an mbuf header containing an IP datagram "
"(<parameter>fragment</parameter>) fragment matches the label of the passed "
"IP fragment reassembly queue (<parameter>ipq</parameter>). Return "
"(<returnvalue>1</returnvalue>) for a successful match, or (<returnvalue>0</"
"returnvalue>) for no match. This call is made when the IP stack attempts to "
"find an existing fragment reassembly queue for a newly received fragment; if "
"this fails, a new fragment reassembly queue may be instantiated for the "
"fragment. Policies may use this entry point to prevent the reassembly of "
"otherwise matching IP fragments if policy does not permit them to be "
"reassembled based on the label or other information."
msgstr ""
"Determina se um cabe�alho mbuf contendo um datagrama IP ( <parameter> "
"fragmento </parameter> ) fragment corresponde ao r�tulo da fila de "
"remontagem de fragmentos IP passada ( <parameter> ipq </parameter> ). "
"Retorna ( <returnvalue> 1 </returnvalue> ) para um jogo bem sucedido, ou ( "
"<returnvalue> 0 </returnvalue> ) sem correspond�ncia. Essa chamada � feita "
"quando a pilha de IP tenta localizar uma fila de remontagem de fragmento "
"existente para um fragmento rec�m-recebido; se isso falhar, uma nova fila de "
"remontagem de fragmento pode ser instanciada para o fragmento. As pol�ticas "
"podem usar este ponto de entrada para impedir a remontagem de fragmentos IP "
"correspondentes, caso a pol�tica n�o permita que eles sejam remontados com "
"base no r�tulo ou em outras informa��es. "

#. (itstool) path: sect4/title
#: book.translate.xml:9727
#, fuzzy
msgid "<function>mpo_relabel_ifnet</function>"
msgstr " <function> mpo_relabel_ifnet </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9730
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_ifnet</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_ifnet </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9769
#, fuzzy
msgid "Object; Network interface"
msgstr "Objeto; interface de rede"

#. (itstool) path: row/entry
#: book.translate.xml:9780
#, fuzzy
msgid "Label update to apply to <parameter>ifnet</parameter>"
msgstr ""
"Atualiza��o de etiqueta para aplicar a <parameter> ifnet </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9787
#, fuzzy
msgid ""
"Update the label of network interface, <parameter>ifnet</parameter>, based "
"on the passed update label, <parameter>newlabel</parameter>, and the passed "
"subject credential, <parameter>cred</parameter>."
msgstr ""
"Atualizar o r�tulo da interface de rede, <parameter> ifnet </parameter> , "
"com base na etiqueta de atualiza��o aprovada, <parameter> newlabel </"
"parameter> e a credencial de assunto passada <parameter> cred </parameter> "

#. (itstool) path: sect4/title
#: book.translate.xml:9794
#, fuzzy
msgid "<function>mpo_update_ipq</function>"
msgstr " <function> mpo_update_ipq </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9797
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_update_ipq</function></funcdef> <paramdef>struct "
"mbuf *<parameter>fragment</parameter></paramdef> <paramdef>struct label "
"*<parameter>fragmentlabel</parameter></paramdef> <paramdef>struct ipq "
"*<parameter>ipq</parameter></paramdef> <paramdef>struct label "
"*<parameter>ipqlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_update_ipq </function></funcdef><paramdef> "
"struct mbuf * <parameter> fragmento </parameter></paramdef><paramdef> label "
"struct * <parameter> fragmento </parameter></paramdef><paramdef> struct ipq "
"* <parameter> ipq </parameter></paramdef><paramdef> label struct * "
"<parameter> ipqlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9831
#, fuzzy
msgid "IP fragment"
msgstr "Fragmento de IP"

#. (itstool) path: row/entry
#: book.translate.xml:9836 book.translate.xml:13976 book.translate.xml:14052
#, fuzzy
msgid "Policy label for <parameter>mbuf</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> mbuf </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9847
#, fuzzy
msgid "Policy label to be updated for <parameter>ipq</parameter>"
msgstr ""
"Etiqueta de pol�tica a ser atualizada para <parameter> ipq </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:9854
#, fuzzy
msgid ""
"Update the label on an IP fragment reassembly queue (<parameter>ipq</"
"parameter>) based on the acceptance of the passed IP fragment mbuf header "
"(<parameter>mbuf</parameter>)."
msgstr ""
"Atualize o r�tulo em uma fila de remontagem de fragmento IP ( <parameter> "
"ipq </parameter> ) com base na aceita��o do cabe�alho mbuf do fragmento IP "
"transmitido ( <parameter> mbuf </parameter> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:9862
#, fuzzy
msgid "Process Labeling Event Operations"
msgstr "Opera��es de eventos de rotulagem de processos"

#. (itstool) path: sect4/title
#: book.translate.xml:9865
#, fuzzy
msgid "<function>mpo_create_cred</function>"
msgstr " <function> mpo_create_cred </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9868
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>parent_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>child_cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_cred </function></funcdef><paramdef> "
"struct ucred * <parameter> parent_cred </parameter></paramdef><paramdef> "
"struct ucred * <parameter> child_cred </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9897
#, fuzzy
msgid "<parameter>parent_cred</parameter>"
msgstr " <parameter> parent_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9898
#, fuzzy
msgid "Parent subject credential"
msgstr "Parent subject credential"

#. (itstool) path: row/entry
#: book.translate.xml:9902
#, fuzzy
msgid "<parameter>child_cred</parameter>"
msgstr " <parameter> child_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9903
#, fuzzy
msgid "Child subject credential"
msgstr "Credencial do sujeito da crian�a"

#. (itstool) path: sect4/para
#: book.translate.xml:9909
#, fuzzy
msgid ""
"Set the label of a newly created subject credential from the passed subject "
"credential. This call will be made when <citerefentry><refentrytitle>crcopy</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> is invoked on a newly "
"created <type>struct ucred</type>. This call should not be confused with a "
"process forking or creation event."
msgstr ""
"Definir o r�tulo de uma credencial de assunto rec�m-criada a partir da "
"credencial de assunto passada. Essa chamada ser� feita quando "
"<citerefentry><refentrytitle> crcopy </refentrytitle><manvolnum> 9 </"
"manvolnum></citerefentry> � invocado em um rec�m-criado <type> structurred </"
"type> . Esta chamada n�o deve ser confundida com um processo de bifurca��o "
"ou evento de cria��o. "

#. (itstool) path: sect4/title
#: book.translate.xml:9917
#, fuzzy
msgid "<function>mpo_execve_transition</function>"
msgstr " <function> mpo_execve_transition </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9920
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_execve_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>new</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_execve_transition </function></"
"funcdef><paramdef> struct ucred * <parameter> velho </parameter></"
"paramdef><paramdef> struct ucred * <parameter> Novo </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:9953 book.translate.xml:10030 book.translate.xml:14434
#, fuzzy
msgid "<parameter>old</parameter>"
msgstr " <parameter> velho </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9954
#, fuzzy
msgid "Existing subject credential"
msgstr "Credencial de assunto existente"

#. (itstool) path: row/entry
#: book.translate.xml:9959 book.translate.xml:14448
#, fuzzy
msgid "<parameter>new</parameter>"
msgstr " <parameter> Novo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:9960
#, fuzzy
msgid "New subject credential to be labeled"
msgstr "Nova credencial de sujeito a ser rotulada"

#. (itstool) path: row/entry
#: book.translate.xml:9965 book.translate.xml:10038
#, fuzzy
msgid "File to execute"
msgstr "Arquivo para executar"

#. (itstool) path: sect4/para
#: book.translate.xml:9977
#, fuzzy
msgid ""
"Update the label of a newly created subject credential (<parameter>new</"
"parameter>) from the passed existing subject credential (<parameter>old</"
"parameter>) based on a label transition caused by executing the passed vnode "
"(<parameter>vp</parameter>). This call occurs when a process executes the "
"passed vnode and one of the policies returns a success from the "
"<function>mpo_execve_will_transition</function> entry point. Policies may "
"choose to implement this call simply by invoking <function>mpo_create_cred</"
"function> and passing the two subject credentials so as not to implement a "
"transitioning event. Policies should not leave this entry point "
"unimplemented if they implement <function>mpo_create_cred</function>, even "
"if they do not implement <function>mpo_execve_will_transition</function>."
msgstr ""
"Atualizar o r�tulo de uma credencial de assunto rec�m-criada ( <parameter> "
"Novo </parameter> ) da credencial de sujeito j� existente ( <parameter> "
"velho </parameter> ) baseado em uma transi��o de r�tulo causada pela "
"execu��o do vnode passado ( <parameter> vp </parameter> ). Essa chamada "
"ocorre quando um processo executa o vnode passado e uma das pol�ticas "
"retorna um sucesso do <function> mpo_execve_will_transition </function> "
"ponto de entrada. As pol�ticas podem optar por implementar essa chamada "
"simplesmente invocando <function> mpo_create_cred </function> e passando as "
"duas credenciais de assunto para n�o implementar um evento de transi��o. As "
"pol�ticas n�o devem deixar este ponto de entrada n�o implementado se "
"implementarem <function> mpo_create_cred </function> , mesmo que eles n�o "
"implementem <function> mpo_execve_will_transition </function> "

#. (itstool) path: sect4/title
#: book.translate.xml:9996
#, fuzzy
msgid "<function>mpo_execve_will_transition</function>"
msgstr " <function> mpo_execve_will_transition </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:9999
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_execve_will_transition</function></funcdef> "
"<paramdef>struct ucred *<parameter>old</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_execve_will_transition </function></"
"funcdef><paramdef> struct ucred * <parameter> velho </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10031
#, fuzzy
msgid ""
"Subject credential prior to <citerefentry><refentrytitle>execve</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Credencial do sujeito antes de <citerefentry><refentrytitle> execve </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect4/para
#: book.translate.xml:10050
#, fuzzy
msgid ""
"Determine whether the policy will want to perform a transition event as a "
"result of the execution of the passed vnode by the passed subject credential."
" Return <returnvalue>1</returnvalue> if a transition is required, "
"<returnvalue>0</returnvalue> if not. Even if a policy returns "
"<returnvalue>0</returnvalue>, it should behave correctly in the presence of "
"an unexpected invocation of <function>mpo_execve_transition</function>, as "
"that call may happen as a result of another policy requesting a transition."
msgstr ""
"Determine se a pol�tica desejar� executar um evento de transi��o como "
"resultado da execu��o do vnode transmitido pela credencial de assunto "
"passada. <returnvalue> 1 </returnvalue> se uma transi��o for necess�ria, "
"<returnvalue> 0 </returnvalue> se n�o. Mesmo que uma pol�tica retorne "
"<returnvalue> 0 </returnvalue> , deve comportar-se corretamente na presen�a "
"de uma invoca��o inesperada de <function> mpo_execve_transition </function> "
", como essa chamada pode acontecer como resultado de outra pol�tica "
"solicitando uma transi��o \""

#. (itstool) path: sect4/title
#: book.translate.xml:10063
#, fuzzy
msgid "<function>mpo_create_proc0</function>"
msgstr " <function> mpo_create_proc0 </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10066
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_proc0</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_proc0 </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10094 book.translate.xml:10136
#, fuzzy
msgid "Subject credential to be filled in"
msgstr "Assunto credencial a ser preenchido"

#. (itstool) path: sect4/para
#: book.translate.xml:10100
#, fuzzy
msgid ""
"Create the subject credential of process 0, the parent of all kernel "
"processes."
msgstr ""
"Crie a credencial do assunto do processo 0, o pai de todos os processos do "
"kernel."

#. (itstool) path: sect4/title
#: book.translate.xml:10105
#, fuzzy
msgid "<function>mpo_create_proc1</function>"
msgstr " <function> mpo_create_proc1 </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10108
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_create_proc1</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_create_proc1 </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect4/para
#: book.translate.xml:10142
#, fuzzy
msgid ""
"Create the subject credential of process 1, the parent of all user processes."
""
msgstr ""
"Crie a credencial do assunto do processo 1, o pai de todos os processos do "
"usu�rio."

#. (itstool) path: sect4/title
#: book.translate.xml:10147
#, fuzzy
msgid "<function>mpo_relabel_cred</function>"
msgstr " <function> mpo_relabel_cred </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10150
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_relabel_cred</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_relabel_cred </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> label "
"struct * <parameter> newlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10185
#, fuzzy
msgid "Label update to apply to <parameter>cred</parameter>"
msgstr "Atualiza��o de etiqueta para aplicar a <parameter> cred </parameter> "

#. (itstool) path: sect4/para
#: book.translate.xml:10192
#, fuzzy
msgid "Update the label on a subject credential from the passed update label."
msgstr ""
"Atualize o r�tulo de uma credencial de assunto da etiqueta de atualiza��o "
"passada."

#. (itstool) path: sect2/title
#: book.translate.xml:10200
#, fuzzy
msgid "Access Control Checks"
msgstr "Verifica��es de controle de acesso"

#. (itstool) path: sect2/para
#: book.translate.xml:10202
#, fuzzy
msgid ""
"Access control entry points permit policy modules to influence access "
"control decisions made by the kernel. Generally, although not always, "
"arguments to an access control entry point will include one or more "
"authorizing credentials, information (possibly including a label) for any "
"other objects involved in the operation. An access control entry point may "
"return 0 to permit the operation, or an <citerefentry><refentrytitle>errno</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> error value. The "
"results of invoking the entry point across various registered policy modules "
"will be composed as follows: if all modules permit the operation to succeed, "
"success will be returned. If one or modules returns a failure, a failure "
"will be returned. If more than one module returns a failure, the errno value "
"to return to the user will be selected using the following precedence, "
"implemented by the <function>error_select()</function> function in "
"<filename>kern_mac.c</filename>:"
msgstr ""
"Pontos de entrada de controle de acesso permitem que m�dulos de pol�tica "
"influenciem decis�es de controle de acesso feitas pelo kernel. Geralmente, "
"embora nem sempre, argumentos para um ponto de entrada de controle de acesso "
"incluir�o uma ou mais credenciais de autoriza��o, informa��es (possivelmente "
"incluindo um r�tulo) para quaisquer outros objetos O ponto de entrada de "
"controle de acesso pode retornar 0 para permitir a opera��o ou "
"<citerefentry><refentrytitle> errno </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> valor de erro. Os resultados de invocar o ponto de "
"entrada em v�rios m�dulos de pol�tica registrados ser�o compostos da "
"seguinte maneira: se todos os m�dulos permitirem que a opera��o seja bem-"
"sucedida, o sucesso ser� retornado. Se um ou os m�dulos retornarem uma "
"falha, uma falha ser� retornada. Se mais de um m�dulo retornar uma falha, o "
"valor de errno a ser retornado ao usu�rio ser� selecionado usando a seguinte "
"preced�ncia, implementada pelo <function> error_select () </function> fun��o "
"em <filename> kern_mac.c </filename> : "

#. (itstool) path: row/entry
#: book.translate.xml:10223
#, fuzzy
msgid "Most precedence"
msgstr "Maior preced�ncia"

#. (itstool) path: row/entry
#: book.translate.xml:10224
#, fuzzy
msgid "<errorcode>EDEADLK</errorcode>"
msgstr " <errorcode> EDEADLK </errorcode> "

#. (itstool) path: row/entry
#: book.translate.xml:10229
#, fuzzy
msgid "<errorcode>EINVAL</errorcode>"
msgstr " <errorcode> escolhido </errorcode> "

#. (itstool) path: row/entry
#: book.translate.xml:10234
#, fuzzy
msgid "<errorcode>ESRCH</errorcode>"
msgstr " <errorcode> ESRCH </errorcode> "

#. (itstool) path: row/entry
#: book.translate.xml:10239
#, fuzzy
msgid "EACCES"
msgstr "EACCES"

#. (itstool) path: row/entry
#: book.translate.xml:10243
#, fuzzy
msgid "Least precedence"
msgstr "Menos preced�ncia"

#. (itstool) path: row/entry
#: book.translate.xml:10244
#, fuzzy
msgid "EPERM"
msgstr "EPERM"

#. (itstool) path: sect2/para
#: book.translate.xml:10250
#, fuzzy
msgid ""
"If none of the error values returned by all modules are listed in the "
"precedence chart then an arbitrarily selected value from the set will be "
"returned. In general, the rules provide precedence to errors in the "
"following order: kernel failures, invalid arguments, object not present, "
"access not permitted, other."
msgstr ""
"Se nenhum dos valores de erro retornados por todos os m�dulos estiverem "
"listados no gr�fico de preced�ncia, um valor selecionado arbitrariamente do "
"conjunto ser� retornado. Em geral, as regras fornecem preced�ncia a erros na "
"seguinte ordem: falhas de kernel, argumentos inv�lidos, objeto n�o presente, "
"acesso n�o permitido, outro \""

#. (itstool) path: sect3/title
#: book.translate.xml:10258
#, fuzzy
msgid "<function>mpo_check_bpfdesc_receive</function>"
msgstr " <function> mpo_check_bpfdesc_receive </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10261
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_bpfdesc_receive</function></funcdef> "
"<paramdef>struct bpf_d *<parameter>bpf_d</parameter></paramdef> "
"<paramdef>struct label *<parameter>bpflabel</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_bpfdesc_receive </function></"
"funcdef><paramdef> struct bpf_d * <parameter> bpf_d </parameter></"
"paramdef><paramdef> label struct * <parameter> bpflabel </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10295
#, fuzzy
msgid "Subject; BPF descriptor"
msgstr "Assunto; descritor BPF"

#. (itstool) path: row/entry
#: book.translate.xml:10300
#, fuzzy
msgid "Policy label for <parameter>bpf_d</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> bpf_d </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10306 book.translate.xml:11425
#, fuzzy
msgid "Object; network interface"
msgstr "Objeto; interface de rede"

#. (itstool) path: sect3/para
#: book.translate.xml:10318
#, fuzzy
msgid ""
"Determine whether the MAC framework should permit datagrams from the passed "
"interface to be delivered to the buffers of the passed BPF descriptor. "
"Return (<returnvalue>0</returnvalue>) for success, or an <varname>errno</"
"varname> value for failure Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatches, <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se o framework MAC deve permitir que os datagramas da interface "
"passada sejam entregues aos buffers do descritor BPF passado. Return ( "
"<returnvalue> 0 </returnvalue> ) para o sucesso, ou um <varname> errno </"
"varname> valor para falha Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidades de r�tulo, <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:10328
#, fuzzy
msgid "<function>mpo_check_kenv_dump</function>"
msgstr " <function> mpo_check_kenv_dump </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10331
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_dump</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_dump </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10365
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve the kernel "
"environment (see <citerefentry><refentrytitle>kenv</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar o ambiente do "
"kernel (veja <citerefentry><refentrytitle> kenv </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:10370
#, fuzzy
msgid "<function>mpo_check_kenv_get</function>"
msgstr " <function> mpo_check_kenv_get </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10373
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_get</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_get </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres "
"* <parameter> nome </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10406 book.translate.xml:10455 book.translate.xml:10503
#: book.translate.xml:12382 book.translate.xml:13424 book.translate.xml:14425
#, fuzzy
msgid "<parameter>name</parameter>"
msgstr " <parameter> nome </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10407 book.translate.xml:10456 book.translate.xml:10504
#, fuzzy
msgid "Kernel environment variable name"
msgstr "Nome da vari�vel de ambiente do kernel"

#. (itstool) path: sect3/para
#: book.translate.xml:10413
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve the value of the "
"specified kernel environment variable."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar o valor da vari�vel "
"de ambiente do kernel especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:10419
#, fuzzy
msgid "<function>mpo_check_kenv_set</function>"
msgstr " <function> mpo_check_kenv_set </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10422
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_set</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_set </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> Caracteres "
"* <parameter> nome </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10462
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to set the specified kernel "
"environment variable."
msgstr ""
"Determine se o assunto deve ter permiss�o para definir a vari�vel de "
"ambiente do kernel especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:10467
#, fuzzy
msgid "<function>mpo_check_kenv_unset</function>"
msgstr " <function> mpo_check_kenv_unset </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10470
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kenv_unset</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>char *<parameter>name</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kenv_unset </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> Caracteres * <parameter> nome </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10510
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to unset the specified "
"kernel environment variable."
msgstr ""
"Determine se o assunto deve ter permiss�o para desfazer a vari�vel de "
"ambiente do kernel especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:10515
#, fuzzy
msgid "<function>mpo_check_kld_load</function>"
msgstr " <function> mpo_check_kld_load </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10518
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_load</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_load </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef><paramdef> struct "
"vnode * <parameter> vp </parameter></paramdef><paramdef> label struct * "
"<parameter> vlabel </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10555
#, fuzzy
msgid "Kernel module vnode"
msgstr "M�dulo do kernel vnode"

#. (itstool) path: row/entry
#: book.translate.xml:10560 book.translate.xml:14179 book.translate.xml:14370
#, fuzzy
msgid "Label associated with <parameter>vp</parameter>"
msgstr "Etiqueta associada a <parameter> vp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:10567
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to load the specified module "
"file."
msgstr ""
"Determine se o assunto deve ter permiss�o para carregar o arquivo do m�dulo "
"especificado."

#. (itstool) path: sect3/title
#: book.translate.xml:10572
#, fuzzy
msgid "<function>mpo_check_kld_stat</function>"
msgstr " <function> mpo_check_kld_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10575
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_stat </function></funcdef><paramdef> "
"struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10609
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve a list of loaded "
"kernel module files and associated statistics."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar uma lista de "
"arquivos do m�dulo do kernel carregados e estat�sticas associadas."

#. (itstool) path: sect3/title
#: book.translate.xml:10615
#, fuzzy
msgid "<function>mpo_check_kld_unload</function>"
msgstr " <function> mpo_check_kld_unload </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10618
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_kld_unload</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_kld_unload </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10652
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to unload a kernel module."
msgstr ""
"Determine se o assunto deve ter permiss�o para descarregar um m�dulo do "
"kernel."

#. (itstool) path: sect3/title
#: book.translate.xml:10657
#, fuzzy
msgid "<function>mpo_check_pipe_ioctl</function>"
msgstr " <function> mpo_check_pipe_ioctl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10660
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_ioctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>unsigned long <parameter>cmd</parameter></paramdef> <paramdef>void "
"*<parameter>data</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_ioctl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef><paramdef> sem assinatura longa <parameter> cmd </parameter></"
"paramdef><paramdef> void * <parameter> dados </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10710
#, fuzzy
msgid "<parameter>cmd</parameter>"
msgstr " <parameter> cmd </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10711
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> command"
msgstr ""
" <citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> comando"

#. (itstool) path: row/entry
#: book.translate.xml:10715
#, fuzzy
msgid "<parameter>data</parameter>"
msgstr " <parameter> dados </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:10716
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> data"
msgstr ""
" <citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> dados"

#. (itstool) path: sect3/para
#: book.translate.xml:10722
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>ioctl</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> call."
msgstr ""
"Determinar se o assunto deve ter permiss�o para fazer o especificado "
"<citerefentry><refentrytitle> ioctl </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> ligar."

#. (itstool) path: sect3/title
#: book.translate.xml:10727
#, fuzzy
msgid "<function>mpo_check_pipe_poll</function>"
msgstr " <function> mpo_check_pipe_poll </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10730
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_poll </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10779
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to poll <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para pesquisar <parameter> tubo </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10784
#, fuzzy
msgid "<function>mpo_check_pipe_read</function>"
msgstr " <function> mpo_check_pipe_read </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10787
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_read</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_read </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10836
#, fuzzy
msgid ""
"Determine whether the subject should be allowed read access to "
"<parameter>pipe</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o de acesso de leitura a <parameter> "
"tubo </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10841
#, fuzzy
msgid "<function>mpo_check_pipe_relabel</function>"
msgstr " <function> mpo_check_pipe_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10844
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:10894
#, fuzzy
msgid "Label update to <parameter>pipelabel</parameter>"
msgstr "Atualiza��o de etiqueta para <parameter> pipelabel </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:10901
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to relabel <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ser autorizado a reclassificar <parameter> tubo "
"</parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10906
#, fuzzy
msgid "<function>mpo_check_pipe_stat</function>"
msgstr " <function> mpo_check_pipe_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10909
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_stat </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:10958
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to retrieve statistics "
"related to <parameter>pipe</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para recuperar estat�sticas "
"relacionadas a <parameter> tubo </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:10964
#, fuzzy
msgid "<function>mpo_check_pipe_write</function>"
msgstr " <function> mpo_check_pipe_write </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:10967
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_pipe_write</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct pipe *<parameter>pipe</parameter></paramdef> "
"<paramdef>struct label *<parameter>pipelabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_pipe_write </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> pipe de estrutura * <parameter> tubo </parameter></"
"paramdef><paramdef> label struct * <parameter> pipelabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:11016
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to write to <parameter>pipe</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para escrever <parameter> tubo </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11021
#, fuzzy
msgid "<function>mpo_check_socket_bind</function>"
msgstr " <function> mpo_check_socket_bind </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11024
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_bind</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_bind </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct sockaddr * <parameter> sockaddr </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11063
#, fuzzy
msgid "Socket to be bound"
msgstr "Soquete a ser ligado"

#. (itstool) path: row/entry
#: book.translate.xml:11073 book.translate.xml:11135
#, fuzzy
msgid "<parameter>sockaddr</parameter>"
msgstr " <parameter> sockaddr </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11074 book.translate.xml:11136
#, fuzzy
msgid "Address of <parameter>socket</parameter>"
msgstr "Endere�o de <parameter> soquete </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11083
#, fuzzy
msgid "<function>mpo_check_socket_connect</function>"
msgstr " <function> mpo_check_socket_connect </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11086
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_connect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct sockaddr *<parameter>sockaddr</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_connect </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> struct sockaddr * <parameter> sockaddr </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11125
#, fuzzy
msgid "Socket to be connected"
msgstr "Soquete para ser conectado"

#. (itstool) path: sect3/para
#: book.translate.xml:11143
#, fuzzy
msgid ""
"Determine whether the subject credential (<parameter>cred</parameter>) can "
"connect the passed socket (<parameter>socket</parameter>) to the passed "
"socket address (<parameter>sockaddr</parameter>). Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatches, "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do sujeito ( <parameter> cred </parameter> ) pode "
"conectar o soquete passado ( <parameter> soquete </parameter> ) para o "
"endere�o de socket passado ( <parameter> sockaddr </parameter> ). Retorna "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidades de r�tulo, <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:11154
#, fuzzy
msgid "<function>mpo_check_socket_receive</function>"
msgstr " <function> mpo_check_socket_receive </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11157
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_receive</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_receive </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11199 book.translate.xml:11257
#, fuzzy
msgid "Policy label associated with <parameter>so</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> assim </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11206
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to receive information from "
"the socket <parameter>so</parameter>."
msgstr ""
"Determinar se o assunto deve receber permiss�o de receber informa��es do "
"soquete <parameter> assim </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11212
#, fuzzy
msgid "<function>mpo_check_socket_send</function>"
msgstr " <function> mpo_check_socket_send </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11215
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_send</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_send </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:11264
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to send information across "
"the socket <parameter>so</parameter>."
msgstr ""
"Determinar se o assunto deve ter permiss�o para enviar informa��es atrav�s "
"do soquete <parameter> assim </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:11270
#, fuzzy
msgid "<function>mpo_check_cred_visible</function>"
msgstr " <function> mpo_check_cred_visible </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11273
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_cred_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>u1</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>u2</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_cred_visible </function></"
"funcdef><paramdef> struct ucred * <parameter> u1 </parameter></"
"paramdef><paramdef> struct ucred * <parameter> u2 </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11302
#, fuzzy
msgid "<parameter>u1</parameter>"
msgstr " <parameter> u1 </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11307
#, fuzzy
msgid "<parameter>u2</parameter>"
msgstr " <parameter> u2 </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11308
#, fuzzy
msgid "Object credential"
msgstr "Credencial do objeto"

#. (itstool) path: sect3/para
#: book.translate.xml:11314
#, fuzzy
msgid ""
"Determine whether the subject credential <parameter>u1</parameter> can "
"<quote>see</quote> other subjects with the passed subject credential "
"<parameter>u2</parameter>. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to hide "
"visibility. This call may be made in a number of situations, including inter-"
"process status sysctl's used by <command>ps</command>, and in procfs lookups."
""
msgstr ""
"Determinar se a credencial do sujeito <parameter> u1 </parameter> posso "
"<quote> Vejo </quote> outros assuntos com a credencial do sujeito passado "
"<parameter> u2 </parameter> . Retorna <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidades de r�tulo, "
"<errorcode> EPERM </errorcode> por falta de privil�gio, ou <errorcode> ESRCH "
"</errorcode> para esconder a visibilidade. Essa chamada pode ser feita em "
"v�rias situa��es, incluindo sysctl de status entre processos usado por "
"<command> ps </command> e em pesquisas procfs \""

#. (itstool) path: sect3/title
#: book.translate.xml:11329 book.translate.xml:14069
#, fuzzy
msgid "<function>mpo_check_socket_visible</function>"
msgstr " <function> mpo_check_socket_visible </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11332
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_visible </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/title
#: book.translate.xml:11383
#, fuzzy
msgid "<function>mpo_check_ifnet_relabel</function>"
msgstr " <function> mpo_check_ifnet_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11386
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_ifnet_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_ifnet_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11430
#, fuzzy
msgid "Existing policy label for <parameter>ifnet</parameter>"
msgstr "Etiqueta de pol�tica existente para <parameter> ifnet </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11436
#, fuzzy
msgid ""
"Policy label update to later be applied to <parameter>ifnet</parameter>"
msgstr ""
"Atualiza��o de r�tulo de pol�tica para depois ser aplicada a <parameter> "
"ifnet </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11443
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed network "
"interface to the passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar a interface de rede "
"passada para a atualiza��o de r�tulo passada."

#. (itstool) path: sect3/title
#: book.translate.xml:11448
#, fuzzy
msgid "<function>mpo_check_socket_relabel</function>"
msgstr " <function> mpo_check_socket_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11451
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11495
#, fuzzy
msgid "Existing policy label for <parameter>socket</parameter>"
msgstr "Etiqueta de pol�tica existente para <parameter> soquete </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11501
#, fuzzy
msgid "Label update to later be applied to <parameter>socketlabel</parameter>"
msgstr ""
"Atualiza��o de etiqueta para depois ser aplicada a <parameter> socketlabel </"
"parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11508
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed socket to "
"the passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar o soquete "
"transmitido para a atualiza��o de r�tulo transmitida."

#. (itstool) path: sect3/title
#: book.translate.xml:11513
#, fuzzy
msgid "<function>mpo_check_cred_relabel</function>"
msgstr " <function> mpo_check_cred_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11516
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_cred_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_cred_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11551
#, fuzzy
msgid "Label update to later be applied to <parameter>cred</parameter>"
msgstr ""
"Atualiza��o de etiqueta para depois ser aplicada a <parameter> cred </"
"parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11558
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel itself to the passed "
"label update."
msgstr ""
"Determine se a credencial do assunto pode se renomear para a atualiza��o de "
"r�tulo passada."

#. (itstool) path: sect3/title
#: book.translate.xml:11564
#, fuzzy
msgid "<function>mpo_check_vnode_relabel</function>"
msgstr " <function> mpo_check_vnode_relabel </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11567
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_relabel</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vnodelabel</parameter></paramdef> "
"<paramdef>struct label *<parameter>newlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_relabel </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vnodelabel </parameter></"
"paramdef><paramdef> label struct * <parameter> newlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11607 book.translate.xml:11797 book.translate.xml:11991
#: book.translate.xml:12161 book.translate.xml:12294 book.translate.xml:12367
#: book.translate.xml:13006 book.translate.xml:13074 book.translate.xml:13199
#: book.translate.xml:13265 book.translate.xml:13331 book.translate.xml:13409
#: book.translate.xml:13495 book.translate.xml:13563 book.translate.xml:13632
#: book.translate.xml:13892
#, fuzzy
msgid "Object; vnode"
msgstr "Objeto; vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11619
#, fuzzy
msgid "Policy label update to later be applied to <parameter>vp</parameter>"
msgstr ""
"Atualiza��o de r�tulo de pol�tica para depois ser aplicada a <parameter> vp "
"</parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11626
#, fuzzy
msgid ""
"Determine whether the subject credential can relabel the passed vnode to the "
"passed label update."
msgstr ""
"Determine se a credencial do assunto pode reclassificar o vnode transmitido "
"para a atualiza��o de r�tulo transmitida."

#. (itstool) path: sect3/title
#: book.translate.xml:11631
#, fuzzy
msgid "<function>mpo_check_mount_stat</function>"
msgstr " <function> mpo_check_mount_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11634
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_mount_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct mount *<parameter>mp</parameter></paramdef> "
"<paramdef>struct label *<parameter>mountlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_mount_stat </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> montagem struct * <parameter> mp </parameter></"
"paramdef><paramdef> label struct * <parameter> mountlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11671
#, fuzzy
msgid "Object; file system mount"
msgstr "Objeto; montagem do sistema de arquivos"

#. (itstool) path: row/entry
#: book.translate.xml:11675
#, fuzzy
msgid "<parameter>mountlabel</parameter>"
msgstr " <parameter> mountlabel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11676
#, fuzzy
msgid "Policy label for <parameter>mp</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> mp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11684
#, fuzzy
msgid ""
"Determine whether the subject credential can see the results of a statfs "
"performed on the file system. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure:"
" <errorcode>EACCES</errorcode> for label mismatches or <errorcode>EPERM</"
"errorcode> for lack of privilege. This call may be made in a number of "
"situations, including during invocations of "
"<citerefentry><refentrytitle>statfs</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and related calls, as well as to determine what file systems "
"to exclude from listings of file systems, such as when "
"<citerefentry><refentrytitle>getfsstat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> is invoked."
msgstr ""
"Determine se a credencial do assunto pode ver os resultados de um statfs "
"executado no sistema de arquivos. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidades de r�tulo ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio. Essa chamada pode "
"ser feita em v�rias situa��es, inclusive durante invoca��es de "
"<citerefentry><refentrytitle> statfs </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> e chamadas relacionadas, bem como para determinar "
"quais sistemas de arquivos devem ser exclu�dos das listagens de sistemas de "
"arquivos, como quando <citerefentry><refentrytitle> getfsstat </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> � invocado. "

#. (itstool) path: sect3/title
#: book.translate.xml:11698
#, fuzzy
msgid "<function>mpo_check_proc_debug</function>"
msgstr " <function> mpo_check_proc_debug </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11701
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_debug</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_debug </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct proc * <parameter> proc </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11736 book.translate.xml:13773 book.translate.xml:13830
#, fuzzy
msgid "<parameter>proc</parameter>"
msgstr " <parameter> por cento </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11737 book.translate.xml:13774 book.translate.xml:13831
#, fuzzy
msgid "Object; process"
msgstr "Objeto; processo"

#. (itstool) path: sect3/para
#: book.translate.xml:11743
#, fuzzy
msgid ""
"Determine whether the subject credential can debug the passed process. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, <errorcode>EPERM</errorcode> for lack of privilege, or "
"<errorcode>ESRCH</errorcode> to hide visibility of the target. This call may "
"be made in a number of situations, including use of the "
"<citerefentry><refentrytitle>ptrace</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>ktrace</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> APIs, as well as for "
"some types of procfs operations."
msgstr ""
"Determine se a credencial do assunto pode depurar o processo passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, <errorcode> EPERM </"
"errorcode> por falta de privil�gio, ou <errorcode> ESRCH </errorcode> para "
"ocultar a visibilidade do alvo. Esta chamada pode ser feita em v�rias "
"situa��es, incluindo o uso do <citerefentry><refentrytitle> ptrace </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> ktrace </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> APIs, bem como para alguns tipos de opera��es "
"procfs \""

#. (itstool) path: sect3/title
#: book.translate.xml:11756
#, fuzzy
msgid "<function>mpo_check_vnode_access</function>"
msgstr " <function> mpo_check_vnode_access </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11759
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_access</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>flags</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_access </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> bandeiras </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11807 book.translate.xml:13505
#, fuzzy
msgid "<parameter>flags</parameter>"
msgstr " <parameter> bandeiras </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:11808
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>access</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> flags"
msgstr ""
" <citerefentry><refentrytitle> Acesso </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> bandeiras"

#. (itstool) path: sect3/para
#: book.translate.xml:11814
#, fuzzy
msgid ""
"Determine how invocations of <citerefentry><refentrytitle>access</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> and related calls by "
"the subject credential should return when performed on the passed vnode "
"using the passed access flags. This should generally be implemented using "
"the same semantics used in <function>mpo_check_vnode_open</function>. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatches or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determinar como invoca��es de <citerefentry><refentrytitle> Acesso </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> e chamadas "
"relacionadas pela credencial de assunto devem retornar quando executadas no "
"vnode passado usando os sinalizadores de acesso passado. Isso geralmente "
"deve ser implementado usando a mesma sem�ntica usada <function> "
"mpo_check_vnode_open </function> . Retorna <returnvalue> 0 </returnvalue> "
"para o sucesso, ou um <varname> errno </varname> valor para falha. Falha "
"sugerida: <errorcode> EACCES </errorcode> para incompatibilidades de r�tulo "
"ou <errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:11827
#, fuzzy
msgid "<function>mpo_check_vnode_chdir</function>"
msgstr " <function> mpo_check_vnode_chdir </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11830
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_chdir</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_chdir </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11867
#, fuzzy
msgid ""
"Object; vnode to <citerefentry><refentrytitle>chdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry> into"
msgstr ""
"Objeto; vnode para <citerefentry><refentrytitle> chdir </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> para dentro"

#. (itstool) path: row/entry
#: book.translate.xml:11872 book.translate.xml:11996 book.translate.xml:12078
#: book.translate.xml:13011 book.translate.xml:13142
#, fuzzy
msgid "Policy label for <parameter>dvp</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> dvp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11879
#, fuzzy
msgid ""
"Determine whether the subject credential can change the process working "
"directory to the passed vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure:"
" <errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode alterar o diret�rio de trabalho do "
"processo para o vnode passado. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:11889
#, fuzzy
msgid "<function>mpo_check_vnode_chroot</function>"
msgstr " <function> mpo_check_vnode_chroot </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11892
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_chroot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_chroot </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:11929 book.translate.xml:12453 book.translate.xml:12781
#: book.translate.xml:12863
#, fuzzy
msgid "Directory vnode"
msgstr "Diret�rio vnode"

#. (itstool) path: row/entry
#: book.translate.xml:11934 book.translate.xml:12458 book.translate.xml:12786
#: book.translate.xml:12868
#, fuzzy
msgid "Policy label associated with <parameter>dvp</parameter>"
msgstr "Etiqueta de pol�tica associada a <parameter> dvp </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:11941
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to "
"<citerefentry><refentrytitle>chroot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> into the specified directory (<parameter>dvp</parameter>)."
msgstr ""
"Determinar se o assunto deve ser permitido <citerefentry><refentrytitle> "
"chroot </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> no "
"diret�rio especificado ( <parameter> dvp </parameter> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:11947
#, fuzzy
msgid "<function>mpo_check_vnode_create</function>"
msgstr " <function> mpo_check_vnode_create </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:11950
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_create</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef> "
"<paramdef>struct vattr *<parameter>vap</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_create </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef><paramdef> struct vattr * <parameter> vap </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12002
#, fuzzy
msgid "Component name for <parameter>dvp</parameter>"
msgstr "Nome do componente para <parameter> dvp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12007
#, fuzzy
msgid "<parameter>vap</parameter>"
msgstr " <parameter> vap </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12008
#, fuzzy
msgid "vnode attributes for <parameter>vap</parameter>"
msgstr "atributos vnode para <parameter> vap </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:12015
#, fuzzy
msgid ""
"Determine whether the subject credential can create a vnode with the passed "
"parent directory, passed name information, and passed attribute information. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege. "
"This call may be made in a number of situations, including as a result of "
"calls to <citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> with <symbol>O_CREAT</symbol>, "
"<citerefentry><refentrytitle>mkfifo</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>, and others."
msgstr ""
"Determine se a credencial de assunto pode criar um vnode com o diret�rio pai "
"passado, informa��es de nome passadas e informa��es de atributo transmitidas."
" <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privil�gio. Esta chamada pode ser feita em v�rias situa��es, "
"inclusive como resultado de chamadas para <citerefentry><refentrytitle> "
"aberto </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> com "
"<symbol> O_CREAT </symbol> , <citerefentry><refentrytitle> mkfifo </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> , e outros."

#. (itstool) path: sect3/title
#: book.translate.xml:12028
#, fuzzy
msgid "<function>mpo_check_vnode_delete</function>"
msgstr " <function> mpo_check_vnode_delete </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12031
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_delete</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> <paramdef>void "
"*<parameter>label</parameter></paramdef> <paramdef>struct componentname "
"*<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_delete </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> void * <parameter> r�tulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12084
#, fuzzy
msgid "Object; vnode to delete"
msgstr "Objeto; vnode para excluir"

#. (itstool) path: sect3/para
#: book.translate.xml:12102
#, fuzzy
msgid ""
"Determine whether the subject credential can delete a vnode from the passed "
"parent directory and passed name information. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including as a result of calls to "
"<citerefentry><refentrytitle>unlink</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> and <citerefentry><refentrytitle>rmdir</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>. Policies implementing "
"this entry point should also implement <function>mpo_check_rename_to</"
"function> to authorize deletion of objects as a result of being the target "
"of a rename."
msgstr ""
"Determine se a credencial do assunto pode excluir um vnode do diret�rio pai "
"passado e passou as informa��es de nome. <returnvalue> 0 </returnvalue> para "
"o sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida:"
" <errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio. Esta chamada pode "
"ser feita em v�rias situa��es, inclusive como resultado de chamadas para "
"<citerefentry><refentrytitle> desvincular </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> rmdir </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> . Pol�ticas que "
"implementam este ponto de entrada tamb�m devem implementar <function> "
"mpo_check_rename_to </function> para autorizar a exclus�o de objetos como "
"resultado de ser o alvo de uma renomea��o. "

#. (itstool) path: sect3/title
#: book.translate.xml:12118
#, fuzzy
msgid "<function>mpo_check_vnode_deleteacl</function>"
msgstr " <function> mpo_check_vnode_deleteacl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12121
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_deleteacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_deleteacl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> acl_type_t <parameter> tipo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12172 book.translate.xml:12304 book.translate.xml:13341
#, fuzzy
msgid "<parameter>type</parameter>"
msgstr " <parameter> tipo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12173 book.translate.xml:12305 book.translate.xml:13342
#, fuzzy
msgid "ACL type"
msgstr "Tipo de ACL"

#. (itstool) path: sect3/para
#: book.translate.xml:12179
#, fuzzy
msgid ""
"Determine whether the subject credential can delete the ACL of passed type "
"from the passed vnode. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode excluir a ACL do tipo passado do "
"vnode passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12189
#, fuzzy
msgid "<function>mpo_check_vnode_exec</function>"
msgstr " <function> mpo_check_vnode_exec </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12192
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_exec</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_exec </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12229
#, fuzzy
msgid "Object; vnode to execute"
msgstr "Objeto; vnode para executar"

#. (itstool) path: sect3/para
#: book.translate.xml:12241
#, fuzzy
msgid ""
"Determine whether the subject credential can execute the passed vnode. "
"Determination of execute privilege is made separately from decisions about "
"any transitioning event. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar o vnode passado. A "
"determina��o do privil�gio de execu��o � feita separadamente das decis�es "
"sobre qualquer evento de transi��o. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12252
#, fuzzy
msgid "<function>mpo_check_vnode_getacl</function>"
msgstr " <function> mpo_check_vnode_getacl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12255
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_getacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_getacl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> acl_type_t <parameter> tipo </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:12311
#, fuzzy
msgid ""
"Determine whether the subject credential can retrieve the ACL of passed type "
"from the passed vnode. Return <returnvalue>0</returnvalue> for success, or "
"an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode recuperar a ACL do tipo passado do "
"vnode passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12321
#, fuzzy
msgid "<function>mpo_check_vnode_getextattr</function>"
msgstr " <function> mpo_check_vnode_getextattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12324
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_getextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_getextattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> attrnamespace </parameter></"
"paramdef><paramdef> const char * <parameter> nome </parameter></"
"paramdef><paramdef> struct uio * <parameter> uio </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12377 book.translate.xml:13419
#, fuzzy
msgid "<parameter>attrnamespace</parameter>"
msgstr " <parameter> attrnamespace </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12378 book.translate.xml:13420
#, fuzzy
msgid "Extended attribute namespace"
msgstr "Namespace de atributo estendido"

#. (itstool) path: row/entry
#: book.translate.xml:12383 book.translate.xml:13425
#, fuzzy
msgid "Extended attribute name"
msgstr "Nome do atributo estendido"

#. (itstool) path: row/entry
#: book.translate.xml:12387 book.translate.xml:13429
#, fuzzy
msgid "<parameter>uio</parameter>"
msgstr " <parameter> uio </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12388 book.translate.xml:13430
#, fuzzy
msgid ""
"I/O structure pointer; see <citerefentry><refentrytitle>uio</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
"Ponteiro de estrutura de E / S; consulte <citerefentry><refentrytitle> uio </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:12394
#, fuzzy
msgid ""
"Determine whether the subject credential can retrieve the extended attribute "
"with the passed namespace and name from the passed vnode. Policies "
"implementing labeling using extended attributes may be interested in special "
"handling of operations on those extended attributes. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode recuperar o atributo estendido com "
"o namespace passado e o nome do vnode transmitido. As pol�ticas que "
"implementam a rotulagem usando atributos estendidos podem estar interessadas "
"no tratamento especial de opera��es nesses atributos estendidos. Voltar para "
"o in�cio <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12407
#, fuzzy
msgid "<function>mpo_check_vnode_link</function>"
msgstr " <function> mpo_check_vnode_link </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12410
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_link</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_link </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12464
#, fuzzy
msgid "Link destination vnode"
msgstr "Link destino vnode"

#. (itstool) path: row/entry
#: book.translate.xml:12475
#, fuzzy
msgid "Component name for the link being created"
msgstr "Nome do componente para o link que est� sendo criado"

#. (itstool) path: sect3/para
#: book.translate.xml:12482
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to create a link to the "
"vnode <parameter>vp</parameter> with the name specified by <parameter>cnp</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para criar um link para o vnode "
"<parameter> vp </parameter> com o nome especificado por <parameter> cnp </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12488
#, fuzzy
msgid "<function>mpo_check_vnode_mmap</function>"
msgstr " <function> mpo_check_vnode_mmap </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12491
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_mmap</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_mmap </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> prot </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12529
#, fuzzy
msgid "Vnode to map"
msgstr "Vnode para mapear"

#. (itstool) path: row/entry
#: book.translate.xml:12539 book.translate.xml:12600 book.translate.xml:12657
#, fuzzy
msgid "<parameter>prot</parameter>"
msgstr " <parameter> prot </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12540
#, fuzzy
msgid ""
"Mmap protections (see <citerefentry><refentrytitle>mmap</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>)"
msgstr ""
"Prote��es Mmap (veja <citerefentry><refentrytitle> mmap </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> ) "

#. (itstool) path: sect3/para
#: book.translate.xml:12546
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to map the vnode "
"<parameter>vp</parameter> with the protections specified in <parameter>prot</"
"parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para mapear o vnode <parameter> vp "
"</parameter> com as prote��es especificadas em <parameter> prot </parameter> "
""

#. (itstool) path: sect3/title
#: book.translate.xml:12552
#, fuzzy
msgid "<function>mpo_check_vnode_mmap_downgrade</function>"
msgstr " <function> mpo_check_vnode_mmap_downgrade </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12555
#, fuzzy
msgid ""
"<funcdef>void <function>mpo_check_vnode_mmap_downgrade</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int *<parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> vazio <function> mpo_check_vnode_mmap_downgrade </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int * <parameter> prot </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12588
#, fuzzy
msgid "See <xref linkend=\"mac-mpo-check-vnode-mmap\"/>."
msgstr "Vejo <xref linkend=\"mac-mpo-check-vnode-mmap\"/> "

#. (itstool) path: row/entry
#: book.translate.xml:12601
#, fuzzy
msgid "Mmap protections to be downgraded"
msgstr "Prote��es Mmap a serem desatualizadas"

#. (itstool) path: sect3/para
#: book.translate.xml:12607
#, fuzzy
msgid "Downgrade the mmap protections based on the subject and object labels."
msgstr ""
"Fa�a o downgrade das prote��es mmap com base nos r�tulos de assunto e objeto."
""

#. (itstool) path: sect3/title
#: book.translate.xml:12612
#, fuzzy
msgid "<function>mpo_check_vnode_mprotect</function>"
msgstr " <function> mpo_check_vnode_mprotect </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12615
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_mprotect</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>prot</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_mprotect </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> prot </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12653
#, fuzzy
msgid "Mapped vnode"
msgstr "Vnode mapeado"

#. (itstool) path: row/entry
#: book.translate.xml:12658
#, fuzzy
msgid "Memory protections"
msgstr "Prote��es de mem�ria"

#. (itstool) path: sect3/para
#: book.translate.xml:12664
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to set the specified memory "
"protections on memory mapped from the vnode <parameter>vp</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para definir as prote��es de "
"mem�ria especificadas na mem�ria mapeada a partir do vnode <parameter> vp </"
"parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12670
#, fuzzy
msgid "<function>mpo_check_vnode_poll</function>"
msgstr " <function> mpo_check_vnode_poll </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12673
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_poll</function></funcdef> "
"<paramdef>struct ucred *<parameter>active_cred</parameter></paramdef> "
"<paramdef>struct ucred *<parameter>file_cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_poll </function></"
"funcdef><paramdef> struct ucred * <parameter> active_cred </parameter></"
"paramdef><paramdef> struct ucred * <parameter> file_cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12706
#, fuzzy
msgid "<parameter>active_cred</parameter>"
msgstr " <parameter> active_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12711
#, fuzzy
msgid "<parameter>file_cred</parameter>"
msgstr " <parameter> file_cred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12712
#, fuzzy
msgid "Credential associated with the <type>struct file</type>"
msgstr "Credencial associado ao <type> arquivo struct </type> "

#. (itstool) path: row/entry
#: book.translate.xml:12718
#, fuzzy
msgid "Polled vnode"
msgstr "Polled vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:12730
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to poll the vnode "
"<parameter>vp</parameter>."
msgstr ""
"Determine se o assunto deve ter permiss�o para pesquisar o vnode <parameter> "
"vp </parameter> "

#. (itstool) path: sect3/title
#: book.translate.xml:12735
#, fuzzy
msgid "<function>mpo_check_vnode_rename_from</function>"
msgstr " <function> mpo_check_vnode_rename_from </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12738
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_vnode_rename_from</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>struct componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_vnode_rename_from </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12792
#, fuzzy
msgid "Vnode to be renamed"
msgstr "Vnode a ser renomeado"

#. (itstool) path: sect3/para
#: book.translate.xml:12810
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to rename the vnode "
"<parameter>vp</parameter> to something else."
msgstr ""
"Determinar se o assunto deve ter permiss�o para renomear o vnode <parameter> "
"vp </parameter> para outra coisa \""

#. (itstool) path: sect3/title
#: book.translate.xml:12816
#, fuzzy
msgid "<function>mpo_check_vnode_rename_to</function>"
msgstr " <function> mpo_check_vnode_rename_to </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12819
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_rename_to</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>dvp</parameter></paramdef> "
"<paramdef>struct label *<parameter>dlabel</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>samedir</parameter></paramdef> <paramdef>struct "
"componentname *<parameter>cnp</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_rename_to </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> dvp </parameter></"
"paramdef><paramdef> label struct * <parameter> dlabel </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> samedir </parameter></"
"paramdef><paramdef> struct componentname * <parameter> cnp </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:12874
#, fuzzy
msgid "Overwritten vnode"
msgstr "Vnode sobrescrito"

#. (itstool) path: row/entry
#: book.translate.xml:12884
#, fuzzy
msgid "<parameter>samedir</parameter>"
msgstr " <parameter> samedir </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:12885
#, fuzzy
msgid ""
"Boolean; <literal>1</literal> if the source and destination directories are "
"the same"
msgstr ""
"Boleano; <literal> 1 </literal> se os diret�rios de origem e destino forem "
"os mesmos "

#. (itstool) path: row/entry
#: book.translate.xml:12891
#, fuzzy
msgid "Destination component name"
msgstr "Nome do componente de destino"

#. (itstool) path: sect3/para
#: book.translate.xml:12897
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to rename to the vnode "
"<parameter>vp</parameter>, into the directory <parameter>dvp</parameter>, or "
"to the name represented by <parameter>cnp</parameter>. If there is no "
"existing file to overwrite, <parameter>vp</parameter> and <parameter>label</"
"parameter> will be NULL."
msgstr ""
"Determinar se o assunto deve ter permiss�o para renomear para o vnode "
"<parameter> vp </parameter> , no diret�rio <parameter> dvp </parameter> , ou "
"para o nome representado por <parameter> cnp </parameter> . Se n�o houver "
"nenhum arquivo existente para substituir, <parameter> vp </parameter> e "
"<parameter> r�tulo </parameter> ser� NULL. "

#. (itstool) path: sect3/title
#: book.translate.xml:12906
#, fuzzy
msgid "<function>mpo_check_socket_listen</function>"
msgstr " <function> mpo_check_socket_listen </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12909
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_listen</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>socket</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_listen </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> soquete </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:12958
#, fuzzy
msgid ""
"Determine whether the subject credential can listen on the passed socket. "
"Return <returnvalue>0</returnvalue> for success, or an <varname>errno</"
"varname> value for failure. Suggested failure: <errorcode>EACCES</errorcode> "
"for label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode escutar no soquete passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:12967
#, fuzzy
msgid "<function>mpo_check_vnode_lookup</function>"
msgstr " <function> mpo_check_vnode_lookup </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:12970
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_lookup</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef> <paramdef>struct componentname *<parameter>cnp</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_lookup </function></"
"funcdef><paramdef> struct ucred * <parameter/> cred </paramdef><paramdef> "
"struct vnode * <parameter/> dvp </paramdef><paramdef> label struct * "
"<parameter/> dlabel </paramdef><paramdef> struct componentname * <parameter> "
"cnp </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13017
#, fuzzy
msgid "Component name being looked up"
msgstr "Nome do componente sendo pesquisado"

#. (itstool) path: sect3/para
#: book.translate.xml:13023
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a lookup in the passed "
"directory vnode for the passed name. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure:"
" <errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma pesquisa no diret�rio "
"passado vnode para o nome passado. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13033
#, fuzzy
msgid "<function>mpo_check_vnode_open</function>"
msgstr " <function> mpo_check_vnode_open </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13036
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_open</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>acc_mode</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_open </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> acc_mode </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13084
#, fuzzy
msgid "<parameter>acc_mode</parameter>"
msgstr " <parameter> acc_mode </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13085
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>open</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> access mode"
msgstr ""
" <citerefentry><refentrytitle> aberto </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> modo de acesso"

#. (itstool) path: sect3/para
#: book.translate.xml:13091
#, fuzzy
msgid ""
"Determine whether the subject credential can perform an open operation on "
"the passed vnode with the passed access mode. Return <returnvalue>0</"
"returnvalue> for success, or an errno value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma opera��o aberta no "
"vnode passado com o modo de acesso passado. <returnvalue> 0 </returnvalue> "
"para o sucesso, ou um valor errno para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13100
#, fuzzy
msgid "<function>mpo_check_vnode_readdir</function>"
msgstr " <function> mpo_check_vnode_readdir </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13103
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_readdir</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>dvp</paramdef> <paramdef>struct label *<parameter/>dlabel</"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_readdir </function></"
"funcdef><paramdef> struct ucred * <parameter/> cred </paramdef><paramdef> "
"struct vnode * <parameter/> dvp </paramdef><paramdef> label struct * "
"<parameter/> dlabel </paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13137
#, fuzzy
msgid "Object; directory vnode"
msgstr "Objeto; diret�rio vnode"

#. (itstool) path: sect3/para
#: book.translate.xml:13149
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a <function>readdir</"
"function> operation on the passed directory vnode. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode executar uma <function> readdir </"
"function> opera��o no diret�rio passado vnode. Retorna <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para "
"falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13159
#, fuzzy
msgid "<function>mpo_check_vnode_readlink</function>"
msgstr " <function> mpo_check_vnode_readlink </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13162
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_readlink</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_readlink </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13211
#, fuzzy
msgid ""
"Determine whether the subject credential can perform a <function>readlink</"
"function> operation on the passed symlink vnode. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege. This call may be made in "
"a number of situations, including an explicit <function>readlink</function> "
"call by the user process, or as a result of an implicit <function>readlink</"
"function> during a name lookup by the process."
msgstr ""
"Determine se a credencial do assunto pode executar uma <function> readlink </"
"function> opera��o no vnode symlink passado. Retorna <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para "
"falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta "
"de privil�gio. Esta chamada pode ser feita em v�rias situa��es, incluindo "
"uma <function> readlink </function> chamada pelo processo do usu�rio ou como "
"resultado de um <function> readlink </function> durante uma pesquisa de nome "
"pelo processo \""

#. (itstool) path: sect3/title
#: book.translate.xml:13225
#, fuzzy
msgid "<function>mpo_check_vnode_revoke</function>"
msgstr " <function> mpo_check_vnode_revoke </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13228
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_revoke</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_revoke </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13277
#, fuzzy
msgid ""
"Determine whether the subject credential can revoke access to the passed "
"vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode revogar o acesso ao vnode passado. "
"Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falha sugerida: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13287
#, fuzzy
msgid "<function>mpo_check_vnode_setacl</function>"
msgstr " <function> mpo_check_vnode_setacl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13290
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setacl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>acl_type_t <parameter>type</parameter></paramdef> <paramdef>struct "
"acl *<parameter>acl</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setacl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> acl_type_t <parameter> tipo </parameter></"
"paramdef><paramdef> struct acl * <parameter> acl </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13346
#, fuzzy
msgid "<parameter>acl</parameter>"
msgstr " <parameter> acl </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13347
#, fuzzy
msgid "ACL"
msgstr "ACL"

#. (itstool) path: sect3/para
#: book.translate.xml:13353
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed ACL of passed "
"type on the passed vnode. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode definir a ACL transmitida do tipo "
"passado no vnode passado. <returnvalue> 0 </returnvalue> para o sucesso, ou "
"um <varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13363
#, fuzzy
msgid "<function>mpo_check_vnode_setextattr</function>"
msgstr " <function> mpo_check_vnode_setextattr </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13366
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setextattr</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>int <parameter>attrnamespace</parameter></paramdef> "
"<paramdef>const char *<parameter>name</parameter></paramdef> "
"<paramdef>struct uio *<parameter>uio</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setextattr </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> int <parameter> attrnamespace </parameter></"
"paramdef><paramdef> const char * <parameter> nome </parameter></"
"paramdef><paramdef> struct uio * <parameter> uio </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13436
#, fuzzy
msgid ""
"Determine whether the subject credential can set the extended attribute of "
"passed name and passed namespace on the passed vnode. Policies implementing "
"security labels backed into extended attributes may want to provide "
"additional protections for those attributes. Additionally, policies should "
"avoid making decisions based on the data referenced from <parameter>uio</"
"parameter>, as there is a potential race condition between this check and "
"the actual operation. The <parameter>uio</parameter> may also be "
"<literal>NULL</literal> if a delete operation is being performed. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determinar se a credencial de assunto pode definir o atributo estendido do "
"nome passado e o espa�o de nomes passado no vnode passado. As pol�ticas que "
"implementam r�tulos de seguran�a com backup em atributos estendidos podem "
"fornecer prote��es adicionais para esses atributos. Al�m disso, as pol�ticas "
"devem evitar tomar decis�es com base no dados referenciados de <parameter> "
"uio </parameter> , como h� uma condi��o de corrida em potencial entre essa "
"verifica��o e a opera��o real. o <parameter> uio </parameter> Tamb�m pode "
"ser <literal> NULO </literal> se uma opera��o de exclus�o estiver sendo "
"executada. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13454
#, fuzzy
msgid "<function>mpo_check_vnode_setflags</function>"
msgstr " <function> mpo_check_vnode_setflags </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13457
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setflags</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>u_long <parameter>flags</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setflags </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> u_long <parameter> bandeiras </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13506
#, fuzzy
msgid ""
"File flags; see <citerefentry><refentrytitle>chflags</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Sinalizadores de arquivo; consulte <citerefentry><refentrytitle> chflags </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13512
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed flags on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir os sinalizadores passados "
"​​no vnode passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, "
"ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, ou "
"<errorcode> EPERM </errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13522
#, fuzzy
msgid "<function>mpo_check_vnode_setmode</function>"
msgstr " <function> mpo_check_vnode_setmode </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13525
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setmode</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>mode_t <parameter>mode</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setmode </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> mode_t <parameter> modo </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13573
#, fuzzy
msgid "<parameter>mode</parameter>"
msgstr " <parameter> modo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13574
#, fuzzy
msgid ""
"File mode; see <citerefentry><refentrytitle>chmod</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Modo de arquivo; consulte <citerefentry><refentrytitle> chmod </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13580
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed mode on the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir o modo passado no vnode "
"passado. Retornar <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13590
#, fuzzy
msgid "<function>mpo_check_vnode_setowner</function>"
msgstr " <function> mpo_check_vnode_setowner </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13593
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setowner</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef> "
"<paramdef>uid_t <parameter>uid</parameter></paramdef> <paramdef>gid_t "
"<parameter>gid</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setowner </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef><paramdef> uid_t <parameter> uido </parameter></paramdef><paramdef> "
"gid_t <parameter> gid </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13642
#, fuzzy
msgid "<parameter>uid</parameter>"
msgstr " <parameter> uido </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13643
#, fuzzy
msgid "User ID"
msgstr "ID do usu�rio"

#. (itstool) path: row/entry
#: book.translate.xml:13647
#, fuzzy
msgid "<parameter>gid</parameter>"
msgstr " <parameter> guia </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13648
#, fuzzy
msgid "Group ID"
msgstr "ID do grupo"

#. (itstool) path: sect3/para
#: book.translate.xml:13654
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed uid and passed "
"gid as file uid and file gid on the passed vnode. The IDs may be set to "
"(<literal>-1</literal>) to request no update. Return <returnvalue>0</"
"returnvalue> for success, or an <varname>errno</varname> value for failure. "
"Suggested failure: <errorcode>EACCES</errorcode> for label mismatch, or "
"<errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do assunto pode definir o uid passado e o gid "
"passado como arquivo uid e gid do arquivo no vnode transmitido. Os IDs podem "
"ser definidos como ( <literal> -1 </literal> ) para solicitar nenhuma "
"atualiza��o. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13665
#, fuzzy
msgid "<function>mpo_check_vnode_setutimes</function>"
msgstr " <function> mpo_check_vnode_setutimes </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13668
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_setutimes</function></funcdef> "
"<paramdef>struct ucred *<parameter/>cred</paramdef> <paramdef>struct vnode "
"*<parameter/>vp</paramdef> <paramdef>struct label *<parameter/>label</"
"paramdef> <paramdef>struct timespec <parameter/>atime</paramdef> "
"<paramdef>struct timespec <parameter/>mtime</paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_setutimes </function></"
"funcdef><paramdef> struct ucred * <parameter/> cred </paramdef><paramdef> "
"struct vnode * <parameter/> vp </paramdef><paramdef> label struct * "
"<parameter/> r�tulo </paramdef><paramdef> struct timespec <parameter/> um "
"tempo </paramdef><paramdef> struct timespec <parameter/> mtime </paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13704
#, fuzzy
msgid "Object; vp"
msgstr "Objeto; vp"

#. (itstool) path: row/entry
#: book.translate.xml:13714
#, fuzzy
msgid "<parameter>atime</parameter>"
msgstr " <parameter> um tempo </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13715
#, fuzzy
msgid ""
"Access time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Tempo de acesso; consulte <citerefentry><refentrytitle> utimes </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: row/entry
#: book.translate.xml:13719
#, fuzzy
msgid "<parameter>mtime</parameter>"
msgstr " <parameter> mtime </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13720
#, fuzzy
msgid ""
"Modification time; see <citerefentry><refentrytitle>utimes</"
"refentrytitle><manvolnum>2</manvolnum></citerefentry>"
msgstr ""
"Tempo de modifica��o; ver <citerefentry><refentrytitle> utimes </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13726
#, fuzzy
msgid ""
"Determine whether the subject credential can set the passed access "
"timestamps on the passed vnode. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure:"
" <errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial de assunto pode definir os registros de data e "
"hora de acesso transmitidos no vnode transmitido. <returnvalue> 0 </"
"returnvalue> para o sucesso, ou um <varname> errno </varname> valor para "
"falha. Falha sugerida: <errorcode> EACCES </errorcode> para "
"incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por falta "
"de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13736
#, fuzzy
msgid "<function>mpo_check_proc_sched</function>"
msgstr " <function> mpo_check_proc_sched </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13739
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_sched</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_sched </function></"
"funcdef><paramdef> struct ucred * <parameter> ucred </parameter></"
"paramdef><paramdef> struct proc * <parameter> proc </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13780
#, fuzzy
msgid ""
"Determine whether the subject credential can change the scheduling "
"parameters of the passed process. Return <returnvalue>0</returnvalue> for "
"success, or an <varname>errno</varname> value for failure. Suggested failure:"
" <errorcode>EACCES</errorcode> for label mismatch, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to limit "
"visibility."
msgstr ""
"Determine se a credencial do assunto pode alterar os par�metros de "
"agendamento do processo passado. <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidade de etiqueta, "
"<errorcode> EPERM </errorcode> por falta de privil�gio, ou <errorcode> ESRCH "
"</errorcode> para limitar a visibilidade \""

#. (itstool) path: sect3/para
#: book.translate.xml:13788
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>setpriority</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"Vejo <citerefentry><refentrytitle> definir prioridades </"
"refentrytitle><manvolnum> 2 </manvolnum></citerefentry> Para maiores "
"informa��es."

#. (itstool) path: sect3/title
#: book.translate.xml:13792
#, fuzzy
msgid "<function>mpo_check_proc_signal</function>"
msgstr " <function> mpo_check_proc_signal </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13795
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_proc_signal</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct proc *<parameter>proc</parameter></paramdef> <paramdef>int "
"<parameter>signal</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_proc_signal </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct proc * <parameter> proc </parameter></"
"paramdef><paramdef> int <parameter> sinal </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13835
#, fuzzy
msgid "<parameter>signal</parameter>"
msgstr " <parameter> sinal </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:13836
#, fuzzy
msgid ""
"Signal; see <citerefentry><refentrytitle>kill</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry>"
msgstr ""
"Signal; ver <citerefentry><refentrytitle> matar </refentrytitle><manvolnum> "
"2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:13842
#, fuzzy
msgid ""
"Determine whether the subject credential can deliver the passed signal to "
"the passed process. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to limit "
"visibility."
msgstr ""
"Determine se a credencial do participante pode entregar o sinal passado ao "
"processo passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, <errorcode> EPERM </"
"errorcode> por falta de privil�gio, ou <errorcode> ESRCH </errorcode> para "
"limitar a visibilidade \""

#. (itstool) path: sect3/title
#: book.translate.xml:13852
#, fuzzy
msgid "<function>mpo_check_vnode_stat</function>"
msgstr " <function> mpo_check_vnode_stat </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13855
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_vnode_stat</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>label</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_vnode_stat </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> r�tulo </parameter></"
"paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:13904
#, fuzzy
msgid ""
"Determine whether the subject credential can <function>stat</function> the "
"passed vnode. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determine se a credencial do sujeito pode <function> stat </function> o "
"vnode passado. Retorna <returnvalue> 0 </returnvalue> para o sucesso, ou um "
"<varname> errno </varname> valor para falha. Falha sugerida: <errorcode> "
"EACCES </errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM "
"</errorcode> por falta de privil�gio \""

#. (itstool) path: sect3/para
#: book.translate.xml:13912
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>stat</refentrytitle><manvolnum>2</"
"manvolnum></citerefentry> for more information."
msgstr ""
"Vejo <citerefentry><refentrytitle> stat </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> Para maiores informa��es."

#. (itstool) path: sect3/title
#: book.translate.xml:13916
#, fuzzy
msgid "<function>mpo_check_ifnet_transmit</function>"
msgstr " <function> mpo_check_ifnet_transmit </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13919
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_ifnet_transmit</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_ifnet_transmit </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:13971
#, fuzzy
msgid "Object; mbuf to be sent"
msgstr "Objeto; mbuf a ser enviado"

#. (itstool) path: sect3/para
#: book.translate.xml:13983
#, fuzzy
msgid ""
"Determine whether the network interface can transmit the passed mbuf. Return "
"<returnvalue>0</returnvalue> for success, or an <varname>errno</varname> "
"value for failure. Suggested failure: <errorcode>EACCES</errorcode> for "
"label mismatch, or <errorcode>EPERM</errorcode> for lack of privilege."
msgstr ""
"Determine se a interface de rede pode transmitir o mbuf passado. "
"<returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> errno </"
"varname> valor para falha. Falha sugerida: <errorcode> EACCES </errorcode> "
"para incompatibilidade de etiqueta, ou <errorcode> EPERM </errorcode> por "
"falta de privil�gio \""

#. (itstool) path: sect3/title
#: book.translate.xml:13992
#, fuzzy
msgid "<function>mpo_check_socket_deliver</function>"
msgstr " <function> mpo_check_socket_deliver </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:13995
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_deliver</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct ifnet *<parameter>ifnet</parameter></paramdef> "
"<paramdef>struct label *<parameter>ifnetlabel</parameter></paramdef> "
"<paramdef>struct mbuf *<parameter>mbuf</parameter></paramdef> "
"<paramdef>struct label *<parameter>mbuflabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_deliver </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct ifnet * <parameter> ifnet </parameter></"
"paramdef><paramdef> label struct * <parameter> ifnetlabel </parameter></"
"paramdef><paramdef> struct mbuf * <parameter> mbuf </parameter></"
"paramdef><paramdef> label struct * <parameter> mbuflabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14047
#, fuzzy
msgid "Object; mbuf to be delivered"
msgstr "Objeto; mbuf a ser entregue"

#. (itstool) path: sect3/para
#: book.translate.xml:14059
#, fuzzy
msgid ""
"Determine whether the socket may receive the datagram stored in the passed "
"mbuf header. Return <returnvalue>0</returnvalue> for success, or an "
"<varname>errno</varname> value for failure. Suggested failures: "
"<errorcode>EACCES</errorcode> for label mismatch, or <errorcode>EPERM</"
"errorcode> for lack of privilege."
msgstr ""
"Determina se o socket pode receber o datagrama armazenado no cabe�alho mbuf "
"passado. <returnvalue> 0 </returnvalue> para o sucesso, ou um <varname> "
"errno </varname> valor para falha. Falhas sugeridas: <errorcode> EACCES </"
"errorcode> para incompatibilidade de etiqueta, ou <errorcode> EPERM </"
"errorcode> por falta de privil�gio \""

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14072
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_socket_visible</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct socket *<parameter>so</parameter></paramdef> "
"<paramdef>struct label *<parameter>socketlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_socket_visible </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> soquete de estrutura * <parameter> assim </parameter></"
"paramdef><paramdef> label struct * <parameter> socketlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14115
#, fuzzy
msgid "Policy label for <parameter>so</parameter>"
msgstr "Etiqueta de pol�tica para <parameter> assim </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:14122
#, fuzzy
msgid ""
"Determine whether the subject credential cred can \"see\" the passed socket "
"(<parameter>socket</parameter>) using system monitoring functions, such as "
"those employed by <citerefentry><refentrytitle>netstat</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>sockstat</refentrytitle><manvolnum>1</"
"manvolnum></citerefentry>. Return <returnvalue>0</returnvalue> for success, "
"or an <varname>errno</varname> value for failure. Suggested failure: "
"<errorcode>EACCES</errorcode> for label mismatches, <errorcode>EPERM</"
"errorcode> for lack of privilege, or <errorcode>ESRCH</errorcode> to hide "
"visibility."
msgstr ""
"Determine se o credencial da pessoa em quest�o pode\" ver \"o soquete "
"passado ( <parameter> soquete </parameter> ) usando fun��es de monitoramento "
"do sistema, como aquelas empregadas <citerefentry><refentrytitle> netstat </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> sockstat </refentrytitle><manvolnum> 1 </"
"manvolnum></citerefentry> . Retorna <returnvalue> 0 </returnvalue> para o "
"sucesso, ou um <varname> errno </varname> valor para falha. Falha sugerida: "
"<errorcode> EACCES </errorcode> para incompatibilidades de r�tulo, "
"<errorcode> EPERM </errorcode> por falta de privil�gio, ou <errorcode> ESRCH "
"</errorcode> para esconder visibilidade \""

#. (itstool) path: sect3/title
#: book.translate.xml:14134
#, fuzzy
msgid "<function>mpo_check_system_acct</function>"
msgstr " <function> mpo_check_system_acct </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14137
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_acct</function></funcdef> "
"<paramdef>struct ucred *<parameter>ucred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_acct </function></"
"funcdef><paramdef> struct ucred * <parameter> ucred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14168
#, fuzzy
msgid "<parameter>ucred</parameter>"
msgstr " <parameter> ucred </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14174
#, fuzzy
msgid ""
"Accounting file; <citerefentry><refentrytitle>acct</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>"
msgstr ""
"Arquivo cont�bil; <citerefentry><refentrytitle> acct </"
"refentrytitle><manvolnum> 5 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:14186
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to enable accounting, based "
"on its label and the label of the accounting log file."
msgstr ""
"Determine se o assunto deve ter permiss�o para ativar a contabilidade, com "
"base em seu r�tulo e no r�tulo do arquivo de registro cont�bil."

#. (itstool) path: sect3/title
#: book.translate.xml:14192
#, fuzzy
msgid "<function>mpo_check_system_nfsd</function>"
msgstr " <function> mpo_check_system_nfsd </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14195
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_nfsd</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_nfsd </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:14229
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to call "
"<citerefentry><refentrytitle>nfssvc</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>."
msgstr ""
"Determinar se o assunto deve ter permiss�o para ligar "
"<citerefentry><refentrytitle> nfssvc </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> "

#. (itstool) path: sect3/title
#: book.translate.xml:14234
#, fuzzy
msgid "<function>mpo_check_system_reboot</function>"
msgstr " <function> mpo_check_system_reboot </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14237
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_reboot</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"<parameter>howto</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_reboot </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> int <parameter> como </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14270
#, fuzzy
msgid "<parameter>howto</parameter>"
msgstr " <parameter> como </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14271
#, fuzzy
msgid ""
"<parameter>howto</parameter> parameter from "
"<citerefentry><refentrytitle>reboot</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry>"
msgstr ""
" <parameter> como </parameter> par�metro de <citerefentry><refentrytitle> "
"reiniciar </refentrytitle><manvolnum> 2 </manvolnum></citerefentry> "

#. (itstool) path: sect3/para
#: book.translate.xml:14278
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to reboot the system in the "
"specified manner."
msgstr ""
"Determine se o assunto deve ter permiss�o para reinicializar o sistema da "
"maneira especificada."

#. (itstool) path: sect3/title
#: book.translate.xml:14283
#, fuzzy
msgid "<function>mpo_check_system_settime</function>"
msgstr " <function> mpo_check_system_settime </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14286
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_settime</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_settime </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></paramdef> "

#. (itstool) path: sect3/para
#: book.translate.xml:14320
#, fuzzy
msgid "Determine whether the user should be allowed to set the system clock."
msgstr ""
"Determine se o usu�rio deve ter permiss�o para definir o rel�gio do sistema."

#. (itstool) path: sect3/title
#: book.translate.xml:14325
#, fuzzy
msgid "<function>mpo_check_system_swapon</function>"
msgstr " <function> mpo_check_system_swapon </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14328
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_swapon</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> "
"<paramdef>struct vnode *<parameter>vp</parameter></paramdef> "
"<paramdef>struct label *<parameter>vlabel</parameter></paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_swapon </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> struct vnode * <parameter> vp </parameter></"
"paramdef><paramdef> label struct * <parameter> vlabel </parameter></"
"paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14365
#, fuzzy
msgid "Swap device"
msgstr "Dispositivo de troca"

#. (itstool) path: sect3/para
#: book.translate.xml:14377
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to add <parameter>vp</"
"parameter> as a swap device."
msgstr ""
"Determine se o assunto deve ter permiss�o para adicionar <parameter> vp </"
"parameter> como um dispositivo de troca \""

#. (itstool) path: sect3/title
#: book.translate.xml:14382
#, fuzzy
msgid "<function>mpo_check_system_sysctl</function>"
msgstr " <function> mpo_check_system_sysctl </function> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:14385
#, fuzzy
msgid ""
"<funcdef>int <function>mpo_check_system_sysctl</function></funcdef> "
"<paramdef>struct ucred *<parameter>cred</parameter></paramdef> <paramdef>int "
"*<parameter>name</parameter></paramdef> <paramdef>u_int *<parameter>namelen</"
"parameter></paramdef> <paramdef>void *<parameter>old</parameter></paramdef> "
"<paramdef>size_t *<parameter>oldlenp</parameter></paramdef> <paramdef>int "
"<parameter>inkernel</parameter></paramdef> <paramdef>void *<parameter>new</"
"parameter></paramdef> <paramdef>size_t <parameter>newlen</parameter></"
"paramdef>"
msgstr ""
" <funcdef> int <function> mpo_check_system_sysctl </function></"
"funcdef><paramdef> struct ucred * <parameter> cred </parameter></"
"paramdef><paramdef> int * <parameter> nome </parameter></paramdef><paramdef> "
"u_int * <parameter> namelen </parameter></paramdef><paramdef> void * "
"<parameter> velho </parameter></paramdef><paramdef> size_t * <parameter> "
"oldlenp </parameter></paramdef><paramdef> int <parameter> t�nica </"
"parameter></paramdef><paramdef> void * <parameter> Novo </parameter></"
"paramdef><paramdef> size_t <parameter> Newlen </parameter></paramdef> "

#. (itstool) path: row/entry
#: book.translate.xml:14426 book.translate.xml:14449
#, fuzzy
msgid ""
"See <citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>"
msgstr ""
"Vejo <citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> "

#. (itstool) path: row/entry
#: book.translate.xml:14438
#, fuzzy
msgid "<parameter>oldlenp</parameter>"
msgstr " <parameter> oldlenp </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14442
#, fuzzy
msgid "<parameter>inkernel</parameter>"
msgstr " <parameter> inkernel </parameter> "

#. (itstool) path: row/entry
#: book.translate.xml:14443
#, fuzzy
msgid "Boolean; <literal>1</literal> if called from kernel"
msgstr "Boleano; <literal> 1 </literal> se chamado do kernel "

#. (itstool) path: row/entry
#: book.translate.xml:14453
#, fuzzy
msgid "<parameter>newlen</parameter>"
msgstr " <parameter> newlen </parameter> "

#. (itstool) path: sect3/para
#: book.translate.xml:14459
#, fuzzy
msgid ""
"Determine whether the subject should be allowed to make the specified "
"<citerefentry><refentrytitle>sysctl</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry> transaction."
msgstr ""
"Determinar se o assunto deve ter permiss�o para fazer o especificado "
"<citerefentry><refentrytitle> sysctl </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> transa��o."

#. (itstool) path: sect2/title
#: book.translate.xml:14465
#, fuzzy
msgid "Label Management Calls"
msgstr "Chamadas de Gerenciamento de Etiqueta"

#. (itstool) path: sect2/para
#: book.translate.xml:14467
#, fuzzy
msgid ""
"Relabel events occur when a user process has requested that the label on an "
"object be modified. A two-phase update occurs: first, an access control "
"check will be performed to determine if the update is both valid and "
"permitted, and then the update itself is performed via a separate entry "
"point. Relabel entry points typically accept the object, object label "
"reference, and an update label submitted by the process. Memory allocation "
"during relabel is discouraged, as relabel calls are not permitted to fail "
"(failure should be reported earlier in the relabel check)."
msgstr ""
"Os eventos de reclassifica��o ocorrem quando um processo do usu�rio solicita "
"que o r�tulo de um objeto seja modificado. Uma atualiza��o de duas fases "
"ocorre: primeiro, uma verifica��o de controle de acesso ser� executada para "
"determinar se a atualiza��o � v�lida e permitida e, em seguida, a "
"atualiza��o O ponto de entrada de reclassifica��o normalmente aceita o "
"objeto, a refer�ncia de r�tulo de objeto e um r�tulo de atualiza��o enviado "
"pelo processo.A aloca��o de mem�ria durante a reclassifica��o n�o � "
"recomendada, pois as chamadas de reclassifica��o n�o t�m permiss�o para "
"falhar mais cedo na verifica��o de reclassifica��o). "

#. (itstool) path: sect1/title
#: book.translate.xml:14481
#, fuzzy
msgid "Userland Architecture"
msgstr "Arquitetura Userland"

#. (itstool) path: sect1/para
#: book.translate.xml:14483
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework includes a number of policy-agnostic elements, "
"including MAC library interfaces for abstractly managing labels, "
"modifications to the system credential management and login libraries to "
"support the assignment of MAC labels to users, and a set of tools to monitor "
"and modify labels on processes, files, and network interfaces. More details "
"on the user architecture will be added to this section in the near future."
msgstr ""
"O TrustedBSD MAC Framework inclui v�rios elementos agn�sticos de pol�ticas, "
"incluindo interfaces de biblioteca MAC para gerenciar r�tulos, modifica��es "
"no gerenciamento de credenciais do sistema e bibliotecas de login para "
"suportar a atribui��o de r�tulos MAC aos usu�rios e um conjunto de "
"ferramentas para monitorar e modificar r�tulos em processos, arquivos e "
"interfaces de rede. Mais detalhes sobre a arquitetura do usu�rio ser�o "
"adicionados a esta se��o em um futuro pr�ximo. "

#. (itstool) path: sect2/title
#: book.translate.xml:14493
#, fuzzy
msgid "APIs for Policy-Agnostic Label Management"
msgstr "APIs para gerenciamento de r�tulos agn�sticos em pol�ticas"

#. (itstool) path: sect2/para
#: book.translate.xml:14495
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework provides a number of library and system calls "
"permitting applications to manage MAC labels on objects using a policy-"
"agnostic interface. This permits applications to manipulate labels for a "
"variety of policies without being written to support specific policies. "
"These interfaces are used by general-purpose tools such as "
"<citerefentry><refentrytitle>ifconfig</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>ls</"
"refentrytitle><manvolnum>1</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>ps</refentrytitle><manvolnum>1</manvolnum></"
"citerefentry> to view labels on network interfaces, files, and processes. "
"The APIs also support MAC management tools including "
"<citerefentry><refentrytitle>getfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>getpmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, "
"<citerefentry><refentrytitle>setfmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>, <citerefentry><refentrytitle>setfsmac</"
"refentrytitle><manvolnum>8</manvolnum></citerefentry>, and "
"<citerefentry><refentrytitle>setpmac</refentrytitle><manvolnum>8</"
"manvolnum></citerefentry>. The MAC APIs are documented in "
"<citerefentry><refentrytitle>mac</refentrytitle><manvolnum>3</manvolnum></"
"citerefentry>."
msgstr ""
"O TrustedBSD MAC Framework fornece v�rias chamadas de biblioteca e de "
"sistema, permitindo que aplicativos gerenciem r�tulos MAC em objetos usando "
"uma interface independente de pol�ticas. Isso permite que os aplicativos "
"manipulem r�tulos para uma variedade de pol�ticas sem serem escritos para "
"suportar pol�ticas espec�ficas. Essas interfaces s�o usado por ferramentas "
"de uso geral, como <citerefentry><refentrytitle> ifconfig </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> ls </refentrytitle><manvolnum> 1 </manvolnum></"
"citerefentry> e <citerefentry><refentrytitle> ps </refentrytitle><manvolnum> "
"1 </manvolnum></citerefentry> para exibir r�tulos em interfaces de rede, "
"arquivos e processos. As APIs tamb�m suportam ferramentas de gerenciamento "
"MAC, incluindo <citerefentry><refentrytitle> getfmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> getpmac </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> , <citerefentry><refentrytitle> setfmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> , "
"<citerefentry><refentrytitle> setfsmac </refentrytitle><manvolnum> 8 </"
"manvolnum></citerefentry> e <citerefentry><refentrytitle> setpmac </"
"refentrytitle><manvolnum> 8 </manvolnum></citerefentry> . As APIs do MAC "
"est�o documentadas em <citerefentry><refentrytitle> Mac </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> "

#. (itstool) path: sect2/para
#: book.translate.xml:14509
#, fuzzy
msgid ""
"Applications handle MAC labels in two forms: an internalized form used to "
"return and set labels on processes and objects (<literal>mac_t</literal>), "
"and externalized form based on C strings appropriate for storage in "
"configuration files, display to the user, or input from the user. Each MAC "
"label contains a number of elements, each consisting of a name and value "
"pair. Policy modules in the kernel bind to specific names and interpret the "
"values in policy-specific ways. In the externalized string form, labels are "
"represented by a comma-delimited list of name and value pairs separated by "
"the <literal>/</literal> character. Labels may be directly converted to and "
"from text using provided APIs; when retrieving labels from the kernel, "
"internalized label storage must first be prepared for the desired label "
"element set. Typically, this is done in one of two ways: using "
"<citerefentry><refentrytitle>mac_prepare</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> and an arbitrary list of desired label elements, "
"or one of the variants of the call that loads a default element set from the "
"<citerefentry><refentrytitle>mac.conf</refentrytitle><manvolnum>5</"
"manvolnum></citerefentry> configuration file. Per-object defaults permit "
"application writers to usefully display labels associated with objects "
"without being aware of the policies present in the system."
msgstr ""
"Os aplicativos manipulam r�tulos MAC de duas formas: um formul�rio "
"internalizado usado para retornar e definir r�tulos em processos e objetos ( "
"<literal> mac_t </literal> ) e formul�rio externalizado baseado em "
"sequ�ncias C apropriadas para armazenamento em arquivos de configura��o, "
"exibi��o para o usu�rio ou entrada do usu�rio. Cada r�tulo MAC cont�m v�rios "
"elementos, cada um consistindo em um par de nome e valor. Os m�dulos de "
"pol�tica no kernel s�o vinculados a nomes espec�ficos e interpretam os "
"valores de maneiras espec�ficas da pol�tica. No formul�rio de string "
"exteriorizado, os r�tulos s�o representados por uma lista delimitada por "
"v�rgulas de pares de nome e valor separados por <literal> / </literal> "
"personagem. Os r�tulos podem ser convertidos diretamente para e a partir do "
"texto usando as APIs fornecidas; Ao recuperar r�tulos do kernel, o "
"armazenamento de r�tulos internalizado deve primeiro ser preparado para o "
"conjunto de elementos de r�tulo desejado. Normalmente, isso � feito de duas "
"maneiras: usando <citerefentry><refentrytitle> mac_prepare </"
"refentrytitle><manvolnum> 3 </manvolnum></citerefentry> e uma lista "
"arbitr�ria de elementos de r�tulo desejados, ou uma das variantes da chamada "
"que carrega um conjunto de elementos padr�o do <citerefentry><refentrytitle> "
"mac.conf </refentrytitle><manvolnum> 5 </manvolnum></citerefentry> arquivo "
"de configura��o. Padr�es por objeto permitem que escritores de aplicativos "
"exibam r�tulos associados a objetos sem estarem cientes das pol�ticas "
"presentes no sistema. "

#. (itstool) path: note/para
#: book.translate.xml:14534
#, fuzzy
msgid ""
"Currently, direct manipulation of label elements other than by conversion to "
"a text string, string editing, and conversion back to an internalized label "
"is not supported by the MAC library. Such interfaces may be added in the "
"future if they prove necessary for application writers."
msgstr ""
"Atualmente, a manipula��o direta de elementos de r�tulo diferentes da "
"convers�o para uma string de texto, edi��o de string e convers�o de volta "
"para um r�tulo internalizado n�o � suportada pela biblioteca MAC. Tais "
"interfaces podem ser adicionadas no futuro se forem necess�rias para "
"escritores de aplicativos "

#. (itstool) path: sect2/title
#: book.translate.xml:14544
#, fuzzy
msgid "Binding of Labels to Users"
msgstr "Liga��o de etiquetas aos usu�rios"

#. (itstool) path: sect2/para
#: book.translate.xml:14546
#, fuzzy
msgid ""
"The standard user context management interface, "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry>, has been modified to retrieve MAC labels "
"associated with a user's class from <citerefentry><refentrytitle>login.conf</"
"refentrytitle><manvolnum>5</manvolnum></citerefentry>. These labels are then "
"set along with other user context when either <literal>LOGIN_SETALL</"
"literal> is specified, or when <literal>LOGIN_SETMAC</literal> is explicitly "
"specified."
msgstr ""
"A interface padr�o de gerenciamento de contexto do usu�rio, "
"<citerefentry><refentrytitle> setusercontext </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> , foi modificado para recuperar r�tulos MAC "
"associados a uma classe de usu�rio de <citerefentry><refentrytitle> login."
"conf </refentrytitle><manvolnum> 5 </manvolnum></citerefentry> . Esses "
"r�tulos s�o ent�o definidos junto com outro contexto de usu�rio quando "
"<literal> LOGIN_SETALL </literal> � especificado, ou quando <literal> "
"LOGIN_SETMAC </literal> � explicitamente especificado. "

#. (itstool) path: note/para
#: book.translate.xml:14555
#, fuzzy
msgid ""
"It is expected that, in a future version of FreeBSD, the MAC label database "
"will be separated from the <filename>login.conf</filename> user class "
"abstraction, and be maintained in a separate database. However, the "
"<citerefentry><refentrytitle>setusercontext</refentrytitle><manvolnum>3</"
"manvolnum></citerefentry> API should remain the same following such a change."
""
msgstr ""
"Espera-se que, em uma vers�o futura do FreeBSD, o banco de dados de r�tulos "
"MAC seja separado do <filename> login.conf </filename> abstra��o de classe "
"de usu�rio, e ser mantido em um banco de dados separado. No entanto, o "
"<citerefentry><refentrytitle> setusercontext </refentrytitle><manvolnum> 3 </"
"manvolnum></citerefentry> A API deve permanecer a mesma ap�s essa mudan�a. "

#. (itstool) path: sect1/title
#: book.translate.xml:14565
#, fuzzy
msgid "Conclusion"
msgstr "Conclus�o"

#. (itstool) path: sect1/para
#: book.translate.xml:14567
#, fuzzy
msgid ""
"The TrustedBSD MAC framework permits kernel modules to augment the system "
"security policy in a highly integrated manner. They may do this based on "
"existing object properties, or based on label data that is maintained with "
"the assistance of the MAC framework. The framework is sufficiently flexible "
"to implement a variety of policy types, including information flow security "
"policies such as MLS and Biba, as well as policies based on existing BSD "
"credentials or file protections. Policy authors may wish to consult this "
"documentation as well as existing security modules when implementing a new "
"security service."
msgstr ""
"A estrutura do TrustedBSD MAC permite que os m�dulos do kernel aumentem a "
"pol�tica de seguran�a do sistema de uma maneira altamente integrada. Eles "
"podem fazer isso com base nas propriedades de objetos existentes ou com base "
"nos dados de r�tulo que s�o mantidos com a assist�ncia da estrutura MAC. "
"flex�veis para implementar uma variedade de tipos de pol�ticas, incluindo "
"pol�ticas de seguran�a de fluxo de informa��es como MLS e Biba, bem como "
"pol�ticas baseadas em credenciais BSD existentes ou prote��es de arquivos."
"Autoriais de pol�ticas podem desejar consultar esta documenta��o assim como "
"m�dulos de seguran�a existentes ao implementar novo servi�o de seguran�a. "

#. (itstool) path: info/title
#: book.translate.xml:14590
#, fuzzy
msgid "Virtual Memory System"
msgstr "Sistema de Mem�ria Virtual"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14593
#, fuzzy
msgid ""
"<personname> <firstname>Matthew</firstname> <surname>Dillon</surname> </"
"personname> <contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Mateus </firstname><surname> Dillon </surname></"
"personname><contrib> Contribu�ram por </contrib> "

#. (itstool) path: sect1/title
#: book.translate.xml:14604
#, fuzzy
msgid "Management of Physical Memory—<literal>vm_page_t</literal>"
msgstr "Gerenciamento de mem�ria f�sica— <literal> vm_page_t </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14607
#, fuzzy
msgid "<primary>virtual memory</primary>"
msgstr " <primary> mem�ria virtual </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14608
#, fuzzy
msgid "<primary>physical memory</primary>"
msgstr " <primary> mem�ria f�sica </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14609
#, fuzzy
msgid "<primary><literal>vm_page_t</literal> structure</primary>"
msgstr " <primary><literal> vm_page_t </literal> estrutura </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14613
#, fuzzy
msgid ""
"Physical memory is managed on a page-by-page basis through the "
"<literal>vm_page_t</literal> structure. Pages of physical memory are "
"categorized through the placement of their respective <literal>vm_page_t</"
"literal> structures on one of several paging queues."
msgstr ""
"A mem�ria f�sica � gerenciada p�gina por p�gina atrav�s do <literal> "
"vm_page_t </literal> estrutura. As p�ginas da mem�ria f�sica s�o "
"categorizadas atrav�s da coloca��o de seus respectivos <literal> vm_page_t </"
"literal> estruturas em uma das v�rias filas de pagina��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:14619
#, fuzzy
msgid ""
"A page can be in a wired, active, inactive, cache, or free state. Except for "
"the wired state, the page is typically placed in a doubly link list queue "
"representing the state that it is in. Wired pages are not placed on any "
"queue."
msgstr ""
"Uma p�gina pode estar em um estado com fio, ativo, inativo, em cache ou "
"livre. Exceto pelo estado com fio, a p�gina normalmente � colocada em uma "
"fila de lista de links duplamente representando o estado em que est�. As "
"p�ginas com fio n�o s�o colocadas em qualquer fila. "

#. (itstool) path: sect1/para
#: book.translate.xml:14624
#, fuzzy
msgid ""
"FreeBSD implements a more involved paging queue for cached and free pages in "
"order to implement page coloring. Each of these states involves multiple "
"queues arranged according to the size of the processor's L1 and L2 caches. "
"When a new page needs to be allocated, FreeBSD attempts to obtain one that "
"is reasonably well aligned from the point of view of the L1 and L2 caches "
"relative to the VM object the page is being allocated for."
msgstr ""
"O FreeBSD implementa uma fila de pagina��o mais envolvida para p�ginas em "
"cache e livres, a fim de implementar colora��o de p�gina. Cada um desses "
"estados envolve v�rias filas organizadas de acordo com o tamanho dos caches "
"L1 e L2 do processador. Quando uma nova p�gina precisa ser alocada, o "
"FreeBSD tenta obter um que esteja razoavelmente bem alinhado do ponto de "
"vista dos caches L1 e L2 em rela��o ao objeto de VM para o qual a p�gina "
"est� sendo alocada. "

#. (itstool) path: sect1/para
#: book.translate.xml:14633
#, fuzzy
msgid ""
"Additionally, a page may be held with a reference count or locked with a "
"busy count. The VM system also implements an <quote>ultimate locked</quote> "
"state for a page using the PG_BUSY bit in the page's flags."
msgstr ""
"Al�m disso, uma p�gina pode ser mantida com uma contagem de refer�ncia ou "
"bloqueada com uma contagem ocupada. O sistema VM tamb�m implementa uma "
"<quote> ultimate bloqueado </quote> estado para uma p�gina usando o bit "
"PG_BUSY nos flags da p�gina. "

#. (itstool) path: sect1/para
#: book.translate.xml:14638
#, fuzzy
msgid ""
"In general terms, each of the paging queues operates in a LRU fashion. A "
"page is typically placed in a wired or active state initially. When wired, "
"the page is usually associated with a page table somewhere. The VM system "
"ages the page by scanning pages in a more active paging queue (LRU) in order "
"to move them to a less-active paging queue. Pages that get moved into the "
"cache are still associated with a VM object but are candidates for immediate "
"reuse. Pages in the free queue are truly free. FreeBSD attempts to minimize "
"the number of pages in the free queue, but a certain minimum number of truly "
"free pages must be maintained in order to accommodate page allocation at "
"interrupt time."
msgstr ""
"Em termos gerais, cada uma das filas de pagina��o opera de forma LRU. Uma "
"p�gina � normalmente colocada em um estado com fio ou ativo inicialmente. "
"Quando ligada, a p�gina � geralmente associada a uma tabela de p�ginas em "
"algum lugar. O sistema VM envelhece a p�gina por varrendo p�ginas em uma "
"fila de pagina��o mais ativa (LRU) para mov�-las para uma fila de pagina��o "
"menos ativa As p�ginas que s�o movidas para o cache ainda s�o associadas a "
"um objeto VM, mas s�o candidatas a reutiliza��o imediata. O FreeBSD tenta "
"minimizar o n�mero de p�ginas na fila livre, mas um certo n�mero m�nimo de "
"p�ginas realmente livres deve ser mantido para acomodar a aloca��o de "
"p�ginas no momento da interrup��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:14651
#, fuzzy
msgid ""
"If a process attempts to access a page that does not exist in its page table "
"but does exist in one of the paging queues (such as the inactive or cache "
"queues), a relatively inexpensive page reactivation fault occurs which "
"causes the page to be reactivated. If the page does not exist in system "
"memory at all, the process must block while the page is brought in from disk."
""
msgstr ""
"Se um processo tentar acessar uma p�gina que n�o existe em sua tabela de "
"p�ginas mas existir em uma das filas de pagina��o (como as filas inativas ou "
"de cache), ocorrer� uma falha de reativa��o de p�gina relativamente barata "
"que faz com que a p�gina seja reativada Se a p�gina n�o existir na mem�ria "
"do sistema, o processo deve ser bloqueado enquanto a p�gina � trazida do "
"disco. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14659
#, fuzzy
msgid "<primary>paging queues</primary>"
msgstr " <primary> filas de pagina��o </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14661
#, fuzzy
msgid ""
"FreeBSD dynamically tunes its paging queues and attempts to maintain "
"reasonable ratios of pages in the various queues as well as attempts to "
"maintain a reasonable breakdown of clean versus dirty pages. The amount of "
"rebalancing that occurs depends on the system's memory load. This "
"rebalancing is implemented by the pageout daemon and involves laundering "
"dirty pages (syncing them with their backing store), noticing when pages are "
"activity referenced (resetting their position in the LRU queues or moving "
"them between queues), migrating pages between queues when the queues are out "
"of balance, and so forth. FreeBSD's VM system is willing to take a "
"reasonable number of reactivation page faults to determine how active or how "
"idle a page actually is. This leads to better decisions being made as to "
"when to launder or swap-out a page."
msgstr ""
"O FreeBSD ajusta dinamicamente suas filas de pagina��o e tenta manter "
"�ndices razo�veis ​​de p�ginas nas v�rias filas, bem como tentativas de "
"manter um detalhamento razo�vel de p�ginas limpas versus p�ginas sujas. A "
"quantidade de rebalanceamento que ocorre depende da carga de mem�ria do "
"sistema. implementado pelo daemon de pageout e envolve a lavagem de p�ginas "
"sujas (sincronizando-as com seu armazenamento de backup), observando quando "
"as p�ginas s�o referenciadas � atividade (redefinindo sua posi��o nas filas "
"de LRU ou movendo-as entre filas), migrando p�ginas entre filas quando as "
"filas est�o fora O sistema VM do FreeBSD est� disposto a aceitar um n�mero "
"razo�vel de falhas de p�gina de reativa��o para determinar o qu�o ativo ou "
"ocioso � uma p�gina. Isso leva a melhores decis�es sobre quando lavar ou "
"trocar uma p�gina. "

#. (itstool) path: sect1/title
#: book.translate.xml:14678
#, fuzzy
msgid "The Unified Buffer Cache—<literal>vm_object_t</literal>"
msgstr "O Unified Buffer Cache— <literal> vm_object_t </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14681
#, fuzzy
msgid "<primary>unified buffer cache</primary>"
msgstr " <primary> cache de buffer unificado </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14682
#, fuzzy
msgid "<primary><literal>vm_object_t</literal> structure</primary>"
msgstr " <primary><literal> vm_object_t </literal> estrutura </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14686
#, fuzzy
msgid ""
"FreeBSD implements the idea of a generic <quote>VM object</quote>. VM "
"objects can be associated with backing store of various types—unbacked, swap-"
"backed, physical device-backed, or file-backed storage. Since the filesystem "
"uses the same VM objects to manage in-core data relating to files, the "
"result is a unified buffer cache."
msgstr ""
"O FreeBSD implementa a id�ia de um gen�rico <quote> Objeto da VM </quote> . "
"Os objetos da VM podem ser associados ao armazenamento de suporte de v�rios "
"tipos - armazenamento n�o suportado, com suporte a permuta, com suporte para "
"dispositivos f�sicos ou com suporte a arquivos. Como o sistema de arquivos "
"usa os mesmos objetos de VM para gerenciar dados internos relacionados aos "
"arquivos, o resultado � um cache de buffer unificado. "

#. (itstool) path: sect1/para
#: book.translate.xml:14693
#, fuzzy
msgid ""
"VM objects can be <emphasis>shadowed</emphasis>. That is, they can be "
"stacked on top of each other. For example, you might have a swap-backed VM "
"object stacked on top of a file-backed VM object in order to implement a "
"MAP_PRIVATE mmap()ing. This stacking is also used to implement various "
"sharing properties, including copy-on-write, for forked address spaces."
msgstr ""
"Objetos VM podem ser <emphasis> sombreado </emphasis> . Ou seja, eles podem "
"ser empilhados uns sobre os outros. Por exemplo, voc� pode ter um objeto de "
"VM com suporte a permuta empilhado sobre um objeto de VM com backup de "
"arquivo para implementar um MAP_PRIVATE mmap (). Esse empilhamento tamb�m � "
"usado para implementar v�rias propriedades de compartilhamento, incluindo "
"copy-on-write, para espa�os de endere�amento bifurcados. "

#. (itstool) path: sect1/para
#: book.translate.xml:14701
#, fuzzy
msgid ""
"It should be noted that a <literal>vm_page_t</literal> can only be "
"associated with one VM object at a time. The VM object shadowing implements "
"the perceived sharing of the same page across multiple instances."
msgstr ""
"Deve-se notar que um <literal> vm_page_t </literal> s� pode ser associado a "
"um objeto de VM por vez. O sombreamento de objeto da VM implementa o "
"compartilhamento percebido da mesma p�gina em v�rias inst�ncias. "

#. (itstool) path: sect1/title
#: book.translate.xml:14708
#, fuzzy
msgid "Filesystem I/O—<literal>struct buf</literal>"
msgstr "Sistema de arquivos I / O— <literal> struct buf </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14710
#, fuzzy
msgid "<primary>vnode</primary>"
msgstr " <primary> vnode </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14711
#, fuzzy
msgid ""
"vnode-backed VM objects, such as file-backed objects, generally need to "
"maintain their own clean/dirty info independent from the VM system's idea of "
"clean/dirty. For example, when the VM system decides to synchronize a "
"physical page to its backing store, the VM system needs to mark the page "
"clean before the page is actually written to its backing store. "
"Additionally, filesystems need to be able to map portions of a file or file "
"metadata into KVM in order to operate on it."
msgstr ""
"Objetos VM com backup de vnode, como objetos com backup de arquivos, "
"geralmente precisam manter suas pr�prias informa��es limpas / sujas "
"independentemente da id�ia de limpeza / sujeira do sistema VM. Por exemplo, "
"quando o sistema VM decide sincronizar uma p�gina f�sica com No backing "
"store, o sistema VM precisa marcar a p�gina limpa antes que a p�gina seja "
"realmente gravada em seu armazenamento de backup. Al�m disso, os sistemas de "
"arquivos precisam poder mapear partes de um arquivo ou metadados de arquivo "
"para o KVM para oper�-lo. "

#. (itstool) path: sect1/para
#: book.translate.xml:14720
#, fuzzy
msgid ""
"The entities used to manage this are known as filesystem buffers, "
"<literal>struct buf</literal>'s, or <literal>bp</literal>'s. When a "
"filesystem needs to operate on a portion of a VM object, it typically maps "
"part of the object into a struct buf and then maps the pages in the struct "
"buf into KVM. In the same manner, disk I/O is typically issued by mapping "
"portions of objects into buffer structures and then issuing the I/O on the "
"buffer structures. The underlying vm_page_t's are typically busied for the "
"duration of the I/O. Filesystem buffers also have their own notion of being "
"busy, which is useful to filesystem driver code which would rather operate "
"on filesystem buffers instead of hard VM pages."
msgstr ""
"As entidades usadas para gerenciar isso s�o conhecidas como buffers de "
"sistema de arquivos, <literal> struct buf </literal> � ou <literal> pb </"
"literal> . Quando um sistema de arquivos precisa operar em uma parte de um "
"objeto VM, ele normalmente mapeia parte do objeto em um struct buf e, em "
"seguida, mapeia as p�ginas no struct buf para o KVM. Da mesma maneira, a E / "
"S de disco normalmente � emitida por partes de mapeamento de objetos em "
"estruturas de buffer e, em seguida, emitindo a E / S nas estruturas de "
"buffer. As vm_page_t subjacentes geralmente s�o ocupadas pela dura��o da E / "
"S. Os buffers do sistema de arquivos tamb�m t�m sua pr�pria no��o de estar "
"ocupado, o que � �til para o c�digo do driver do sistema de arquivos, que "
"preferia operar em buffers do sistema de arquivos em vez de p�ginas da VM. "

#. (itstool) path: sect1/para
#: book.translate.xml:14733
#, fuzzy
msgid ""
"FreeBSD reserves a limited amount of KVM to hold mappings from struct bufs, "
"but it should be made clear that this KVM is used solely to hold mappings "
"and does not limit the ability to cache data. Physical data caching is "
"strictly a function of <literal>vm_page_t</literal>'s, not filesystem "
"buffers. However, since filesystem buffers are used to placehold I/O, they "
"do inherently limit the amount of concurrent I/O possible. However, as there "
"are usually a few thousand filesystem buffers available, this is not usually "
"a problem."
msgstr ""
"O FreeBSD reserva uma quantidade limitada de KVM para conter os mapeamentos "
"de struct bufs, mas deve ficar claro que este KVM � usado apenas para manter "
"mapeamentos e n�o limita a capacidade de armazenar dados em cache. O cache "
"de dados f�sicos � estritamente uma fun��o de <literal> vm_page_t </literal> "
"n�o s�o buffers de sistema de arquivos. No entanto, como os buffers do "
"sistema de arquivos s�o usados ​​para posicionar E / S, eles limitam "
"inerentemente a quantidade de E / S simult�nea poss�vel. No entanto, como "
"geralmente h� alguns milhares de buffers de sistema de arquivos dispon�veis, "
"isso geralmente n�o � um problema. "

#. (itstool) path: sect1/title
#: book.translate.xml:14745
#, fuzzy
msgid "Mapping Page Tables—<literal>vm_map_t, vm_entry_t</literal>"
msgstr "Mapping Page Tables— <literal> vm_map_t, vm_entry_t </literal> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14748
#, fuzzy
msgid "<primary>page tables</primary>"
msgstr " <primary> tabelas de p�ginas </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14749
#, fuzzy
msgid ""
"FreeBSD separates the physical page table topology from the VM system. All "
"hard per-process page tables can be reconstructed on the fly and are usually "
"considered throwaway. Special page tables such as those managing KVM are "
"typically permanently preallocated. These page tables are not throwaway."
msgstr ""
"O FreeBSD separa a topologia da tabela de p�ginas f�sicas do sistema VM. "
"Todas as tabelas de p�ginas dif�ceis por processo podem ser reconstru�das "
"rapidamente e s�o geralmente consideradas descart�veis. Tabelas de p�ginas "
"especiais como aquelas que gerenciam KVM s�o tipicamente pr�-alocadas "
"permanentemente. jogar fora."

#. (itstool) path: sect1/para
#: book.translate.xml:14756
#, fuzzy
msgid ""
"FreeBSD associates portions of vm_objects with address ranges in virtual "
"memory through <literal>vm_map_t</literal> and <literal>vm_entry_t</literal> "
"structures. Page tables are directly synthesized from the <literal>vm_map_t</"
"literal>/<literal>vm_entry_t</literal>/ <literal>vm_object_t</literal> "
"hierarchy. Recall that I mentioned that physical pages are only directly "
"associated with a <literal>vm_object</literal>; that is not quite true. "
"<literal>vm_page_t</literal>'s are also linked into page tables that they "
"are actively associated with. One <literal>vm_page_t</literal> can be linked "
"into several <emphasis>pmaps</emphasis>, as page tables are called. However, "
"the hierarchical association holds, so all references to the same page in "
"the same object reference the same <literal>vm_page_t</literal> and thus "
"give us buffer cache unification across the board."
msgstr ""
"O FreeBSD associa por��es de vm_objects com intervalos de endere�o na "
"mem�ria virtual atrav�s de <literal> vm_map_t </literal> e <literal> "
"vm_entry_t </literal> estruturas. Tabelas de p�gina s�o diretamente "
"sintetizadas a partir do <literal> vm_map_t </literal> / <literal> "
"vm_entry_t </literal> / <literal> vm_object_t </literal> hierarquia. Lembre-"
"se de que mencionei que as p�ginas f�sicas s�o associadas diretamente a "
"<literal> vm_object </literal> ; isso n�o � bem verdade. <literal> vm_page_t "
"</literal> tamb�m est�o ligados a tabelas de p�ginas com as quais est�o "
"ativamente associados. 1 <literal> vm_page_t </literal> pode ser ligado em "
"v�rios <emphasis> pmaps </emphasis> , como as tabelas de p�ginas s�o "
"chamadas. No entanto, a associa��o hier�rquica � v�lida, portanto, todas as "
"refer�ncias � mesma p�gina no mesmo objeto fazem refer�ncia ao mesmo "
"<literal> vm_page_t </literal> e assim nos dar a unifica��o do cache de "
"buffer atrav�s da placa. "

#. (itstool) path: sect1/title
#: book.translate.xml:14775
#, fuzzy
msgid "KVM Memory Mapping"
msgstr "Mapeamento de mem�ria KVM"

#. (itstool) path: sect1/para
#: book.translate.xml:14777
#, fuzzy
msgid ""
"FreeBSD uses KVM to hold various kernel structures. The single largest "
"entity held in KVM is the filesystem buffer cache. That is, mappings "
"relating to <literal>struct buf</literal> entities."
msgstr ""
"O FreeBSD usa o KVM para armazenar v�rias estruturas de kernel. A maior "
"entidade individual mantida no KVM � o cache de buffer do sistema de "
"arquivos. Ou seja, mapeamentos relacionados a <literal> struct buf </"
"literal> entidades."

#. (itstool) path: sect1/para
#: book.translate.xml:14782
#, fuzzy
msgid ""
"Unlike Linux, FreeBSD does <emphasis>not</emphasis> map all of physical "
"memory into KVM. This means that FreeBSD can handle memory configurations up "
"to 4G on 32 bit platforms. In fact, if the mmu were capable of it, FreeBSD "
"could theoretically handle memory configurations up to 8TB on a 32 bit "
"platform. However, since most 32 bit platforms are only capable of mapping "
"4GB of ram, this is a moot point."
msgstr ""
"Ao contr�rio do Linux, o FreeBSD faz <emphasis> n�o </emphasis> mapear toda "
"a mem�ria f�sica para o KVM. Isso significa que o FreeBSD pode manipular "
"configura��es de mem�ria de at� 4G em plataformas de 32 bits. De fato, se o "
"mmu fosse capaz disso, o FreeBSD teoricamente poderia manipular "
"configura��es de mem�ria de at� 8 TB em uma plataforma de 32 bits. No "
"entanto, como a maioria das plataformas de 32 bits s� � capaz de mapear 4 GB "
"de RAM, isso � um ponto discut�vel. "

#. (itstool) path: sect1/para
#: book.translate.xml:14790
#, fuzzy
msgid ""
"KVM is managed through several mechanisms. The main mechanism used to manage "
"KVM is the <emphasis>zone allocator</emphasis>. The zone allocator takes a "
"chunk of KVM and splits it up into constant-sized blocks of memory in order "
"to allocate a specific type of structure. You can use <command>vmstat -m</"
"command> to get an overview of current KVM utilization broken down by zone."
msgstr ""
"O KVM � gerenciado atrav�s de v�rios mecanismos. O principal mecanismo usado "
"para gerenciar o KVM � o <emphasis> alocador de zona </emphasis> . O "
"alocador de zona pega um peda�o do KVM e o divide em blocos de mem�ria de "
"tamanho constante para alocar um tipo espec�fico de estrutura. Voc� pode "
"usar <command> vmstat -m </command> para obter uma vis�o geral da utiliza��o "
"atual da KVM dividida por zona. "

#. (itstool) path: sect1/title
#: book.translate.xml:14800
#, fuzzy
msgid "Tuning the FreeBSD VM System"
msgstr "Ajustando o sistema VM do FreeBSD"

#. (itstool) path: sect1/para
#: book.translate.xml:14802
#, fuzzy
msgid ""
"A concerted effort has been made to make the FreeBSD kernel dynamically tune "
"itself. Typically you do not need to mess with anything beyond the "
"<option>maxusers</option> and <option>NMBCLUSTERS</option> kernel config "
"options. That is, kernel compilation options specified in (typically) "
"<filename>/usr/src/sys/i386/conf/<replaceable>CONFIG_FILE</replaceable></"
"filename>. A description of all available kernel configuration options can "
"be found in <filename>/usr/src/sys/i386/conf/LINT</filename>."
msgstr ""
"Um esfor�o concentrado foi feito para fazer o kernel do FreeBSD se ajustar "
"dinamicamente. Normalmente voc� n�o precisa mexer com nada al�m do <option "
"value=maxusers> maxusers </option> e <option value=NMBCLUSTERS> NMBCLUSTERS "
"</option> op��es de configura��o do kernel. Isto �, op��es de compila��o do "
"kernel especificadas em (tipicamente) <filename> / usr / src / sys / i386 / "
"conf / <replaceable> CONFIG_FILE </replaceable></filename> . Uma descri��o "
"de todas as op��es de configura��o do kernel dispon�veis pode ser encontrada "
"em <filename> / usr / src / sys / i386 / conf / LINT </filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:14812
#, fuzzy
msgid ""
"In a large system configuration you may wish to increase <option>maxusers</"
"option>. Values typically range from 10 to 128. Note that raising "
"<option>maxusers</option> too high can cause the system to overflow "
"available KVM resulting in unpredictable operation. It is better to leave "
"<option>maxusers</option> at some reasonable number and add other options, "
"such as <option>NMBCLUSTERS</option>, to increase specific resources."
msgstr ""
"Em uma grande configura��o do sistema, voc� pode querer aumentar <option "
"value=maxusers> maxusers </option> . Os valores geralmente variam de 10 a "
"128. Observe que aumentar <option value=maxusers> maxusers </option> muito "
"alto pode fazer com que o sistema transborde KVM dispon�vel, resultando em "
"opera��o imprevis�vel. � melhor deixar <option value=maxusers> maxusers </"
"option> em algum n�mero razo�vel e adicionar outras op��es, como <option "
"value=NMBCLUSTERS> NMBCLUSTERS </option> , para aumentar recursos "
"espec�ficos \""

#. (itstool) path: sect1/para
#: book.translate.xml:14821
#, fuzzy
msgid ""
"If your system is going to use the network heavily, you may want to increase "
"<option>NMBCLUSTERS</option>. Typical values range from 1024 to 4096."
msgstr ""
"Se o seu sistema vai usar a rede pesadamente, voc� pode querer aumentar "
"<option value=NMBCLUSTERS> NMBCLUSTERS </option> . Valores t�picos variam de "
"1024 a 4096. "

#. (itstool) path: sect1/para
#: book.translate.xml:14825
#, fuzzy
msgid ""
"The <literal>NBUF</literal> parameter is also traditionally used to scale "
"the system. This parameter determines the amount of KVA the system can use "
"to map filesystem buffers for I/O. Note that this parameter has nothing "
"whatsoever to do with the unified buffer cache! This parameter is "
"dynamically tuned in 3.0-CURRENT and later kernels and should generally not "
"be adjusted manually. We recommend that you <emphasis>not</emphasis> try to "
"specify an <literal>NBUF</literal> parameter. Let the system pick it. Too "
"small a value can result in extremely inefficient filesystem operation while "
"too large a value can starve the page queues by causing too many pages to "
"become wired down."
msgstr ""
"O <literal> NBUF </literal> par�metro tamb�m � tradicionalmente usado para "
"dimensionar o sistema. Esse par�metro determina a quantidade de KVA que o "
"sistema pode usar para mapear buffers de sistema de arquivos para E / S. "
"Note que este par��metro n�o tem nada a ver com o cache de buffer unificado! "
"Este par�metro � dinamicamente ajustado nos kernels 3.0-CURRENT e "
"posteriores e geralmente n�o deve ser ajustado manualmente. Recomendamos que "
"voc� <emphasis> n�o </emphasis> tente especificar um <literal> NBUF </"
"literal> par�metro. Deixe o sistema selecion�-lo. Um valor muito pequeno "
"pode resultar em opera��o do sistema de arquivos extremamente ineficiente, "
"enquanto um valor muito grande pode prejudicar as filas de p�ginas, fazendo "
"com que muitas p�ginas fiquem inativas. "

#. (itstool) path: sect1/para
#: book.translate.xml:14838
#, fuzzy
msgid ""
"By default, FreeBSD kernels are not optimized. You can set debugging and "
"optimization flags with the <literal>makeoptions</literal> directive in the "
"kernel configuration. Note that you should not use <option>-g</option> "
"unless you can accommodate the large (typically 7 MB+) kernels that result."
msgstr ""
"Por padr�o, os kernels do FreeBSD n�o s�o otimizados. Voc� pode definir "
"sinalizadores de depura��o e otimiza��o com o <literal> makeoptions </"
"literal> diretiva na configura��o do kernel. Note que voc� n�o deve usar "
"<option value=-g> -g </option> a menos que voc� possa acomodar os kernels "
"grandes (normalmente de 7 MB +) resultantes. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:14845
#, no-wrap
msgid "makeoptions      DEBUG=\"-g\"\n"
"makeoptions      COPTFLAGS=\"-O -pipe\""
msgstr "makeoptions      DEBUG=\"-g\"\n"
"makeoptions      COPTFLAGS=\"-O -pipe\""

#. (itstool) path: sect1/para
#: book.translate.xml:14848
#, fuzzy
msgid ""
"Sysctl provides a way to tune kernel parameters at run-time. You typically "
"do not need to mess with any of the sysctl variables, especially the VM "
"related ones."
msgstr ""
"O Sysctl fornece uma maneira de ajustar os par�metros do kernel em tempo de "
"execu��o. Voc� normalmente n�o precisa mexer em nenhuma das vari�veis ​​do "
"sysctl, especialmente aquelas relacionadas � VM."

#. (itstool) path: sect1/para
#: book.translate.xml:14852
#, fuzzy
msgid ""
"Run time VM and system tuning is relatively straightforward. First, use Soft "
"Updates on your UFS/FFS filesystems whenever possible. <filename>/usr/src/"
"sys/ufs/ffs/README.softupdates</filename> contains instructions (and "
"restrictions) on how to configure it."
msgstr ""
"A VM de tempo de execu��o e o ajuste do sistema s�o relativamente diretos. "
"Primeiro, use as Soft Updates nos seus sistemas de arquivos UFS / FFS sempre "
"que poss�vel. <filename> /usr/src/sys/ufs/ffs/README.softupdates </filename> "
"cont�m instru��es (e restri��es) sobre como configur�-lo. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14859
#, fuzzy
msgid "<primary>swap partition</primary>"
msgstr " <primary> parti��o swap </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14860
#, fuzzy
msgid ""
"Second, configure sufficient swap. You should have a swap partition "
"configured on each physical disk, up to four, even on your <quote>work</"
"quote> disks. You should have at least 2x the swap space as you have main "
"memory, and possibly even more if you do not have a lot of memory. You "
"should also size your swap partition based on the maximum memory "
"configuration you ever intend to put on the machine so you do not have to "
"repartition your disks later on. If you want to be able to accommodate a "
"crash dump, your first swap partition must be at least as large as main "
"memory and <filename>/var/crash</filename> must have sufficient free space "
"to hold the dump."
msgstr ""
"Segundo, configure uma troca suficiente. Voc� deve ter uma parti��o swap "
"configurada em cada disco f�sico, at� quatro, mesmo no seu <quote> trabalhos "
"</quote> discos. Voc� deve ter pelo menos 2x o espa�o de troca como voc� tem "
"mem�ria principal, e possivelmente ainda mais se voc� n�o tiver muita "
"mem�ria. Voc� tamb�m deve dimensionar sua parti��o de troca com base na "
"configura��o m�xima de mem�ria que voc� pretende colocar na m�quina para que "
"n�o seja necess�rio reparticionar seus discos posteriormente. Se voc� quiser "
"ser capaz de acomodar um despejo de mem�ria, sua primeira parti��o de troca "
"deve ser pelo menos t�o grande quanto a mem�ria principal e <filename> / var "
"/ crash </filename> deve ter espa�o livre suficiente para guardar o lixo. "

#. (itstool) path: sect1/para
#: book.translate.xml:14872
#, fuzzy
msgid ""
"NFS-based swap is perfectly acceptable on 4.X or later systems, but you must "
"be aware that the NFS server will take the brunt of the paging load."
msgstr ""
"A troca baseada em NFS � perfeitamente aceit�vel em sistemas 4.X ou "
"posteriores, mas voc� deve estar ciente de que o servidor NFS ir� receber o "
"peso da carga de pagina��o."

#. (itstool) path: info/title
#: book.translate.xml:14886
#, fuzzy
msgid "SMPng Design Document"
msgstr "Documento de Projeto SMPng"

#. (itstool) path: authorgroup/author
#: book.translate.xml:14888
#, fuzzy
msgid ""
"<personname><firstname>John</firstname><surname>Baldwin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> John </firstname><surname> Baldwin </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:14889
#, fuzzy
msgid ""
"<personname><firstname>Robert</firstname><surname>Watson</surname></"
"personname>"
msgstr ""
" <personname><firstname> Robert </firstname><surname> Watson </surname></"
"personname> "

#. (itstool) path: info/copyright
#: book.translate.xml:14892
#, fuzzy
msgid ""
"<year>2002</year> <year>2004</year> <year>2005</year> <holder>John Baldwin</"
"holder> <holder>Robert Watson</holder>"
msgstr ""
" <year> 2002 </year><year> 2004 </year><year> 2005 </year><holder> John "
"Baldwin </holder><holder> Robert Watson </holder> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14906
#, fuzzy
msgid "<primary>SMP Next Generation</primary>"
msgstr " <primary> SMP Next Generation </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14907
#, fuzzy
msgid "<primary>kernel synchronization</primary>"
msgstr " <primary> sincroniza��o do kernel </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14909
#, fuzzy
msgid ""
"This document presents the current design and implementation of the SMPng "
"Architecture. First, the basic primitives and tools are introduced. Next, a "
"general architecture for the FreeBSD kernel's synchronization and execution "
"model is laid out. Then, locking strategies for specific subsystems are "
"discussed, documenting the approaches taken to introduce fine-grained "
"synchronization and parallelism for each subsystem. Finally, detailed "
"implementation notes are provided to motivate design choices, and make the "
"reader aware of important implications involving the use of specific "
"primitives."
msgstr ""
"Este documento apresenta o projeto atual e a implementa��o da Arquitetura "
"SMPng. Primeiro, as primitivas e ferramentas b�sicas s�o apresentadas. Em "
"seguida, � apresentada uma arquitetura geral para o modelo de execu��o e "
"sincroniza��o do kernel do FreeBSD. Ent�o, estrat�gias de bloqueio para "
"subsistemas espec�ficos s�o discutidas. , documentando as abordagens "
"adotadas para introduzir sincroniza��o e paralelismo de alta granularidade "
"para cada subsistema. Finalmente, notas de implementa��o detalhadas s�o "
"fornecidas para motivar as escolhas de design e tornar o leitor ciente de "
"implica��es importantes envolvendo o uso de primitivos espec�ficos. "

#. (itstool) path: sect1/para
#: book.translate.xml:14920
#, fuzzy
msgid ""
"This document is a work-in-progress, and will be updated to reflect on-going "
"design and implementation activities associated with the SMPng Project. Many "
"sections currently exist only in outline form, but will be fleshed out as "
"work proceeds. Updates or suggestions regarding the document may be directed "
"to the document editors."
msgstr ""
"Este documento � um trabalho em andamento e ser� atualizado para refletir as "
"atividades de projeto e implementa��o associadas ao Projeto SMPng. Muitas "
"se��es existem atualmente apenas em forma de t�picos, mas ser�o "
"desenvolvidas � medida que o trabalho prossegue. Atualiza��es ou sugest�es "
"relativas ao documento podem ser direcionadas aos editores de documentos. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:14927
#, fuzzy
msgid "<primary>concurrency</primary>"
msgstr " <primary> simultaneidade </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:14928
#, fuzzy
msgid ""
"The goal of SMPng is to allow concurrency in the kernel. The kernel is "
"basically one rather large and complex program. To make the kernel multi-"
"threaded we use some of the same tools used to make other programs multi-"
"threaded. These include mutexes, shared/exclusive locks, semaphores, and "
"condition variables. For the definitions of these and other SMP-related "
"terms, please see the <xref linkend=\"smp-glossary\"/> section of this "
"article."
msgstr ""
"O objetivo do SMPng � permitir a simultaneidade no kernel. O kernel � "
"basicamente um programa bastante grande e complexo. Para fazer o kernel "
"multi-threaded usamos algumas das mesmas ferramentas usadas para fazer "
"outros programas multi-threaded. Estes incluem mutexes , bloqueios "
"compartilhados / exclusivos, sem�foros e vari�veis ​​de condi��o. Para as "
"defini��es desses e de outros termos relacionados a PMS, consulte <xref "
"linkend=\"smp-glossary\"/> se��o deste artigo. "

#. (itstool) path: sect1/title
#: book.translate.xml:14938
#, fuzzy
msgid "Basic Tools and Locking Fundamentals"
msgstr "Ferramentas B�sicas e Fundamentos de Bloqueio"

#. (itstool) path: sect2/title
#: book.translate.xml:14941
#, fuzzy
msgid "Atomic Instructions and Memory Barriers"
msgstr "Instru��es at�micas e barreiras de mem�ria"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:14943
#, fuzzy
msgid "<primary>atomic instructions</primary>"
msgstr " <primary> instru��es at�micas </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:14944
#, fuzzy
msgid "<primary>memory barriers</primary>"
msgstr " <primary> barreiras de mem�ria </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:14946
#, fuzzy
msgid ""
"There are several existing treatments of memory barriers and atomic "
"instructions, so this section will not include a lot of detail. To put it "
"simply, one can not go around reading variables without a lock if a lock is "
"used to protect writes to that variable. This becomes obvious when you "
"consider that memory barriers simply determine relative order of memory "
"operations; they do not make any guarantee about timing of memory operations."
" That is, a memory barrier does not force the contents of a CPU's local "
"cache or store buffer to flush. Instead, the memory barrier at lock release "
"simply ensures that all writes to the protected data will be visible to "
"other CPU's or devices if the write to release the lock is visible. The CPU "
"is free to keep that data in its cache or store buffer as long as it wants. "
"However, if another CPU performs an atomic instruction on the same datum, "
"the first CPU must guarantee that the updated value is made visible to the "
"second CPU along with any other operations that memory barriers may require."
msgstr ""
"H� v�rios tratamentos existentes de barreiras de mem�ria e instru��es "
"at�micas, portanto esta se��o n�o incluir� muitos detalhes. Para "
"simplificar, n�o � poss�vel ler vari�veis ​​sem um bloqueio se um bloqueio "
"for usado para proteger as grava��es nessa vari�vel Isso fica �bvio quando "
"voc� considera que as barreiras de mem�ria simplesmente determinam a ordem "
"relativa das opera��es de mem�ria, elas n�o garantem o tempo das opera��es "
"de mem�ria, ou seja, uma barreira de mem�ria n�o for�a o conte�do do cache "
"local Em vez disso, a barreira de mem�ria na libera��o de bloqueio "
"simplesmente garante que todas as grava��es nos dados protegidos ficar�o "
"vis�veis para outras CPUs ou dispositivos, se a grava��o para liberar o "
"bloqueio estiver vis�vel.A CPU est� livre para manter esses dados em seu "
"cache ou armazenar Entretanto, se outra CPU executar uma instru��o at�mica "
"no mesmo datum, a primeira CPU deve garantir que o valor atualizado fique "
"vis�vel para a segunda CPU junto com qualquer outra opera��o. ns que as "
"barreiras de mem�ria podem exigir. "

#. (itstool) path: sect2/para
#: book.translate.xml:14965
#, fuzzy
msgid ""
"For example, assuming a simple model where data is considered visible when "
"it is in main memory (or a global cache), when an atomic instruction is "
"triggered on one CPU, other CPU's store buffers and caches must flush any "
"writes to that same cache line along with any pending operations behind a "
"memory barrier."
msgstr ""
"Por exemplo, supondo um modelo simples em que os dados s�o considerados "
"vis�veis quando est�o na mem�ria principal (ou em um cache global), quando "
"uma instru��o at��mica � acionada em uma CPU, os buffers e caches de "
"armazenamento de outra CPU precisam liberar as grava��es para o mesmo cache "
"linha junto com quaisquer opera��es pendentes por tr�s de uma barreira de "
"mem�ria. "

#. (itstool) path: sect2/para
#: book.translate.xml:14972
#, fuzzy
msgid ""
"This requires one to take special care when using an item protected by "
"atomic instructions. For example, in the sleep mutex implementation, we have "
"to use an <function>atomic_cmpset</function> rather than an "
"<function>atomic_set</function> to turn on the <constant>MTX_CONTESTED</"
"constant> bit. The reason is that we read the value of <varname remap="
"\"structfield\">mtx_lock</varname> into a variable and then make a decision "
"based on that read. However, the value we read may be stale, or it may "
"change while we are making our decision. Thus, when the "
"<function>atomic_set</function> executed, it may end up setting the bit on "
"another value than the one we made the decision on. Thus, we have to use an "
"<function>atomic_cmpset</function> to set the value only if the value we "
"made the decision on is up-to-date and valid."
msgstr ""
"Isso requer um cuidado especial ao usar um item protegido por instru��es "
"at�micas. Por exemplo, na implementa��o do mutex de suspens�o, temos que "
"usar um <function> atomic_cmpset </function> em vez de um <function> "
"atomic_set </function> para ligar o <constant> MTX_CONTESTED </constant> "
"pouco. A raz�o � que lemos o valor de <varname remap=\"structfield\"> "
"mtx_lock </varname> em uma vari�vel e, em seguida, tomar uma decis�o com "
"base nessa leitura. No entanto, o valor que lemos pode estar obsoleto ou "
"pode mudar enquanto tomamos nossa decis�o. Assim, quando o <function> "
"atomic_set </function> executado, pode acabar definindo o bit em outro valor "
"diferente daquele em que tomamos a decis�o. Assim, temos que usar um "
"<function> atomic_cmpset </function> para definir o valor apenas se o valor "
"em que tomamos a decis�o estiver atualizado e v�lido. "

#. (itstool) path: sect2/para
#: book.translate.xml:14989
#, fuzzy
msgid ""
"Finally, atomic instructions only allow one item to be updated or read. If "
"one needs to atomically update several items, then a lock must be used "
"instead. For example, if two counters must be read and have values that are "
"consistent relative to each other, then those counters must be protected by "
"a lock rather than by separate atomic instructions."
msgstr ""
"Finalmente, as instru��es at�micas permitem apenas que um item seja "
"atualizado ou lido. Se for necess�rio atualizar atomicamente v�rios itens, "
"um bloqueio deve ser usado. Por exemplo, se dois contadores precisarem ser "
"lidos e ter valores consistentes em rela��o a cada item outros, ent�o esses "
"contadores devem ser protegidos por um bloqueio, e n�o por instru��es "
"at�micas separadas. "

#. (itstool) path: sect2/title
#: book.translate.xml:14998
#, fuzzy
msgid "Read Locks Versus Write Locks"
msgstr "Ler bloqueios versus bloqueios de grava��o"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15000
#, fuzzy
msgid "<primary>read locks</primary>"
msgstr " <primary> leia bloqueios </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15001
#, fuzzy
msgid "<primary>write locks</primary>"
msgstr " <primary> escrever bloqueios </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15002
#, fuzzy
msgid ""
"Read locks do not need to be as strong as write locks. Both types of locks "
"need to ensure that the data they are accessing is not stale. However, only "
"write access requires exclusive access. Multiple threads can safely read a "
"value. Using different types of locks for reads and writes can be "
"implemented in a number of ways."
msgstr ""
"Os bloqueios de leitura n�o precisam ser t�o fortes quanto os bloqueios de "
"grava��o. Os dois tipos de bloqueios precisam garantir que os dados que "
"est�o acessando n�o sejam obsoletos. No entanto, somente o acesso de "
"grava��o requer acesso exclusivo. V�rios segmentos podem ler um valor com "
"seguran�a. tipos de bloqueios para leituras e grava��es podem ser "
"implementados de v�rias maneiras. "

#. (itstool) path: sect2/para
#: book.translate.xml:15009
#, fuzzy
msgid ""
"First, sx locks can be used in this manner by using an exclusive lock when "
"writing and a shared lock when reading. This method is quite straightforward."
""
msgstr ""
"Primeiro, os bloqueios sx podem ser usados ​​dessa maneira usando um "
"bloqueio exclusivo ao escrever e um bloqueio compartilhado durante a leitura."
" Esse m�todo � bastante simples."

#. (itstool) path: sect2/para
#: book.translate.xml:15013
#, fuzzy
msgid ""
"A second method is a bit more obscure. You can protect a datum with multiple "
"locks. Then for reading that data you simply need to have a read lock of one "
"of the locks. However, to write to the data, you need to have a write lock "
"of all of the locks. This can make writing rather expensive but can be "
"useful when data is accessed in various ways. For example, the parent "
"process pointer is protected by both the <varname>proctree_lock</varname> sx "
"lock and the per-process mutex. Sometimes the proc lock is easier as we are "
"just checking to see who a parent of a process is that we already have "
"locked. However, other places such as <function>inferior</function> need to "
"walk the tree of processes via parent pointers and locking each process "
"would be prohibitive as well as a pain to guarantee that the condition you "
"are checking remains valid for both the check and the actions taken as a "
"result of the check."
msgstr ""
"Um segundo m�todo � um pouco mais obscuro. Voc� pode proteger um datum com "
"v�rios bloqueios. Em seguida, para ler esses dados, basta ter um bloqueio de "
"leitura de um dos bloqueios. No entanto, para gravar os dados, voc� precisa "
"ter um bloqueio de grava��o de todos os bloqueios. Isso pode tornar a "
"escrita bastante cara, mas pode ser �til quando os dados s�o acessados ​​de "
"v�rias maneiras. Por exemplo, o ponteiro de processo pai � protegido por "
"ambos <varname> proctree_lock </varname> sx lock e o mutex por processo. �s "
"vezes, o proc lock � mais f�cil, pois estamos apenas verificando quem � pai "
"de um processo e j� estamos bloqueados. Por�m, outros lugares como "
"<function> inferior </function> precisa percorrer a �rvore de processos "
"atrav�s de ponteiros pai e bloquear cada processo seria proibitivo, assim "
"como uma dor para garantir que a condi��o que voc� est� verificando "
"permane�a v�lida tanto para a verifica��o quanto para as a��es tomadas como "
"resultado da verifica��o. "

#. (itstool) path: sect2/title
#: book.translate.xml:15032
#, fuzzy
msgid "Locking Conditions and Results"
msgstr "Condi��es de bloqueio e resultados"

#. (itstool) path: sect2/para
#: book.translate.xml:15034
#, fuzzy
msgid ""
"If you need a lock to check the state of a variable so that you can take an "
"action based on the state you read, you can not just hold the lock while "
"reading the variable and then drop the lock before you act on the value you "
"read. Once you drop the lock, the variable can change rendering your "
"decision invalid. Thus, you must hold the lock both while reading the "
"variable and while performing the action as a result of the test."
msgstr ""
"Se voc� precisa de um bloqueio para verificar o estado de uma vari�vel para "
"que possa realizar uma a��o com base no estado que voc� leu, n�o � poss�vel "
"manter o bloqueio enquanto l� a vari�vel e soltar o bloqueio antes de agir "
"no valor que voc� Uma vez que voc� soltar o bloqueio, a vari�vel pode mudar "
"tornando sua decis�o inv�lida. Assim, voc� deve manter o bloqueio tanto "
"durante a leitura da vari�vel e durante a execu��o da a��o como resultado do "
"teste. "

#. (itstool) path: sect1/title
#: book.translate.xml:15046
#, fuzzy
msgid "General Architecture and Design"
msgstr "Arquitetura Geral e Design"

#. (itstool) path: sect2/title
#: book.translate.xml:15049
#, fuzzy
msgid "Interrupt Handling"
msgstr "Interrupt Handling"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15051
#, fuzzy
msgid "<primary>interrupt handling</primary>"
msgstr " <primary> manuseio de interrup��es </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15053
#, fuzzy
msgid ""
"Following the pattern of several other multi-threaded <trademark class="
"\"registered\">UNIX</trademark> kernels, FreeBSD deals with interrupt "
"handlers by giving them their own thread context. Providing a context for "
"interrupt handlers allows them to block on locks. To help avoid latency, "
"however, interrupt threads run at real-time kernel priority. Thus, interrupt "
"handlers should not execute for very long to avoid starving other kernel "
"threads. In addition, since multiple handlers may share an interrupt thread, "
"interrupt handlers should not sleep or use a sleepable lock to avoid "
"starving another interrupt handler."
msgstr ""
"Seguindo o padr�o de v�rios outros multi-threaded <trademark class="
"\"registered\"> UNIX </trademark> kernels, o FreeBSD lida com manipuladores "
"de interrup��o, dando-lhes seu pr�prio contexto de encadeamento. Fornecer um "
"contexto para os manipuladores de interrup��o permite bloquear bloqueios. "
"Para ajudar a evitar a lat�ncia, no entanto, os threads de interrup��o s�o "
"executados na prioridade do kernel em tempo real. Assim, os manipuladores de "
"interrup��o n�o devem ser executados por muito tempo para evitar que outros "
"segmentos do kernel fiquem com fome. Al�m disso, como v�rios manipuladores "
"podem compartilhar um encadeamento de interrup��o, os manipuladores de "
"interrup��o n�o devem dormir ou usar um bloqueio adormecido para evitar "
"passar fome a outro manipulador de interrup��o. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15064
#, fuzzy
msgid "<primary>interrupt threads</primary>"
msgstr " <primary> interromper t�picos </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15066
#, fuzzy
msgid ""
"The interrupt threads currently in FreeBSD are referred to as heavyweight "
"interrupt threads. They are called this because switching to an interrupt "
"thread involves a full context switch. In the initial implementation, the "
"kernel was not preemptive and thus interrupts that interrupted a kernel "
"thread would have to wait until the kernel thread blocked or returned to "
"userland before they would have an opportunity to run."
msgstr ""
"Os threads de interrup��o atualmente no FreeBSD s�o chamados de threads de "
"interrup��o de peso. Eles s�o chamados porque mudar para um thread de "
"interrup��o envolve um switch de contexto completo. Na implementa��o "
"inicial, o kernel n�o era preemptivo e assim interrup��es que interrompiam "
"um thread do kernel tem que esperar at� que o thread do kernel seja "
"bloqueado ou retornado ao userland antes que eles tenham a oportunidade de "
"executar. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15075
#, fuzzy
msgid "<primary>latency</primary>"
msgstr " <primary> lat�ncia </primary> "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15076
#, fuzzy
msgid "<primary>preemption</primary>"
msgstr " <primary> preemp��o </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15078
#, fuzzy
msgid ""
"To deal with the latency problems, the kernel in FreeBSD has been made "
"preemptive. Currently, we only preempt a kernel thread when we release a "
"sleep mutex or when an interrupt comes in. However, the plan is to make the "
"FreeBSD kernel fully preemptive as described below."
msgstr ""
"Para lidar com os problemas de lat�ncia, o kernel do FreeBSD tornou-se "
"preemptivo. Atualmente, n�s apenas preemptamos um thread do kernel quando "
"lan�amos um mutex de suspens�o ou quando uma interrup��o entra. No entanto, "
"o plano � fazer com que o kernel do FreeBSD seja totalmente preventivo. como "
"descrito abaixo."

#. (itstool) path: sect2/para
#: book.translate.xml:15084
#, fuzzy
msgid ""
"Not all interrupt handlers execute in a thread context. Instead, some "
"handlers execute directly in primary interrupt context. These interrupt "
"handlers are currently misnamed <quote>fast</quote> interrupt handlers since "
"the <constant>INTR_FAST</constant> flag used in earlier versions of the "
"kernel is used to mark these handlers. The only interrupts which currently "
"use these types of interrupt handlers are clock interrupts and serial I/O "
"device interrupts. Since these handlers do not have their own context, they "
"may not acquire blocking locks and thus may only use spin mutexes."
msgstr ""
"Nem todos os manipuladores de interrup��o executam em um contexto de "
"encadeamento. Em vez disso, alguns manipuladores executam diretamente no "
"contexto de interrup��o principal. Esses manipuladores de interrup��o s�o "
"atualmente atribu�dos incorretamente <quote> velozes </quote> interromper "
"manipuladores desde o <constant> INTR_FAST </constant> flag usado em vers�es "
"anteriores do kernel � usado para marcar esses manipuladores. As �nicas "
"interrup��es que atualmente usam esses tipos de interrup��o s�o interrup��es "
"de clock e interrup��es de dispositivos de E / S serial. Como esses "
"manipuladores n�o t�m seu pr�prio contexto, eles podem n�o adquirir "
"bloqueios de bloqueio e, portanto, s� podem usar mutexes de rota��o. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15096
#, fuzzy
msgid "<primary>context switches</primary>"
msgstr " <primary> comutadores de contexto </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15098
#, fuzzy
msgid ""
"Finally, there is one optional optimization that can be added in MD code "
"called lightweight context switches. Since an interrupt thread executes in a "
"kernel context, it can borrow the vmspace of any process. Thus, in a "
"lightweight context switch, the switch to the interrupt thread does not "
"switch vmspaces but borrows the vmspace of the interrupted thread. In order "
"to ensure that the vmspace of the interrupted thread does not disappear out "
"from under us, the interrupted thread is not allowed to execute until the "
"interrupt thread is no longer borrowing its vmspace. This can happen when "
"the interrupt thread either blocks or finishes. If an interrupt thread "
"blocks, then it will use its own context when it is made runnable again. "
"Thus, it can release the interrupted thread."
msgstr ""
"Finalmente, h� uma otimiza��o opcional que pode ser adicionada no c�digo MD, "
"chamada de comutadores de contexto leves. Como um thread de interrup��o � "
"executado em um contexto de kernel, ele pode emprestar o vmspace de qualquer "
"processo. Assim, em um switch de contexto leve, o thread de interrup��o n�o "
"troca vmspaces, mas toma emprestado o vmspace do thread interrompido.A fim "
"de garantir que o vmspace do thread interrompido n�o desapare�a de debaixo "
"de n�s, o thread interrompido n�o tem permiss�o para executar at� que o "
"thread de interrup��o n�o seja mais emprestando seu vmspace. Isso pode "
"acontecer quando o thread de interrup��o bloqueia ou finaliza. Se um thread "
"de interrup��o bloquear, ele usar� seu pr�prio contexto quando for tornado "
"execut�vel novamente. Assim, ele pode liberar o thread interrompido. "

#. (itstool) path: sect2/para
#: book.translate.xml:15113
#, fuzzy
msgid ""
"The cons of this optimization are that they are very machine specific and "
"complex and thus only worth the effort if their is a large performance "
"improvement. At this point it is probably too early to tell, and in fact, "
"will probably hurt performance as almost all interrupt handlers will "
"immediately block on Giant and require a thread fix-up when they block. "
"Also, an alternative method of interrupt handling has been proposed by Mike "
"Smith that works like so:"
msgstr ""
"Os contras desta otimiza��o s�o que eles s�o muito espec�ficos da m�quina e "
"complexos e, portanto, s� valem o esfor�o se a sua for uma grande melhoria "
"de desempenho. Neste momento, � provavelmente cedo demais para dizer e, de "
"fato, provavelmente prejudicar� o desempenho como quase todos os "
"manipuladores de interrup��es bloquear�o imediatamente o Giant e exigir�o "
"uma corre��o de thread quando eles bloquearem. Al�m disso, um m�todo "
"alternativo de manipula��o de interrup��es foi proposto por Mike Smith que "
"funciona assim: "

#. (itstool) path: listitem/para
#: book.translate.xml:15124
#, fuzzy
msgid ""
"Each interrupt handler has two parts: a predicate which runs in primary "
"interrupt context and a handler which runs in its own thread context."
msgstr ""
"Cada manipulador de interrup��o tem duas partes: um predicado que � "
"executado no contexto de interrup��o prim�rio e um manipulador que � "
"executado em seu pr�prio contexto de encadeamento."

#. (itstool) path: listitem/para
#: book.translate.xml:15130
#, fuzzy
msgid ""
"If an interrupt handler has a predicate, then when an interrupt is "
"triggered, the predicate is run. If the predicate returns true then the "
"interrupt is assumed to be fully handled and the kernel returns from the "
"interrupt. If the predicate returns false or there is no predicate, then the "
"threaded handler is scheduled to run."
msgstr ""
"Se um manipulador de interrup��o tiver um predicado, quando uma interrup��o "
"for disparada, o predicado ser� executado. Se o predicado retornar "
"verdadeiro, presume-se que a interrup��o seja totalmente tratada e o kernel "
"retorna da interrup��o. Se o predicado retornar falso ou n�o � um predicado, "
"ent�o o manipulador encadeado est� programado para ser executado. "

#. (itstool) path: sect2/para
#: book.translate.xml:15139
#, fuzzy
msgid ""
"Fitting light weight context switches into this scheme might prove rather "
"complicated. Since we may want to change to this scheme at some point in the "
"future, it is probably best to defer work on light weight context switches "
"until we have settled on the final interrupt handling architecture and "
"determined how light weight context switches might or might not fit into it."
msgstr ""
"Ajustar contextos de peso leve a esse esquema pode ser um pouco complicado. "
"Como podemos querer mudar para esse esquema em algum momento no futuro, "
"provavelmente � melhor adiar o trabalho em interruptores de contexto de peso "
"leve at� termos resolvido a interrup��o final. lidando com a arquitetura e "
"determinando como as chaves de contexto leves podem ou n�o se encaixar nela. "
""

#. (itstool) path: sect2/title
#: book.translate.xml:15149
#, fuzzy
msgid "Kernel Preemption and Critical Sections"
msgstr "Preemp��o do kernel e se��es cr�ticas"

#. (itstool) path: sect3/title
#: book.translate.xml:15152
#, fuzzy
msgid "Kernel Preemption in a Nutshell"
msgstr "Preemp��o do kernel em poucas palavras"

#. (itstool) path: sect3/para
#: book.translate.xml:15154
#, fuzzy
msgid ""
"Kernel preemption is fairly simple. The basic idea is that a CPU should "
"always be doing the highest priority work available. Well, that is the ideal "
"at least. There are a couple of cases where the expense of achieving the "
"ideal is not worth being perfect."
msgstr ""
"Preemp��o do kernel � bastante simples. A id�ia b�sica � que uma CPU deve "
"sempre estar fazendo o trabalho de maior prioridade dispon�vel. Bem, isso � "
"o ideal, pelo menos. H� alguns casos em que a despesa de alcan�ar o ideal "
"n�o vale a pena ser perfeito."

#. (itstool) path: sect3/para
#: book.translate.xml:15160
#, fuzzy
msgid ""
"Implementing full kernel preemption is very straightforward: when you "
"schedule a thread to be executed by putting it on a run queue, you check to "
"see if its priority is higher than the currently executing thread. If so, "
"you initiate a context switch to that thread."
msgstr ""
"Implementar preemp��o completa do kernel � muito simples: quando voc� "
"programa um encadeamento para ser executado colocando-o em uma fila de "
"execu��o, voc� verifica se sua prioridade � maior do que o encadeamento "
"atualmente em execu��o. Nesse caso, voc� inicia uma altern�ncia de contexto "
"fio."

#. (itstool) path: sect3/para
#: book.translate.xml:15166
#, fuzzy
msgid ""
"While locks can protect most data in the case of a preemption, not all of "
"the kernel is preemption safe. For example, if a thread holding a spin mutex "
"preempted and the new thread attempts to grab the same spin mutex, the new "
"thread may spin forever as the interrupted thread may never get a chance to "
"execute. Also, some code such as the code to assign an address space number "
"for a process during <function>exec</function> on the Alpha needs to not be "
"preempted as it supports the actual context switch code. Preemption is "
"disabled for these code sections by using a critical section."
msgstr ""
"Embora os bloqueios possam proteger a maioria dos dados no caso de uma "
"preemp��o, nem todo o kernel � protegido por preemp��o. Por exemplo, se um "
"segmento que det�m um mutex de rota��o for antecipado e o novo thread tentar "
"obter o mesmo mutex de rota��o, o novo thread pode giram para sempre, pois o "
"thread interrompido pode nunca ter a chance de executar.Tamb�m, algum c�digo "
"como o c�digo para atribuir um n�mero de espa�o de endere�o para um processo "
"durante <function> exec </function> no Alpha n�o precisa ser preterido, pois "
"suporta o c�digo de mudan�a de contexto real. A preemp��o est� desativada "
"para essas se��es de c�digo usando uma se��o cr�tica. "

#. (itstool) path: sect3/title
#: book.translate.xml:15180
#, fuzzy
msgid "Critical Sections"
msgstr "Sec��es Cr�ticas"

#. (itstool) path: sect3/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:15182 book.translate.xml:15304
#, fuzzy
msgid "<primary>critical sections</primary>"
msgstr " <primary> se��es cr�ticas </primary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15184
#, fuzzy
msgid ""
"The responsibility of the critical section API is to prevent context "
"switches inside of a critical section. With a fully preemptive kernel, every "
"<function>setrunqueue</function> of a thread other than the current thread "
"is a preemption point. One implementation is for <function>critical_enter</"
"function> to set a per-thread flag that is cleared by its counterpart. If "
"<function>setrunqueue</function> is called with this flag set, it does not "
"preempt regardless of the priority of the new thread relative to the current "
"thread. However, since critical sections are used in spin mutexes to prevent "
"context switches and multiple spin mutexes can be acquired, the critical "
"section API must support nesting. For this reason the current implementation "
"uses a nesting count instead of a single per-thread flag."
msgstr ""
"A responsabilidade da API da se��o cr�tica � evitar interruptores de "
"contexto dentro de uma se��o cr�tica. Com um kernel totalmente preemptivo, "
"cada <function> setrunqueue </function> de um segmento diferente do segmento "
"atual � um ponto de preemp��o. Uma implementa��o � para <function> "
"critical_enter </function> para definir um sinalizador por thread que � "
"limpo por sua contraparte. E se <function> setrunqueue </function> � chamado "
"com este conjunto de sinalizadores, ele n�o se antecipa independentemente da "
"prioridade do novo encadeamento relativo ao encadeamento atual. No entanto, "
"como as se��es cr�ticas s�o usadas em mutexes de rota��o para evitar "
"comutadores de contexto e v�rios mutexes de rota��o podem ser adquiridos, a "
"API de se��o cr�tica deve oferecer suporte ao aninhamento. Por esse motivo, "
"a implementa��o atual usa uma contagem de aninhamento em vez de um �nico "
"sinalizador por thread. "

#. (itstool) path: sect3/para
#: book.translate.xml:15200
#, fuzzy
msgid ""
"In order to minimize latency, preemptions inside of a critical section are "
"deferred rather than dropped. If a thread that would normally be preempted "
"to is made runnable while the current thread is in a critical section, then "
"a per-thread flag is set to indicate that there is a pending preemption. "
"When the outermost critical section is exited, the flag is checked. If the "
"flag is set, then the current thread is preempted to allow the higher "
"priority thread to run."
msgstr ""
"Para minimizar a lat�ncia, as preemp��es dentro de uma se��o cr�tica s�o "
"adiadas em vez de descartadas. Se um encadeamento que normalmente seria "
"precedido for tornado execut�vel enquanto o encadeamento atual estiver em "
"uma se��o cr�tica, um sinalizador por encadeamento ser� definido como indica "
"que h� uma preemp��o pendente. Quando a se��o cr�tica mais externa � "
"encerrada, o sinalizador � verificado. Se o sinalizador estiver configurado, "
"o encadeamento atual ser� precedido para permitir que o encadeamento de "
"maior prioridade seja executado. "

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15210
#, fuzzy
msgid "<primary>spin mutexes</primary>"
msgstr " <primary> mutexes de spin </primary> "

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15211
#, fuzzy
msgid "<primary>mutexes</primary><secondary>spin</secondary>"
msgstr " <primary> mutexes </primary><secondary> girar </secondary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15212
#, fuzzy
msgid ""
"Interrupts pose a problem with regards to spin mutexes. If a low-level "
"interrupt handler needs a lock, it needs to not interrupt any code needing "
"that lock to avoid possible data structure corruption. Currently, providing "
"this mechanism is piggybacked onto critical section API by means of the "
"<function>cpu_critical_enter</function> and <function>cpu_critical_exit</"
"function> functions. Currently this API disables and re-enables interrupts "
"on all of FreeBSD's current platforms. This approach may not be purely "
"optimal, but it is simple to understand and simple to get right. "
"Theoretically, this second API need only be used for spin mutexes that are "
"used in primary interrupt context. However, to make the code simpler, it is "
"used for all spin mutexes and even all critical sections. It may be "
"desirable to split out the MD API from the MI API and only use it in "
"conjunction with the MI API in the spin mutex implementation. If this "
"approach is taken, then the MD API likely would need a rename to show that "
"it is a separate API."
msgstr ""
"Interrup��es representam um problema com rela��o a mutexes de rota��o. Se um "
"manipulador de interrup��o de baixo n�vel precisar de um bloqueio, ele n�o "
"precisar� interromper nenhum c�digo que precise desse bloqueio para evitar "
"poss�vel corrup��o da estrutura de dados. Atualmente, fornecer esse "
"mecanismo � inserido na se��o cr�tica API por meio do <function> "
"cpu_critical_enter </function> e <function> cpu_critical_exit </function> "
"fun��es. Atualmente esta API desativa e reativa interrup��es em todas as "
"plataformas atuais do FreeBSD. Essa abordagem pode n�o ser puramente ideal, "
"mas � simples de entender e simples de acertar. Teoricamente, esta segunda "
"API s� precisa ser usada para mutexes de spin que s�o usados ​​no contexto "
"de interrup��o prim�ria. No entanto, para tornar o c�digo mais simples, ele "
"� usado para todos os mutexes de spin e at� mesmo para todas as se��es "
"cr�ticas. Pode ser desej�vel dividir a API do MD da API do MI e us�-la "
"somente em conjunto com a API do MI na implementa��o do mutex de rota��o. Se "
"essa abordagem for adotada, a API do MD provavelmente precisaria de uma "
"renomea��o para mostrar que � uma API separada. "

#. (itstool) path: sect3/title
#: book.translate.xml:15234
#, fuzzy
msgid "Design Tradeoffs"
msgstr "Tradeoffs de design"

#. (itstool) path: sect3/para
#: book.translate.xml:15236
#, fuzzy
msgid ""
"As mentioned earlier, a couple of trade-offs have been made to sacrifice "
"cases where perfect preemption may not always provide the best performance."
msgstr ""
"Como mencionado anteriormente, algumas compensa��es foram feitas para "
"sacrificar casos em que a preemp��o perfeita nem sempre fornece o melhor "
"desempenho."

#. (itstool) path: sect3/para
#: book.translate.xml:15240
#, fuzzy
msgid ""
"The first trade-off is that the preemption code does not take other CPUs "
"into account. Suppose we have a two CPU's A and B with the priority of A's "
"thread as 4 and the priority of B's thread as 2. If CPU B makes a thread "
"with priority 1 runnable, then in theory, we want CPU A to switch to the new "
"thread so that we will be running the two highest priority runnable threads. "
"However, the cost of determining which CPU to enforce a preemption on as "
"well as actually signaling that CPU via an IPI along with the "
"synchronization that would be required would be enormous. Thus, the current "
"code would instead force CPU B to switch to the higher priority thread. Note "
"that this still puts the system in a better position as CPU B is executing a "
"thread of priority 1 rather than a thread of priority 2."
msgstr ""
"O primeiro trade-off � que o c�digo de preemp��o n�o leva em conta outras "
"CPUs. Suponha que tenhamos dois A e B de um processador com a prioridade do "
"encadeamento de A como 4 e a prioridade do encadeamento de B como 2. Se a "
"CPU B fizer uma thread com prioridade 1 execut�vel, ent�o, em teoria, "
"queremos que a CPU A mude para o novo thread, para que possamos executar os "
"dois threads execut�veis ​​de maior prioridade, mas o custo de determinar "
"para qual CPU aplicar uma preemp��o, bem como sinalizar que a CPU atrav�s de "
"um IPI, juntamente com a sincroniza��o que seria necess�ria seria enorme."
"Assim, o c�digo atual, em vez for�ar CPU B para mudar para o segmento de "
"maior prioridade.Note que isso ainda coloca o sistema em uma posi��o melhor "
"como CPU B est� executando um encadeamento de prioridade 1 em vez de um "
"encadeamento de prioridade 2. "

#. (itstool) path: sect3/para
#: book.translate.xml:15255
#, fuzzy
msgid ""
"The second trade-off limits immediate kernel preemption to real-time "
"priority kernel threads. In the simple case of preemption defined above, a "
"thread is always preempted immediately (or as soon as a critical section is "
"exited) if a higher priority thread is made runnable. However, many threads "
"executing in the kernel only execute in a kernel context for a short time "
"before either blocking or returning to userland. Thus, if the kernel "
"preempts these threads to run another non-realtime kernel thread, the kernel "
"may switch out the executing thread just before it is about to sleep or "
"execute. The cache on the CPU must then adjust to the new thread. When the "
"kernel returns to the preempted thread, it must refill all the cache "
"information that was lost. In addition, two extra context switches are "
"performed that could be avoided if the kernel deferred the preemption until "
"the first thread blocked or returned to userland. Thus, by default, the "
"preemption code will only preempt immediately if the higher priority thread "
"is a real-time priority thread."
msgstr ""
"O segundo trade-off limita a preemp��o imediata do kernel a threads de "
"kernel de prioridade em tempo real. No caso simples de preemp��o definido "
"acima, um thread � sempre preempted imediatamente (ou assim que uma se��o "
"cr�tica � encerrada) se um thread de prioridade mais alta for No entanto, "
"muitos threads executados no kernel s� executam em um contexto de kernel por "
"um curto per�odo de tempo antes de bloquear ou retornar a userland. O thread "
"na CPU deve ent�o se ajustar ao novo thread.Quando o kernel retorna para o "
"thread preempted, ele deve preencher todas as informa��es do cache que foram "
"perdidas.Al�m disso, o thread em execu��o antes da hora de dormir ou "
"executar. duas op��es de contexto extras s�o executadas, o que poderia ser "
"evitado se o kernel adiasse a preemp��o at� que o primeiro thread fosse "
"bloqueado ou retornado � userland. Assim, por padr�o, o c�digo de preemp��o "
"s� se antecipar� imediatamente se o thread de prioridade mais alta � um "
"thread de prioridade em tempo real. "

#. (itstool) path: sect3/para
#: book.translate.xml:15275
#, fuzzy
msgid ""
"Turning on full kernel preemption for all kernel threads has value as a "
"debugging aid since it exposes more race conditions. It is especially useful "
"on UP systems were many races are hard to simulate otherwise. Thus, there is "
"a kernel option <literal>FULL_PREEMPTION</literal> to enable preemption for "
"all kernel threads that can be used for debugging purposes."
msgstr ""
"Ativar a preemp��o total do kernel para todos os encadeamentos do kernel tem "
"valor como um aux�lio de depura��o, pois exp�e mais condi��es de corrida. � "
"especialmente �til em sistemas UP, pois muitas corridas s�o dif�ceis de "
"serem simuladas. Assim, h� uma op��o de kernel <literal> FULL_PREEMPTION </"
"literal> para ativar a preemp��o para todos os encadeamentos do kernel que "
"podem ser usados ​​para prop�sitos de depura��o. "

#. (itstool) path: sect2/title
#: book.translate.xml:15286
#, fuzzy
msgid "Thread Migration"
msgstr "Thread Migration"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15288
#, fuzzy
msgid "<primary>thread migration</primary>"
msgstr " <primary> migra��o de thread </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15290
#, fuzzy
msgid ""
"Simply put, a thread migrates when it moves from one CPU to another. In a "
"non-preemptive kernel this can only happen at well-defined points such as "
"when calling <function>msleep</function> or returning to userland. However, "
"in the preemptive kernel, an interrupt can force a preemption and possible "
"migration at any time. This can have negative affects on per-CPU data since "
"with the exception of <varname>curthread</varname> and <varname>curpcb</"
"varname> the data can change whenever you migrate. Since you can potentially "
"migrate at any time this renders unprotected per-CPU data access rather "
"useless. Thus it is desirable to be able to disable migration for sections "
"of code that need per-CPU data to be stable."
msgstr ""
"Simplificando, um thread migra quando se move de um CPU para outro. Em um "
"kernel n�o preemptiva, isso s� pode acontecer em pontos bem definidos, como "
"quando se chama <function> msleep </function> ou retornando ao userland. No "
"entanto, no kernel preemptivo, uma interrup��o pode for�ar uma preemp��o e "
"uma poss�vel migra��o a qualquer momento. Isso pode ter efeitos negativos "
"nos dados por CPU, pois, com a exce��o de <varname> encurtar </varname> e "
"<varname> curpcb </varname> os dados podem mudar sempre que voc� migrar. "
"Como voc� pode migrar a qualquer momento, isso torna o acesso aos dados "
"desprotegidos por CPU um pouco in�til. Assim, � desej�vel poder desabilitar "
"a migra��o para se��es de c�digo que precisam de dados por CPU para serem "
"est�veis. "

#. (itstool) path: sect2/para
#: book.translate.xml:15306
#, fuzzy
msgid ""
"Critical sections currently prevent migration since they do not allow "
"context switches. However, this may be too strong of a requirement to "
"enforce in some cases since a critical section also effectively blocks "
"interrupt threads on the current processor. As a result, another API has "
"been provided to allow the current thread to indicate that if it preempted "
"it should not migrate to another CPU."
msgstr ""
"As se��es cr�ticas atualmente impedem a migra��o, pois n�o permitem "
"comutadores de contexto. No entanto, isso pode ser um requisito muito forte "
"para ser aplicado em alguns casos, pois uma se��o cr�tica tamb�m bloqueia "
"efetivamente os threads de interrup��o no processador atual. Como resultado, "
"outra API foi fornecido para permitir que o segmento atual indique que, se "
"ele se precisasse, ele n�o deveria migrar para outra CPU. "

#. (itstool) path: sect2/para
#: book.translate.xml:15314
#, fuzzy
msgid ""
"This API is known as thread pinning and is provided by the scheduler. The "
"API consists of two functions: <function>sched_pin</function> and "
"<function>sched_unpin</function>. These functions manage a per-thread "
"nesting count <varname>td_pinned</varname>. A thread is pinned when its "
"nesting count is greater than zero and a thread starts off unpinned with a "
"nesting count of zero. Each scheduler implementation is required to ensure "
"that pinned threads are only executed on the CPU that they were executing on "
"when the <function>sched_pin</function> was first called. Since the nesting "
"count is only written to by the thread itself and is only read by other "
"threads when the pinned thread is not executing but while "
"<varname>sched_lock</varname> is held, then <varname>td_pinned</varname> "
"does not need any locking. The <function>sched_pin</function> function "
"increments the nesting count and <function>sched_unpin</function> decrements "
"the nesting count. Note that these functions only operate on the current "
"thread and bind the current thread to the CPU it is executing on at the time."
" To bind an arbitrary thread to a specific CPU, the <function>sched_bind</"
"function> and <function>sched_unbind</function> functions should be used "
"instead."
msgstr ""
"Essa API � conhecida como fixa��o de threads e � fornecida pelo agendador. A "
"API consiste em duas fun��es: <function> sched_pin </function> e <function> "
"sched_unpin </function> . Essas fun��es gerenciam uma contagem de "
"aninhamento por thread <varname> td_pinned </varname> . Um encadeamento � "
"fixado quando sua contagem de aninhamento � maior que zero e um encadeamento "
"� iniciado desmarcado com uma contagem de aninhamento igual a zero. Cada "
"implementa��o do planejador � necess�ria para garantir que os encadeamentos "
"fixados sejam executados somente na CPU em que estavam sendo executados "
"quando o encadeamento <function> sched_pin </function> foi chamado pela "
"primeira vez. Como a contagem de aninhamento � gravada apenas pelo pr�prio "
"thread e � lida apenas por outros threads quando o thread fixo n�o est� em "
"execu��o, mas enquanto <varname> sched_lock </varname> � realizada, ent�o "
"<varname> td_pinned </varname> n�o precisa de nenhum bloqueio. o <function> "
"sched_pin </function> fun��o incrementa a contagem de aninhamento e "
"<function> sched_unpin </function> decrementa a contagem de aninhamento. "
"Observe que essas fun��es s� operam no encadeamento atual e ligam o "
"encadeamento atual � CPU que est� sendo executada no momento. Para ligar um "
"encadeamento arbitr�rio a uma CPU espec�fica, o <function> sched_bind </"
"function> e <function> sched_unbind </function> fun��es devem ser usadas em "
"vez disso. "

#. (itstool) path: sect2/title
#: book.translate.xml:15340
#, fuzzy
msgid "Callouts"
msgstr "Chamadas"

#. (itstool) path: sect2/para
#: book.translate.xml:15342
#, fuzzy
msgid ""
"The <function>timeout</function> kernel facility permits kernel services to "
"register functions for execution as part of the <function>softclock</"
"function> software interrupt. Events are scheduled based on a desired number "
"of clock ticks, and callbacks to the consumer-provided function will occur "
"at approximately the right time."
msgstr ""
"O <function> tempo esgotado </function> O recurso kernel permite que os "
"servi�os do kernel registrem fun��es para execu��o como parte do <function> "
"softclock </function> interrup��o de software. Os eventos s�o programados "
"com base em um n�mero desejado de pulsos de clock, e os retornos de chamada "
"para a fun��o fornecida pelo consumidor ocorrer�o aproximadamente no momento "
"certo. "

#. (itstool) path: sect2/para
#: book.translate.xml:15349
#, fuzzy
msgid ""
"The global list of pending timeout events is protected by a global spin "
"mutex, <varname>callout_lock</varname>; all access to the timeout list must "
"be performed with this mutex held. When <function>softclock</function> is "
"woken up, it scans the list of pending timeouts for those that should fire. "
"In order to avoid lock order reversal, the <function>softclock</function> "
"thread will release the <varname>callout_lock</varname> mutex when invoking "
"the provided <function>timeout</function> callback function. If the "
"<constant>CALLOUT_MPSAFE</constant> flag was not set during registration, "
"then Giant will be grabbed before invoking the callout, and then released "
"afterwards. The <varname>callout_lock</varname> mutex will be re-grabbed "
"before proceeding. The <function>softclock</function> code is careful to "
"leave the list in a consistent state while releasing the mutex. If "
"<constant>DIAGNOSTIC</constant> is enabled, then the time taken to execute "
"each function is measured, and a warning is generated if it exceeds a "
"threshold."
msgstr ""
"A lista global de eventos de timeout pendentes � protegida por um mutex de "
"rota��o global, <varname> callout_lock </varname> ; todo acesso � lista de "
"tempo limite deve ser executado com esse mutex mantido. Quando <function> "
"softclock </function> � acordado, varre a lista de tempos limite pendentes "
"para aqueles que devem disparar. Para evitar a revers�o da ordem de "
"bloqueio, o <function> softclock </function> fio vai liberar o <varname> "
"callout_lock </varname> mutex ao invocar o fornecido <function> tempo "
"esgotado </function> fun��o de retorno de chamada. Se o <constant> "
"CALLOUT_MPSAFE </constant> flag n�o foi definido durante o registro, ent�o o "
"Giant ser� agarrado antes de invocar o texto explicativo e, em seguida, "
"liberado posteriormente. o <varname> callout_lock </varname> mutex ser� re-"
"agarrado antes de prosseguir. o <function> softclock </function> c�digo tem "
"o cuidado de deixar a lista em um estado consistente ao liberar o mutex. E "
"se <constant> DIAGN�STICO </constant> est� habilitado, o tempo gasto para "
"executar cada fun��o � medido e um aviso � gerado se exceder um limite. "

#. (itstool) path: sect1/title
#: book.translate.xml:15372
#, fuzzy
msgid "Specific Locking Strategies"
msgstr "Estrat�gias Espec�ficas de Bloqueio"

#. (itstool) path: sect2/title
#: book.translate.xml:15375
#, fuzzy
msgid "Credentials"
msgstr "Credenciais"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15377
#, fuzzy
msgid "<primary>credentials</primary>"
msgstr " <primary> credenciais </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15379
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct ucred</varname> is the kernel's "
"internal credential structure, and is generally used as the basis for "
"process-driven access control within the kernel. BSD-derived systems use a "
"<quote>copy-on-write</quote> model for credential data: multiple references "
"may exist for a credential structure, and when a change needs to be made, "
"the structure is duplicated, modified, and then the reference replaced. Due "
"to wide-spread caching of the credential to implement access control on "
"open, this results in substantial memory savings. With a move to fine-"
"grained SMP, this model also saves substantially on locking operations by "
"requiring that modification only occur on an unshared credential, avoiding "
"the need for explicit synchronization when consuming a known-shared "
"credential."
msgstr ""
" <varname remap=\"structname\"> structurred </varname> � a estrutura de "
"credenciais internas do kernel e � geralmente usada como base para o "
"controle de acesso orientado a processos dentro do kernel. Sistemas "
"derivados de BSD usam um <quote> copiar-em-escrever </quote> modelo para "
"dados de credencial: podem existir v�rias refer�ncias para uma estrutura de "
"credenciais e, quando uma altera��o precisa ser feita, a estrutura � "
"duplicada, modificada e, em seguida, a refer�ncia � substitu�da. Devido ao "
"amplo armazenamento em cache da credencial para implementar o controle de "
"acesso em aberto, isso resulta em economias substanciais de mem�ria. Com uma "
"mudan�a para o SMP refinado, esse modelo tamb�m economiza substancialmente "
"nas opera��es de bloqueio, exigindo que essa modifica��o ocorra apenas em "
"uma credencial n�o compartilhada, evitando a necessidade de sincroniza��o "
"expl�cita ao consumir uma credencial compartilhada conhecida. "

#. (itstool) path: sect2/para
#: book.translate.xml:15394
#, fuzzy
msgid ""
"Credential structures with a single reference are considered mutable; shared "
"credential structures must not be modified or a race condition is risked. A "
"mutex, <varname remap=\"structfield\">cr_mtxp</varname> protects the "
"reference count of <varname remap=\"structname\">struct ucred</varname> so "
"as to maintain consistency. Any use of the structure requires a valid "
"reference for the duration of the use, or the structure may be released out "
"from under the illegitimate consumer."
msgstr ""
"Estruturas de credenciais com uma �nica refer�ncia s�o consideradas "
"mut�veis; estruturas de credenciais compartilhadas n�o devem ser modificadas "
"ou uma condi��o de corrida � arriscada. Um mutex, <varname remap="
"\"structfield\"> cr_mtxp </varname> protege a contagem de refer�ncia de "
"<varname remap=\"structname\"> structurred </varname> de modo a manter a "
"consist�ncia. Qualquer uso da estrutura requer uma refer�ncia v�lida para a "
"dura��o do uso, ou a estrutura pode ser liberada sob o consumidor ileg�timo "
"\""

#. (itstool) path: sect2/para
#: book.translate.xml:15404
#, fuzzy
msgid ""
"The <varname remap=\"structname\">struct ucred</varname> mutex is a leaf "
"mutex and is implemented via a mutex pool for performance reasons."
msgstr ""
"O <varname remap=\"structname\"> structurred </varname> mutex � um mutex de "
"folha e � implementado por meio de um pool mutex por motivos de desempenho. "

#. (itstool) path: sect2/para
#: book.translate.xml:15408
#, fuzzy
msgid ""
"Usually, credentials are used in a read-only manner for access control "
"decisions, and in this case <varname remap=\"structfield\">td_ucred</"
"varname> is generally preferred because it requires no locking. When a "
"process' credential is updated the <literal>proc</literal> lock must be held "
"across the check and update operations thus avoid races. The process "
"credential <varname remap=\"structfield\">p_ucred</varname> must be used for "
"check and update operations to prevent time-of-check, time-of-use races."
msgstr ""
"Geralmente, as credenciais s�o usadas de maneira somente leitura para "
"decis�es de controle de acesso e, nesse caso, <varname remap="
"\"structfield\"> td_ucred </varname> � geralmente preferido porque n�o "
"requer bloqueio. Quando a credencial de um processo � atualizada, <literal> "
"proc </literal> o bloqueio deve ser mantido entre as opera��es de "
"verifica��o e atualiza��o, evitando assim as corridas. A credencial do "
"processo <varname remap=\"structfield\"> p_ucred </varname> deve ser usado "
"para verificar e atualizar as opera��es para evitar corridas de tempo de "
"verifica��o e tempo de uso. "

#. (itstool) path: sect2/para
#: book.translate.xml:15418
#, fuzzy
msgid ""
"If system call invocations will perform access control after an update to "
"the process credential, the value of <varname remap="
"\"structfield\">td_ucred</varname> must also be refreshed to the current "
"process value. This will prevent use of a stale credential following a "
"change. The kernel automatically refreshes the <varname remap="
"\"structfield\">td_ucred</varname> pointer in the thread structure from the "
"process <varname remap=\"structfield\">p_ucred</varname> whenever a process "
"enters the kernel, permitting use of a fresh credential for kernel access "
"control."
msgstr ""
"Se as invoca��es de chamada do sistema realizarem o controle de acesso ap�s "
"uma atualiza��o para a credencial do processo, o valor de <varname remap="
"\"structfield\"> td_ucred </varname> tamb�m deve ser atualizado para o valor "
"do processo atual. Isso impedir� o uso de uma credencial obsoleta ap�s uma "
"altera��o. O kernel atualiza automaticamente <varname remap=\"structfield\"> "
"td_ucred </varname> ponteiro na estrutura de thread do processo <varname "
"remap=\"structfield\"> p_ucred </varname> sempre que um processo entrar no "
"kernel, permitindo o uso de uma nova credencial para o controle de acesso ao "
"kernel. "

#. (itstool) path: sect2/title
#: book.translate.xml:15431
#, fuzzy
msgid "File Descriptors and File Descriptor Tables"
msgstr "Descritores de Arquivo e Tabelas de Descritor de Arquivo"

#. (itstool) path: sect2/para
#: book.translate.xml:15433
#, fuzzy
msgid "Details to follow."
msgstr "Detalhes para seguir."

#. (itstool) path: sect2/title
#: book.translate.xml:15437
#, fuzzy
msgid "Jail Structures"
msgstr "Estruturas da cadeia"

#. (itstool) path: sect2/para
#: book.translate.xml:15441
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct prison</varname> stores administrative "
"details pertinent to the maintenance of jails created using the "
"<citerefentry><refentrytitle>jail</refentrytitle><manvolnum>2</manvolnum></"
"citerefentry> API. This includes the per-jail hostname, IP address, and "
"related settings. This structure is reference-counted since pointers to "
"instances of the structure are shared by many credential structures. A "
"single mutex, <varname remap=\"structfield\">pr_mtx</varname> protects read "
"and write access to the reference count and all mutable variables inside the "
"struct jail. Some variables are set only when the jail is created, and a "
"valid reference to the <varname remap=\"structname\">struct prison</varname> "
"is sufficient to read these values. The precise locking of each entry is "
"documented via comments in <filename>sys/jail.h</filename>."
msgstr ""
" <varname remap=\"structname\"> pris�o de estrutura </varname> armazena "
"detalhes administrativos pertinentes � manuten��o de cadeias criadas usando "
"o <citerefentry><refentrytitle> cadeia </refentrytitle><manvolnum> 2 </"
"manvolnum></citerefentry> API. Isso inclui o nome do host, endere�o IP e "
"configura��es relacionadas por jail. Essa estrutura � contada por "
"refer�ncia, pois os ponteiros para inst�ncias da estrutura s�o "
"compartilhados por muitas estruturas de credenciais. Um �nico mutex, "
"<varname remap=\"structfield\"> pr_mtx </varname> protege o acesso de "
"leitura e grava��o � contagem de refer�ncia e todas as vari�veis ​​mut�veis "
"​​dentro da cadeia de struct. Algumas vari�veis ​​s�o definidas somente "
"quando o jail � criado e uma refer�ncia v�lida <varname remap="
"\"structname\"> pris�o de estrutura </varname> � suficiente para ler esses "
"valores. O bloqueio preciso de cada entrada � documentado atrav�s de "
"coment�rios em <filename> sys / jail.h </filename> "

#. (itstool) path: sect2/title
#: book.translate.xml:15457
#, fuzzy
msgid "MAC Framework"
msgstr "MAC Framework"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15459
#, fuzzy
msgid "<primary>MAC</primary>"
msgstr " <primary> MAC </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15461
#, fuzzy
msgid ""
"The TrustedBSD MAC Framework maintains data in a variety of kernel objects, "
"in the form of <varname remap=\"structname\">struct label</varname>. In "
"general, labels in kernel objects are protected by the same lock as the "
"remainder of the kernel object. For example, the <varname remap="
"\"structfield\">v_label</varname> label in <varname remap="
"\"structname\">struct vnode</varname> is protected by the vnode lock on the "
"vnode."
msgstr ""
"O TrustedBSD MAC Framework mant�m dados em uma variedade de objetos do "
"kernel, na forma de <varname remap=\"structname\"> r�tulo struct </varname> ."
" Em geral, os r�tulos nos objetos do kernel s�o protegidos pelo mesmo "
"bloqueio que o restante do objeto do kernel. Por exemplo, o <varname remap="
"\"structfield\"> v_label </varname> r�tulo em <varname remap=\"structname\"> "
"struct vnode </varname> est� protegido pelo bloqueio vnode no vnode. "

#. (itstool) path: sect2/para
#: book.translate.xml:15469
#, fuzzy
msgid ""
"In addition to labels maintained in standard kernel objects, the MAC "
"Framework also maintains a list of registered and active policies. The "
"policy list is protected by a global mutex (<varname>mac_policy_list_lock</"
"varname>) and a busy count (also protected by the mutex). Since many access "
"control checks may occur in parallel, entry to the framework for a read-only "
"access to the policy list requires holding the mutex while incrementing (and "
"later decrementing) the busy count. The mutex need not be held for the "
"duration of the MAC entry operation--some operations, such as label "
"operations on file system objects--are long-lived. To modify the policy "
"list, such as during policy registration and de-registration, the mutex must "
"be held and the reference count must be zero, to prevent modification of the "
"list while it is in use."
msgstr ""
"Al�m de r�tulos mantidos em objetos padr�o do kernel, o MAC Framework tamb�m "
"mant�m uma lista de pol�ticas registradas e ativas. A lista de pol�ticas � "
"protegida por um mutex global ( <varname> mac_policy_list_lock </varname> ) "
"e uma contagem ocupada (tamb�m protegida pelo mutex). Como muitas "
"verifica��es de controle de acesso podem ocorrer em paralelo, a entrada na "
"estrutura para um acesso somente leitura � lista de pol�ticas requer a "
"reten��o do mutex ao incrementar (e decrementar posteriormente) a contagem "
"de ocupa��es. O mutex n�o precisa ser mantido durante a opera��o de entrada "
"MAC - algumas opera��es, como opera��es de r�tulo em objetos do sistema de "
"arquivos - s�o de longa dura��o. Para modificar a lista de pol�ticas, como "
"durante o registro de pol�tica e o cancelamento de registro, o mutex deve "
"ser mantido e a contagem de refer�ncia deve ser zero, para evitar a "
"modifica��o da lista enquanto ela estiver em uso. "

#. (itstool) path: sect2/para
#: book.translate.xml:15484
#, fuzzy
msgid ""
"A condition variable, <varname>mac_policy_list_not_busy</varname>, is "
"available to threads that need to wait for the list to become unbusy, but "
"this condition variable must only be waited on if the caller is holding no "
"other locks, or a lock order violation may be possible. The busy count, in "
"effect, acts as a form of shared/exclusive lock over access to the framework:"
" the difference is that, unlike with an sx lock, consumers waiting for the "
"list to become unbusy may be starved, rather than permitting lock order "
"problems with regards to the busy count and other locks that may be held on "
"entry to (or inside) the MAC Framework."
msgstr ""
"Uma vari�vel de condi��o, <varname> mac_policy_list_not_busy </varname> , "
"est� dispon�vel para encadeamentos que precisam aguardar que a lista fique "
"desuniforme, mas essa vari�vel de condi��o s� deve ser aguardada se o "
"chamador n�o estiver segurando nenhum outro bloqueio ou se uma viola��o de "
"ordem de bloqueio for poss�vel. A contagem ocupada, na verdade, atua como "
"uma forma de bloqueio compartilhado / exclusivo sobre o acesso � estrutura: "
"a diferen�a � que, ao contr�rio de um bloqueio sx, os consumidores que "
"esperam que a lista se torne desusada podem ficar sem alimenta��o, em vez de "
"permitir a ordem de bloqueio problemas com rela��o � contagem de ocupa��es e "
"outros bloqueios que podem ser mantidos na entrada para (ou dentro) do MAC "
"Framework. "

#. (itstool) path: sect2/title
#: book.translate.xml:15498
#, fuzzy
msgid "Modules"
msgstr "M�dulos"

#. (itstool) path: sect2/para
#: book.translate.xml:15502
#, fuzzy
msgid ""
"For the module subsystem there exists a single lock that is used to protect "
"the shared data. This lock is a shared/exclusive (SX) lock and has a good "
"chance of needing to be acquired (shared or exclusively), therefore there "
"are a few macros that have been added to make access to the lock more easy. "
"These macros can be located in <filename>sys/module.h</filename> and are "
"quite basic in terms of usage. The main structures protected under this lock "
"are the <varname remap=\"structname\">module_t</varname> structures (when "
"shared) and the global <varname remap=\"structname\">modulelist_t</varname> "
"structure, modules. One should review the related source code in "
"<filename>kern/kern_module.c</filename> to further understand the locking "
"strategy."
msgstr ""
"Para o subsistema do m�dulo existe um �nico bloqueio que � usado para "
"proteger os dados compartilhados. Esse bloqueio � um bloqueio compartilhado /"
" exclusivo (SX) e tem uma boa chance de precisar ser adquirido "
"(compartilhado ou exclusivo), portanto, h� um bloqueio. algumas macros que "
"foram adicionadas para facilitar o acesso ao bloqueio. Essas macros podem "
"ser localizadas <filename> sys / module.h </filename> e s�o bastante b�sicos "
"em termos de uso. As principais estruturas protegidas sob este bloqueio s�o "
"as <varname remap=\"structname\"> module_t </varname> estruturas (quando "
"compartilhadas) e as <varname remap=\"structname\"> modulelist_t </varname> "
"estrutura, m�dulos. Deve-se rever o c�digo fonte relacionado em <filename> "
"kern / kern_module.c </filename> para entender melhor a estrat�gia de "
"bloqueio. "

#. (itstool) path: sect2/title
#: book.translate.xml:15517
#, fuzzy
msgid "Newbus Device Tree"
msgstr "�rvore de Dispositivos Newbus"

#. (itstool) path: sect2/indexterm
#. (itstool) path: sect1/indexterm
#: book.translate.xml:15519 book.translate.xml:22509
#, fuzzy
msgid "<primary>Newbus</primary>"
msgstr " <primary> Newbus </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15521
#, fuzzy
msgid ""
"The newbus system will have one sx lock. Readers will hold a shared (read) "
"lock (<citerefentry><refentrytitle>sx_slock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>) and writers will hold an exclusive (write) lock "
"(<citerefentry><refentrytitle>sx_xlock</refentrytitle><manvolnum>9</"
"manvolnum></citerefentry>). Internal functions will not do locking at all. "
"Externally visible ones will lock as needed. Those items that do not matter "
"if the race is won or lost will not be locked, since they tend to be read "
"all over the place (e.g., <citerefentry><refentrytitle>device_get_softc</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>). There will be "
"relatively few changes to the newbus data structures, so a single lock "
"should be sufficient and not impose a performance penalty."
msgstr ""
"O sistema newbus ter� um bloqueio sx. Os leitores ter�o um bloqueio "
"compartilhado (leitura) ( <citerefentry><refentrytitle> sx_slock </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ) e os escritores "
"ter�o um bloqueio exclusivo (grava��o) ( <citerefentry><refentrytitle> "
"sx_xlock </refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ). "
"Fun��es internas n�o far�o nenhum bloqueio. Os vis�veis externamente ser�o "
"bloqueados conforme necess�rio. Os itens que n�o importam se a corrida for "
"vencida ou perdida n�o ser�o bloqueados, pois tendem a ser lidos em todo o "
"lugar (por exemplo, <citerefentry><refentrytitle> device_get_softc </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> ). Haver� "
"relativamente poucas altera��es nas estruturas de dados do newbus, portanto, "
"um �nico bloqueio deve ser suficiente e n�o impor uma penalidade de "
"desempenho. "

#. (itstool) path: sect2/title
#: book.translate.xml:15534
#, fuzzy
msgid "Pipes"
msgstr "Tubos"

#. (itstool) path: sect2/para
#: book.translate.xml:15536 book.translate.xml:15569
#, fuzzy
msgid "..."
msgstr "..."

#. (itstool) path: sect2/title
#: book.translate.xml:15540
#, fuzzy
msgid "Processes and Threads"
msgstr "Processos e Threads"

#. (itstool) path: sect2/para
#: book.translate.xml:15542
#, fuzzy
msgid "- process hierarchy"
msgstr "- hierarquia de processos"

#. (itstool) path: sect2/para
#: book.translate.xml:15543
#, fuzzy
msgid "- proc locks, references"
msgstr "- bloqueios proc, refer�ncias"

#. (itstool) path: sect2/para
#: book.translate.xml:15544
#, fuzzy
msgid ""
"- thread-specific copies of proc entries to freeze during system calls, "
"including td_ucred"
msgstr ""
"- c�pias espec�ficas de segmento de entradas proc para congelar durante as "
"chamadas do sistema, incluindo td_ucred"

#. (itstool) path: sect2/para
#: book.translate.xml:15546
#, fuzzy
msgid "- inter-process operations"
msgstr "- opera��es entre processos"

#. (itstool) path: sect2/para
#: book.translate.xml:15547
#, fuzzy
msgid "- process groups and sessions"
msgstr "- processar grupos e sess�es"

#. (itstool) path: sect2/title
#: book.translate.xml:15551
#, fuzzy
msgid "Scheduler"
msgstr "Agendador"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15553
#, fuzzy
msgid "<primary>scheduler</primary>"
msgstr " <primary> Agendador </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15555
#, fuzzy
msgid ""
"Lots of references to <varname>sched_lock</varname> and notes pointing at "
"specific primitives and related magic elsewhere in the document."
msgstr ""
"Muitas refer�ncias a <varname> sched_lock </varname> e notas apontando para "
"primitivos espec�ficos e magias relacionadas em outras partes do documento. "

#. (itstool) path: sect2/title
#: book.translate.xml:15561
#, fuzzy
msgid "Select and Poll"
msgstr "Selecione e Pesquise"

#. (itstool) path: sect2/para
#: book.translate.xml:15563
#, fuzzy
msgid ""
"The <function>select</function> and <function>poll</function> functions "
"permit threads to block waiting on events on file descriptors--most "
"frequently, whether or not the file descriptors are readable or writable."
msgstr ""
"O <function> selecione </function> e <function> vota��o </function> As "
"fun��es permitem que os encadeamentos bloqueiem a espera de eventos nos "
"descritores de arquivos - com mais freq��ncia, independentemente de os "
"descritores de arquivos serem leg�veis ou grav�veis. "

#. (itstool) path: sect2/title
#: book.translate.xml:15573
#, fuzzy
msgid "SIGIO"
msgstr "SIGIO"

#. (itstool) path: sect2/para
#: book.translate.xml:15575
#, fuzzy
msgid ""
"The SIGIO service permits processes to request the delivery of a SIGIO "
"signal to its process group when the read/write status of specified file "
"descriptors changes. At most one process or process group is permitted to "
"register for SIGIO from any given kernel object, and that process or group "
"is referred to as the owner. Each object supporting SIGIO registration "
"contains pointer field that is <constant>NULL</constant> if the object is "
"not registered, or points to a <varname remap=\"structname\">struct sigio</"
"varname> describing the registration. This field is protected by a global "
"mutex, <varname>sigio_lock</varname>. Callers to SIGIO maintenance functions "
"must pass in this field <quote>by reference</quote> so that local register "
"copies of the field are not made when unprotected by the lock."
msgstr ""
"O servi�o SIGIO permite que os processos solicitem a entrega de um sinal "
"SIGIO ao seu grupo de processos quando o status de leitura / grava��o dos "
"descritores de arquivo especificados muda. No m�ximo, um processo ou grupo "
"de processos tem permiss�o para se registrar no SIGIO de qualquer objeto do "
"kernel e esse processo ou grupo � chamado de propriet�rio. Cada objeto que "
"suporta o registro SIGIO cont�m um campo de ponteiro que � <constant> NULO </"
"constant> se o objeto n�o estiver registrado, ou apontar para um <varname "
"remap=\"structname\"> struct sigio </varname> descrevendo o registro. Este "
"campo � protegido por um mutex global, <varname> sigio_lock </varname> . Os "
"chamadores para as fun��es de manuten��o do SIGIO devem passar neste campo "
"<quote> por refer�ncia </quote> para que as c�pias de registro locais do "
"campo n�o sejam feitas quando desprotegidas pelo bloqueio. "

#. (itstool) path: sect2/para
#: book.translate.xml:15590
#, fuzzy
msgid ""
"One <varname remap=\"structname\">struct sigio</varname> is allocated for "
"each registered object associated with any process or process group, and "
"contains back-pointers to the object, owner, signal information, a "
"credential, and the general disposition of the registration. Each process or "
"progress group contains a list of registered <varname remap="
"\"structname\">struct sigio</varname> structures, <varname remap="
"\"structfield\">p_sigiolst</varname> for processes, and <varname remap="
"\"structfield\">pg_sigiolst</varname> for process groups. These lists are "
"protected by the process or process group locks respectively. Most fields in "
"each <varname remap=\"structname\">struct sigio</varname> are constant for "
"the duration of the registration, with the exception of the <varname remap="
"\"structfield\">sio_pgsigio</varname> field which links the <varname remap="
"\"structname\">struct sigio</varname> into the process or process group list."
" Developers implementing new kernel objects supporting SIGIO will, in "
"general, want to avoid holding structure locks while invoking SIGIO "
"supporting functions, such as <function>fsetown</function> or "
"<function>funsetown</function> to avoid defining a lock order between "
"structure locks and the global SIGIO lock. This is generally possible "
"through use of an elevated reference count on the structure, such as "
"reliance on a file descriptor reference to a pipe during a pipe operation."
msgstr ""
"1 <varname remap=\"structname\"> struct sigio </varname> � alocado para cada "
"objeto registrado associado a qualquer processo ou grupo de processos e "
"cont�m indicadores de retorno para o objeto, propriet�rio, informa��es de "
"sinal, uma credencial e a disposi��o geral do registro. Cada processo ou "
"grupo de progresso cont�m uma lista de <varname remap=\"structname\"> struct "
"sigio </varname> estruturas, <varname remap=\"structfield\"> p_sigiolst </"
"varname> para processos e <varname remap=\"structfield\"> pg_sigiolst </"
"varname> para grupos de processos. Essas listas s�o protegidas pelos "
"bloqueios de processos ou grupos de processos, respectivamente. A maioria "
"dos campos em cada <varname remap=\"structname\"> struct sigio </varname> "
"s�o constantes durante o per�odo de registro, com exce��o do <varname remap="
"\"structfield\"> sio_pgsigio </varname> campo que liga o <varname remap="
"\"structname\"> struct sigio </varname> na lista de processos ou grupos de "
"processos. Os desenvolvedores que implementam novos objetos de kernel que "
"suportam o SIGIO, em geral, querem evitar manter bloqueios de estrutura "
"enquanto invocam fun��es de suporte SIGIO, como <function> fsetown </"
"function> ou <function> funsetown </function> para evitar definir uma ordem "
"de bloqueio entre bloqueios de estrutura e o bloqueio global SIGIO. Isso "
"geralmente � poss�vel atrav�s do uso de uma contagem de refer�ncia elevada "
"na estrutura, como a depend�ncia de uma refer�ncia de descritor de arquivo a "
"um pipe durante uma opera��o de pipe. "

#. (itstool) path: sect2/title
#: book.translate.xml:15617
#, fuzzy
msgid "Sysctl"
msgstr "Sysctl"

#. (itstool) path: sect2/para
#: book.translate.xml:15619
#, fuzzy
msgid ""
"The <function>sysctl</function> MIB service is invoked from both within the "
"kernel and from userland applications using a system call. At least two "
"issues are raised in locking: first, the protection of the structures "
"maintaining the namespace, and second, interactions with kernel variables "
"and functions that are accessed by the sysctl interface. Since sysctl "
"permits the direct export (and modification) of kernel statistics and "
"configuration parameters, the sysctl mechanism must become aware of "
"appropriate locking semantics for those variables. Currently, sysctl makes "
"use of a single global sx lock to serialize use of <function>sysctl</"
"function>; however, it is assumed to operate under Giant and other "
"protections are not provided. The remainder of this section speculates on "
"locking and semantic changes to sysctl."
msgstr ""
"O <function> sysctl </function> O servi�o MIB � invocado a partir de ambos "
"dentro do kernel e de aplicativos da terra do usu�rio usando uma chamada de "
"sistema. Pelo menos dois problemas s�o levantados no bloqueio: primeiro, a "
"prote��o das estruturas que mant�m o namespace e, em segundo lugar, "
"intera��es com vari�veis ​​e fun��es do kernel que s�o acessadas pela "
"interface sysctl. Como sysctl permite a exporta��o direta (e modifica��o) de "
"estat�sticas do kernel e par�metros de configura��o, o mecanismo sysctl deve "
"estar ciente da sem�ntica de bloqueio apropriada para essas vari�veis. "
"Atualmente, o sysctl faz uso de um �nico sx lock global para serializar o "
"uso de <function> sysctl </function> ; no entanto, sup�e-se que ele opere "
"sob Gigante e outras prote��es n�o s�o fornecidas. O restante desta se��o "
"especula sobre o bloqueio e altera��es sem�nticas no sysctl. "

#. (itstool) path: sect2/para
#: book.translate.xml:15635
#, fuzzy
msgid ""
"- Need to change the order of operations for sysctl's that update values "
"from read old, copyin and copyout, write new to copyin, lock, read old and "
"write new, unlock, copyout. Normal sysctl's that just copyout the old value "
"and set a new value that they copyin may still be able to follow the old "
"model. However, it may be cleaner to use the second model for all of the "
"sysctl handlers to avoid lock operations."
msgstr ""
"- Necessidade de alterar a ordem das opera��es para sysctl';s que atualizam "
"valores de read old, copyin e copyout, write new para copyin, lock, read "
"old, new, unlock, copyout. Sysctls normais que apenas copiam o valor antigo "
"e definem um O novo valor que eles copiam ainda pode ser capaz de seguir o "
"modelo antigo. No entanto, pode ser mais limpo usar o segundo modelo para "
"todos os manipuladores sysctl para evitar opera��es de bloqueio. "

#. (itstool) path: sect2/para
#: book.translate.xml:15643
#, fuzzy
msgid ""
"- To allow for the common case, a sysctl could embed a pointer to a mutex in "
"the SYSCTL_FOO macros and in the struct. This would work for most sysctl's. "
"For values protected by sx locks, spin mutexes, or other locking strategies "
"besides a single sleep mutex, SYSCTL_PROC nodes could be used to get the "
"locking right."
msgstr ""
"- Para permitir o caso comum, um sysctl poderia incorporar um ponteiro a um "
"mutex nas macros SYSCTL_FOO e no struct. Isso funcionaria para a maioria dos "
"sysctl. Para valores protegidos por bloqueios sx, mutexes de rota��o ou "
"outras estrat�gias de bloqueio al�m de um single sleep mutex, n�s "
"SYSCTL_PROC poderiam ser usados ​​para obter o bloqueio certo \""

#. (itstool) path: sect2/title
#: book.translate.xml:15652
#, fuzzy
msgid "Taskqueue"
msgstr "Taskqueue"

#. (itstool) path: sect2/para
#: book.translate.xml:15654
#, fuzzy
msgid ""
"The taskqueue's interface has two basic locks associated with it in order to "
"protect the related shared data. The <varname>taskqueue_queues_mutex</"
"varname> is meant to serve as a lock to protect the "
"<varname>taskqueue_queues</varname> TAILQ. The other mutex lock associated "
"with this system is the one in the <varname remap=\"structname\">struct "
"taskqueue</varname> data structure. The use of the synchronization primitive "
"here is to protect the integrity of the data in the <varname remap="
"\"structname\">struct taskqueue</varname>. It should be noted that there are "
"no separate macros to assist the user in locking down his/her own work since "
"these locks are most likely not going to be used outside of <filename>kern/"
"subr_taskqueue.c</filename>."
msgstr ""
"A interface da fila de tarefas tem dois bloqueios b�sicos associados a ela "
"para proteger os dados compartilhados relacionados. <varname> "
"taskqueue_queues_mutex </varname> destina-se a servir como um bloqueio para "
"proteger o <varname> taskqueue_queues </varname> TAILQ O outro bloqueio "
"mutex associado a este sistema � aquele no <varname remap=\"structname\"> "
"structqueueue </varname> estrutura de dados. O uso da primitiva de "
"sincroniza��o aqui � para proteger a integridade dos dados no <varname remap="
"\"structname\"> structqueueue </varname> . Deve-se notar que n�o h� macros "
"separadas para ajudar o usu�rio a bloquear seu pr�prio trabalho, j� que "
"esses bloqueios n�o ser�o mais usados ​​fora <filename> kern / "
"subr_taskqueue.c </filename> "

#. (itstool) path: sect1/title
#: book.translate.xml:15670
#, fuzzy
msgid "Implementation Notes"
msgstr "Notas de Implementa��o"

#. (itstool) path: sect2/title
#: book.translate.xml:15673
#, fuzzy
msgid "Sleep Queues"
msgstr "Filas do sono"

#. (itstool) path: sect2/para
#: book.translate.xml:15675
#, fuzzy
msgid ""
"A sleep queue is a structure that holds the list of threads asleep on a wait "
"channel. Each thread that is not asleep on a wait channel carries a sleep "
"queue structure around with it. When a thread blocks on a wait channel, it "
"donates its sleep queue structure to that wait channel. Sleep queues "
"associated with a wait channel are stored in a hash table."
msgstr ""
"Uma fila de espera � uma estrutura que mant�m a lista de threads adormecida "
"em um canal de espera. Cada thread que n�o est� dormindo em um canal de "
"espera carrega consigo uma estrutura de fila de espera. Quando um segmento "
"bloqueia em um canal de espera, ele doa estrutura da fila de espera para "
"esse canal de espera. As filas de espera associadas a um canal de espera s�o "
"armazenadas em uma tabela de hash. "

#. (itstool) path: sect2/para
#: book.translate.xml:15683
#, fuzzy
msgid ""
"The sleep queue hash table holds sleep queues for wait channels that have at "
"least one blocked thread. Each entry in the hash table is called a "
"sleepqueue chain. The chain contains a linked list of sleep queues and a "
"spin mutex. The spin mutex protects the list of sleep queues as well as the "
"contents of the sleep queue structures on the list. Only one sleep queue is "
"associated with a given wait channel. If multiple threads block on a wait "
"channel than the sleep queues associated with all but the first thread are "
"stored on a list of free sleep queues in the master sleep queue. When a "
"thread is removed from the sleep queue it is given one of the sleep queue "
"structures from the master queue's free list if it is not the only thread "
"asleep on the queue. The last thread is given the master sleep queue when it "
"is resumed. Since threads may be removed from the sleep queue in a different "
"order than they are added, a thread may depart from a sleep queue with a "
"different sleep queue structure than the one it arrived with."
msgstr ""
"A tabela hash da fila de espera cont�m filas de espera para canais de espera "
"que possuem pelo menos um thread bloqueado. Cada entrada na tabela de hash � "
"chamada de cadeia sleepqueue. A cadeia cont�m uma lista vinculada de filas "
"de espera e um mutex de rota��o. a lista de filas de espera, bem como o "
"conte�do das estruturas da fila de espera na lista.Somente uma fila de "
"espera est� associada a um determinado canal de espera.Se v�rios segmentos "
"bloquearem em um canal de espera que as filas de espera associadas a todos, "
"exceto ao primeiro segmento s�o armazenados em uma lista de filas de espera "
"livres na fila de espera principal.Quando um thread � removido da fila de "
"espera, � dada uma das estruturas de fila de espera a partir da lista livre "
"da fila mestre, se n�o for o �nico thread a adormecer na fila O �ltimo "
"segmento recebe a fila de espera principal quando � reiniciado.Como os "
"encadeamentos podem ser removidos da fila de espera em uma ordem diferente "
"da que foram inclu�dos, um encadeamento pode se afastar de uma fila de "
"espera com uma estrutura de fila de suspens�o diferente e aquele com quem "
"chegou. "

#. (itstool) path: sect2/para
#: book.translate.xml:15702
#, fuzzy
msgid ""
"The <function>sleepq_lock</function> function locks the spin mutex of the "
"sleep queue chain that maps to a specific wait channel. The "
"<function>sleepq_lookup</function> function looks in the hash table for the "
"master sleep queue associated with a given wait channel. If no master sleep "
"queue is found, it returns <constant>NULL</constant>. The "
"<function>sleepq_release</function> function unlocks the spin mutex "
"associated with a given wait channel."
msgstr ""
"O <function> sleepq_lock </function> function bloqueia o mutex de rota��o da "
"cadeia de fila de espera que mapeia para um canal de espera espec�fico. o "
"<function> sleepq_lookup </function> A fun��o procura na tabela de hash da "
"fila de espera principal associada a um determinado canal de espera. Se "
"nenhuma fila de espera principal for encontrada, ela retornar� <constant> "
"NULO </constant> . o <function> sleepq_release </function> A fun��o "
"desbloqueia o mutex de rota��o associado a um determinado canal de espera. "

#. (itstool) path: sect2/para
#: book.translate.xml:15711
#, fuzzy
msgid ""
"A thread is added to a sleep queue via the <function>sleepq_add</function>. "
"This function accepts the wait channel, a pointer to the mutex that protects "
"the wait channel, a wait message description string, and a mask of flags. "
"The sleep queue chain should be locked via <function>sleepq_lock</function> "
"before this function is called. If no mutex protects the wait channel (or it "
"is protected by Giant), then the mutex pointer argument should be "
"<constant>NULL</constant>. The flags argument contains a type field that "
"indicates the kind of sleep queue that the thread is being added to and a "
"flag to indicate if the sleep is interruptible "
"(<constant>SLEEPQ_INTERRUPTIBLE</constant>). Currently there are only two "
"types of sleep queues: traditional sleep queues managed via the "
"<function>msleep</function> and <function>wakeup</function> functions "
"(<constant>SLEEPQ_MSLEEP</constant>) and condition variable sleep queues "
"(<constant>SLEEPQ_CONDVAR</constant>). The sleep queue type and lock pointer "
"argument are used solely for internal assertion checking. Code that calls "
"<function>sleepq_add</function> should explicitly unlock any interlock "
"protecting the wait channel after the associated sleepqueue chain has been "
"locked via <function>sleepq_lock</function> and before blocking on the sleep "
"queue via one of the waiting functions."
msgstr ""
"Um encadeamento � adicionado a uma fila de espera atrav�s do <function> "
"sleepq_add </function> . Essa fun��o aceita o canal de espera, um ponteiro "
"para o mutex que protege o canal de espera, uma cadeia de descri��o da "
"mensagem de espera e uma m�scara de sinalizadores. A cadeia da fila de "
"espera deve ser bloqueada via <function> sleepq_lock </function> antes que "
"esta fun��o seja chamada. Se nenhum mutex protege o canal de espera (ou � "
"protegido pelo Gigante), ent�o o argumento do ponteiro do mutex deve ser "
"<constant> NULO </constant> . O argumento flags cont�m um campo type que "
"indica o tipo de fila de espera que o thread est� sendo adicionado e um flag "
"para indicar se o sleep � interromp�vel ( <constant> SLEEPQ_INTERRUPTIBLE </"
"constant> ). Atualmente, existem apenas dois tipos de filas de espera: filas "
"de sono tradicionais gerenciadas pelo <function> msleep </function> e "
"<function> acorde </function> fun��es ( <constant> SLEEPQ_MSLEEP </constant> "
") e filas de sono de vari�veis ​​de condi��o ( <constant> SLEEPQ_CONDVAR </"
"constant> ). O tipo de fila de espera e o argumento de ponteiro de bloqueio "
"s�o usados ​​somente para verifica��o de asser��o interna. C�digo que chama "
"<function> sleepq_add </function> deve desbloquear explicitamente qualquer "
"bloqueio protegendo o canal de espera ap�s a cadeia de sleepqueue associada "
"ter sido bloqueada via <function> sleepq_lock </function> e antes de "
"bloquear na fila de espera atrav�s de uma das fun��es de espera. "

#. (itstool) path: sect2/para
#: book.translate.xml:15736
#, fuzzy
msgid ""
"A timeout for a sleep is set by invoking <function>sleepq_set_timeout</"
"function>. The function accepts the wait channel and the timeout time as a "
"relative tick count as its arguments. If a sleep should be interrupted by "
"arriving signals, the <function>sleepq_catch_signals</function> function "
"should be called as well. This function accepts the wait channel as its only "
"parameter. If there is already a signal pending for this thread, then "
"<function>sleepq_catch_signals</function> will return a signal number; "
"otherwise, it will return 0."
msgstr ""
"Um tempo limite para um sono � definido invocando <function> "
"sleepq_set_timeout </function> . A fun��o aceita o canal de espera e o tempo "
"de timeout como uma contagem relativa de toques como seus argumentos. Se um "
"sono deve ser interrompido por sinais de chegada, o <function> "
"sleepq_catch_signals </function> fun��o deve ser chamada tamb�m. Esta fun��o "
"aceita o canal de espera como seu �nico par�metro. Se j� houver um sinal "
"pendente para este encadeamento, <function> sleepq_catch_signals </function> "
"retornar� um n�mero de sinal; caso contr�rio, retornar� 0. "

#. (itstool) path: sect2/para
#: book.translate.xml:15747
#, fuzzy
msgid ""
"Once a thread has been added to a sleep queue, it blocks using one of the "
"<function>sleepq_wait</function> functions. There are four wait functions "
"depending on whether or not the caller wishes to use a timeout or have the "
"sleep aborted by caught signals or an interrupt from the userland thread "
"scheduler. The <function>sleepq_wait</function> function simply waits until "
"the current thread is explicitly resumed by one of the wakeup functions. The "
"<function>sleepq_timedwait</function> function waits until either the thread "
"is explicitly resumed or the timeout set by an earlier call to "
"<function>sleepq_set_timeout</function> expires. The "
"<function>sleepq_wait_sig</function> function waits until either the thread "
"is explicitly resumed or its sleep is aborted. The "
"<function>sleepq_timedwait_sig</function> function waits until either the "
"thread is explicitly resumed, the timeout set by an earlier call to "
"<function>sleepq_set_timeout</function> expires, or the thread's sleep is "
"aborted. All of the wait functions accept the wait channel as their first "
"parameter. In addition, the <function>sleepq_timedwait_sig</function> "
"function accepts a second boolean parameter to indicate if the earlier call "
"to <function>sleepq_catch_signals</function> found a pending signal."
msgstr ""
"Uma vez que um thread foi adicionado a uma fila de espera, ele bloqueia "
"usando um dos <function> sleepq_wait </function> fun��es. Existem quatro "
"fun��es de espera, dependendo se o chamador deseja ou n�o usar um tempo "
"limite ou interromper o sono por sinais capturados ou por uma interrup��o do "
"agendador de segmentos do espa�o do usu�rio. o <function> sleepq_wait </"
"function> fun��o simplesmente aguarda at� que o segmento atual seja "
"explicitamente retomado por uma das fun��es de ativa��o. o <function> "
"sleepq_timedwait </function> fun��o aguarda at� que o encadeamento seja "
"retomado explicitamente ou o tempo limite definido por uma chamada anterior "
"para <function> sleepq_set_timeout </function> expira. o <function> "
"sleepq_wait_sig </function> A fun��o aguarda at� que o encadeamento seja "
"explicitamente retomado ou que sua suspens�o seja interrompida. o <function> "
"sleepq_timedwait_sig </function> fun��o aguarda at� que o encadeamento seja "
"explicitamente retomado, o tempo limite definido por uma chamada anterior "
"para <function> sleepq_set_timeout </function> expira, ou o sono do segmento "
"� abortado. Todas as fun��es de espera aceitam o canal de espera como seu "
"primeiro par�metro. Al�m disso, o <function> sleepq_timedwait_sig </"
"function> fun��o aceita um segundo par�metro booleano para indicar se a "
"chamada anterior para <function> sleepq_catch_signals </function> encontrou "
"um sinal pendente \""

#. (itstool) path: sect2/para
#: book.translate.xml:15771
#, fuzzy
msgid ""
"If the thread is explicitly resumed or is aborted by a signal, then a value "
"of zero is returned by the wait function to indicate a successful sleep. If "
"the thread is resumed by either a timeout or an interrupt from the userland "
"thread scheduler then an appropriate errno value is returned instead. Note "
"that since <function>sleepq_wait</function> can only return 0 it does not "
"return anything and the caller should assume a successful sleep. Also, if a "
"thread's sleep times out and is aborted simultaneously then "
"<function>sleepq_timedwait_sig</function> will return an error indicating "
"that a timeout occurred. If an error value of 0 is returned and either "
"<function>sleepq_wait_sig</function> or <function>sleepq_timedwait_sig</"
"function> was used to block, then the function "
"<function>sleepq_calc_signal_retval</function> should be called to check for "
"any pending signals and calculate an appropriate return value if any are "
"found. The signal number returned by the earlier call to "
"<function>sleepq_catch_signals</function> should be passed as the sole "
"argument to <function>sleepq_calc_signal_retval</function>."
msgstr ""
"Se o thread � explicitamente retomado ou � abortado por um sinal, ent�o um "
"valor de zero � retornado pela fun��o de espera para indicar uma suspens�o "
"bem-sucedida. Se o thread for retomado por um tempo limite ou uma "
"interrup��o do agendador de segmento do usu�rio valor errno apropriado � "
"retornado. <function> sleepq_wait </function> s� pode retornar 0, ele n�o "
"retorna nada e o chamador deve assumir um sono bem-sucedido. Al�m disso, se "
"o tempo de espera de um thread expirar e for abortado simultaneamente, "
"<function> sleepq_timedwait_sig </function> retornar� um erro indicando que "
"ocorreu um tempo limite. Se um valor de erro de 0 for retornado e <function> "
"sleepq_wait_sig </function> ou <function> sleepq_timedwait_sig </function> "
"foi usado para bloquear, ent�o a fun��o <function> sleepq_calc_signal_retval "
"</function> deve ser chamado para verificar quaisquer sinais pendentes e "
"calcular um valor de retorno apropriado, se algum for encontrado. O n�mero "
"do sinal retornado pela chamada anterior para <function> "
"sleepq_catch_signals </function> deve ser passado como o �nico argumento "
"para <function> sleepq_calc_signal_retval </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:15793
#, fuzzy
msgid ""
"Threads asleep on a wait channel are explicitly resumed by the "
"<function>sleepq_broadcast</function> and <function>sleepq_signal</function> "
"functions. Both functions accept the wait channel from which to resume "
"threads, a priority to raise resumed threads to, and a flags argument to "
"indicate which type of sleep queue is being resumed. The priority argument "
"is treated as a minimum priority. If a thread being resumed already has a "
"higher priority (numerically lower) than the priority argument then its "
"priority is not adjusted. The flags argument is used for internal assertions "
"to ensure that sleep queues are not being treated as the wrong type. For "
"example, the condition variable functions should not resume threads on a "
"traditional sleep queue. The <function>sleepq_broadcast</function> function "
"resumes all threads that are blocked on the specified wait channel while "
"<function>sleepq_signal</function> only resumes the highest priority thread "
"blocked on the wait channel. The sleep queue chain should first be locked "
"via the <function>sleepq_lock</function> function before calling these "
"functions."
msgstr ""
"Threads dormindo em um canal de espera s�o explicitamente retomados pelo "
"<function> sleepq_broadcast </function> e <function> sleepq_signal </"
"function> fun��es. Ambas as fun��es aceitam o canal de espera do qual "
"retomar os encadeamentos, uma prioridade para elevar os encadeamentos "
"iniciados e um argumento de sinalizadores para indicar qual tipo de fila de "
"espera est� sendo retomado. O argumento de prioridade � tratado como uma "
"prioridade m�nima. Se um encadeamento que est� sendo retomado j� tiver uma "
"prioridade mais alta (numericamente menor) que o argumento de prioridade, "
"sua prioridade n�o ser� ajustada. O argumento flags � usado para asser��es "
"internas para garantir que as filas de espera n�o estejam sendo tratadas "
"como o tipo errado. Por exemplo, as fun��es de vari�vel de condi��o n�o "
"devem retomar os encadeamentos em uma fila de espera tradicional. o "
"<function> sleepq_broadcast </function> fun��o retoma todos os threads que "
"est�o bloqueados no canal de espera especificado enquanto <function> "
"sleepq_signal </function> somente retoma o encadeamento de prioridade mais "
"alta bloqueado no canal de espera. A cadeia de fila de espera deve primeiro "
"ser bloqueada pelo <function> sleepq_lock </function> fun��o antes de chamar "
"essas fun��es. "

#. (itstool) path: sect2/para
#: book.translate.xml:15814
#, fuzzy
msgid ""
"A sleeping thread may have its sleep interrupted by calling the "
"<function>sleepq_abort</function> function. This function must be called "
"with <varname>sched_lock</varname> held and the thread must be queued on a "
"sleep queue. A thread may also be removed from a specific sleep queue via "
"the <function>sleepq_remove</function> function. This function accepts both "
"a thread and a wait channel as an argument and only awakens the thread if it "
"is on the sleep queue for the specified wait channel. If the thread is not "
"on a sleep queue or it is on a sleep queue for a different wait channel, "
"then this function does nothing."
msgstr ""
"Um fio de dormir pode ter seu sono interrompido chamando o <function> "
"sleepq_abort </function> fun��o. Esta fun��o deve ser chamada com <varname> "
"sched_lock </varname> mantido e o encadeamento deve estar enfileirado em uma "
"fila de espera. Um encadeamento tamb�m pode ser removido de uma fila de "
"espera espec�fica <function> sleepq_remove </function> fun��o. Essa fun��o "
"aceita um encadeamento e um canal de espera como um argumento e apenas ativa "
"o encadeamento, se estiver na fila de espera do canal de espera especificado."
" Se o encadeamento n�o estiver em uma fila de espera ou estiver em uma fila "
"de espera para um canal de espera diferente, essa fun��o n�o far� nada. "

#. (itstool) path: sect2/title
#: book.translate.xml:15828
#, fuzzy
msgid "Turnstiles"
msgstr "Torniquetes"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15830
#, fuzzy
msgid "<primary>turnstiles</primary>"
msgstr " <primary> torniquetes </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15832
#, fuzzy
msgid "- Compare/contrast with sleep queues."
msgstr "- Compare / contraste com filas de sono."

#. (itstool) path: sect2/para
#: book.translate.xml:15834
#, fuzzy
msgid "- Lookup/wait/release. - Describe TDF_TSNOBLOCK race."
msgstr "- Lookup / wait / release. - Descreva a corrida TDF_TSNOBLOCK."

#. (itstool) path: sect2/para
#: book.translate.xml:15837
#, fuzzy
msgid "- Priority propagation."
msgstr "- Propaga��o de prioridade."

#. (itstool) path: sect2/title
#: book.translate.xml:15841
#, fuzzy
msgid "Details of the Mutex Implementation"
msgstr "Detalhes da Implementa��o Mutex"

#. (itstool) path: sect2/para
#: book.translate.xml:15843
#, fuzzy
msgid ""
"- Should we require mutexes to be owned for mtx_destroy() since we can not "
"safely assert that they are unowned by anyone else otherwise?"
msgstr ""
"- Devemos exigir que os mutexes sejam de propriedade de mtx_destroy (), j� "
"que n�o podemos afirmar com seguran�a que eles s�o sem dono de outra pessoa?"

#. (itstool) path: sect3/title
#: book.translate.xml:15848
#, fuzzy
msgid "Spin Mutexes"
msgstr "Spin Mutexes"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15850
#, fuzzy
msgid "<primary>mutex</primary><secondary>spin</secondary>"
msgstr " <primary> mutex </primary><secondary> girar </secondary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15852
#, fuzzy
msgid "- Use a critical section..."
msgstr "- Use uma se��o cr�tica ..."

#. (itstool) path: sect3/title
#: book.translate.xml:15856
#, fuzzy
msgid "Sleep Mutexes"
msgstr "Mutexes do sono"

#. (itstool) path: sect3/indexterm
#: book.translate.xml:15858
#, fuzzy
msgid "<primary>mutex</primary><secondary>sleep</secondary>"
msgstr " <primary> mutex </primary><secondary> dormir </secondary> "

#. (itstool) path: sect3/para
#: book.translate.xml:15859
#, fuzzy
msgid "- Describe the races with contested mutexes"
msgstr "- Descreva as ra�as com mutexes contestados"

#. (itstool) path: sect3/para
#: book.translate.xml:15861
#, fuzzy
msgid ""
"- Why it is safe to read mtx_lock of a contested mutex when holding the "
"turnstile chain lock."
msgstr ""
"- Por que � seguro ler o mtx_lock de um mutex contestado ao segurar a trava "
"da corrente do torniquete."

#. (itstool) path: sect2/title
#: book.translate.xml:15867
#, fuzzy
msgid "Witness"
msgstr "Testemunha"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:15869
#, fuzzy
msgid "<primary>witness</primary>"
msgstr " <primary> testemunha </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:15871
#, fuzzy
msgid "- What does it do"
msgstr "- O que isso faz"

#. (itstool) path: sect2/para
#: book.translate.xml:15873
#, fuzzy
msgid "- How does it work"
msgstr "- Como funciona"

#. (itstool) path: sect1/title
#: book.translate.xml:15878
#, fuzzy
msgid "Miscellaneous Topics"
msgstr "T�picos Diversos"

#. (itstool) path: sect2/title
#: book.translate.xml:15881
#, fuzzy
msgid "Interrupt Source and ICU Abstractions"
msgstr "Interromper fontes e abstra��es de ICU"

#. (itstool) path: sect2/para
#: book.translate.xml:15883
#, fuzzy
msgid "- struct isrc"
msgstr "- struct isrc"

#. (itstool) path: sect2/para
#: book.translate.xml:15885
#, fuzzy
msgid "- pic drivers"
msgstr "- drivers de pic"

#. (itstool) path: sect2/title
#: book.translate.xml:15889
#, fuzzy
msgid "Other Random Questions/Topics"
msgstr "Outras quest�es aleat�rias / t�picos"

#. (itstool) path: sect2/para
#: book.translate.xml:15891
#, fuzzy
msgid "- Should we pass an interlock into <function>sema_wait</function>?"
msgstr "- Devemos passar um bloqueio em <function> sema_wait </function> "

#. (itstool) path: sect2/para
#: book.translate.xml:15894
#, fuzzy
msgid "- Should we have non-sleepable sx locks?"
msgstr "- Devemos ter fechaduras sx n�o adormecidas?"

#. (itstool) path: sect2/para
#: book.translate.xml:15896
#, fuzzy
msgid "- Add some info about proper use of reference counts."
msgstr ""
"- Adicione algumas informa��es sobre o uso adequado de contagens de "
"refer�ncia."

#. (itstool) path: glossary/title
#: book.translate.xml:15901
#, fuzzy
msgid "Glossary"
msgstr "Gloss�rio"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15904
#, fuzzy
msgid "atomic"
msgstr "at�mica"

#. (itstool) path: glossdef/para
#: book.translate.xml:15906
#, fuzzy
msgid ""
"An operation is atomic if all of its effects are visible to other CPUs "
"together when the proper access protocol is followed. In the degenerate case "
"are atomic instructions provided directly by machine architectures. At a "
"higher level, if several members of a structure are protected by a lock, "
"then a set of operations are atomic if they are all performed while holding "
"the lock without releasing the lock in between any of the operations."
msgstr ""
"Uma opera��o � at�mica se todos os seus efeitos s�o vis�veis para outras "
"CPUs juntos quando o protocolo de acesso apropriado � seguido. No caso "
"degenerado s�o fornecidas instru��es at�micas diretamente por arquiteturas "
"de m�quina. Em um n�vel superior, se v�rios membros de uma estrutura s�o "
"protegidos por um bloqueio, ent�o um conjunto de opera��es s�o at�micas, se "
"todas elas forem realizadas, mantendo a trava sem liberar a trava entre "
"qualquer uma das opera��es. "

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15915 book.translate.xml:15966
#, fuzzy
msgid "operation"
msgstr "Opera��o"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossdef/glossseealso
#: book.translate.xml:15920 book.translate.xml:15998
#, fuzzy
msgid "block"
msgstr "quadra"

#. (itstool) path: glossdef/para
#: book.translate.xml:15922
#, fuzzy
msgid ""
"A thread is blocked when it is waiting on a lock, resource, or condition. "
"Unfortunately this term is a bit overloaded as a result."
msgstr ""
"Um encadeamento � bloqueado quando est� aguardando um bloqueio, recurso ou "
"condi��o. Infelizmente, esse termo � um pouco sobrecarregado como resultado."

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15926 book.translate.xml:15992 book.translate.xml:16011
#, fuzzy
msgid "sleep"
msgstr "dormir"

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15931
#, fuzzy
msgid "critical section"
msgstr "se��o Cr�tica"

#. (itstool) path: glossdef/para
#: book.translate.xml:15933
#, fuzzy
msgid ""
"A section of code that is not allowed to be preempted. A critical section is "
"entered and exited using the <citerefentry><refentrytitle>critical_enter</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> API."
msgstr ""
"Uma se��o de c�digo que n�o pode ser preterida. Uma se��o cr�tica � inserida "
"e encerrada usando o <citerefentry><refentrytitle> critical_enter </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> API \""

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossdef/glossseealso
#: book.translate.xml:15940 book.translate.xml:15961
#, fuzzy
msgid "MD"
msgstr "MD"

#. (itstool) path: glossdef/para
#: book.translate.xml:15942
#, fuzzy
msgid "Machine dependent."
msgstr "Dependente da m�quina"

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15944 book.translate.xml:15957
#, fuzzy
msgid "MI"
msgstr "MI"

#. (itstool) path: glossentry/glossterm
#. (itstool) path: glossentry/glosssee
#: book.translate.xml:15949 book.translate.xml:15967
#, fuzzy
msgid "memory operation"
msgstr "opera��o de mem�ria"

#. (itstool) path: glossdef/para
#: book.translate.xml:15951
#, fuzzy
msgid "A memory operation reads and/or writes to a memory location."
msgstr "Uma opera��o de mem�ria l� e / ou grava em um local da mem�ria."

#. (itstool) path: glossdef/para
#: book.translate.xml:15959
#, fuzzy
msgid "Machine independent."
msgstr "M�quina independente\""

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15971
#, fuzzy
msgid "primary interrupt context"
msgstr "contexto de interrup��o prim�rio"

#. (itstool) path: glossdef/para
#: book.translate.xml:15973
#, fuzzy
msgid ""
"Primary interrupt context refers to the code that runs when an interrupt "
"occurs. This code can either run an interrupt handler directly or schedule "
"an asynchronous interrupt thread to execute the interrupt handlers for a "
"given interrupt source."
msgstr ""
"Contexto de interrup��o prim�ria refere-se ao c�digo que � executado quando "
"ocorre uma interrup��o. Esse c�digo pode executar um manipulador de "
"interrup��o diretamente ou agendar um thread de interrup��o ass�ncrono para "
"executar os manipuladores de interrup��o para uma determinada origem de "
"interrup��o."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15982
#, fuzzy
msgid "realtime kernel thread"
msgstr "thread do kernel em tempo real"

#. (itstool) path: glossdef/para
#: book.translate.xml:15984
#, fuzzy
msgid ""
"A high priority kernel thread. Currently, the only realtime priority kernel "
"threads are interrupt threads."
msgstr ""
"Um encadeamento de kernel de alta prioridade. Atualmente, os �nicos "
"encadeamentos de kernel de prioridade em tempo real s�o encadeamentos de "
"interrup��o."

#. (itstool) path: glossdef/glossseealso
#. (itstool) path: glossentry/glossterm
#: book.translate.xml:15987 book.translate.xml:16016
#, fuzzy
msgid "thread"
msgstr "fio"

#. (itstool) path: glossdef/para
#: book.translate.xml:15994
#, fuzzy
msgid ""
"A thread is asleep when it is blocked on a condition variable or a sleep "
"queue via <function>msleep</function> or <function>tsleep</function>."
msgstr ""
"Um encadeamento est� adormecido quando � bloqueado em uma vari�vel de "
"condi��o ou em uma fila de espera via <function> msleep </function> ou "
"<function> tsleep </function> "

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16003
#, fuzzy
msgid "sleepable lock"
msgstr "fecho adormecido"

#. (itstool) path: glossdef/para
#: book.translate.xml:16005
#, fuzzy
msgid ""
"A sleepable lock is a lock that can be held by a thread which is asleep. "
"Lockmgr locks and sx locks are currently the only sleepable locks in FreeBSD."
" Eventually, some sx locks such as the allproc and proctree locks may become "
"non-sleepable locks."
msgstr ""
"Uma trava sleepable � uma trava que pode ser mantida por um thread que est� "
"adormecido. Bloqueios lockmgr e sx lock s�o atualmente os �nicos bloqueios "
"que podem ser suspensos no FreeBSD. Eventualmente, alguns bloqueios sx, como "
"os bloqueios allproc e proctree, podem se tornar bloqueios n�o adormecidos. "

#. (itstool) path: glossdef/para
#: book.translate.xml:16018
#, fuzzy
msgid ""
"A kernel thread represented by a struct thread. Threads own locks and hold a "
"single execution context."
msgstr ""
"Um encadeamento de kernel representado por um encadeamento de estrutura. "
"Encadeia os pr�prios bloqueios e mant�m um �nico contexto de execu��o."

#. (itstool) path: glossentry/glossterm
#: book.translate.xml:16024
#, fuzzy
msgid "wait channel"
msgstr "canal de espera"

#. (itstool) path: glossdef/para
#: book.translate.xml:16026
#, fuzzy
msgid "A kernel virtual address that threads may sleep on."
msgstr "Um endere�o virtual do kernel no qual os threads podem dormir\""

#. (itstool) path: part/title
#. (itstool) path: sect1/title
#: book.translate.xml:16036 book.translate.xml:22448
#, fuzzy
msgid "Device Drivers"
msgstr "Drivers de dispositivo"

#. (itstool) path: info/title
#: book.translate.xml:16048
#, fuzzy
msgid "Writing FreeBSD Device Drivers"
msgstr "Gravar drivers de dispositivo FreeBSD"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16051
#, fuzzy
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16062
#, fuzzy
msgid ""
"<personname> <firstname>Jörg</firstname> <surname>Wunsch</surname> </"
"personname> <contrib>Based on intro(4) manual page by </contrib>"
msgstr ""
" <personname><firstname> J�rg </firstname><surname> Wunsch </surname></"
"personname><contrib> Baseado na p�gina de manual intro (4) por </contrib> "

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16076 book.translate.xml:22453
#, fuzzy
msgid "<primary>device driver</primary>"
msgstr " <primary> driver do dispositivo </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16077
#, fuzzy
msgid "<primary>pseudo-device</primary>"
msgstr " <primary> pseudo-dispositivo </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16079
#, fuzzy
msgid ""
"This chapter provides a brief introduction to writing device drivers for "
"FreeBSD. A device in this context is a term used mostly for hardware-related "
"stuff that belongs to the system, like disks, printers, or a graphics "
"display with its keyboard. A device driver is the software component of the "
"operating system that controls a specific device. There are also so-called "
"pseudo-devices where a device driver emulates the behavior of a device in "
"software without any particular underlying hardware. Device drivers can be "
"compiled into the system statically or loaded on demand through the dynamic "
"kernel linker facility `kld'."
msgstr ""
"Este cap�tulo fornece uma breve introdu��o � grava��o de drivers de "
"dispositivo para o FreeBSD. Um dispositivo neste contexto � um termo usado "
"principalmente para material relacionado ao hardware que pertence ao "
"sistema, como discos, impressoras ou um monitor gr�fico com seu teclado. Um "
"dispositivo driver � o componente de software do sistema operacional que "
"controla um dispositivo espec�fico.Existem tamb�m os chamados pseudo-"
"dispositivos em que um driver de dispositivo emula o comportamento de um "
"dispositivo em um software sem qualquer hardware subjacente espec�fico.Os "
"drivers de dispositivo podem ser compilados no sistema estaticamente ou "
"carregado sob demanda atrav�s do recurso de linker do kernel din�mico `kld "
"';."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16091
#, fuzzy
msgid "<primary>device nodes</primary>"
msgstr " <primary> n�s de dispositivo </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16093
#, fuzzy
msgid ""
"Most devices in a <trademark class=\"registered\">UNIX</trademark>-like "
"operating system are accessed through device-nodes, sometimes also called "
"special files. These files are usually located under the directory "
"<filename>/dev</filename> in the filesystem hierarchy."
msgstr ""
"A maioria dos dispositivos em um <trademark class=\"registered\"> UNIX </"
"trademark> como o sistema operacional s�o acessados ​​atrav�s de n�s de "
"dispositivos, �s vezes tamb�m chamados de arquivos especiais. Esses arquivos "
"geralmente est�o localizados no diret�rio <filename> / dev </filename> na "
"hierarquia do sistema de arquivos. "

#. (itstool) path: sect1/para
#: book.translate.xml:16098
#, fuzzy
msgid ""
"Device drivers can roughly be broken down into two categories; character and "
"network device drivers."
msgstr ""
"Os drivers de dispositivos podem ser divididos em duas categorias: drivers "
"de dispositivos e de rede."

#. (itstool) path: sect1/title
#: book.translate.xml:16104
#, fuzzy
msgid "Dynamic Kernel Linker Facility - KLD"
msgstr "Instala��o do Linker Kernel Din�mico - KLD"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16106
#, fuzzy
msgid "<primary>kernel linking</primary> <secondary>dynamic</secondary>"
msgstr ""
" <primary> liga��o do kernel </primary><secondary> din�mico </secondary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16110
#, fuzzy
msgid "<primary>kernel loadable modules (KLD)</primary>"
msgstr " <primary> m�dulos carreg�veis ​​de kernel (KLD) </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16114
#, fuzzy
msgid ""
"The kld interface allows system administrators to dynamically add and remove "
"functionality from a running system. This allows device driver writers to "
"load their new changes into a running kernel without constantly rebooting to "
"test changes."
msgstr ""
"A interface kld permite que os administradores do sistema adicionem e "
"removam dinamicamente a funcionalidade de um sistema em execu��o. Isso "
"permite que os gravadores de driver de dispositivo carreguem suas novas "
"altera��es em um kernel em execu��o sem constantemente reinicializar para "
"testar as altera��es."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16120
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>loading</secondary>"
msgstr ""
" <primary> m�dulos do kernel </primary><secondary> Carregando </secondary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16124
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>unloading</secondary>"
msgstr ""
" <primary> m�dulos do kernel </primary><secondary> descarga </secondary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16128
#, fuzzy
msgid "<primary>kernel modules</primary> <secondary>listing</secondary>"
msgstr ""
" <primary> m�dulos do kernel </primary><secondary> listando </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16133
#, fuzzy
msgid "The kld interface is used through:"
msgstr "A interface kld � usada atrav�s de:"

#. (itstool) path: listitem/simpara
#: book.translate.xml:16137
#, fuzzy
msgid "<command>kldload</command> - loads a new kernel module"
msgstr " <command> kldload </command> - carrega um novo m�dulo do kernel "

#. (itstool) path: listitem/simpara
#: book.translate.xml:16140
#, fuzzy
msgid "<command>kldunload</command> - unloads a kernel module"
msgstr " <command> kldunload </command> - descarrega um m�dulo do kernel "

#. (itstool) path: listitem/simpara
#: book.translate.xml:16143
#, fuzzy
msgid "<command>kldstat</command> - lists loaded modules"
msgstr " <command> kldstat </command> - listas de m�dulos carregados "

#. (itstool) path: sect1/para
#: book.translate.xml:16147
#, fuzzy
msgid "Skeleton Layout of a kernel module"
msgstr "Layout do esqueleto de um m�dulo do kernel"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16149
#, no-wrap
msgid ""
"/*\n"
" * KLD Skeleton\n"
" * Inspired by Andrew Reiter's Daemonnews article\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"\n"
"/*\n"
" * Load handler that deals with the loading and unloading of a KLD.\n"
" */\n"
"\n"
"static int\n"
"skel_loader(struct module *m, int what, void *arg)\n"
"{\n"
"  int err = 0;\n"
"\n"
"  switch (what) {\n"
"  case MOD_LOAD:                /* kldload */\n"
"    uprintf(\"Skeleton KLD loaded.\\n\");\n"
"    break;\n"
"  case MOD_UNLOAD:\n"
"    uprintf(\"Skeleton KLD unloaded.\\n\");\n"
"    break;\n"
"  default:\n"
"    err = EOPNOTSUPP;\n"
"    break;\n"
"  }\n"
"  return(err);\n"
"}\n"
"\n"
"/* Declare this module to the rest of the kernel */\n"
"\n"
"static moduledata_t skel_mod = {\n"
"  \"skel\",\n"
"  skel_loader,\n"
"  NULL\n"
"};\n"
"\n"
"DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);"
msgstr ""
"/*\n"
" * KLD Skeleton\n"
" * Inspired by Andrew Reiter's Daemonnews article\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"\n"
"/*\n"
" * Load handler that deals with the loading and unloading of a KLD.\n"
" */\n"
"\n"
"static int\n"
"skel_loader(struct module *m, int what, void *arg)\n"
"{\n"
"  int err = 0;\n"
"\n"
"  switch (what) {\n"
"  case MOD_LOAD:                /* kldload */\n"
"    uprintf(\"Skeleton KLD loaded.\\n\");\n"
"    break;\n"
"  case MOD_UNLOAD:\n"
"    uprintf(\"Skeleton KLD unloaded.\\n\");\n"
"    break;\n"
"  default:\n"
"    err = EOPNOTSUPP;\n"
"    break;\n"
"  }\n"
"  return(err);\n"
"}\n"
"\n"
"/* Declare this module to the rest of the kernel */\n"
"\n"
"static moduledata_t skel_mod = {\n"
"  \"skel\",\n"
"  skel_loader,\n"
"  NULL\n"
"};\n"
"\n"
"DECLARE_MODULE(skeleton, skel_mod, SI_SUB_KLD, SI_ORDER_ANY);"

#. (itstool) path: sect2/title
#: book.translate.xml:16196
#, fuzzy
msgid "Makefile"
msgstr "Makefile"

#. (itstool) path: sect2/para
#: book.translate.xml:16198
#, fuzzy
msgid ""
"FreeBSD provides a system makefile to simplify compiling a kernel module."
msgstr ""
"O FreeBSD fornece um makefile do sistema para simplificar a compila��o de um "
"m�dulo do kernel."

#. (itstool) path: sect2/programlisting
#: book.translate.xml:16201
#, no-wrap
msgid "SRCS=skeleton.c\n"
"KMOD=skeleton\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"
msgstr "SRCS=skeleton.c\n"
"KMOD=skeleton\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:16206
#, fuzzy
msgid ""
"Running <command>make</command> with this makefile will create a file "
"<filename>skeleton.ko</filename> that can be loaded into the kernel by "
"typing:"
msgstr ""
"Corrida <command> fa�o </command> com este makefile ir� criar um arquivo "
"<filename> skeleton.ko </filename> que pode ser carregado no kernel "
"digitando: "

#. (itstool) path: sect2/screen
#: book.translate.xml:16210
#, no-wrap
msgid "<prompt>#</prompt> <userinput>kldload -v ./skeleton.ko</userinput>"
msgstr "<prompt>#</prompt> <userinput>kldload -v ./skeleton.ko</userinput>"

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:16215 book.translate.xml:22492
#, fuzzy
msgid "Character Devices"
msgstr "Dispositivos de Personagem"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16217 book.translate.xml:22494
#, fuzzy
msgid "<primary>character devices</primary>"
msgstr " <primary> dispositivos de caracteres </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16220
#, fuzzy
msgid ""
"A character device driver is one that transfers data directly to and from a "
"user process. This is the most common type of device driver and there are "
"plenty of simple examples in the source tree."
msgstr ""
"Um driver de dispositivo de caracteres � aquele que transfere dados "
"diretamente para e de um processo do usu�rio. Esse � o tipo mais comum de "
"driver de dispositivo e h� v�rios exemplos simples na �rvore de c�digo-fonte."
""

#. (itstool) path: sect1/para
#: book.translate.xml:16225
#, fuzzy
msgid ""
"This simple example pseudo-device remembers whatever values are written to "
"it and can then echo them back when read."
msgstr ""
"Este pseudo-dispositivo de exemplo simples lembra-se de todos os valores que "
"foram escritos e pode, ent�o, eco�-los quando lidos."

#. (itstool) path: example/title
#: book.translate.xml:16230
#, fuzzy
msgid "Example of a Sample Echo Pseudo-Device Driver for FreeBSD 10.X - 12.X"
msgstr ""
"Exemplo de um driver de pseudo-dispositivo de eco de amostra para o FreeBSD "
"10.X - 12.X"

#. (itstool) path: example/programlisting
#: book.translate.xml:16233
#, no-wrap
msgid ""
"/*\n"
" * Simple Echo pseudo-device KLD\n"
" *\n"
" * Murray Stokely\n"
" * Søren (Xride) Straarup\n"
" * Eitan Adler\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;   /* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;    /* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"\n"
"#define BUFFERSIZE 255\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t      echo_open;\n"
"static d_close_t     echo_close;\n"
"static d_read_t      echo_read;\n"
"static d_write_t     echo_write;\n"
"\n"
"/* Character device entry points */\n"
"static struct cdevsw echo_cdevsw = {\n"
"\t.d_version = D_VERSION,\n"
"\t.d_open = echo_open,\n"
"\t.d_close = echo_close,\n"
"\t.d_read = echo_read,\n"
"\t.d_write = echo_write,\n"
"\t.d_name = \"echo\",\n"
"};\n"
"\n"
"struct s_echo {\n"
"\tchar msg[BUFFERSIZE + 1];\n"
"\tint len;\n"
"};\n"
"\n"
"/* vars */\n"
"static struct cdev *echo_dev;\n"
"static struct s_echo *echomsg;\n"
"\n"
"MALLOC_DECLARE(M_ECHOBUF);\n"
"MALLOC_DEFINE(M_ECHOBUF, \"echobuffer\", \"buffer for echo module\");\n"
"\n"
"/*\n"
" * This function is called by the kld[un]load(2) system calls to\n"
" * determine what actions to take when a module is loaded or unloaded.\n"
" */\n"
"static int\n"
"echo_loader(struct module *m __unused, int what, void *arg __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tswitch (what) {\n"
"\tcase MOD_LOAD:                /* kldload */\n"
"\t\terror = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,\n"
"\t\t    &amp;echo_dev,\n"
"\t\t    &amp;echo_cdevsw,\n"
"\t\t    0,\n"
"\t\t    UID_ROOT,\n"
"\t\t    GID_WHEEL,\n"
"\t\t    0600,\n"
"\t\t    \"echo\");\n"
"\t\tif (error != 0)\n"
"\t\t\tbreak;\n"
"\n"
"\t\techomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |\n"
"\t\t    M_ZERO);\n"
"\t\tprintf(\"Echo device loaded.\\n\");\n"
"\t\tbreak;\n"
"\tcase MOD_UNLOAD:\n"
"\t\tdestroy_dev(echo_dev);\n"
"\t\tfree(echomsg, M_ECHOBUF);\n"
"\t\tprintf(\"Echo device unloaded.\\n\");\n"
"\t\tbreak;\n"
"\tdefault:\n"
"\t\terror = EOPNOTSUPP;\n"
"\t\tbreak;\n"
"\t}\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_open(struct cdev *dev __unused, int oflags __unused, int devtype "
"__unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tuprintf(\"Opened device \\\"echo\\\" successfully.\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_close(struct cdev *dev __unused, int fflag __unused, int devtype "
"__unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\n"
"\tuprintf(\"Closing device \\\"echo\\\".\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * The read function just takes the buf that was saved via\n"
" * echo_write() and returns it to userland for accessing.\n"
" * uio(9)\n"
" */\n"
"static int\n"
"echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * How big is this read operation?  Either as big as the user wants,\n"
"\t * or as big as the remaining data.  Note that the 'len' does not\n"
"\t * include the trailing null character.\n"
"\t */\n"
"\tamt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 "
"? 0 :\n"
"\t    echomsg-&gt;len + 1 - uio-&gt;uio_offset);\n"
"\n"
"\tif ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)\n"
"\t\tuprintf(\"uiomove failed!\\n\");\n"
"\n"
"\treturn (error);\n"
"}\n"
"\n"
"/*\n"
" * echo_write takes in a character string and saves it\n"
" * to buf for later accessing.\n"
" */\n"
"static int\n"
"echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * We either write from the beginning or are appending -- do\n"
"\t * not allow random access.\n"
"\t */\n"
"\tif (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-"
"&gt;len))\n"
"\t\treturn (EINVAL);\n"
"\n"
"\t/* This is a new message, reset length */\n"
"\tif (uio-&gt;uio_offset == 0)\n"
"\t\techomsg-&gt;len = 0;\n"
"\n"
"\t/* Copy the string in from user memory to kernel memory */\n"
"\tamt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));\n"
"\n"
"\terror = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);\n"
"\n"
"\t/* Now we need to null terminate and record the length */\n"
"\techomsg-&gt;len = uio-&gt;uio_offset;\n"
"\techomsg-&gt;msg[echomsg-&gt;len] = 0;\n"
"\n"
"\tif (error != 0)\n"
"\t\tuprintf(\"Write failed: bad address!\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"DEV_MODULE(echo, echo_loader, NULL);"
msgstr ""
"/*\n"
" * Simple Echo pseudo-device KLD\n"
" *\n"
" * Murray Stokely\n"
" * Søren (Xride) Straarup\n"
" * Eitan Adler\n"
" */\n"
"\n"
"#include &lt;sys/types.h&gt;\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;  /* uprintf */\n"
"#include &lt;sys/param.h&gt;  /* defines used in kernel.h */\n"
"#include &lt;sys/kernel.h&gt; /* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;   /* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;    /* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"\n"
"#define BUFFERSIZE 255\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t      echo_open;\n"
"static d_close_t     echo_close;\n"
"static d_read_t      echo_read;\n"
"static d_write_t     echo_write;\n"
"\n"
"/* Character device entry points */\n"
"static struct cdevsw echo_cdevsw = {\n"
"\t.d_version = D_VERSION,\n"
"\t.d_open = echo_open,\n"
"\t.d_close = echo_close,\n"
"\t.d_read = echo_read,\n"
"\t.d_write = echo_write,\n"
"\t.d_name = \"echo\",\n"
"};\n"
"\n"
"struct s_echo {\n"
"\tchar msg[BUFFERSIZE + 1];\n"
"\tint len;\n"
"};\n"
"\n"
"/* vars */\n"
"static struct cdev *echo_dev;\n"
"static struct s_echo *echomsg;\n"
"\n"
"MALLOC_DECLARE(M_ECHOBUF);\n"
"MALLOC_DEFINE(M_ECHOBUF, \"echobuffer\", \"buffer for echo module\");\n"
"\n"
"/*\n"
" * This function is called by the kld[un]load(2) system calls to\n"
" * determine what actions to take when a module is loaded or unloaded.\n"
" */\n"
"static int\n"
"echo_loader(struct module *m __unused, int what, void *arg __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tswitch (what) {\n"
"\tcase MOD_LOAD:                /* kldload */\n"
"\t\terror = make_dev_p(MAKEDEV_CHECKNAME | MAKEDEV_WAITOK,\n"
"\t\t    &amp;echo_dev,\n"
"\t\t    &amp;echo_cdevsw,\n"
"\t\t    0,\n"
"\t\t    UID_ROOT,\n"
"\t\t    GID_WHEEL,\n"
"\t\t    0600,\n"
"\t\t    \"echo\");\n"
"\t\tif (error != 0)\n"
"\t\t\tbreak;\n"
"\n"
"\t\techomsg = malloc(sizeof(*echomsg), M_ECHOBUF, M_WAITOK |\n"
"\t\t    M_ZERO);\n"
"\t\tprintf(\"Echo device loaded.\\n\");\n"
"\t\tbreak;\n"
"\tcase MOD_UNLOAD:\n"
"\t\tdestroy_dev(echo_dev);\n"
"\t\tfree(echomsg, M_ECHOBUF);\n"
"\t\tprintf(\"Echo device unloaded.\\n\");\n"
"\t\tbreak;\n"
"\tdefault:\n"
"\t\terror = EOPNOTSUPP;\n"
"\t\tbreak;\n"
"\t}\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_open(struct cdev *dev __unused, int oflags __unused, int devtype "
"__unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\tint error = 0;\n"
"\n"
"\tuprintf(\"Opened device \\\"echo\\\" successfully.\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"static int\n"
"echo_close(struct cdev *dev __unused, int fflag __unused, int devtype "
"__unused,\n"
"    struct thread *td __unused)\n"
"{\n"
"\n"
"\tuprintf(\"Closing device \\\"echo\\\".\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * The read function just takes the buf that was saved via\n"
" * echo_write() and returns it to userland for accessing.\n"
" * uio(9)\n"
" */\n"
"static int\n"
"echo_read(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * How big is this read operation?  Either as big as the user wants,\n"
"\t * or as big as the remaining data.  Note that the 'len' does not\n"
"\t * include the trailing null character.\n"
"\t */\n"
"\tamt = MIN(uio-&gt;uio_resid, uio-&gt;uio_offset &gt;= echomsg-&gt;len + 1 "
"? 0 :\n"
"\t    echomsg-&gt;len + 1 - uio-&gt;uio_offset);\n"
"\n"
"\tif ((error = uiomove(echomsg-&gt;msg, amt, uio)) != 0)\n"
"\t\tuprintf(\"uiomove failed!\\n\");\n"
"\n"
"\treturn (error);\n"
"}\n"
"\n"
"/*\n"
" * echo_write takes in a character string and saves it\n"
" * to buf for later accessing.\n"
" */\n"
"static int\n"
"echo_write(struct cdev *dev __unused, struct uio *uio, int ioflag __unused)\n"
"{\n"
"\tsize_t amt;\n"
"\tint error;\n"
"\n"
"\t/*\n"
"\t * We either write from the beginning or are appending -- do\n"
"\t * not allow random access.\n"
"\t */\n"
"\tif (uio-&gt;uio_offset != 0 &amp;&amp; (uio-&gt;uio_offset != echomsg-"
"&gt;len))\n"
"\t\treturn (EINVAL);\n"
"\n"
"\t/* This is a new message, reset length */\n"
"\tif (uio-&gt;uio_offset == 0)\n"
"\t\techomsg-&gt;len = 0;\n"
"\n"
"\t/* Copy the string in from user memory to kernel memory */\n"
"\tamt = MIN(uio-&gt;uio_resid, (BUFFERSIZE - echomsg-&gt;len));\n"
"\n"
"\terror = uiomove(echomsg-&gt;msg + uio-&gt;uio_offset, amt, uio);\n"
"\n"
"\t/* Now we need to null terminate and record the length */\n"
"\techomsg-&gt;len = uio-&gt;uio_offset;\n"
"\techomsg-&gt;msg[echomsg-&gt;len] = 0;\n"
"\n"
"\tif (error != 0)\n"
"\t\tuprintf(\"Write failed: bad address!\\n\");\n"
"\treturn (error);\n"
"}\n"
"\n"
"DEV_MODULE(echo, echo_loader, NULL);"

#. (itstool) path: sect1/para
#: book.translate.xml:16400
#, fuzzy
msgid "With this driver loaded try:"
msgstr "Com este driver carregado tente:"

#. (itstool) path: sect1/screen
#: book.translate.xml:16402
#, no-wrap
msgid ""
"<prompt>#</prompt> <userinput>echo -n \"Test Data\" &gt; /dev/echo</"
"userinput>\n"
"<prompt>#</prompt> <userinput>cat /dev/echo</userinput>\n"
"Opened device \"echo\" successfully.\n"
"Test Data\n"
"Closing device \"echo\"."
msgstr ""
"<prompt>#</prompt> <userinput>echo -n \"Test Data\" &gt; /dev/echo</"
"userinput>\n"
"<prompt>#</prompt> <userinput>cat /dev/echo</userinput>\n"
"Opened device \"echo\" successfully.\n"
"Test Data\n"
"Closing device \"echo\"."

#. (itstool) path: sect1/para
#: book.translate.xml:16408
#, fuzzy
msgid "Real hardware devices are described in the next chapter."
msgstr "Dispositivos de hardware reais s�o descritos no pr�ximo cap�tulo."

#. (itstool) path: sect1/title
#: book.translate.xml:16413
#, fuzzy
msgid "Block Devices (Are Gone)"
msgstr "Dispositivos de bloco (foram embora)"

#. (itstool) path: sect1/indexterm
#. (itstool) path: sect2/indexterm
#: book.translate.xml:16415 book.translate.xml:22479
#, fuzzy
msgid "<primary>block devices</primary>"
msgstr " <primary> dispositivos de bloco </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16417
#, fuzzy
msgid ""
"Other <trademark class=\"registered\">UNIX</trademark> systems may support a "
"second type of disk device known as block devices. Block devices are disk "
"devices for which the kernel provides caching. This caching makes block-"
"devices almost unusable, or at least dangerously unreliable. The caching "
"will reorder the sequence of write operations, depriving the application of "
"the ability to know the exact disk contents at any one instant in time."
msgstr ""
"De outros <trademark class=\"registered\"> UNIX </trademark> sistemas podem "
"suportar um segundo tipo de dispositivo de disco conhecido como dispositivos "
"de bloco. Dispositivos de bloco s�o dispositivos de disco para os quais o "
"kernel fornece armazenamento em cache. Esse cache torna os dispositivos de "
"bloco quase inutiliz�veis, ou pelo menos perigosamente n�o confi�veis. O "
"cache ir� reordenar a sequ�ncia de opera��es de grava��o, privando o "
"aplicativo da capacidade de saber o conte�do exato do disco a qualquer "
"instante. "

#. (itstool) path: sect1/para
#: book.translate.xml:16425
#, fuzzy
msgid ""
"This makes predictable and reliable crash recovery of on-disk data "
"structures (filesystems, databases, etc.) impossible. Since writes may be "
"delayed, there is no way the kernel can report to the application which "
"particular write operation encountered a write error, this further compounds "
"the consistency problem."
msgstr ""
"Isso impossibilita a previs�vel e confi�vel recupera��o de falhas de "
"estruturas de dados em disco (sistemas de arquivos, bancos de dados, etc.). "
"Como as grava��es podem ser atrasadas, n�o h� como o kernel reportar ao "
"aplicativo qual opera��o de grava��o encontrou um erro de grava��o\" isso "
"complica ainda mais o problema de consist�ncia \""

#. (itstool) path: sect1/para
#: book.translate.xml:16432
#, fuzzy
msgid ""
"For this reason, no serious applications rely on block devices, and in fact, "
"almost all applications which access disks directly take great pains to "
"specify that character (or <quote>raw</quote>) devices should always be used."
" Because the implementation of the aliasing of each disk (partition) to two "
"devices with different semantics significantly complicated the relevant "
"kernel code FreeBSD dropped support for cached disk devices as part of the "
"modernization of the disk I/O infrastructure."
msgstr ""
"Por essa raz�o, nenhum aplicativo s�rio depende de dispositivos de bloco e, "
"de fato, quase todos os aplicativos que acessam discos fazem um grande "
"esfor�o para especificar esse caractere (ou <quote> cru </quote> ) "
"dispositivos devem sempre ser usados. Como a implementa��o do aliasing de "
"cada disco (parti��o) para dois dispositivos com sem�ntica diferente "
"complicou significativamente o c�digo do kernel relevante, o FreeBSD removeu "
"o suporte para dispositivos de disco em cache como parte da moderniza��o da "
"infra-estrutura de E / S de disco. "

#. (itstool) path: sect1/title
#: book.translate.xml:16444
#, fuzzy
msgid "Network Drivers"
msgstr "Drivers de Rede"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16446
#, fuzzy
msgid "<primary>network devices</primary>"
msgstr " <primary> dispositivos de rede </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16449
#, fuzzy
msgid ""
"Drivers for network devices do not use device nodes in order to be accessed. "
"Their selection is based on other decisions made inside the kernel and "
"instead of calling open(), use of a network device is generally introduced "
"by using the system call socket(2)."
msgstr ""
"Drivers para dispositivos de rede n�o usam n�s de dispositivos para serem "
"acessados. Sua sele��o � baseada em outras decis�es feitas dentro do kernel "
"e em vez de chamar open (), o uso de um dispositivo de rede � geralmente "
"introduzido usando o socket de chamada do sistema ( 2) "

#. (itstool) path: sect1/para
#: book.translate.xml:16455
#, fuzzy
msgid ""
"For more information see ifnet(9), the source of the loopback device, and "
"Bill Paul's network drivers."
msgstr ""
"Para obter mais informa��es, consulte ifnet (9), a origem do dispositivo de "
"loopback e os drivers de rede de Bill Paul."

#. (itstool) path: info/title
#: book.translate.xml:16467
#, fuzzy
msgid "ISA Device Drivers"
msgstr "Drivers de dispositivo ISA"

#. (itstool) path: authorgroup/author
#: book.translate.xml:16469 book.translate.xml:19438
#, fuzzy
msgid ""
"<personname><firstname>Sergey</firstname><surname>Babkin</surname></"
"personname><contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Sergey </firstname><surname> Babkin </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16472 book.translate.xml:19441
#, fuzzy
msgid ""
"<personname><firstname>Murray</firstname><surname>Stokely</surname></"
"personname><contrib>Modifications for Handbook made by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Modifica��es para o manual feito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16473
#, fuzzy
msgid ""
"<personname><firstname>Valentino</firstname><surname>Vaschetto</surname></"
"personname>"
msgstr ""
" <personname><firstname> Valentino </firstname><surname> Vaschetto </"
"surname></personname> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:16474
#, fuzzy
msgid ""
"<personname><firstname>Wylie</firstname><surname>Stilwell</surname></"
"personname>"
msgstr ""
" <personname><firstname> Wylie </firstname><surname> Stilwell </surname></"
"personname> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16483
#, fuzzy
msgid "<primary>ISA</primary>"
msgstr " <primary> ISA </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16484
#, fuzzy
msgid "<primary>device driver</primary><secondary>ISA</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> � UM </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16486
#, fuzzy
msgid ""
"This chapter introduces the issues relevant to writing a driver for an ISA "
"device. The pseudo-code presented here is rather detailed and reminiscent of "
"the real code but is still only pseudo-code. It avoids the details "
"irrelevant to the subject of the discussion. The real-life examples can be "
"found in the source code of real drivers. In particular the drivers "
"<literal>ep</literal> and <literal>aha</literal> are good sources of "
"information."
msgstr ""
"Este cap�tulo apresenta as quest�es relevantes para escrever um driver para "
"um dispositivo ISA. O pseudo-c�digo apresentado aqui � bastante detalhado e "
"lembra o c�digo real, mas ainda � apenas pseudo-c�digo. Evita os detalhes "
"irrelevantes para o assunto da discuss�o Os exemplos da vida real podem ser "
"encontrados no c�digo fonte dos drivers reais. <literal> ep </literal> e "
"<literal> aha </literal> s�o boas fontes de informa��o \""

#. (itstool) path: sect1/title
#: book.translate.xml:16496
#, fuzzy
msgid "Basic Information"
msgstr "Informa��o b�sica"

#. (itstool) path: sect1/para
#: book.translate.xml:16498
#, fuzzy
msgid "A typical ISA driver would need the following include files:"
msgstr "Um driver ISA t�pico precisaria dos seguintes arquivos include:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16501
#, no-wrap
msgid ""
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/bus.h&gt;\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"\n"
"#include &lt;isa/isavar.h&gt;\n"
"#include &lt;isa/pnpvar.h&gt;"
msgstr ""
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/bus.h&gt;\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"\n"
"#include &lt;isa/isavar.h&gt;\n"
"#include &lt;isa/pnpvar.h&gt;"

#. (itstool) path: sect1/para
#: book.translate.xml:16510
#, fuzzy
msgid ""
"They describe the things specific to the ISA and generic bus subsystem."
msgstr ""
"Eles descrevem as coisas espec�ficas do ISA e do subsistema de barramento "
"gen�rico."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16513
#, fuzzy
msgid "<primary>object-oriented</primary>"
msgstr " <primary> Orientado a Objeto </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16514
#, fuzzy
msgid ""
"The bus subsystem is implemented in an object-oriented fashion, its main "
"structures are accessed by associated method functions."
msgstr ""
"O subsistema de barramento � implementado de forma orientada a objeto, suas "
"principais estruturas s�o acessadas por fun��es de m�todo associadas."

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16518
#, fuzzy
msgid "<primary>bus methods</primary>"
msgstr " <primary> m�todos de �nibus </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16519
#, fuzzy
msgid ""
"The list of bus methods implemented by an ISA driver is like one for any "
"other bus. For a hypothetical driver named <quote>xxx</quote> they would be:"
msgstr ""
"A lista de m�todos de barramento implementados por um driver ISA � como um "
"para qualquer outro barramento. Para um driver hipot�tico chamado <quote> "
"xxx </quote> eles seriam:"

#. (itstool) path: listitem/para
#: book.translate.xml:16525
#, fuzzy
msgid ""
"<function>static void xxx_isa_identify (driver_t *, device_t);</function> "
"Normally used for bus drivers, not device drivers. But for ISA devices this "
"method may have special use: if the device provides some device-specific "
"(non-PnP) way to auto-detect devices this routine may implement it."
msgstr ""
" <function> Vazio est�tico xxx_isa_identify (driver_t *, device_t); </"
"function> Normalmente usado para motoristas de �nibus, n�o drivers de "
"dispositivo. Mas, para dispositivos ISA, esse m�todo pode ter um uso "
"especial: se o dispositivo fornecer alguma maneira espec�fica de dispositivo "
"(n�o PnP) de detectar dispositivos automaticamente, essa rotina poder� "
"implement�-lo. "

#. (itstool) path: listitem/para
#: book.translate.xml:16534
#, fuzzy
msgid ""
"<function>static int xxx_isa_probe (device_t dev);</function> Probe for a "
"device at a known (or PnP) location. This routine can also accommodate "
"device-specific auto-detection of parameters for partially configured "
"devices."
msgstr ""
" <function> est�tico int xxx_isa_probe (device_t dev); </function> Sonda "
"para um dispositivo em um local conhecido (ou PnP). Essa rotina tamb�m pode "
"acomodar a detec��o autom�tica espec�fica de dispositivos de par�metros para "
"dispositivos parcialmente configurados. "

#. (itstool) path: listitem/para
#: book.translate.xml:16542
#, fuzzy
msgid ""
"<function>static int xxx_isa_attach (device_t dev);</function> Attach and "
"initialize device."
msgstr ""
" <function> est�tico int xxx_isa_attach (device_t dev); </function> Anexe e "
"inicialize o dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:16547
#, fuzzy
msgid ""
"<function>static int xxx_isa_detach (device_t dev);</function> Detach device "
"before unloading the driver module."
msgstr ""
" <function> est�tico int xxx_isa_detach (device_t dev); </function> Retire o "
"dispositivo antes de descarregar o m�dulo do driver. "

#. (itstool) path: listitem/para
#: book.translate.xml:16553
#, fuzzy
msgid ""
"<function>static int xxx_isa_shutdown (device_t dev);</function> Execute "
"shutdown of the device before system shutdown."
msgstr ""
" <function> est�tico int xxx_isa_shutdown (device_t dev); </function> "
"Execute o desligamento do dispositivo antes do desligamento do sistema. "

#. (itstool) path: listitem/para
#: book.translate.xml:16559
#, fuzzy
msgid ""
"<function>static int xxx_isa_suspend (device_t dev);</function> Suspend the "
"device before the system goes to the power-save state. May also abort "
"transition to the power-save state."
msgstr ""
" <function> est�tico int xxx_isa_suspend (device_t dev); </function> "
"Suspenda o dispositivo antes que o sistema v� para o estado de economia de "
"energia. Pode tamb�m abortar a transi��o para o estado de economia de "
"energia. "

#. (itstool) path: listitem/para
#: book.translate.xml:16566
#, fuzzy
msgid ""
"<function>static int xxx_isa_resume (device_t dev);</function> Resume the "
"device activity after return from power-save state."
msgstr ""
" <function> est�tico int xxx_isa_resume (device_t dev); </function> Retomar "
"a atividade do dispositivo ap�s o retorno do estado de economia de energia. "

#. (itstool) path: sect1/para
#: book.translate.xml:16573
#, fuzzy
msgid ""
"<function>xxx_isa_probe()</function> and <function>xxx_isa_attach()</"
"function> are mandatory, the rest of the routines are optional, depending on "
"the device's needs."
msgstr ""
" <function> xxx_isa_probe () </function> e <function> xxx_isa_attach () </"
"function> s�o obrigat�rios, o resto das rotinas s�o opcionais, dependendo "
"das necessidades do dispositivo. "

#. (itstool) path: sect1/para
#: book.translate.xml:16578
#, fuzzy
msgid ""
"The driver is linked to the system with the following set of descriptions."
msgstr ""
"O driver est� ligado ao sistema com o seguinte conjunto de descri��es."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16581
#, no-wrap
msgid ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"    };\n"
"\n"
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
"\n"
"\n"
"    static devclass_t xxx_devclass;\n"
"\n"
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);"
msgstr ""
"    /* table of supported bus methods */\n"
"    static device_method_t xxx_isa_methods[] = {\n"
"        /* list all the bus method functions supported by the driver */\n"
"        /* omit the unsupported methods */\n"
"        DEVMETHOD(device_identify,  xxx_isa_identify),\n"
"        DEVMETHOD(device_probe,     xxx_isa_probe),\n"
"        DEVMETHOD(device_attach,    xxx_isa_attach),\n"
"        DEVMETHOD(device_detach,    xxx_isa_detach),\n"
"        DEVMETHOD(device_shutdown,  xxx_isa_shutdown),\n"
"        DEVMETHOD(device_suspend,   xxx_isa_suspend),\n"
"        DEVMETHOD(device_resume,    xxx_isa_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"    };\n"
"\n"
"    static driver_t xxx_isa_driver = {\n"
"        \"xxx\",\n"
"        xxx_isa_methods,\n"
"        sizeof(struct xxx_softc),\n"
"    };\n"
"\n"
"\n"
"    static devclass_t xxx_devclass;\n"
"\n"
"    DRIVER_MODULE(xxx, isa, xxx_isa_driver, xxx_devclass,\n"
"        load_function, load_argument);"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16608
#, fuzzy
msgid "<primary>softc</primary>"
msgstr " <primary> softc </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16610
#, fuzzy
msgid ""
"Here struct <varname remap=\"structname\">xxx_softc</varname> is a device-"
"specific structure that contains private driver data and descriptors for the "
"driver's resources. The bus code automatically allocates one softc "
"descriptor per device as needed."
msgstr ""
"Aqui struct <varname remap=\"structname\"> xxx_softc </varname> � uma "
"estrutura espec�fica do dispositivo que cont�m dados do driver privado e "
"descritores para os recursos do driver. O c�digo de barramento aloca "
"automaticamente um descritor softc por dispositivo, conforme necess�rio. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16616
#, fuzzy
msgid "<primary>kernel module</primary>"
msgstr " <primary> m�dulo do kernel </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16618
#, fuzzy
msgid ""
"If the driver is implemented as a loadable module then "
"<function>load_function()</function> is called to do driver-specific "
"initialization or clean-up when the driver is loaded or unloaded and "
"load_argument is passed as one of its arguments. If the driver does not "
"support dynamic loading (in other words it must always be linked into the "
"kernel) then these values should be set to 0 and the last definition would "
"look like:"
msgstr ""
"Se o driver for implementado como um m�dulo carreg�vel, <function> "
"load_function () </function> � chamado para fazer inicializa��o ou limpeza "
"espec�fica do driver quando o driver � carregado ou descarregado e "
"load_argument � passado como um dos seus argumentos. Se o driver n�o "
"suportar o carregamento din�mico (em outras palavras, ele deve estar sempre "
"vinculado ao kernel), ent�o esses valores devem ser definidos como 0 e a "
"�ltima defini��o deve ficar assim: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16627
#, no-wrap
msgid " DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);"
msgstr " DRIVER_MODULE(xxx, isa, xxx_isa_driver,\n"
"       xxx_devclass, 0, 0);"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16630
#, fuzzy
msgid "<primary>PnP</primary>"
msgstr " <primary> PnP </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16632
#, fuzzy
msgid ""
"If the driver is for a device which supports PnP then a table of supported "
"PnP IDs must be defined. The table consists of a list of PnP IDs supported "
"by this driver and human-readable descriptions of the hardware types and "
"models having these IDs. It looks like:"
msgstr ""
"Se o driver for para um dispositivo que suporte PnP, uma tabela de IDs PnP "
"compat�veis deve ser definida. A tabela consiste em uma lista de IDs PnP "
"suportados por esse driver e descri��es leg�veis por humanos dos tipos e "
"modelos de hardware que possuem esses IDs. Parece: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16638
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        /* a line for each supported PnP ID */\n"
"        { 0x12345678,   \"Our device model 1234A\" },\n"
"        { 0x12345679,   \"Our device model 1234B\" },\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"

#. (itstool) path: sect1/para
#: book.translate.xml:16645
#, fuzzy
msgid ""
"If the driver does not support PnP devices it still needs an empty PnP ID "
"table, like:"
msgstr ""
"Se o driver n�o suporta dispositivos PnP, ele ainda precisa de uma tabela "
"vazia de IDs PnP, como:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16648
#, no-wrap
msgid ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"
msgstr ""
"    static struct isa_pnp_id xxx_pnp_ids[] = {\n"
"        { 0,        NULL }, /* end of table */\n"
"    };"

#. (itstool) path: sect1/title
#: book.translate.xml:16655
#, fuzzy
msgid "<varname remap=\"structname\">device_t</varname> Pointer"
msgstr " <varname remap=\"structname\"> device_t </varname> Ponteiro "

#. (itstool) path: sect1/para
#: book.translate.xml:16657
#, fuzzy
msgid ""
"<varname remap=\"structname\">device_t</varname> is the pointer type for the "
"device structure. Here we consider only the methods interesting from the "
"device driver writer's standpoint. The methods to manipulate values in the "
"device structure are:"
msgstr ""
" <varname remap=\"structname\"> device_t </varname> � o tipo de ponteiro "
"para a estrutura do dispositivo. Aqui consideramos apenas os m�todos "
"interessantes do ponto de vista do gravador do driver de dispositivo. Os "
"m�todos para manipular valores na estrutura do dispositivo s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:16665
#, fuzzy
msgid ""
"<function>device_t device_get_parent(dev)</function> Get the parent bus of a "
"device."
msgstr ""
" <function> device_t device_get_parent (dev) </function> Obtenha o "
"barramento pai de um dispositivo \""

#. (itstool) path: listitem/para
#: book.translate.xml:16669
#, fuzzy
msgid ""
"<function>driver_t device_get_driver(dev)</function> Get pointer to its "
"driver structure."
msgstr ""
" <function> driver_t device_get_driver (dev) </function> Obter ponteiro para "
"sua estrutura de driver \""

#. (itstool) path: listitem/para
#: book.translate.xml:16673
#, fuzzy
msgid ""
"<function>char *device_get_name(dev)</function> Get the driver name, such as "
"<literal>\"xxx\"</literal> for our example."
msgstr ""
" <function> char * device_get_name (dev) </function> Obtenha o nome do "
"driver, como <literal> \\ \"xxx \" </literal> para o nosso exemplo \""

#. (itstool) path: listitem/para
#: book.translate.xml:16677
#, fuzzy
msgid ""
"<function>int device_get_unit(dev)</function> Get the unit number (units are "
"numbered from 0 for the devices associated with each driver)."
msgstr ""
" <function> int device_get_unit (dev) </function> Obtenha o n�mero da "
"unidade (as unidades s�o numeradas de 0 para os dispositivos associados a "
"cada driver). "

#. (itstool) path: listitem/para
#: book.translate.xml:16681
#, fuzzy
msgid ""
"<function>char *device_get_nameunit(dev)</function> Get the device name "
"including the unit number, such as <quote>xxx0</quote>, <quote>xxx1</quote> "
"and so on."
msgstr ""
" <function> char * device_get_nameunit (dev) </function> Obtenha o nome do "
"dispositivo, incluindo o n�mero da unidade, como <quote> xxx0 </quote> , "
"<quote> xxx1 </quote> e assim por diante."

#. (itstool) path: listitem/para
#: book.translate.xml:16686
#, fuzzy
msgid ""
"<function>char *device_get_desc(dev)</function> Get the device description. "
"Normally it describes the exact model of device in human-readable form."
msgstr ""
" <function> char * device_get_desc (dev) </function> Obtenha a descri��o do "
"dispositivo. Normalmente, descreve o modelo exato do dispositivo em forma "
"leg�vel por humanos. "

#. (itstool) path: listitem/para
#: book.translate.xml:16691
#, fuzzy
msgid ""
"<function>device_set_desc(dev, desc)</function> Set the description. This "
"makes the device description point to the string desc which may not be "
"deallocated or changed after that."
msgstr ""
" <function> device_set_desc (dev, desc) </function> Defina a descri��o. Isso "
"faz com que a descri��o do dispositivo aponte para a string desc que n�o "
"pode ser desalocada ou alterada depois disso. "

#. (itstool) path: listitem/para
#: book.translate.xml:16696
#, fuzzy
msgid ""
"<function>device_set_desc_copy(dev, desc)</function> Set the description. "
"The description is copied into an internal dynamically allocated buffer, so "
"the string desc may be changed afterwards without adverse effects."
msgstr ""
" <function> device_set_desc_copy (dev, desc) </function> Defina a descri��o. "
"A descri��o � copiada em um buffer interno alocado dinamicamente, ent�o a "
"string desc pode ser alterada posteriormente sem efeitos adversos. "

#. (itstool) path: listitem/para
#: book.translate.xml:16702
#, fuzzy
msgid ""
"<function>void *device_get_softc(dev)</function> Get pointer to the device "
"descriptor (struct <varname remap=\"structname\">xxx_softc</varname>) "
"associated with this device."
msgstr ""
" <function> void * device_get_softc (dev) </function> Obt�m o ponteiro para "
"o descritor de dispositivo (struct <varname remap=\"structname\"> xxx_softc "
"</varname> ) associado a este dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:16707
#, fuzzy
msgid ""
"<function>u_int32_t device_get_flags(dev)</function> Get the flags specified "
"for the device in the configuration file."
msgstr ""
" <function> u_int32_t device_get_flags (dev) </function> Obtenha os "
"sinalizadores especificados para o dispositivo no arquivo de configura��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:16713
#, fuzzy
msgid ""
"A convenience function <function>device_printf(dev, fmt, ...)</function> may "
"be used to print the messages from the device driver. It automatically "
"prepends the unitname and colon to the message."
msgstr ""
"Uma fun��o de conveni�ncia <function> device_printf (dev, fmt, ...) </"
"function> pode ser usado para imprimir as mensagens do driver de dispositivo."
" Ele preenche automaticamente o nome da unidade e os dois pontos da mensagem."
" "

#. (itstool) path: sect1/para
#: book.translate.xml:16718
#, fuzzy
msgid ""
"The device_t methods are implemented in the file <filename>kern/bus_subr.c</"
"filename>."
msgstr ""
"Os m�todos device_t s�o implementados no arquivo <filename> kern / bus_subr."
"c </filename> "

#. (itstool) path: sect1/title
#: book.translate.xml:16724
#, fuzzy
msgid ""
"Configuration File and the Order of Identifying and Probing During Auto-"
"Configuration"
msgstr ""
"Arquivo de configura��o e a ordem de identifica��o e pesquisa durante a "
"configura��o autom�tica"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16727
#, fuzzy
msgid "<primary>ISA</primary><secondary>probing</secondary>"
msgstr " <primary> � UM </primary><secondary> sondagem </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16729
#, fuzzy
msgid "The ISA devices are described in the kernel configuration file like:"
msgstr ""
"Os dispositivos ISA s�o descritos no arquivo de configura��o do kernel como:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16732
#, no-wrap
msgid ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive"
msgstr ""
"device xxx0 at isa? port 0x300 irq 10 drq 5\n"
"       iomem 0xd0000 flags 0x1 sensitive"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16735
#, fuzzy
msgid "<primary>IRQ</primary>"
msgstr " <primary> IRQ </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:16737
#, fuzzy
msgid ""
"The values of port, IRQ and so on are converted to the resource values "
"associated with the device. They are optional, depending on the device's "
"needs and abilities for auto-configuration. For example, some devices do not "
"need DRQ at all and some allow the driver to read the IRQ setting from the "
"device configuration ports. If a machine has multiple ISA buses the exact "
"bus may be specified in the configuration line, like <literal>isa0</literal> "
"or <literal>isa1</literal>, otherwise the device would be searched for on "
"all the ISA buses."
msgstr ""
"Os valores de porta, IRQ e assim por diante s�o convertidos para os valores "
"de recursos associados ao dispositivo. Eles s�o opcionais, dependendo das "
"necessidades e capacidades do dispositivo para a autoconfigura��o. Por "
"exemplo, alguns dispositivos n�o precisam de DRQ e alguns permite que o "
"driver leia a configura��o de IRQ a partir das portas de configura��o do "
"dispositivo.Se uma m�quina tiver v�rios barramentos ISA, o barramento exato "
"pode ser especificado na linha de configura��o, como <literal> isa0 </"
"literal> ou <literal> isa1 </literal> caso contr�rio, o dispositivo seria "
"procurado em todos os barramentos ISA. "

#. (itstool) path: sect1/para
#: book.translate.xml:16747
#, fuzzy
msgid ""
"<literal>sensitive</literal> is a resource requesting that this device must "
"be probed before all non-sensitive devices. It is supported but does not "
"seem to be used in any current driver."
msgstr ""
" <literal> sens�vel </literal> � um recurso que solicita que este "
"dispositivo seja analisado antes de todos os dispositivos n�o sens�veis. � "
"suportado, mas n�o parece ser usado em nenhum driver atual. "

#. (itstool) path: para/programlisting
#: book.translate.xml:16756
#, no-wrap
msgid "device xxx0 at isa?"
msgstr "device xxx0 at isa?"

#. (itstool) path: sect1/para
#: book.translate.xml:16751
#, fuzzy
msgid ""
"For legacy ISA devices in many cases the drivers are still able to detect "
"the configuration parameters. But each device to be configured in the system "
"must have a config line. If two devices of some type are installed in the "
"system but there is only one configuration line for the corresponding "
"driver, ie: <_:programlisting-1/> then only one device will be configured."
msgstr ""
"Para dispositivos ISA legados, em muitos casos, os drivers ainda s�o capazes "
"de detectar os par�metros de configura��o. Mas cada dispositivo a ser "
"configurado no sistema deve ter uma linha de configura��o. Se dois "
"dispositivos de algum tipo estiverem instalados no sistema, h� apenas um "
"linha de configura��o para o driver correspondente, ou seja: <_: "
"programlisting-1 /> ent�o apenas um dispositivo ser� configurado. "

#. (itstool) path: sect1/para
#: book.translate.xml:16759
#, fuzzy
msgid ""
"But for the devices supporting automatic identification by the means of Plug-"
"n-Play or some proprietary protocol one configuration line is enough to "
"configure all the devices in the system, like the one above or just simply:"
msgstr ""
"Mas para os dispositivos que suportam identifica��o autom�tica por meio do "
"Plug-n-Play ou algum protocolo propriet�rio, uma linha de configura��o � "
"suficiente para configurar todos os dispositivos no sistema, como o acima ou "
"simplesmente:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16764
#, no-wrap
msgid "device xxx at isa?"
msgstr "device xxx at isa?"

#. (itstool) path: sect1/para
#: book.translate.xml:16766
#, fuzzy
msgid ""
"If a driver supports both auto-identified and legacy devices and both kinds "
"are installed at once in one machine then it is enough to describe in the "
"config file the legacy devices only. The auto-identified devices will be "
"added automatically."
msgstr ""
"Se um driver suportar dispositivos legados e identificados automaticamente e "
"ambos os tipos forem instalados de uma s� vez em uma m�quina, ser� "
"suficiente descrever apenas no arquivo de configura��o os dispositivos "
"legados. Os dispositivos identificados automaticamente ser�o adicionados "
"automaticamente."

#. (itstool) path: sect1/para
#: book.translate.xml:16772
#, fuzzy
msgid "When an ISA bus is auto-configured the events happen as follows:"
msgstr ""
"Quando um barramento ISA � configurado automaticamente, os eventos acontecem "
"da seguinte maneira:"

#. (itstool) path: sect1/para
#: book.translate.xml:16775
#, fuzzy
msgid ""
"All the drivers' identify routines (including the PnP identify routine which "
"identifies all the PnP devices) are called in random order. As they identify "
"the devices they add them to the list on the ISA bus. Normally the drivers' "
"identify routines associate their drivers with the new devices. The PnP "
"identify routine does not know about the other drivers yet so it does not "
"associate any with the new devices it adds."
msgstr ""
"Todas as rotinas de identifica��o dos motoristas (incluindo a rotina de "
"identifica��o PnP que identifica todos os dispositivos PnP) s�o chamadas em "
"ordem aleat�ria. Ao identificar os dispositivos, elas s�o adicionadas � "
"lista no barramento ISA. Normalmente, as rotinas de identifica��o dos "
"motoristas associam drivers com os novos dispositivos. A rotina de "
"identifica��o do PnP ainda n�o conhece os outros drivers, por isso n�o "
"associa qualquer um aos novos dispositivos que ele adiciona. "

#. (itstool) path: sect1/para
#: book.translate.xml:16784
#, fuzzy
msgid ""
"The PnP devices are put to sleep using the PnP protocol to prevent them from "
"being probed as legacy devices."
msgstr ""
"Os dispositivos PnP s�o colocados em suspens�o usando o protocolo PnP para "
"impedir que sejam testados como dispositivos legados."

#. (itstool) path: sect1/para
#: book.translate.xml:16787
#, fuzzy
msgid ""
"The probe routines of non-PnP devices marked as <literal>sensitive</literal> "
"are called. If probe for a device went successfully, the attach routine is "
"called for it."
msgstr ""
"As rotinas de sondagem de dispositivos n�o PnP marcados como <literal> "
"sens�vel </literal> s�o chamados. Se o probe para um dispositivo foi bem-"
"sucedido, a rotina de anexa��o � chamada para ele. "

#. (itstool) path: sect1/para
#: book.translate.xml:16791
#, fuzzy
msgid ""
"The probe and attach routines of all non-PNP devices are called likewise."
msgstr ""
"As rotinas de teste e anexa��o de todos os dispositivos n�o-PNP s�o chamadas "
"da mesma forma."

#. (itstool) path: sect1/para
#: book.translate.xml:16794
#, fuzzy
msgid ""
"The PnP devices are brought back from the sleep state and assigned the "
"resources they request: I/O and memory address ranges, IRQs and DRQs, all of "
"them not conflicting with the attached legacy devices."
msgstr ""
"Os dispositivos PnP s�o trazidos de volta do estado de suspens�o e recebem "
"os recursos que eles solicitam: E / S e intervalos de endere�os de mem�ria, "
"IRQs e DRQs, todos eles n�o conflitam com os dispositivos legados anexados."

#. (itstool) path: sect1/para
#: book.translate.xml:16799
#, fuzzy
msgid ""
"Then for each PnP device the probe routines of all the present ISA drivers "
"are called. The first one that claims the device gets attached. It is "
"possible that multiple drivers would claim the device with different "
"priority; in this case, the highest-priority driver wins. The probe routines "
"must call <function>ISA_PNP_PROBE()</function> to compare the actual PnP ID "
"with the list of the IDs supported by the driver and if the ID is not in the "
"table return failure. That means that absolutely every driver, even the ones "
"not supporting any PnP devices must call <function>ISA_PNP_PROBE()</"
"function>, at least with an empty PnP ID table to return failure on unknown "
"PnP devices."
msgstr ""
"Ent�o, para cada dispositivo PnP, as rotinas de an�lise de todos os drivers "
"ISA atuais s�o chamadas. A primeira que reivindica o dispositivo � anexada. "
"� poss�vel que v�rios drivers reivindiquem o dispositivo com prioridade "
"diferente; nesse caso, a prioridade mais alta o driver ganha.As rotinas de "
"teste devem chamar <function> ISA_PNP_PROBE () </function> para comparar o "
"ID PnP real com a lista de IDs suportados pelo driver e se o ID n�o estiver "
"na falha de retorno da tabela. Isso significa que absolutamente todos os "
"drivers, mesmo aqueles que n�o suportam qualquer dispositivo PnP, devem "
"ligar <function> ISA_PNP_PROBE () </function> , pelo menos com uma tabela "
"vazia de IDs PnP para retornar falhas em dispositivos PnP desconhecidos. "

#. (itstool) path: sect1/para
#: book.translate.xml:16812
#, fuzzy
msgid ""
"The probe routine returns a positive value (the error code) on error, zero "
"or negative value on success."
msgstr ""
"A rotina da sonda retorna um valor positivo (o c�digo de erro) no erro, "
"valor zero ou negativo no sucesso."

#. (itstool) path: sect1/para
#: book.translate.xml:16815
#, fuzzy
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, returning -1 is next, returning -2 is after it and "
"so on). In result the devices which support only the old interface will be "
"handled by the old driver (which should return -1 from the probe routine) "
"while the devices supporting the new interface as well will be handled by "
"the new driver (which should return 0 from the probe routine). If multiple "
"drivers return the same value then the one called first wins. So if a driver "
"returns value 0 it may be sure that it won the priority arbitration."
msgstr ""
"Os valores de retorno negativos s�o usados ​​quando um dispositivo PnP "
"suporta v�rias interfaces. Por exemplo, uma interface de compatibilidade "
"mais antiga e uma interface avan�ada mais recente suportada por drivers "
"diferentes. Ent�o, ambos os drivers detectariam o dispositivo. O driver que "
"retorna um valor mais alto a rotina da sonda tem preced�ncia (em outras "
"palavras, o driver retornando 0 tem a preced�ncia mais alta, retornando -1 � "
"a pr�xima, retornando -2 � depois dela e assim por diante.) Em resultado, os "
"dispositivos que suportam apenas a interface antiga ser�o manipulados pelo "
"driver antigo (que deve retornar -1 da rotina da sonda), enquanto os "
"dispositivos que suportam a nova interface tamb�m ser�o manipulados pelo "
"novo driver (que deve retornar 0 da rotina da sonda) .Se v�rios drivers "
"retornarem o mesmo valor, ent�o o chamadas primeiras vit�rias. Ent�o, se um "
"driver retornar o valor 0, pode ter certeza de que ganhou a arbitragem "
"priorit�ria. "

#. (itstool) path: sect1/para
#: book.translate.xml:16831
#, fuzzy
msgid ""
"The device-specific identify routines can also assign not a driver but a "
"class of drivers to the device. Then all the drivers in the class are probed "
"for this device, like the case with PnP. This feature is not implemented in "
"any existing driver and is not considered further in this document."
msgstr ""
"As rotinas de identifica��o espec�ficas do dispositivo tamb�m podem designar "
"n�o um driver, mas uma classe de drivers para o dispositivo. Ent�o, todos os "
"drivers da classe s�o testados para esse dispositivo, como no caso do PnP. "
"Esse recurso n�o � implementado em nenhum driver existente. e n�o � "
"considerado mais adiante neste documento. "

#. (itstool) path: sect1/para
#: book.translate.xml:16837
#, fuzzy
msgid ""
"Because the PnP devices are disabled when probing the legacy devices they "
"will not be attached twice (once as legacy and once as PnP). But in case of "
"device-dependent identify routines it is the responsibility of the driver to "
"make sure that the same device will not be attached by the driver twice: "
"once as legacy user-configured and once as auto-identified."
msgstr ""
"Como os dispositivos PnP s�o desativados ao sondar os dispositivos herdados, "
"eles n�o ser�o conectados duas vezes (uma vez como legado e uma vez como "
"PnP). Mas, no caso de rotinas de identifica��o dependentes de dispositivo, � "
"responsabilidade do motorista certificar-se de que o dispositivo n�o ser� "
"conectado pelo driver duas vezes: uma vez como legado configurado pelo "
"usu�rio e uma vez como identificado automaticamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:16845
#, fuzzy
msgid ""
"Another practical consequence for the auto-identified devices (both PnP and "
"device-specific) is that the flags can not be passed to them from the kernel "
"configuration file. So they must either not use the flags at all or use the "
"flags from the device unit 0 for all the auto-identified devices or use the "
"sysctl interface instead of flags."
msgstr ""
"Outra conseq��ncia pr�tica para os dispositivos identificados "
"automaticamente (tanto PnP quanto espec�ficos do dispositivo) � que os flags "
"n�o podem ser passados ​​para eles a partir do arquivo de configura��o do "
"kernel. Portanto, eles n�o devem usar as flags ou usar os sinalizadores do "
"unidade de dispositivo 0 para todos os dispositivos identificados "
"automaticamente ou use a interface sysctl em vez de sinalizadores. "

#. (itstool) path: sect1/para
#: book.translate.xml:16852
#, fuzzy
msgid ""
"Other unusual configurations may be accommodated by accessing the "
"configuration resources directly with functions of families "
"<function>resource_query_*()</function> and <function>resource_*_value()</"
"function>. Their implementations are located in <filename>kern/subr_bus.c</"
"filename>. The old IDE disk driver <filename>i386/isa/wd.c</filename> "
"contains examples of such use. But the standard means of configuration must "
"always be preferred. Leave parsing the configuration resources to the bus "
"configuration code."
msgstr ""
"Outras configura��es incomuns podem ser acomodadas acessando os recursos de "
"configura��o diretamente com as fun��es das fam�lias. <function> "
"resource_query _ * () </function> e <function> recurso _ * _ valor () </"
"function> . Suas implementa��es est�o localizadas em <filename> kern / "
"subr_bus.c </filename> . O antigo driver de disco IDE <filename> i386 / isa /"
" wd.c </filename> cont�m exemplos de tal uso. Mas os meios padr�o de "
"configura��o sempre devem ser preferidos. Deixe analisando os recursos de "
"configura��o para o c�digo de configura��o do barramento. "

#. (itstool) path: sect1/title
#: book.translate.xml:16865
#, fuzzy
msgid "Resources"
msgstr "Recursos"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16867
#, fuzzy
msgid "<primary>resources</primary>"
msgstr " <primary> Recursos </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16868
#, fuzzy
msgid "<primary>device driver</primary><secondary>resources</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> Recursos </secondary> "
""

#. (itstool) path: sect1/para
#: book.translate.xml:16870
#, fuzzy
msgid ""
"The information that a user enters into the kernel configuration file is "
"processed and passed to the kernel as configuration resources. This "
"information is parsed by the bus configuration code and transformed into a "
"value of structure device_t and the bus resources associated with it. The "
"drivers may access the configuration resources directly using functions "
"<function>resource_*</function> for more complex cases of configuration. "
"However, generally this is neither needed nor recommended, so this issue is "
"not discussed further here."
msgstr ""
"As informa��es que um usu�rio insere no arquivo de configura��o do kernel "
"s�o processadas e passadas para o kernel como recursos de configura��o. "
"Essas informa��es s�o analisadas pelo c�digo de configura��o do barramento e "
"transformadas em um valor de estrutura device_t e os recursos de barramento "
"associados a ele. pode acessar os recursos de configura��o diretamente "
"usando fun��es <function> recurso_* </function> para casos mais complexos de "
"configura��o. No entanto, geralmente isso n�o � necess�rio nem recomendado, "
"por isso esta quest�o n�o � discutida aqui. "

#. (itstool) path: sect1/para
#: book.translate.xml:16880
#, fuzzy
msgid ""
"The bus resources are associated with each device. They are identified by "
"type and number within the type. For the ISA bus the following types are "
"defined:"
msgstr ""
"Os recursos de barramento est�o associados a cada dispositivo. Eles s�o "
"identificados por tipo e n�mero dentro do tipo. Para o barramento ISA, os "
"seguintes tipos s�o definidos:"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:16884
#, fuzzy
msgid "<primary>DMA channel</primary>"
msgstr " <primary> Canal de DMA </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:16888
#, fuzzy
msgid "<emphasis>SYS_RES_IRQ</emphasis> - interrupt number"
msgstr " <emphasis> SYS_RES_IRQ </emphasis> - n�mero de interrup��o "

#. (itstool) path: listitem/para
#: book.translate.xml:16893
#, fuzzy
msgid "<emphasis>SYS_RES_DRQ</emphasis> - ISA DMA channel number"
msgstr " <emphasis> SYS_RES_DRQ </emphasis> - n�mero do canal ISA DMA "

#. (itstool) path: listitem/para
#: book.translate.xml:16898
#, fuzzy
msgid ""
"<emphasis>SYS_RES_MEMORY</emphasis> - range of device memory mapped into the "
"system memory space"
msgstr ""
" <emphasis> SYS_RES_MEMORY </emphasis> - intervalo de mem�ria do dispositivo "
"mapeado no espa�o de mem�ria do sistema "

#. (itstool) path: listitem/para
#: book.translate.xml:16904
#, fuzzy
msgid "<emphasis>SYS_RES_IOPORT</emphasis> - range of device I/O registers"
msgstr ""
" <emphasis> SYS_RES_IOPORT </emphasis> - intervalo de registros de E / S do "
"dispositivo "

#. (itstool) path: sect1/para
#: book.translate.xml:16909
#, fuzzy
msgid ""
"The enumeration within types starts from 0, so if a device has two memory "
"regions it would have resources of type <literal>SYS_RES_MEMORY</literal> "
"numbered 0 and 1. The resource type has nothing to do with the C language "
"type, all the resource values have the C language type <literal>unsigned "
"long</literal> and must be cast as necessary. The resource numbers do not "
"have to be contiguous, although for ISA they normally would be. The "
"permitted resource numbers for ISA devices are:"
msgstr ""
"A enumera��o dentro de tipos come�a em 0, portanto, se um dispositivo tiver "
"duas regi�es de mem�ria, ele ter� recursos do tipo <literal> SYS_RES_MEMORY "
"</literal> numerados 0 e 1. O tipo de recurso n�o tem nada a ver com o tipo "
"de linguagem C, todos os valores de recursos t�m o tipo de linguagem C "
"<literal> sem assinatura longa </literal> e deve ser lan�ado conforme "
"necess�rio. Os n�meros de recursos n�o precisam ser cont�guos, embora, para "
"o ISA, eles normalmente sejam. Os n�meros de recursos permitidos para "
"dispositivos ISA s�o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:16918
#, no-wrap
msgid ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7"
msgstr ""
"          IRQ: 0-1\n"
"          DRQ: 0-1\n"
"          MEMORY: 0-3\n"
"          IOPORT: 0-7"

#. (itstool) path: sect1/para
#: book.translate.xml:16923
#, fuzzy
msgid ""
"All the resources are represented as ranges, with a start value and count. "
"For IRQ and DRQ resources the count would normally be equal to 1. The values "
"for memory refer to the physical addresses."
msgstr ""
"Todos os recursos s�o representados como intervalos, com um valor inicial e "
"uma contagem. Para recursos de IRQ e DRQ, a contagem normalmente seria igual "
"a 1. Os valores para mem�ria referem-se aos endere�os f�sicos."

#. (itstool) path: sect1/para
#: book.translate.xml:16928
#, fuzzy
msgid "Three types of activities can be performed on resources:"
msgstr "Tr�s tipos de atividades podem ser executadas em recursos:"

#. (itstool) path: listitem/para
#: book.translate.xml:16932
#, fuzzy
msgid "set/get"
msgstr "set / get"

#. (itstool) path: listitem/para
#: book.translate.xml:16933
#, fuzzy
msgid "allocate/release"
msgstr "alocar / liberar"

#. (itstool) path: listitem/para
#: book.translate.xml:16934
#, fuzzy
msgid "activate/deactivate"
msgstr "ativar / desativar"

#. (itstool) path: sect1/para
#: book.translate.xml:16937
#, fuzzy
msgid ""
"Setting sets the range used by the resource. Allocation reserves the "
"requested range that no other driver would be able to reserve it (and "
"checking that no other driver reserved this range already). Activation makes "
"the resource accessible to the driver by doing whatever is necessary for "
"that (for example, for memory it would be mapping into the kernel virtual "
"address space)."
msgstr ""
"A configura��o define o intervalo usado pelo recurso. A aloca��o reserva o "
"intervalo solicitado que nenhum outro driver poder� reserv�-lo (e verificar "
"se nenhum outro driver j� reservou esse intervalo). A ativa��o torna o "
"recurso acess�vel ao driver fazendo o que for necess�rio para isso (por "
"exemplo, para mem�ria, seria mapeado para o espa�o de endere�o virtual do "
"kernel). "

#. (itstool) path: sect1/para
#: book.translate.xml:16945
#, fuzzy
msgid "The functions to manipulate resources are:"
msgstr "As fun��es para manipular recursos s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:16949
#, fuzzy
msgid ""
"<function>int bus_set_resource(device_t dev, int type, int rid, u_long "
"start, u_long count)</function>"
msgstr ""
" <function> int bus_set_resource (device_t dev, int tipo, int rid, u_long "
"start, u_long count) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:16952
#, fuzzy
msgid ""
"Set a range for a resource. Returns 0 if successful, error code otherwise. "
"Normally, this function will return an error only if one of <literal>type</"
"literal>, <literal>rid</literal>, <literal>start</literal> or "
"<literal>count</literal> has a value that falls out of the permitted range."
msgstr ""
"Definir um intervalo para um recurso. Retorna 0 se for bem-sucedido, c�digo "
"de erro. Normalmente, essa fun��o retornar� um erro somente se um dos "
"<literal> tipo </literal> , <literal> livrar </literal> , <literal> come�ar "
"</literal> ou <literal> contagem </literal> tem um valor que cai fora do "
"intervalo permitido \""

#. (itstool) path: listitem/para
#: book.translate.xml:16961
#, fuzzy
msgid "dev - driver's device"
msgstr "dev - dispositivo do motorista"

#. (itstool) path: listitem/para
#: book.translate.xml:16964
#, fuzzy
msgid "type - type of resource, SYS_RES_*"
msgstr "tipo - tipo de recurso, SYS_RES_ *"

#. (itstool) path: listitem/para
#: book.translate.xml:16967
#, fuzzy
msgid "rid - resource number (ID) within type"
msgstr "rid - n�mero do recurso (ID) dentro do tipo"

#. (itstool) path: listitem/para
#: book.translate.xml:16970
#, fuzzy
msgid "start, count - resource range"
msgstr "start, count - intervalo de recursos"

#. (itstool) path: listitem/para
#: book.translate.xml:16976
#, fuzzy
msgid ""
"<function>int bus_get_resource(device_t dev, int type, int rid, u_long "
"*startp, u_long *countp)</function>"
msgstr ""
" <function> int bus_get_resource (device_t dev, tipo int, int livrar, u_long "
"* startp, u_long * countp) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:16979
#, fuzzy
msgid ""
"Get the range of resource. Returns 0 if successful, error code if the "
"resource is not defined yet."
msgstr ""
"Obt�m o intervalo de recursos. Retorna 0 se for bem-sucedido, c�digo de erro "
"se o recurso ainda n�o estiver definido."

#. (itstool) path: listitem/para
#: book.translate.xml:16984
#, fuzzy
msgid ""
"<function>u_long bus_get_resource_start(device_t dev, int type, int rid) "
"u_long bus_get_resource_count (device_t dev, int type, int rid)</function>"
msgstr ""
" <function> u_long bus_get_resource_start (device_t dev, int tipo, int rid) "
"u_long bus_get_resource_count (device_t dev, tipo int, int livrado) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:16988
#, fuzzy
msgid ""
"Convenience functions to get only the start or count. Return 0 in case of "
"error, so if the resource start has 0 among the legitimate values it would "
"be impossible to tell if the value is 0 or an error occurred. Luckily, no "
"ISA resources for add-on drivers may have a start value equal to 0."
msgstr ""
"Fun��es de conveni�ncia para obter apenas o in�cio ou a contagem. Retorna 0 "
"em caso de erro, portanto, se o in�cio do recurso tiver 0 entre os valores "
"leg�timos, seria imposs�vel dizer se o valor � 0 ou ocorreu um erro. "
"Felizmente, n�o h� recursos do ISA para drivers add-on pode ter um valor "
"inicial igual a 0. "

#. (itstool) path: listitem/para
#: book.translate.xml:16997
#, fuzzy
msgid ""
"<function>void bus_delete_resource(device_t dev, int type, int rid)</"
"function>"
msgstr ""
" <function> void bus_delete_resource (device_t dev, tipo int, int rid) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:16999
#, fuzzy
msgid "Delete a resource, make it undefined."
msgstr "Excluir um recurso, torn�-lo indefinido."

#. (itstool) path: listitem/para
#: book.translate.xml:17003
#, fuzzy
msgid ""
"<function>struct resource * bus_alloc_resource(device_t dev, int type, int "
"*rid, u_long start, u_long end, u_long count, u_int flags)</function>"
msgstr ""
" <function> struct resource * bus_alloc_resource (device_t dev, int tipo, "
"int * rid, u_long in�cio, u_long end, u_long count, u_int flags) </function> "
""

#. (itstool) path: listitem/para
#: book.translate.xml:17008
#, fuzzy
msgid ""
"Allocate a resource as a range of count values not allocated by anyone else, "
"somewhere between start and end. Alas, alignment is not supported. If the "
"resource was not set yet it is automatically created. The special values of "
"start 0 and end ~0 (all ones) means that the fixed values previously set by "
"<function>bus_set_resource()</function> must be used instead: start and "
"count as themselves and end=(start+count), in this case if the resource was "
"not defined before then an error is returned. Although rid is passed by "
"reference it is not set anywhere by the resource allocation code of the ISA "
"bus. (The other buses may use a different approach and modify it)."
msgstr ""
"Alocar um recurso como um intervalo de valores de contagem n�o alocado por "
"mais ningu�m, em algum lugar entre o in�cio e o final. Infelizmente, o "
"alinhamento n�o � suportado. Se o recurso ainda n�o foi definido, ele � "
"criado automaticamente. Os valores especiais de in�cio 0 e final ~ 0 (todos "
"os) significa que os valores fixos previamente definidos <function> "
"bus_set_resource () </function> deve ser usado em vez disso: start e count "
"como si mesmo e end = (start + count), neste caso, se o recurso n�o foi "
"definido antes, um erro ser� retornado. Embora o rid seja passado por "
"refer�ncia, ele n�o � definido em nenhum lugar pelo c�digo de aloca��o de "
"recursos do barramento ISA. (Os outros �nibus podem usar uma abordagem "
"diferente e modific�-lo). "

#. (itstool) path: sect1/para
#: book.translate.xml:17024
#, fuzzy
msgid "Flags are a bitmap, the flags interesting for the caller are:"
msgstr ""
"Bandeiras s�o um bitmap, as bandeiras interessantes para o chamador s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17029
#, fuzzy
msgid ""
"<emphasis>RF_ACTIVE</emphasis> - causes the resource to be automatically "
"activated after allocation."
msgstr ""
" <emphasis> RF_ACTIVE </emphasis> - faz com que o recurso seja ativado "
"automaticamente ap�s a aloca��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:17034
#, fuzzy
msgid ""
"<emphasis>RF_SHAREABLE</emphasis> - resource may be shared at the same time "
"by multiple drivers."
msgstr ""
" <emphasis> RF_SHAREABLE </emphasis> - recurso pode ser compartilhado ao "
"mesmo tempo por v�rios drivers. "

#. (itstool) path: listitem/para
#: book.translate.xml:17039
#, fuzzy
msgid ""
"<emphasis>RF_TIMESHARE</emphasis> - resource may be time-shared by multiple "
"drivers, i.e., allocated at the same time by many but activated only by one "
"at any given moment of time."
msgstr ""
" <emphasis> RF_TIMESHARE </emphasis> - o recurso pode ser compartilhado no "
"tempo por v�rios drivers, isto �, alocado ao mesmo tempo por muitos, mas "
"ativado apenas por um em qualquer momento. "

#. (itstool) path: listitem/para
#: book.translate.xml:17046
#, fuzzy
msgid ""
"Returns 0 on error. The allocated values may be obtained from the returned "
"handle using methods <function>rhand_*()</function>."
msgstr ""
"Retorna 0 no erro. Os valores alocados podem ser obtidos a partir do "
"identificador retornado usando m�todos <function> rhand _ * () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17051
#, fuzzy
msgid ""
"<function>int bus_release_resource(device_t dev, int type, int rid, struct "
"resource *r)</function>"
msgstr ""
" <function> int bus_release_resource (device_t dev, tipo int, int rid, "
"recurso struct * r) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17056
#, fuzzy
msgid ""
"Release the resource, r is the handle returned by "
"<function>bus_alloc_resource()</function>. Returns 0 on success, error code "
"otherwise."
msgstr ""
"Libere o recurso, r � o identificador retornado por <function> "
"bus_alloc_resource () </function> . Retorna 0 em caso de sucesso, c�digo de "
"erro. "

#. (itstool) path: listitem/para
#: book.translate.xml:17062
#, fuzzy
msgid ""
"<function>int bus_activate_resource(device_t dev, int type, int rid, struct "
"resource *r)</function> <function>int bus_deactivate_resource(device_t dev, "
"int type, int rid, struct resource *r)</function>"
msgstr ""
" <function> int bus_activate_resource (device_t dev, tipo int, int rid, "
"recurso struct * r) </function><function> int bus_deactivate_resource "
"(device_t dev, int tipo, int rid, struct resource * r) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17069
#, fuzzy
msgid ""
"Activate or deactivate resource. Return 0 on success, error code otherwise. "
"If the resource is time-shared and currently activated by another driver "
"then <literal>EBUSY</literal> is returned."
msgstr ""
"Ativar ou desativar o recurso. Retornar 0 em caso de sucesso, c�digo de erro "
"de outra forma. Se o recurso for compartilhado por tempo e atualmente "
"ativado por outro driver, ent�o <literal> EBUSY </literal> � devolvido \""

#. (itstool) path: listitem/para
#: book.translate.xml:17076
#, fuzzy
msgid ""
"<function>int bus_setup_intr(device_t dev, struct resource *r, int flags, "
"driver_intr_t *handler, void *arg, void **cookiep)</function> <function>int "
"bus_teardown_intr(device_t dev, struct resource *r, void *cookie)</function>"
msgstr ""
" <function> int bus_setup_intr (device_t dev, struct recurso * r, int flags, "
"driver_intr_t * manipulador, void * arg, void ** cookiep) </"
"function><function> int bus_teardown_intr (device_t dev, struct recurso * r, "
"void * cookie) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17084
#, fuzzy
msgid ""
"Associate or de-associate the interrupt handler with a device. Return 0 on "
"success, error code otherwise."
msgstr ""
"Associe ou desassocie o manipulador de interrup��o com um dispositivo. "
"Retorne 0 ao sucesso, caso contr�rio, o c�digo de erro."

#. (itstool) path: listitem/para
#: book.translate.xml:17089
#, fuzzy
msgid "r - the activated resource handler describing the IRQ"
msgstr "r - o manipulador de recursos ativado que descreve o IRQ"

#. (itstool) path: listitem/para
#: book.translate.xml:17091
#, fuzzy
msgid "flags - the interrupt priority level, one of:"
msgstr "flags - o n�vel de prioridade de interrup��o, um dos seguintes:"

#. (itstool) path: listitem/para
#: book.translate.xml:17095
#, fuzzy
msgid ""
"<function>INTR_TYPE_TTY</function> - terminals and other likewise character-"
"type devices. To mask them use <function>spltty()</function>."
msgstr ""
" <function> INTR_TYPE_TTY </function> - terminais e outros dispositivos do "
"tipo caractere. Para mascar�-los, use <function> spltty () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17100
#, fuzzy
msgid ""
"<function>(INTR_TYPE_TTY | INTR_TYPE_FAST)</function> - terminal type "
"devices with small input buffer, critical to the data loss on input (such as "
"the old-fashioned serial ports). To mask them use <function>spltty()</"
"function>."
msgstr ""
" <function> (INTR_TYPE_TTY | INTR_TYPE_FAST) </function> - dispositivos do "
"tipo terminal com pequeno buffer de entrada, cr�tico para a perda de dados "
"na entrada (como as portas seriais antigas). Para mascar�-los, use "
"<function> spltty () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17107
#, fuzzy
msgid ""
"<function>INTR_TYPE_BIO</function> - block-type devices, except those on the "
"CAM controllers. To mask them use <function>splbio()</function>."
msgstr ""
" <function> INTR_TYPE_BIO </function> - dispositivos do tipo bloco, exceto "
"aqueles nos controladores CAM. Para mascar�-los, use <function> splbio () </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17112
#, fuzzy
msgid ""
"<function>INTR_TYPE_CAM</function> - CAM (Common Access Method) bus "
"controllers. To mask them use <function>splcam()</function>."
msgstr ""
" <function> INTR_TYPE_CAM </function> - Controladores de barramento CAM "
"(Common Access Method). Para mascar�-los, use <function> splcam () </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17117
#, fuzzy
msgid ""
"<function>INTR_TYPE_NET</function> - network interface controllers. To mask "
"them use <function>splimp()</function>."
msgstr ""
" <function> INTR_TYPE_NET </function> - controladores de interface de rede. "
"Para mascar�-los, use <function> splimp () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17122
#, fuzzy
msgid ""
"<function>INTR_TYPE_MISC</function> - miscellaneous devices. There is no "
"other way to mask them than by <function>splhigh()</function> which masks "
"all interrupts."
msgstr ""
" <function> INTR_TYPE_MISC </function> - dispositivos diversos. N�o h� outra "
"maneira de mascar�-los do que <function> splhigh () </function> que mascara "
"todas as interrup��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:17131
#, fuzzy
msgid ""
"When an interrupt handler executes all the other interrupts matching its "
"priority level will be masked. The only exception is the MISC level for "
"which no other interrupts are masked and which is not masked by any other "
"interrupt."
msgstr ""
"Quando um manipulador de interrup��es executa todas as outras interrup��es "
"correspondentes ao seu n�vel de prioridade ser� mascarado. A �nica exce��o � "
"o n�vel MISC para o qual nenhuma outra interrup��o � mascarada e que n�o � "
"mascarada por qualquer outra interrup��o."

#. (itstool) path: listitem/para
#: book.translate.xml:17139
#, fuzzy
msgid ""
"<emphasis>handler</emphasis> - pointer to the handler function, the type "
"driver_intr_t is defined as <function>void driver_intr_t(void *)</function>"
msgstr ""
" <emphasis> manipulador </emphasis> - ponteiro para a fun��o de manipulador, "
"o tipo driver_intr_t � definido como <function> void driver_intr_t (void *) "
"</function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17144
#, fuzzy
msgid ""
"<emphasis>arg</emphasis> - the argument passed to the handler to identify "
"this particular device. It is cast from void* to any real type by the "
"handler. The old convention for the ISA interrupt handlers was to use the "
"unit number as argument, the new (recommended) convention is using a pointer "
"to the device softc structure."
msgstr ""
" <emphasis> arg </emphasis> - o argumento passado para o manipulador para "
"identificar esse dispositivo em particular. Ele � convertido de void * para "
"qualquer tipo real pelo manipulador. A antiga conven��o para os "
"manipuladores de interrup��o do ISA era usar o n�mero da unidade como "
"argumento, a nova conven��o (recomendada) est� usando um ponteiro para a "
"estrutura do dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:17152
#, fuzzy
msgid ""
"<emphasis>cookie[p]</emphasis> - the value received from <function>setup()</"
"function> is used to identify the handler when passed to "
"<function>teardown()</function>"
msgstr ""
" <emphasis> cookie [p] </emphasis> - o valor recebido de <function> "
"configura��o() </function> � usado para identificar o manipulador quando "
"passado para <function> destruir() </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:17159
#, fuzzy
msgid ""
"A number of methods are defined to operate on the resource handlers (struct "
"resource *). Those of interest to the device driver writers are:"
msgstr ""
"V�rios m�todos s�o definidos para operar nos manipuladores de recursos "
"(struct resource *). Aqueles de interesse para os gravadores de driver de "
"dispositivo s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17165
#, fuzzy
msgid ""
"<function>u_long rman_get_start(r) u_long rman_get_end(r)</function> Get the "
"start and end of allocated resource range."
msgstr ""
" <function> u_long rman_get_start (r) u_long rman_get_end (r) </function> "
"Obtenha o in�cio e o fim do intervalo de recursos alocados. "

#. (itstool) path: listitem/para
#: book.translate.xml:17170
#, fuzzy
msgid ""
"<function>void *rman_get_virtual(r)</function> Get the virtual address of "
"activated memory resource."
msgstr ""
" <function> void * rman_get_virtual (r) </function> Obtenha o endere�o "
"virtual do recurso de mem�ria ativada. "

#. (itstool) path: sect1/title
#: book.translate.xml:17178
#, fuzzy
msgid "Bus Memory Mapping"
msgstr "Mapeamento de mem�ria de barramento"

#. (itstool) path: sect1/para
#: book.translate.xml:17180
#, fuzzy
msgid ""
"In many cases data is exchanged between the driver and the device through "
"the memory. Two variants are possible:"
msgstr ""
"Em muitos casos, os dados s�o trocados entre o driver e o dispositivo "
"atrav�s da mem�ria. Duas variantes s�o poss�veis:"

#. (itstool) path: sect1/para
#: book.translate.xml:17183
#, fuzzy
msgid "(a) memory is located on the device card"
msgstr "(a) a mem�ria est� localizada no cart�o do dispositivo"

#. (itstool) path: sect1/para
#: book.translate.xml:17184
#, fuzzy
msgid "(b) memory is the main memory of the computer"
msgstr "(b) mem�ria � a mem�ria principal do computador"

#. (itstool) path: sect1/para
#: book.translate.xml:17186
#, fuzzy
msgid ""
"In case (a) the driver always copies the data back and forth between the on-"
"card memory and the main memory as necessary. To map the on-card memory into "
"the kernel virtual address space the physical address and length of the on-"
"card memory must be defined as a <literal>SYS_RES_MEMORY</literal> resource. "
"That resource can then be allocated and activated, and its virtual address "
"obtained using <function>rman_get_virtual()</function>. The older drivers "
"used the function <function>pmap_mapdev()</function> for this purpose, which "
"should not be used directly any more. Now it is one of the internal steps of "
"resource activation."
msgstr ""
"No caso (a), o driver sempre copia os dados entre a mem�ria no cart�o e a "
"mem�ria principal, conforme necess�rio. Para mapear a mem�ria no cart�o para "
"o espa�o de endere�o virtual do kernel, o endere�o f�sico eo comprimento do "
"mem�ria do cart�o deve ser definida como <literal> SYS_RES_MEMORY </literal> "
"recurso. Esse recurso pode ent�o ser alocado e ativado, e seu endere�o "
"virtual obtido usando <function> rman_get_virtual () </function> . Os "
"drivers mais antigos usavam a fun��o <function> pmap_mapdev () </function> "
"para este fim, que n�o deve ser usado diretamente mais. Agora � uma das "
"etapas internas da ativa��o de recursos. "

#. (itstool) path: sect1/para
#: book.translate.xml:17198
#, fuzzy
msgid ""
"Most of the ISA cards will have their memory configured for physical "
"location somewhere in range 640KB-1MB. Some of the ISA cards require larger "
"memory ranges which should be placed somewhere under 16MB (because of the 24-"
"bit address limitation on the ISA bus). In that case if the machine has more "
"memory than the start address of the device memory (in other words, they "
"overlap) a memory hole must be configured at the address range used by "
"devices. Many BIOSes allow configuration of a memory hole of 1MB starting at "
"14MB or 15MB. FreeBSD can handle the memory holes properly if the BIOS "
"reports them properly (this feature may be broken on old BIOSes)."
msgstr ""
"A maioria das placas ISA ter� sua mem�ria configurada para localiza��o "
"f�sica em algum lugar no intervalo de 640 KB-1 MB. Algumas das placas ISA "
"exigem intervalos de mem�ria maiores que devem ser colocados em algum lugar "
"abaixo de 16 MB (devido � limita��o de endere�o de 24 bits no barramento ISA "
"Nesse caso, se a m�quina tiver mais mem�ria do que o endere�o inicial da "
"mem�ria do dispositivo (em outras palavras, eles se sobrep�em), um orif�cio "
"de mem�ria deve ser configurado na faixa de endere�os usada pelos "
"dispositivos.Muitos BIOS permitem a configura��o de um orif�cio de mem�ria. "
"1MB a partir de 14MB ou 15MB O FreeBSD pode lidar com os buracos de mem�ria "
"se o BIOS reportar corretamente (este recurso pode estar quebrado em BIOS "
"antigas). "

#. (itstool) path: sect1/para
#: book.translate.xml:17210
#, fuzzy
msgid ""
"In case (b) just the address of the data is sent to the device, and the "
"device uses DMA to actually access the data in the main memory. Two "
"limitations are present: First, ISA cards can only access memory below 16MB. "
"Second, the contiguous pages in virtual address space may not be contiguous "
"in physical address space, so the device may have to do scatter/gather "
"operations. The bus subsystem provides ready solutions for some of these "
"problems, the rest has to be done by the drivers themselves."
msgstr ""
"No caso (b) apenas o endere�o dos dados � enviado para o dispositivo, e o "
"dispositivo usa DMA para acessar os dados na mem�ria principal. Duas "
"limita��es est�o presentes: Primeiro, as placas ISA s� podem acessar mem�ria "
"abaixo de 16MB. , as p�ginas cont�guas no espa�o de endere�o virtual podem "
"n�o ser cont�guas no espa�o de endere�o f�sico, portanto, o dispositivo pode "
"ter que fazer opera��es de dispers�o / coleta.O subsistema de barramento "
"fornece solu��es prontas para alguns desses problemas, o restante deve ser "
"feito pelos drivers si mesmos."

#. (itstool) path: sect1/para
#: book.translate.xml:17220
#, fuzzy
msgid ""
"Two structures are used for DMA memory allocation, <varname>bus_dma_tag_t</"
"varname> and <varname>bus_dmamap_t</varname>. Tag describes the properties "
"required for the DMA memory. Map represents a memory block allocated "
"according to these properties. Multiple maps may be associated with the same "
"tag."
msgstr ""
"Duas estruturas s�o usadas para aloca��o de mem�ria DMA, <varname> "
"bus_dma_tag_t </varname> e <varname> bus_dmamap_t </varname> . Tag descreve "
"as propriedades necess�rias para a mem�ria DMA. Mapa representa um bloco de "
"mem�ria alocado de acordo com essas propriedades. V�rios mapas podem estar "
"associados � mesma tag. "

#. (itstool) path: sect1/para
#: book.translate.xml:17226
#, fuzzy
msgid ""
"Tags are organized into a tree-like hierarchy with inheritance of the "
"properties. A child tag inherits all the requirements of its parent tag, and "
"may make them more strict but never more loose."
msgstr ""
"As tags s�o organizadas em uma hierarquia em forma de �rvore com heran�a das "
"propriedades. Uma tag filha herda todos os requisitos de sua tag pai e pode "
"torn�-los mais r�gidos, mas nunca mais frouxos."

#. (itstool) path: sect1/para
#: book.translate.xml:17231
#, fuzzy
msgid ""
"Normally one top-level tag (with no parent) is created for each device unit. "
"If multiple memory areas with different requirements are needed for each "
"device then a tag for each of them may be created as a child of the parent "
"tag."
msgstr ""
"Normalmente, uma tag de n�vel superior (sem pai) � criada para cada unidade "
"de dispositivo. Se v�rias �reas de mem�ria com requisitos diferentes forem "
"necess�rias para cada dispositivo, uma tag para cada uma delas poder� ser "
"criada como filha da tag pai."

#. (itstool) path: sect1/para
#: book.translate.xml:17236
#, fuzzy
msgid "The tags can be used to create a map in two ways."
msgstr "As tags podem ser usadas para criar um mapa de duas maneiras."

#. (itstool) path: sect1/para
#: book.translate.xml:17238
#, fuzzy
msgid ""
"First, a chunk of contiguous memory conformant with the tag requirements may "
"be allocated (and later may be freed). This is normally used to allocate "
"relatively long-living areas of memory for communication with the device. "
"Loading of such memory into a map is trivial: it is always considered as one "
"chunk in the appropriate physical memory range."
msgstr ""
"Primeiro, um peda�o de mem�ria cont�gua em conformidade com os requisitos de "
"tag pode ser alocado (e mais tarde pode ser liberado). Isso � normalmente "
"usado para alocar �reas de mem�ria relativamente longas para comunica��o com "
"o dispositivo. Carregamento de tal mem�ria em um mapa. � trivial: � sempre "
"considerado como um peda�o na faixa de mem�ria f�sica apropriada \""

#. (itstool) path: sect1/para
#: book.translate.xml:17246
#, fuzzy
msgid ""
"Second, an arbitrary area of virtual memory may be loaded into a map. Each "
"page of this memory will be checked for conformance to the map requirement. "
"If it conforms then it is left at its original location. If it is not then a "
"fresh conformant <quote>bounce page</quote> is allocated and used as "
"intermediate storage. When writing the data from the non-conformant original "
"pages they will be copied to their bounce pages first and then transferred "
"from the bounce pages to the device. When reading the data would go from the "
"device to the bounce pages and then copied to their non-conformant original "
"pages. The process of copying between the original and bounce pages is "
"called synchronization. This is normally used on a per-transfer basis: "
"buffer for each transfer would be loaded, transfer done and buffer unloaded."
msgstr ""
"Segundo, uma �rea arbitr�ria da mem�ria virtual pode ser carregada em um "
"mapa. Cada p�gina dessa mem�ria ser� verificada quanto � conformidade com o "
"requisito do mapa. Se estiver em conformidade, ela ser� deixada no local "
"original. Se n�o for, ent�o, um novo conformant <quote> p�gina de rejei��o </"
"quote> � alocado e usado como armazenamento intermedi�rio. Ao gravar os "
"dados das p�ginas originais n�o conformes, eles ser�o copiados primeiro para "
"suas p�ginas devolvidas e depois transferidos das p�ginas devolvidas para o "
"dispositivo. Ao ler os dados, eles iriam do dispositivo para as p�ginas "
"devolvidas e depois copiados para as p�ginas originais n�o conformes. O "
"processo de c�pia entre as p�ginas original e de retorno � chamado de "
"sincroniza��o. Isso � normalmente usado em uma base por transfer�ncia: "
"buffer para cada transfer�ncia seria carregado, transfer�ncia feita e buffer "
"descarregado. "

#. (itstool) path: sect1/para
#: book.translate.xml:17261
#, fuzzy
msgid "The functions working on the DMA memory are:"
msgstr "As fun��es que trabalham na mem�ria DMA s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17265
#, fuzzy
msgid ""
"<function>int bus_dma_tag_create(bus_dma_tag_t parent, bus_size_t alignment, "
"bus_size_t boundary, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t *filter, void *filterarg, bus_size_t maxsize, int "
"nsegments, bus_size_t maxsegsz, int flags, bus_dma_tag_t *dmat)</function>"
msgstr ""
" <function> int bus_dma_tag_create (bus_dma_tag_t pai, bus_size_t "
"alinhamento, bus_size_t limite, bus_addr_t lowaddr, bus_addr_t highaddr, "
"bus_dma_filter_t * filtro, void * filterarg, bus_size_t maxsize, int "
"nsegmentos, bus_size_t maxsegsz, int sinalizadores, bus_dma_tag_t * dmat) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17271
#, fuzzy
msgid "Create a new tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Crie uma nova tag. Retorna 0 em caso de sucesso, caso contr�rio, o c�digo de "
"erro."

#. (itstool) path: listitem/para
#: book.translate.xml:17276
#, fuzzy
msgid ""
"<emphasis>parent</emphasis> - parent tag, or NULL to create a top-level tag."
msgstr ""
" <emphasis> pai </emphasis> - tag pai ou NULL para criar uma tag de n�vel "
"superior. "

#. (itstool) path: listitem/para
#: book.translate.xml:17281
#, fuzzy
msgid ""
"<emphasis>alignment</emphasis> - required physical alignment of the memory "
"area to be allocated for this tag. Use value 1 for <quote>no specific "
"alignment</quote>. Applies only to the future <function>bus_dmamem_alloc()</"
"function> but not <function>bus_dmamap_create()</function> calls."
msgstr ""
" <emphasis> alinhamento </emphasis> - necess�rio alinhamento f�sico da �rea "
"de mem�ria a ser alocada para esta tag. Use o valor 1 para <quote> sem "
"alinhamento espec�fico </quote> . Aplica-se apenas ao futuro <function> "
"bus_dmamem_alloc () </function> mas n�o <function> bus_dmamap_create () </"
"function> chama \""

#. (itstool) path: listitem/para
#: book.translate.xml:17290
#, fuzzy
msgid ""
"<emphasis>boundary</emphasis> - physical address boundary that must not be "
"crossed when allocating the memory. Use value 0 for <quote>no boundary</"
"quote>. Applies only to the future <function>bus_dmamem_alloc()</function> "
"but not <function>bus_dmamap_create()</function> calls. Must be power of 2. "
"If the memory is planned to be used in non-cascaded DMA mode (i.e., the DMA "
"addresses will be supplied not by the device itself but by the ISA DMA "
"controller) then the boundary must be no larger than 64KB (64*1024) due to "
"the limitations of the DMA hardware."
msgstr ""
" <emphasis> fronteira </emphasis> - limite de endere�o f�sico que n�o deve "
"ser ultrapassado ao alocar a mem�ria. Use o valor 0 para <quote> sem limite "
"</quote> . Aplica-se apenas ao futuro <function> bus_dmamem_alloc () </"
"function> mas n�o <function> bus_dmamap_create () </function> chamadas. Deve "
"ser a pot�ncia de 2. Se a mem�ria for planejada para ser usada no modo DMA "
"n�o em cascata (ou seja, os endere�os DMA ser�o fornecidos n�o pelo pr�prio "
"dispositivo, mas pelo controlador ISA DMA), o limite n�o dever� ser maior "
"que 64 KB (64 * 1024) devido �s limita��es do hardware DMA. "

#. (itstool) path: listitem/para
#: book.translate.xml:17304
#, fuzzy
msgid ""
"<emphasis>lowaddr, highaddr</emphasis> - the names are slightly misleading; "
"these values are used to limit the permitted range of physical addresses "
"used to allocate the memory. The exact meaning varies depending on the "
"planned future use:"
msgstr ""
" <emphasis> lowaddr, highaddr </emphasis> - os nomes s�o ligeiramente "
"enganadores; esses valores s�o usados ​​para limitar o intervalo permitido "
"de endere�os f�sicos usados ​​para alocar a mem�ria. O significado exato "
"varia dependendo do uso futuro planejado: "

#. (itstool) path: listitem/para
#: book.translate.xml:17312
#, fuzzy
msgid ""
"For <function>bus_dmamem_alloc()</function> all the addresses from 0 to "
"lowaddr-1 are considered permitted, the higher ones are forbidden."
msgstr ""
"Para <function> bus_dmamem_alloc () </function> todos os endere�os de 0 a "
"lowaddr-1 s�o considerados permitidos, os mais altos s�o proibidos. "

#. (itstool) path: listitem/para
#: book.translate.xml:17318
#, fuzzy
msgid ""
"For <function>bus_dmamap_create()</function> all the addresses outside the "
"inclusive range [lowaddr; highaddr] are considered accessible. The addresses "
"of pages inside the range are passed to the filter function which decides if "
"they are accessible. If no filter function is supplied then all the range is "
"considered unaccessible."
msgstr ""
"Para <function> bus_dmamap_create () </function> todos os endere�os fora do "
"intervalo inclusivo [lowaddr; highaddr] s�o considerados acess�veis. Os "
"endere�os das p�ginas dentro do intervalo s�o passados ​​para a fun��o de "
"filtro que decide se eles est�o acess�veis. Se nenhuma fun��o de filtro for "
"fornecida, todo o intervalo ser� considerado inacess�vel. "

#. (itstool) path: listitem/para
#: book.translate.xml:17328
#, fuzzy
msgid "For the ISA devices the normal values (with no filter function) are:"
msgstr ""
"Para os dispositivos ISA, os valores normais (sem fun��o de filtro) s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:17330
#, fuzzy
msgid "lowaddr = BUS_SPACE_MAXADDR_24BIT"
msgstr "lowaddr = BUS_SPACE_MAXADDR_24BIT"

#. (itstool) path: listitem/para
#: book.translate.xml:17331
#, fuzzy
msgid "highaddr = BUS_SPACE_MAXADDR"
msgstr "highaddr = BUS_SPACE_MAXADDR"

#. (itstool) path: listitem/para
#: book.translate.xml:17338
#, fuzzy
msgid ""
"<emphasis>filter, filterarg</emphasis> - the filter function and its "
"argument. If NULL is passed for filter then the whole range [lowaddr, "
"highaddr] is considered unaccessible when doing "
"<function>bus_dmamap_create()</function>. Otherwise the physical address of "
"each attempted page in range [lowaddr; highaddr] is passed to the filter "
"function which decides if it is accessible. The prototype of the filter "
"function is: <function>int filterfunc(void *arg, bus_addr_t paddr)</"
"function>. It must return 0 if the page is accessible, non-zero otherwise."
msgstr ""
" <emphasis> filtrar, filtrar </emphasis> - a fun��o de filtro e seu "
"argumento. Se NULL for passado para filtro, todo o intervalo [lowaddr, "
"highaddr] ser� considerado inacess�vel ao fazer <function> bus_dmamap_create "
"() </function> . Caso contr�rio, o endere�o f�sico de cada p�gina tentada no "
"intervalo [lowaddr; highaddr] � passado para a fun��o de filtro que decide "
"se � acess�vel. O prot�tipo da fun��o de filtro �: <function> int filterfunc "
"(void * arg, bus_addr_t paddr) </function> . Ele deve retornar 0 se a p�gina "
"estiver acess�vel, diferente de zero. "

#. (itstool) path: listitem/para
#: book.translate.xml:17352
#, fuzzy
msgid ""
"<emphasis>maxsize</emphasis> - the maximal size of memory (in bytes) that "
"may be allocated through this tag. In case it is difficult to estimate or "
"could be arbitrarily big, the value for ISA devices would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
" <emphasis> tamanho m�ximo </emphasis> - o tamanho m�ximo de mem�ria (em "
"bytes) que pode ser alocado atrav�s desta tag. No caso de ser dif�cil "
"estimar ou ser arbitrariamente grande, o valor dos dispositivos ISA seria "
"<literal> BUS_SPACE_MAXSIZE_24BIT </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:17360
#, fuzzy
msgid ""
"<emphasis>nsegments</emphasis> - maximal number of scatter-gather segments "
"supported by the device. If unrestricted then the value "
"<literal>BUS_SPACE_UNRESTRICTED</literal> should be used. This value is "
"recommended for the parent tags, the actual restrictions would then be "
"specified for the descendant tags. Tags with nsegments equal to "
"<literal>BUS_SPACE_UNRESTRICTED</literal> may not be used to actually load "
"maps, they may be used only as parent tags. The practical limit for "
"nsegments seems to be about 250-300, higher values will cause kernel stack "
"overflow (the hardware can not normally support that many scatter-gather "
"buffers anyway)."
msgstr ""
" <emphasis> nsegmentos </emphasis> - N�mero m�ximo de segmentos de coleta "
"dispersa suportados pelo dispositivo. Se irrestrito, ent�o o valor <literal> "
"BUS_SPACE_UNRESTRICTED </literal> deve ser usado. Esse valor � recomendado "
"para as tags pai, as restri��es reais seriam, ent�o, especificadas para as "
"tags descendentes. Tags com nsegmentos iguais a <literal> "
"BUS_SPACE_UNRESTRICTED </literal> n�o podem ser usados ​​para carregar "
"mapas, eles podem ser usados ​​apenas como tags pai. O limite pr�tico para "
"nsegments parece ser de cerca de 250-300, valores mais altos causar�o "
"estouro de pilha do kernel (o hardware normalmente n�o suporta muitos "
"buffers de dispers�o de coleta). "

#. (itstool) path: listitem/para
#: book.translate.xml:17375
#, fuzzy
msgid ""
"<emphasis>maxsegsz</emphasis> - maximal size of a scatter-gather segment "
"supported by the device. The maximal value for ISA device would be "
"<literal>BUS_SPACE_MAXSIZE_24BIT</literal>."
msgstr ""
" <emphasis> maxsegsz </emphasis> - tamanho m�ximo de um segmento de coleta "
"dispersa suportado pelo dispositivo. O valor m�ximo para o dispositivo ISA "
"seria <literal> BUS_SPACE_MAXSIZE_24BIT </literal> "

#. (itstool) path: listitem/para
#: book.translate.xml:17382
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - a bitmap of flags. The only interesting flags "
"are:"
msgstr ""
" <emphasis> bandeiras </emphasis> - um bitmap de bandeiras. As �nicas "
"bandeiras interessantes s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:17387
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_ALLOCNOW</emphasis> - requests to allocate all the "
"potentially needed bounce pages when creating the tag."
msgstr ""
" <emphasis> BUS_DMA_ALLOCNOW </emphasis> - solicita��es para alocar todas as "
"p�ginas de rejei��o potencialmente necess�rias ao criar a tag. "

#. (itstool) path: listitem/para
#: book.translate.xml:17393
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_ISA</emphasis> - mysterious flag used only on Alpha "
"machines. It is not defined for the i386 machines. Probably it should be "
"used by all the ISA drivers for Alpha machines but it looks like there are "
"no such drivers yet."
msgstr ""
" <emphasis> BUS_DMA_ISA </emphasis> - bandeira misteriosa usada somente em "
"m�quinas Alpha. N�o est� definido para as m�quinas i386. Provavelmente deve "
"ser usado por todos os drivers ISA para m�quinas Alpha, mas parece que ainda "
"n�o existem drivers. "

#. (itstool) path: listitem/para
#: book.translate.xml:17403
#, fuzzy
msgid ""
"<emphasis>dmat</emphasis> - pointer to the storage for the new tag to be "
"returned."
msgstr ""
" <emphasis> dmat </emphasis> - ponteiro para o armazenamento para a nova tag "
"a ser devolvida. "

#. (itstool) path: listitem/para
#: book.translate.xml:17412
#, fuzzy
msgid "<function>int bus_dma_tag_destroy(bus_dma_tag_t dmat)</function>"
msgstr " <function> int bus_dma_tag_destroy (bus_dma_tag_t dmat) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17415
#, fuzzy
msgid "Destroy a tag. Returns 0 on success, the error code otherwise."
msgstr ""
"Destrua uma tag. Retorna 0 em caso de sucesso, caso contr�rio, o c�digo de "
"erro."

#. (itstool) path: listitem/para
#: book.translate.xml:17418
#, fuzzy
msgid "dmat - the tag to be destroyed."
msgstr "dmat - a tag a ser destru�da."

#. (itstool) path: listitem/para
#: book.translate.xml:17423
#, fuzzy
msgid ""
"<function>int bus_dmamem_alloc(bus_dma_tag_t dmat, void** vaddr, int flags, "
"bus_dmamap_t *mapp)</function>"
msgstr ""
" <function> int bus_dmamem_alloc (bus_dma_tag_t_dmat, void ** vaddr, int "
"flags, bus_dmamap_t * mapp) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17427
#, fuzzy
msgid ""
"Allocate an area of contiguous memory described by the tag. The size of "
"memory to be allocated is tag's maxsize. Returns 0 on success, the error "
"code otherwise. The result still has to be loaded by "
"<function>bus_dmamap_load()</function> before being used to get the physical "
"address of the memory."
msgstr ""
"Aloca uma �rea de mem�ria cont�gua descrita pela tag. O tamanho da mem�ria a "
"ser alocada � maxsize da tag. Retorna 0 em caso de sucesso, caso contr�rio o "
"c�digo de erro. O resultado ainda tem que ser carregado por <function> "
"bus_dmamap_load () </function> antes de ser usado para obter o endere�o "
"f�sico da mem�ria \""

#. (itstool) path: listitem/para
#: book.translate.xml:17436 book.translate.xml:17492 book.translate.xml:17523
#: book.translate.xml:17595
#, fuzzy
msgid "<emphasis>dmat</emphasis> - the tag"
msgstr " <emphasis> dmat </emphasis> - a etiqueta"

#. (itstool) path: listitem/para
#: book.translate.xml:17441
#, fuzzy
msgid ""
"<emphasis>vaddr</emphasis> - pointer to the storage for the kernel virtual "
"address of the allocated area to be returned."
msgstr ""
" <emphasis> vaddr </emphasis> - ponteiro para o armazenamento do endere�o "
"virtual do kernel da �rea alocada a ser retornada. "

#. (itstool) path: listitem/para
#: book.translate.xml:17448
#, fuzzy
msgid "flags - a bitmap of flags. The only interesting flag is:"
msgstr "flags - um bitmap de bandeiras. A �nica bandeira interessante �:"

#. (itstool) path: listitem/para
#: book.translate.xml:17453
#, fuzzy
msgid ""
"<emphasis>BUS_DMA_NOWAIT</emphasis> - if the memory is not immediately "
"available return the error. If this flag is not set then the routine is "
"allowed to sleep until the memory becomes available."
msgstr ""
" <emphasis> BUS_DMA_NOWAIT </emphasis> - se a mem�ria n�o estiver "
"imediatamente dispon�vel, devolva o erro. Se esse sinalizador n�o estiver "
"definido, a rotina poder� ser suspensa at� que a mem�ria fique dispon�vel. "

#. (itstool) path: listitem/para
#: book.translate.xml:17464
#, fuzzy
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be "
"returned."
msgstr ""
" <emphasis> mapp </emphasis> - ponteiro para o armazenamento para o novo "
"mapa a ser devolvido. "

#. (itstool) path: listitem/para
#: book.translate.xml:17473
#, fuzzy
msgid ""
"<function>void bus_dmamem_free(bus_dma_tag_t dmat, void *vaddr, bus_dmamap_t "
"map)</function>"
msgstr ""
" <function> void bus_dmamem_free (bus_dma_tag_t dmat, void * vaddr, mapa de "
"bus_dmamap_t) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17477
#, fuzzy
msgid ""
"Free the memory allocated by <function>bus_dmamem_alloc()</function>. At "
"present, freeing of the memory allocated with ISA restrictions is not "
"implemented. Because of this the recommended model of use is to keep and re-"
"use the allocated areas for as long as possible. Do not lightly free some "
"area and then shortly allocate it again. That does not mean that "
"<function>bus_dmamem_free()</function> should not be used at all: hopefully "
"it will be properly implemented soon."
msgstr ""
"Libere a mem�ria alocada por <function> bus_dmamem_alloc () </function> . "
"Atualmente, a libera��o da mem�ria alocada com restri��es ISA n�o est� "
"implementada. Por isso, o modelo de uso recomendado � manter e reutilizar as "
"�reas alocadas pelo maior tempo poss�vel. N�o liberte levemente alguma �rea "
"e, em seguida, aloque-a de novo. Isso n�o significa que <function> "
"bus_dmamem_free () </function> n�o deve ser usado: esperamos que seja "
"implementado em breve. "

#. (itstool) path: listitem/para
#: book.translate.xml:17496
#, fuzzy
msgid "<emphasis>vaddr</emphasis> - the kernel virtual address of the memory"
msgstr ""
" <emphasis> vaddr </emphasis> - o endere�o virtual do kernel da mem�ria "

#. (itstool) path: listitem/para
#: book.translate.xml:17502
#, fuzzy
msgid ""
"<emphasis>map</emphasis> - the map of the memory (as returned from "
"<function>bus_dmamem_alloc()</function>)"
msgstr ""
" <emphasis> mapa </emphasis> - o mapa da mem�ria (conforme retornado de "
"<function> bus_dmamem_alloc () </function> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:17512
#, fuzzy
msgid ""
"<function>int bus_dmamap_create(bus_dma_tag_t dmat, int flags, bus_dmamap_t "
"*mapp)</function>"
msgstr ""
" <function> int bus_dmamap_create (bus_dma_tag_t dmat, sinalizadores int, "
"bus_dmamap_t * mapp) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17516
#, fuzzy
msgid ""
"Create a map for the tag, to be used in <function>bus_dmamap_load()</"
"function> later. Returns 0 on success, the error code otherwise."
msgstr ""
"Crie um mapa para a tag, para ser usado em <function> bus_dmamap_load () </"
"function> mais tarde. Retorna 0 em caso de sucesso, caso contr�rio, o c�digo "
"de erro. "

#. (itstool) path: listitem/para
#: book.translate.xml:17528
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - theoretically, a bit map of flags. But no flags "
"are defined yet, so at present it will be always 0."
msgstr ""
" <emphasis> bandeiras </emphasis> - teoricamente, um pouco mapa de bandeiras."
" Mas nenhum sinalizador ainda est� definido, ent�o no momento ser� sempre 0. "
""

#. (itstool) path: listitem/para
#: book.translate.xml:17535
#, fuzzy
msgid ""
"<emphasis>mapp</emphasis> - pointer to the storage for the new map to be "
"returned"
msgstr ""
" <emphasis> mapp </emphasis> - ponteiro para o armazenamento para o novo "
"mapa a ser devolvido "

#. (itstool) path: listitem/para
#: book.translate.xml:17544
#, fuzzy
msgid ""
"<function>int bus_dmamap_destroy(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"
msgstr ""
" <function> int bus_dmamap_destroy (bus_dma_tag_t dmat, bus_dmamap_t map) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17548
#, fuzzy
msgid "Destroy a map. Returns 0 on success, the error code otherwise."
msgstr ""
"Destrua um mapa. Retorna 0 em sucesso, o c�digo de erro de outra forma."

#. (itstool) path: listitem/para
#: book.translate.xml:17554
#, fuzzy
msgid "dmat - the tag to which the map is associated"
msgstr "dmat - a tag � qual o mapa est� associado"

#. (itstool) path: listitem/para
#: book.translate.xml:17559
#, fuzzy
msgid "map - the map to be destroyed"
msgstr "mapa - o mapa a ser destru�do"

#. (itstool) path: listitem/para
#: book.translate.xml:17567
#, fuzzy
msgid ""
"<function>int bus_dmamap_load(bus_dma_tag_t dmat, bus_dmamap_t map, void "
"*buf, bus_size_t buflen, bus_dmamap_callback_t *callback, void "
"*callback_arg, int flags)</function>"
msgstr ""
" <function> int bus_dmamap_load (bus_dma_tag_t dmat, bus_dmamap_t mapa, void "
"* buf, bus_size_t buflen, bus_dmamap_callback_t * retorno de chamada, void * "
"callback_arg, int flags) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17573
#, fuzzy
msgid ""
"Load a buffer into the map (the map must be previously created by "
"<function>bus_dmamap_create()</function> or <function>bus_dmamem_alloc()</"
"function>). All the pages of the buffer are checked for conformance to the "
"tag requirements and for those not conformant the bounce pages are allocated."
" An array of physical segment descriptors is built and passed to the "
"callback routine. This callback routine is then expected to handle it in "
"some way. The number of bounce buffers in the system is limited, so if the "
"bounce buffers are needed but not immediately available the request will be "
"queued and the callback will be called when the bounce buffers will become "
"available. Returns 0 if the callback was executed immediately or "
"<errorname>EINPROGRESS</errorname> if the request was queued for future "
"execution. In the latter case the synchronization with queued callback "
"routine is the responsibility of the driver."
msgstr ""
"Carregue um buffer no mapa (o mapa deve ser criado anteriormente por "
"<function> bus_dmamap_create () </function> ou <function> bus_dmamem_alloc "
"() </function> ). Todas as p�ginas do buffer s�o verificadas quanto � "
"conformidade com os requisitos da tag e, para aqueles que n�o est�o em "
"conformidade, as p�ginas devolvidas s�o alocadas. Uma matriz de descritores "
"de segmento f�sico � criada e passada para a rotina de retorno de chamada. "
"Espera-se, ent�o, que essa rotina de retorno de chamada lide com isso de "
"alguma forma. O n�mero de buffers de rejei��o no sistema � limitado, "
"portanto, se os buffers de rejei��o forem necess�rios, mas n�o estiverem "
"dispon�veis imediatamente, a solicita��o ser� enfileirada e o retorno de "
"chamada ser� chamado quando os buffers de rejei��o ficar�o dispon�veis. "
"Retorna 0 se o retorno de chamada foi executado imediatamente ou <errorname> "
"EINPROGRESS </errorname> se a solicita��o foi enfileirada para execu��o "
"futura. Neste �ltimo caso, a sincroniza��o com a rotina de retorno de "
"chamada em fila � de responsabilidade do driver. "

#. (itstool) path: listitem/para
#: book.translate.xml:17600
#, fuzzy
msgid "<emphasis>map</emphasis> - the map"
msgstr " <emphasis> mapa </emphasis> - o mapa"

#. (itstool) path: listitem/para
#: book.translate.xml:17605
#, fuzzy
msgid "<emphasis>buf</emphasis> - kernel virtual address of the buffer"
msgstr " <emphasis> buf </emphasis> - endere�o virtual do kernel do buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17611
#, fuzzy
msgid "<emphasis>buflen</emphasis> - length of the buffer"
msgstr " <emphasis> buflen </emphasis> - comprimento do buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17616
#, fuzzy
msgid ""
"<emphasis>callback</emphasis>,<function> callback_arg</function> - the "
"callback function and its argument"
msgstr ""
" <emphasis> ligue de volta </emphasis> , <function> callback_arg </function> "
"- a fun��o de retorno de chamada e seu argumento "

#. (itstool) path: listitem/para
#: book.translate.xml:17624
#, fuzzy
msgid "The prototype of callback function is:"
msgstr "O prot�tipo da fun��o de retorno de chamada �:"

#. (itstool) path: listitem/para
#: book.translate.xml:17627
#, fuzzy
msgid ""
"<function>void callback(void *arg, bus_dma_segment_t *seg, int nseg, int "
"error)</function>"
msgstr ""
" <function> void callback (erro void * arg, bus_dma_segment_t * seg, int "
"nseg, int) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17634
#, fuzzy
msgid ""
"<emphasis>arg</emphasis> - the same as callback_arg passed to "
"<function>bus_dmamap_load()</function>"
msgstr ""
" <emphasis> arg </emphasis> - o mesmo que callback_arg passado para "
"<function> bus_dmamap_load () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17640
#, fuzzy
msgid "<emphasis>seg</emphasis> - array of the segment descriptors"
msgstr " <emphasis> seg </emphasis> - matriz dos descritores de segmento "

#. (itstool) path: listitem/para
#: book.translate.xml:17646
#, fuzzy
msgid "<emphasis>nseg</emphasis> - number of descriptors in array"
msgstr " <emphasis> nseg </emphasis> - n�mero de descritores na matriz "

#. (itstool) path: listitem/para
#: book.translate.xml:17652
#, fuzzy
msgid ""
"<emphasis>error</emphasis> - indication of the segment number overflow: if "
"it is set to <errorname>EFBIG</errorname> then the buffer did not fit into "
"the maximal number of segments permitted by the tag. In this case only the "
"permitted number of descriptors will be in the array. Handling of this "
"situation is up to the driver: depending on the desired semantics it can "
"either consider this an error or split the buffer in two and handle the "
"second part separately"
msgstr ""
" <emphasis> erro </emphasis> - indica��o do excesso de n�mero de segmento: "
"se estiver configurado para <errorname> EFBIG </errorname> ent�o o buffer "
"n�o se encaixava no n�mero m�ximo de segmentos permitido pela tag. Nesse "
"caso, apenas o n�mero permitido de descritores estar� na matriz. O manuseio "
"desta situa��o depende do driver: dependendo da sem�ntica desejada, ele pode "
"considerar isso como um erro ou dividir o buffer em dois e manipular a "
"segunda parte separadamente "

#. (itstool) path: listitem/para
#: book.translate.xml:17666
#, fuzzy
msgid "Each entry in the segments array contains the fields:"
msgstr "Cada entrada na matriz de segmentos cont�m os campos:"

#. (itstool) path: listitem/para
#: book.translate.xml:17673
#, fuzzy
msgid "<emphasis>ds_addr</emphasis> - physical bus address of the segment"
msgstr ""
" <emphasis> ds_addr </emphasis> - endere�o de barramento f�sico do segmento "

#. (itstool) path: listitem/para
#: book.translate.xml:17679
#, fuzzy
msgid "<emphasis>ds_len</emphasis> - length of the segment"
msgstr " <emphasis> ds_len </emphasis> - comprimento do segmento "

#. (itstool) path: listitem/para
#: book.translate.xml:17688
#, fuzzy
msgid ""
"<function>void bus_dmamap_unload(bus_dma_tag_t dmat, bus_dmamap_t map)</"
"function>"
msgstr ""
" <function> void bus_dmamap_unload (bus_dma_tag_t dmat, bus_dmamap_t map) </"
"function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17692
#, fuzzy
msgid "unload the map."
msgstr "descarregar o mapa."

#. (itstool) path: listitem/para
#: book.translate.xml:17697 book.translate.xml:17726
#, fuzzy
msgid "<emphasis>dmat</emphasis> - tag"
msgstr " <emphasis> DMAT </emphasis> - dia "

#. (itstool) path: listitem/para
#: book.translate.xml:17702 book.translate.xml:17731
#, fuzzy
msgid "<emphasis>map</emphasis> - loaded map"
msgstr " <emphasis> mapa </emphasis> - mapa carregado "

#. (itstool) path: listitem/para
#: book.translate.xml:17711
#, fuzzy
msgid ""
"<function>void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t map, "
"bus_dmasync_op_t op)</function>"
msgstr ""
" <function> void bus_dmamap_sync (bus_dma_tag_t dmat, bus_dmamap_t mapa, "
"bus_dmasync_op_t op) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:17715
#, fuzzy
msgid ""
"Synchronise a loaded buffer with its bounce pages before and after physical "
"transfer to or from device. This is the function that does all the necessary "
"copying of data between the original buffer and its mapped version. The "
"buffers must be synchronized both before and after doing the transfer."
msgstr ""
"Sincronize um buffer carregado com suas p�ginas de rejei��o antes e depois "
"da transfer�ncia f�sica para ou do dispositivo. Essa � a fun��o que faz toda "
"a c�pia necess�ria de dados entre o buffer original e sua vers�o mapeada. Os "
"buffers devem ser sincronizados antes e depois de fazer a transfer�ncia."

#. (itstool) path: listitem/para
#: book.translate.xml:17736
#, fuzzy
msgid ""
"<emphasis>op</emphasis> - type of synchronization operation to perform:"
msgstr ""
" <emphasis> op </emphasis> - tipo de opera��o de sincroniza��o a executar: "

#. (itstool) path: listitem/para
#: book.translate.xml:17745
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_PREREAD</function> - before reading from device into "
"buffer"
msgstr ""
" <function> BUS_DMASYNC_PREREAD </function> - antes de ler do dispositivo "
"para o buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17751
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_POSTREAD</function> - after reading from device into "
"buffer"
msgstr ""
" <function> BUS_DMASYNC_POSTREAD </function> - depois de ler do dispositivo "
"no buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:17757
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_PREWRITE</function> - before writing the buffer to "
"device"
msgstr ""
" <function> BUS_DMASYNC_PREWRITE </function> - antes de escrever o buffer "
"para o dispositivo "

#. (itstool) path: listitem/para
#: book.translate.xml:17763
#, fuzzy
msgid ""
"<function>BUS_DMASYNC_POSTWRITE</function> - after writing the buffer to "
"device"
msgstr ""
" <function> BUS_DMASYNC_POSTWRITE </function> - depois de escrever o buffer "
"para o dispositivo "

#. (itstool) path: sect1/para
#: book.translate.xml:17774
#, fuzzy
msgid ""
"As of now PREREAD and POSTWRITE are null operations but that may change in "
"the future, so they must not be ignored in the driver. Synchronization is "
"not needed for the memory obtained from <function>bus_dmamem_alloc()</"
"function>."
msgstr ""
"A partir de agora, PREREAD e POSTWRITE s�o opera��es nulas, mas que podem "
"mudar no futuro, portanto, elas n�o devem ser ignoradas no driver. A "
"sincroniza��o n�o � necess�ria para a mem�ria obtida de <function> "
"bus_dmamem_alloc () </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:17780
#, fuzzy
msgid ""
"Before calling the callback function from <function>bus_dmamap_load()</"
"function> the segment array is stored in the stack. And it gets pre-"
"allocated for the maximal number of segments allowed by the tag. Because of "
"this the practical limit for the number of segments on i386 architecture is "
"about 250-300 (the kernel stack is 4KB minus the size of the user structure, "
"size of a segment array entry is 8 bytes, and some space must be left). "
"Because the array is allocated based on the maximal number this value must "
"not be set higher than really needed. Fortunately, for most of hardware the "
"maximal supported number of segments is much lower. But if the driver wants "
"to handle buffers with a very large number of scatter-gather segments it "
"should do that in portions: load part of the buffer, transfer it to the "
"device, load next part of the buffer, and so on."
msgstr ""
"Antes de chamar a fun��o de retorno de chamada <function> bus_dmamap_load () "
"</function> o array de segmentos � armazenado na pilha. E ele � pr�-alocado "
"para o n�mero m�ximo de segmentos permitido pela tag. Devido a isso, o "
"limite pr�tico para o n�mero de segmentos na arquitetura i386 � de cerca de "
"250-300 (a pilha do kernel � 4KB menos o tamanho da estrutura do usu�rio, o "
"tamanho de uma entrada de matriz de segmento � de 8 bytes e algum espa�o "
"deve ser deixado) . Como a matriz � alocada com base no n�mero m�ximo, esse "
"valor n�o deve ser definido mais alto do que o realmente necess�rio. "
"Felizmente, para a maioria do hardware, o n�mero m�ximo de segmentos "
"suportados � muito menor. Mas se o driver quiser manipular buffers com um "
"n�mero muito grande de segmentos de dispers�o, ele deve fazer isso em partes:"
" carregar parte do buffer, transferi-lo para o dispositivo, carregar a "
"pr�xima parte do buffer e assim por diante. "

#. (itstool) path: sect1/para
#: book.translate.xml:17797
#, fuzzy
msgid ""
"Another practical consequence is that the number of segments may limit the "
"size of the buffer. If all the pages in the buffer happen to be physically "
"non-contiguous then the maximal supported buffer size for that fragmented "
"case would be (nsegments * page_size). For example, if a maximal number of "
"10 segments is supported then on i386 maximal guaranteed supported buffer "
"size would be 40K. If a higher size is desired then special tricks should be "
"used in the driver."
msgstr ""
"Outra conseq��ncia pr�tica � que o n�mero de segmentos pode limitar o "
"tamanho do buffer. Se todas as p�ginas no buffer forem fisicamente n�o "
"cont�guas, o tamanho m�ximo do buffer suportado para esse caso fragmentado "
"seria (nsegments * page_size). Por exemplo, se um n�mero m�ximo de 10 "
"segmentos for suportado, em i386 o tamanho m�ximo do buffer suportado "
"garantido seria 40 K. Se um tamanho maior for desejado, ent�o truques "
"especiais devem ser usados ​​no driver. "

#. (itstool) path: sect1/para
#: book.translate.xml:17807
#, fuzzy
msgid ""
"If the hardware does not support scatter-gather at all or the driver wants "
"to support some buffer size even if it is heavily fragmented then the "
"solution is to allocate a contiguous buffer in the driver and use it as "
"intermediate storage if the original buffer does not fit."
msgstr ""
"Se o hardware n�o suporta scatter-gather ou se o driver quiser suportar "
"algum tamanho de buffer mesmo que seja muito fragmentado, a solu��o � alocar "
"um buffer cont�guo no driver e us�-lo como armazenamento intermedi�rio se o "
"buffer original n�o serve."

#. (itstool) path: sect1/para
#: book.translate.xml:17814
#, fuzzy
msgid ""
"Below are the typical call sequences when using a map depend on the use of "
"the map. The characters -&gt; are used to show the flow of time."
msgstr ""
"Abaixo est�o as seq��ncias de chamadas t�picas ao usar um mapa dependem do "
"uso do mapa. Os caracteres -&gt; s�o usados ​​para mostrar o fluxo de tempo."

#. (itstool) path: sect1/para
#: book.translate.xml:17819
#, fuzzy
msgid ""
"For a buffer which stays practically fixed during all the time between "
"attachment and detachment of a device:"
msgstr ""
"Para um buffer que fica praticamente fixo durante todo o tempo entre a "
"conex�o e o desligamento de um dispositivo:"

#. (itstool) path: sect1/para
#: book.translate.xml:17822
#, fuzzy
msgid ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ...use buffer... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"
msgstr ""
"bus_dmamem_alloc -&gt; bus_dmamap_load -&gt; ... use buffer ... -&gt; -&gt; "
"bus_dmamap_unload -&gt; bus_dmamem_free"

#. (itstool) path: para/programlisting
#: book.translate.xml:17831
#, no-wrap
msgid ""
"          bus_dmamap_create -&gt;\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do "
"transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          ...\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do "
"transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          -&gt; bus_dmamap_destroy        "
msgstr ""
"          bus_dmamap_create -&gt;\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do "
"transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          ...\n"
"          -&gt; bus_dmamap_load -&gt; bus_dmamap_sync(PRE...) -&gt; do "
"transfer -&gt;\n"
"          -&gt; bus_dmamap_sync(POST...) -&gt; bus_dmamap_unload -&gt;\n"
"          -&gt; bus_dmamap_destroy        "

#. (itstool) path: sect1/para
#: book.translate.xml:17827
#, fuzzy
msgid ""
"For a buffer that changes frequently and is passed from outside the driver: "
"<_:programlisting-1/>"
msgstr ""
"Para um buffer que muda com freq��ncia e � passado de fora do driver: <_: "
"programlisting-1 />"

#. (itstool) path: sect1/para
#: book.translate.xml:17840
#, fuzzy
msgid ""
"When loading a map created by <function>bus_dmamem_alloc()</function> the "
"passed address and size of the buffer must be the same as used in "
"<function>bus_dmamem_alloc()</function>. In this case it is guaranteed that "
"the whole buffer will be mapped as one segment (so the callback may be based "
"on this assumption) and the request will be executed immediately "
"(EINPROGRESS will never be returned). All the callback needs to do in this "
"case is to save the physical address."
msgstr ""
"Ao carregar um mapa criado por <function> bus_dmamem_alloc () </function> o "
"endere�o passado e tamanho do buffer deve ser o mesmo usado em <function> "
"bus_dmamem_alloc () </function> . Nesse caso, � garantido que o buffer "
"inteiro ser� mapeado como um segmento (para que o retorno de chamada possa "
"se basear nessa suposi��o) e a solicita��o ser� executada imediatamente (o "
"EINPROGRESS nunca ser� retornado). Todo o retorno de chamada que precisa ser "
"feito neste caso � salvar o endere�o f�sico. "

#. (itstool) path: sect1/para
#: book.translate.xml:17851
#, fuzzy
msgid "A typical example would be:"
msgstr "Um exemplo t�pico seria:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:17855
#, no-wrap
msgid ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int "
"error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
"\n"
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
"\n"
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &amp;tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
"\n"
"          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ "
"0,\n"
"             &amp;map_somedata);\n"
"          if(error)\n"
"             return error;\n"
"\n"
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &amp;psomedata, /*flags*/0);        "
msgstr ""
"          static void\n"
"        alloc_callback(void *arg, bus_dma_segment_t *seg, int nseg, int "
"error)\n"
"        {\n"
"          *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"        }\n"
"\n"
"          ...\n"
"          int error;\n"
"          struct somedata {\n"
"            ....\n"
"          };\n"
"          struct somedata *vsomedata; /* virtual address */\n"
"          bus_addr_t psomedata; /* physical bus-relative address */\n"
"          bus_dma_tag_t tag_somedata;\n"
"          bus_dmamap_t map_somedata;\n"
"          ...\n"
"\n"
"          error=bus_dma_tag_create(parent_tag, alignment,\n"
"           boundary, lowaddr, highaddr, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"           /*maxsize*/ sizeof(struct somedata), /*nsegments*/ 1,\n"
"           /*maxsegsz*/ sizeof(struct somedata), /*flags*/ 0,\n"
"           &amp;tag_somedata);\n"
"          if(error)\n"
"          return error;\n"
"\n"
"          error = bus_dmamem_alloc(tag_somedata, &amp;vsomedata, /* flags*/ "
"0,\n"
"             &amp;map_somedata);\n"
"          if(error)\n"
"             return error;\n"
"\n"
"          bus_dmamap_load(tag_somedata, map_somedata, (void *)vsomedata,\n"
"             sizeof (struct somedata), alloc_callback,\n"
"             (void *) &amp;psomedata, /*flags*/0);        "

#. (itstool) path: sect1/para
#: book.translate.xml:17889
#, fuzzy
msgid ""
"Looks a bit long and complicated but that is the way to do it. The practical "
"consequence is: if multiple memory areas are allocated always together it "
"would be a really good idea to combine them all into one structure and "
"allocate as one (if the alignment and boundary limitations permit)."
msgstr ""
"Parece um pouco longo e complicado, mas � assim. A consequ�ncia pr�tica �: "
"se v�rias �reas de mem�ria forem alocadas sempre juntas, seria uma boa id�ia "
"combin�-las em uma estrutura e alocar como uma (se a limita��es de "
"alinhamento e limite permitem). "

#. (itstool) path: sect1/para
#: book.translate.xml:17896
#, fuzzy
msgid ""
"When loading an arbitrary buffer into the map created by "
"<function>bus_dmamap_create()</function> special measures must be taken to "
"synchronize with the callback in case it would be delayed. The code would "
"look like:"
msgstr ""
"Ao carregar um buffer arbitr�rio no mapa criado por <function> "
"bus_dmamap_create () </function> Medidas especiais devem ser tomadas para "
"sincronizar com o retorno de chamada caso ele seja atrasado. O c�digo "
"ficaria assim: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:17903
#, no-wrap
msgid ""
"          {\n"
"           int s;\n"
"           int error;\n"
"\n"
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }        "
msgstr ""
"          {\n"
"           int s;\n"
"           int error;\n"
"\n"
"           s = splsoftvm();\n"
"           error = bus_dmamap_load(\n"
"               dmat,\n"
"               dmamap,\n"
"               buffer_ptr,\n"
"               buffer_len,\n"
"               callback,\n"
"               /*callback_arg*/ buffer_descriptor,\n"
"               /*flags*/0);\n"
"           if (error == EINPROGRESS) {\n"
"               /*\n"
"                * Do whatever is needed to ensure synchronization\n"
"                * with callback. Callback is guaranteed not to be started\n"
"                * until we do splx() or tsleep().\n"
"                */\n"
"              }\n"
"           splx(s);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:17926
#, fuzzy
msgid "Two possible approaches for the processing of requests are:"
msgstr "Duas abordagens poss�veis para o processamento de pedidos s�o:"

#. (itstool) path: sect1/para
#: book.translate.xml:17929
#, fuzzy
msgid ""
"1. If requests are completed by marking them explicitly as done (such as the "
"CAM requests) then it would be simpler to put all the further processing "
"into the callback driver which would mark the request when it is done. Then "
"not much extra synchronization is needed. For the flow control reasons it "
"may be a good idea to freeze the request queue until this request gets "
"completed."
msgstr ""
"1. Se as solicita��es forem conclu�das marcando-as explicitamente como "
"conclu�das (como as solicita��es de CAM), seria mais simples colocar todo o "
"processamento adicional no driver de retorno de chamada que marcaria a "
"solicita��o quando isso � feito. Para os motivos de controle de fluxo, pode "
"ser uma boa ideia congelar a fila de solicita��es at� que essa solicita��o "
"seja conclu�da. "

#. (itstool) path: sect1/para
#: book.translate.xml:17938
#, fuzzy
msgid ""
"2. If requests are completed when the function returns (such as classic read "
"or write requests on character devices) then a synchronization flag should "
"be set in the buffer descriptor and <function>tsleep()</function> called. "
"Later when the callback gets called it will do its processing and check this "
"synchronization flag. If it is set then the callback should issue a wakeup. "
"In this approach the callback function could either do all the needed "
"processing (just like the previous case) or simply save the segments array "
"in the buffer descriptor. Then after callback completes the calling function "
"could use this saved segments array and do all the processing."
msgstr ""
"2. Se as solicita��es forem conclu�das quando a fun��o retornar (como "
"solicita��es cl�ssicas de leitura ou grava��o em dispositivos de "
"caracteres), um sinalizador de sincroniza��o dever� ser definido no "
"descritor de buffer e <function> tsleep () </function> chamado. Mais tarde, "
"quando o retorno de chamada for chamado, ele far� seu processamento e "
"verificar� esse sinalizador de sincroniza��o. Se estiver definido, o retorno "
"de chamada deve emitir uma ativa��o. Nessa abordagem, a fun��o de retorno de "
"chamada poderia fazer todo o processamento necess�rio (como no caso "
"anterior) ou simplesmente salvar a matriz de segmentos no descritor de "
"buffer. Ent�o, depois que o retorno de chamada for conclu�do, a fun��o de "
"chamada poder� usar essa matriz de segmentos salvos e fazer todo o "
"processamento. "

#. (itstool) path: sect1/title
#. (itstool) path: sect2/title
#: book.translate.xml:17958 book.translate.xml:19379
#, fuzzy
msgid "DMA"
msgstr "DMA"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:17961
#, fuzzy
msgid "<primary>Direct Memory Access (DMA)</primary>"
msgstr " <primary> Acesso Direto � Mem�ria (DMA) </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:17963
#, fuzzy
msgid ""
"The Direct Memory Access (DMA) is implemented in the ISA bus through the DMA "
"controller (actually, two of them but that is an irrelevant detail). To make "
"the early ISA devices simple and cheap the logic of the bus control and "
"address generation was concentrated in the DMA controller. Fortunately, "
"FreeBSD provides a set of functions that mostly hide the annoying details of "
"the DMA controller from the device drivers."
msgstr ""
"O Direct Memory Access (DMA) � implementado no barramento ISA atrav�s do "
"controlador DMA (na verdade, dois deles, mas isso � um detalhe irrelevante). "
"Para tornar os primeiros dispositivos ISA simples e baratos, a l�gica do "
"controle de barramento e gera��o de endere�os estava concentrada no "
"controlador de DMA. Felizmente, o FreeBSD fornece um conjunto de fun��es que "
"ocultam principalmente os detalhes irritantes do controlador de DMA dos "
"drivers de dispositivos. "

#. (itstool) path: sect1/para
#: book.translate.xml:17974
#, fuzzy
msgid ""
"The simplest case is for the fairly intelligent devices. Like the bus master "
"devices on PCI they can generate the bus cycles and memory addresses all by "
"themselves. The only thing they really need from the DMA controller is bus "
"arbitration. So for this purpose they pretend to be cascaded slave DMA "
"controllers. And the only thing needed from the system DMA controller is to "
"enable the cascaded mode on a DMA channel by calling the following function "
"when attaching the driver:"
msgstr ""
"O caso mais simples � para os dispositivos razoavelmente inteligentes. Como "
"os dispositivos mestre de barramento em PCI, eles podem gerar os ciclos de "
"barramento e os endere�os de mem�ria sozinhos. A �nica coisa que eles "
"realmente precisam do controlador de DMA � a arbitragem de barramento. "
"fingir ser controladores DMA escravo em cascata. E a �nica coisa necess�ria "
"do controlador DMA do sistema � ativar o modo em cascata em um canal DMA "
"chamando a seguinte fun��o ao anexar o driver: "

#. (itstool) path: sect1/para
#: book.translate.xml:17986
#, fuzzy
msgid "<function>void isa_dmacascade(int channel_number)</function>"
msgstr " <function> void isa_dmacascade (int channel_number) </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:17990
#, fuzzy
msgid ""
"All the further activity is done by programming the device. When detaching "
"the driver no DMA-related functions need to be called."
msgstr ""
"Toda a atividade adicional � feita pela programa��o do dispositivo. Ao "
"desconectar o driver, nenhuma fun��o relacionada ao DMA precisa ser chamada."

#. (itstool) path: sect1/para
#: book.translate.xml:17996
#, fuzzy
msgid ""
"For the simpler devices things get more complicated. The functions used are:"
msgstr ""
"Para os dispositivos mais simples, as coisas ficam mais complicadas. As "
"fun��es usadas s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:18004
#, fuzzy
msgid "<function>int isa_dma_acquire(int chanel_number)</function>"
msgstr " <function> int isa_dma_acquire (int chanel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18007
#, fuzzy
msgid ""
"Reserve a DMA channel. Returns 0 on success or EBUSY if the channel was "
"already reserved by this or a different driver. Most of the ISA devices are "
"not able to share DMA channels anyway, so normally this function is called "
"when attaching a device. This reservation was made redundant by the modern "
"interface of bus resources but still must be used in addition to the latter. "
"If not used then later, other DMA routines will panic."
msgstr ""
"Reserve um canal DMA. Retorna 0 em sucesso ou EBUSY se o canal j� estiver "
"reservado por este ou um driver diferente. A maioria dos dispositivos ISA "
"n�o � capaz de compartilhar canais DMA, ent�o normalmente essa fun��o � "
"chamada ao conectar um dispositivo. Essa reserva foi tornada redundante pela "
"interface moderna dos recursos de barramento, mas ainda deve ser usada em "
"adi��o a esta �ltima. Se n�o for usada, mais tarde, outras rotinas de DMA "
"entrar�o em p�nico. "

#. (itstool) path: listitem/para
#: book.translate.xml:18021
#, fuzzy
msgid "<function>int isa_dma_release(int chanel_number)</function>"
msgstr " <function> int isa_dma_release (int chanel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18024
#, fuzzy
msgid ""
"Release a previously reserved DMA channel. No transfers must be in progress "
"when the channel is released (in addition the device must not try to "
"initiate transfer after the channel is released)."
msgstr ""
"Liberar um canal de DMA previamente reservado. Nenhuma transfer�ncia deve "
"estar em progresso quando o canal for liberado (al�m disso, o dispositivo "
"n�o deve tentar iniciar a transfer�ncia ap�s o canal ser liberado)."

#. (itstool) path: listitem/para
#: book.translate.xml:18033
#, fuzzy
msgid "<function>void isa_dmainit(int chan, u_int bouncebufsize)</function>"
msgstr ""
" <function> void isa_dmainit (int chan, u_int bouncebufsize) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18037
#, fuzzy
msgid ""
"Allocate a bounce buffer for use with the specified channel. The requested "
"size of the buffer can not exceed 64KB. This bounce buffer will be "
"automatically used later if a transfer buffer happens to be not physically "
"contiguous or outside of the memory accessible by the ISA bus or crossing "
"the 64KB boundary. If the transfers will be always done from buffers which "
"conform to these conditions (such as those allocated by "
"<function>bus_dmamem_alloc()</function> with proper limitations) then "
"<function>isa_dmainit()</function> does not have to be called. But it is "
"quite convenient to transfer arbitrary data using the DMA controller. The "
"bounce buffer will automatically care of the scatter-gather issues."
msgstr ""
"Alocar um buffer de rejei��o para uso com o canal especificado. O tamanho "
"solicitado do buffer n�o pode exceder 64 KB. Esse buffer de rejei��o ser� "
"usado automaticamente mais tarde se um buffer de transfer�ncia n�o estiver "
"fisicamente cont�guo ou fora da mem�ria acess�vel pelo ISA barramento ou "
"cruzando o limite de 64 Kb. Se as transfer�ncias forem sempre feitas a "
"partir de buffers que estejam de acordo com estas condi��es (tais <function> "
"bus_dmamem_alloc () </function> com limita��es adequadas) <function> "
"isa_dmainit () </function> n�o precisa ser chamado. Mas � bastante "
"conveniente transferir dados arbitr�rios usando o controlador de DMA. O "
"buffer de rejei��o cuidar� automaticamente dos problemas de dispers�o e "
"coleta. "

#. (itstool) path: listitem/para
#: book.translate.xml:18057
#, fuzzy
msgid "<emphasis>chan</emphasis> - channel number"
msgstr " <emphasis> chan </emphasis> - n�mero do canal"

#. (itstool) path: listitem/para
#: book.translate.xml:18062
#, fuzzy
msgid ""
"<emphasis>bouncebufsize</emphasis> - size of the bounce buffer in bytes"
msgstr ""
" <emphasis> bouncebufsize </emphasis> - tamanho do buffer de rejei��o em "
"bytes "

#. (itstool) path: listitem/para
#: book.translate.xml:18073
#, fuzzy
msgid ""
"<function>void isa_dmastart(int flags, caddr_t addr, u_int nbytes, int "
"chan)</function>"
msgstr ""
" <function> void isa_dmastart (sinalizadores int, caddr_t addr, u_int "
"nbytes, int chan) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18077
#, fuzzy
msgid ""
"Prepare to start a DMA transfer. This function must be called to set up the "
"DMA controller before actually starting transfer on the device. It checks "
"that the buffer is contiguous and falls into the ISA memory range, if not "
"then the bounce buffer is automatically used. If bounce buffer is required "
"but not set up by <function>isa_dmainit()</function> or too small for the "
"requested transfer size then the system will panic. In case of a write "
"request with bounce buffer the data will be automatically copied to the "
"bounce buffer."
msgstr ""
"Prepare-se para iniciar uma transfer�ncia de DMA. Esta fun��o deve ser "
"chamada para configurar o controlador de DMA antes de iniciar a "
"transfer�ncia no dispositivo. Ele verifica se o buffer � cont�guo e cai no "
"intervalo de mem�ria ISA, sen�o o buffer de rejei��o � automaticamente Se o "
"buffer de rejei��o for necess�rio, mas n�o configurado <function> "
"isa_dmainit () </function> ou muito pequeno para o tamanho de transfer�ncia "
"solicitado, o sistema entra em p�nico. No caso de uma solicita��o de "
"grava��o com buffer de rejei��o, os dados ser�o automaticamente copiados "
"para o buffer de rejei��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:18092
#, fuzzy
msgid ""
"flags - a bitmask determining the type of operation to be done. The "
"direction bits B_READ and B_WRITE are mutually exclusive."
msgstr ""
"flags - um bitmask que determina o tipo de opera��o a ser executada. Os bits "
"de dire��o B_READ e B_WRITE s�o mutuamente exclusivos."

#. (itstool) path: listitem/para
#: book.translate.xml:18099
#, fuzzy
msgid "B_READ - read from the ISA bus into memory"
msgstr "B_READ - ler do barramento ISA na mem�ria"

#. (itstool) path: listitem/para
#: book.translate.xml:18104
#, fuzzy
msgid "B_WRITE - write from the memory to the ISA bus"
msgstr "B_WRITE - escreva da mem�ria para o barramento ISA"

#. (itstool) path: listitem/para
#: book.translate.xml:18109
#, fuzzy
msgid ""
"B_RAW - if set then the DMA controller will remember the buffer and after "
"the end of transfer will automatically re-initialize itself to repeat "
"transfer of the same buffer again (of course, the driver may change the data "
"in the buffer before initiating another transfer in the device). If not set "
"then the parameters will work only for one transfer, and "
"<function>isa_dmastart()</function> will have to be called again before "
"initiating the next transfer. Using B_RAW makes sense only if the bounce "
"buffer is not used."
msgstr ""
"B_RAW - se configurado, o controlador de DMA se lembrar� do buffer e, ap�s o "
"t�rmino da transfer�ncia, reinicializar� automaticamente para repetir a "
"transfer�ncia do mesmo buffer novamente (� claro, o driver pode alterar os "
"dados no buffer antes de iniciar outra transfer�ncia Se n�o estiver "
"definido, os par�metros funcionar�o apenas para uma transfer�ncia e "
"<function> isa_dmastart () </function> ter� que ser chamado novamente antes "
"de iniciar a pr�xima transfer�ncia. O uso de B_RAW faz sentido apenas se o "
"buffer de rejei��o n�o for usado. "

#. (itstool) path: listitem/para
#: book.translate.xml:18127
#, fuzzy
msgid "addr - virtual address of the buffer"
msgstr "addr - endere�o virtual do buffer"

#. (itstool) path: listitem/para
#: book.translate.xml:18132
#, fuzzy
msgid ""
"nbytes - length of the buffer. Must be less or equal to 64KB. Length of 0 is "
"not allowed: the DMA controller will understand it as 64KB while the kernel "
"code will understand it as 0 and that would cause unpredictable effects. For "
"channels number 4 and higher the length must be even because these channels "
"transfer 2 bytes at a time. In case of an odd length the last byte will not "
"be transferred."
msgstr ""
"nbytes - comprimento do buffer. Deve ser menor ou igual a 64 KB. Comprimento "
"de 0 n�o � permitido: o controlador de DMA o entender� como 64 KB enquanto o "
"c�digo do kernel o entender� como 0 e isso causaria efeitos imprevis�veis. "
"Para o n�mero de canais 4 e maior o comprimento deve ser mesmo porque estes "
"canais transferem 2 bytes de cada vez. No caso de um comprimento �mpar, o "
"�ltimo byte n�o ser� transferido. "

#. (itstool) path: listitem/para
#: book.translate.xml:18144
#, fuzzy
msgid "chan - channel number"
msgstr "chan - n�mero do canal"

#. (itstool) path: listitem/para
#: book.translate.xml:18150
#, fuzzy
msgid ""
"<function>void isa_dmadone(int flags, caddr_t addr, int nbytes, int chan)</"
"function>"
msgstr ""
" <function> void isa_dmadone (sinalizadores int, caddr_t addr, int nbytes, "
"int chan) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18154
#, fuzzy
msgid ""
"Synchronize the memory after device reports that transfer is done. If that "
"was a read operation with a bounce buffer then the data will be copied from "
"the bounce buffer to the original buffer. Arguments are the same as for "
"<function>isa_dmastart()</function>. Flag B_RAW is permitted but it does not "
"affect <function>isa_dmadone()</function> in any way."
msgstr ""
"Sincronize a mem�ria ap�s o dispositivo informar que a transfer�ncia est� "
"conclu�da. Se essa foi uma opera��o de leitura com um buffer de rejei��o, os "
"dados ser�o copiados do buffer de rejei��o para o buffer original. Os "
"argumentos s�o os mesmos que para <function> isa_dmastart () </function> . A "
"sinaliza��o B_RAW � permitida, mas n�o afeta <function> isa_dmadone () </"
"function> de qualquer forma \""

#. (itstool) path: listitem/para
#: book.translate.xml:18166
#, fuzzy
msgid "<function>int isa_dmastatus(int channel_number)</function>"
msgstr " <function> int isa_dmastatus (int channel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18169
#, fuzzy
msgid ""
"Returns the number of bytes left in the current transfer to be transferred. "
"In case the flag B_READ was set in <function>isa_dmastart()</function> the "
"number returned will never be equal to zero. At the end of transfer it will "
"be automatically reset back to the length of buffer. The normal use is to "
"check the number of bytes left after the device signals that the transfer is "
"completed. If the number of bytes is not 0 then something probably went "
"wrong with that transfer."
msgstr ""
"Retorna o n�mero de bytes restantes na transfer�ncia atual a ser transferida."
" Caso o sinalizador B_READ tenha sido configurado em <function> isa_dmastart "
"() </function> o n�mero retornado nunca ser� igual a zero. No final da "
"transfer�ncia, ele ser� redefinido automaticamente de volta ao tamanho do "
"buffer. O uso normal � verificar o n�mero de bytes restantes depois que o "
"dispositivo sinaliza que a transfer�ncia foi conclu�da. Se o n�mero de bytes "
"n�o for 0, ent�o algo provavelmente deu errado com essa transfer�ncia. "

#. (itstool) path: listitem/para
#: book.translate.xml:18183
#, fuzzy
msgid "<function>int isa_dmastop(int channel_number)</function>"
msgstr " <function> int isa_dmastop (int channel_number) </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:18186
#, fuzzy
msgid ""
"Aborts the current transfer and returns the number of bytes left "
"untransferred."
msgstr ""
"Anula a transfer�ncia atual e retorna o n�mero de bytes n�o transferidos."

#. (itstool) path: sect1/title
#: book.translate.xml:18195
#, fuzzy
msgid "xxx_isa_probe"
msgstr "xxx_isa_probe"

#. (itstool) path: sect1/para
#: book.translate.xml:18198
#, fuzzy
msgid ""
"This function probes if a device is present. If the driver supports auto-"
"detection of some part of device configuration (such as interrupt vector or "
"memory address) this auto-detection must be done in this routine."
msgstr ""
"Esta fun��o investiga se um dispositivo est� presente. Se o driver suportar "
"a detec��o autom�tica de alguma parte da configura��o do dispositivo (como "
"vetor de interrup��o ou endere�o de mem�ria), esta detec��o autom�tica deve "
"ser feita nesta rotina."

#. (itstool) path: sect1/para
#: book.translate.xml:18205
#, fuzzy
msgid ""
"As for any other bus, if the device cannot be detected or is detected but "
"failed the self-test or some other problem happened then it returns a "
"positive value of error. The value <errorname>ENXIO</errorname> must be "
"returned if the device is not present. Other error values may mean other "
"conditions. Zero or negative values mean success. Most of the drivers return "
"zero as success."
msgstr ""
"Quanto a qualquer outro barramento, se o dispositivo n�o puder ser detectado "
"ou for detectado, mas falhar no autoteste ou algum outro problema ocorrer, "
"ele retornar� um valor positivo de erro. O valor <errorname> ENXIO </"
"errorname> deve ser devolvido se o dispositivo n�o estiver presente. Outros "
"valores de erro podem significar outras condi��es. Valores zero ou negativos "
"significam sucesso. A maioria dos motoristas retorna zero como sucesso. "

#. (itstool) path: sect1/para
#: book.translate.xml:18215
#, fuzzy
msgid ""
"The negative return values are used when a PnP device supports multiple "
"interfaces. For example, an older compatibility interface and a newer "
"advanced interface which are supported by different drivers. Then both "
"drivers would detect the device. The driver which returns a higher value in "
"the probe routine takes precedence (in other words, the driver returning 0 "
"has highest precedence, one returning -1 is next, one returning -2 is after "
"it and so on). In result the devices which support only the old interface "
"will be handled by the old driver (which should return -1 from the probe "
"routine) while the devices supporting the new interface as well will be "
"handled by the new driver (which should return 0 from the probe routine)."
msgstr ""
"Os valores de retorno negativos s�o usados ​​quando um dispositivo PnP "
"suporta v�rias interfaces. Por exemplo, uma interface de compatibilidade "
"mais antiga e uma interface avan�ada mais recente suportada por drivers "
"diferentes. Ent�o, ambos os drivers detectariam o dispositivo. O driver que "
"retorna um valor mais alto a rotina da sonda tem preced�ncia (em outras "
"palavras, o driver retornando 0 tem a preced�ncia mais alta, uma retornando -"
"1 � a pr�xima, uma retornando -2 � depois dela e assim por diante) Em "
"resultado, os dispositivos que suportam apenas a interface antiga ser�o "
"manipulados pelo driver antigo (que deve retornar -1 da rotina da sonda), "
"enquanto os dispositivos que suportam a nova interface tamb�m ser�o "
"manipulados pelo novo driver (que deve retornar 0 da rotina da sonda). "

#. (itstool) path: sect1/para
#: book.translate.xml:18231
#, fuzzy
msgid ""
"The device descriptor struct xxx_softc is allocated by the system before "
"calling the probe routine. If the probe routine returns an error the "
"descriptor will be automatically deallocated by the system. So if a probing "
"error occurs the driver must make sure that all the resources it used during "
"probe are deallocated and that nothing keeps the descriptor from being "
"safely deallocated. If the probe completes successfully the descriptor will "
"be preserved by the system and later passed to the routine "
"<function>xxx_isa_attach()</function>. If a driver returns a negative value "
"it can not be sure that it will have the highest priority and its attach "
"routine will be called. So in this case it also must release all the "
"resources before returning and if necessary allocate them again in the "
"attach routine. When <function>xxx_isa_probe()</function> returns 0 "
"releasing the resources before returning is also a good idea and a well-"
"behaved driver should do so. But in cases where there is some problem with "
"releasing the resources the driver is allowed to keep resources between "
"returning 0 from the probe routine and execution of the attach routine."
msgstr ""
"O descritor de dispositivo struct xxx_softc � alocado pelo sistema antes de "
"chamar a rotina de an�lise. Se a rotina de an�lise retornar um erro, o "
"descritor ser� desalocado automaticamente pelo sistema. Portanto, se ocorrer "
"um erro de an�lise, o driver deve certificar-se de que todos os recursos "
"usados ​​durante o probe s�o desalocados e nada impede que o descritor seja "
"desalocado com seguran�a.Se o probe for conclu�do com �xito, o descritor "
"ser� preservado pelo sistema e, posteriormente, passado para a rotina "
"<function> xxx_isa_attach () </function> . Se um driver retornar um valor "
"negativo, ele n�o pode ter certeza de que ter� a prioridade mais alta e sua "
"rotina de anexa��o ser� chamada. Portanto, neste caso, tamb�m deve liberar "
"todos os recursos antes de retornar e, se necess�rio, aloc�-los novamente na "
"rotina de anexa��o. Quando <function> xxx_isa_probe () </function> Retorna 0 "
"liberando os recursos antes de retornar tamb�m � uma boa id�ia e um driver "
"bem comportado deve faz�-lo. Mas nos casos em que houver algum problema com "
"a libera��o dos recursos, o driver poder� manter os recursos entre o retorno "
"de 0 da rotina de an�lise e a execu��o da rotina de anexa��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:18255
#, fuzzy
msgid ""
"A typical probe routine starts with getting the device descriptor and unit:"
msgstr ""
"Uma rotina de sonda t�pica come�a com o descritor e a unidade do dispositivo:"
""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18260
#, no-wrap
msgid ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
"\n"
"          sc-&gt;dev = dev; /* link it back */\n"
"          sc-&gt;unit = unit;        "
msgstr ""
"         struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int pnperror;\n"
"          int error = 0;\n"
"\n"
"          sc-&gt;dev = dev; /* link it back */\n"
"          sc-&gt;unit = unit;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18268
#, fuzzy
msgid ""
"Then check for the PnP devices. The check is carried out by a table "
"containing the list of PnP IDs supported by this driver and human-readable "
"descriptions of the device models corresponding to these IDs."
msgstr ""
"Ent�o, verifique os dispositivos PnP. A verifica��o � realizada por uma "
"tabela contendo a lista de IDs PnP suportados por este driver e descri��es "
"leg�veis por humanos dos modelos de dispositivos correspondentes a esses IDs."
""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18275
#, no-wrap
msgid ""
"\n"
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
"        "
msgstr ""
"\n"
"        pnperror=ISA_PNP_PROBE(device_get_parent(dev), dev,\n"
"        xxx_pnp_ids); if(pnperror == ENXIO) return ENXIO;\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18280
#, fuzzy
msgid ""
"The logic of ISA_PNP_PROBE is the following: If this card (device unit) was "
"not detected as PnP then ENOENT will be returned. If it was detected as PnP "
"but its detected ID does not match any of the IDs in the table then ENXIO is "
"returned. Finally, if it has PnP support and it matches on of the IDs in the "
"table, 0 is returned and the appropriate description from the table is set "
"by <function>device_set_desc()</function>."
msgstr ""
"A l�gica de ISA_PNP_PROBE � a seguinte: Se esta placa (unidade de "
"dispositivo) n�o foi detectada como PnP, ent�o ENOENT ser� retornado. Se ela "
"foi detectada como PnP, mas sua ID detectada n�o corresponde a nenhuma das "
"IDs na tabela, ent�o ENXIO � Finalmente, se ele tiver suporte PnP e "
"corresponder aos IDs na tabela, 0 ser� retornado e a descri��o apropriada da "
"tabela ser� definida por <function> device_set_desc () </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18291
#, fuzzy
msgid ""
"If a driver supports only PnP devices then the condition would look like:"
msgstr ""
"Se um driver suporta apenas dispositivos PnP, a condi��o seria semelhante a:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18296
#, no-wrap
msgid "          if(pnperror != 0)\n"
"              return pnperror;        "
msgstr "          if(pnperror != 0)\n"
"              return pnperror;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18299
#, fuzzy
msgid ""
"No special treatment is required for the drivers which do not support PnP "
"because they pass an empty PnP ID table and will always get ENXIO if called "
"on a PnP card."
msgstr ""
"Nenhum tratamento especial � requerido para os drivers que n�o suportam PnP "
"porque eles passam uma tabela vazia de ID PnP e sempre recebem ENXIO se "
"forem chamados em uma placa PnP."

#. (itstool) path: sect1/para
#: book.translate.xml:18305
#, fuzzy
msgid ""
"The probe routine normally needs at least some minimal set of resources, "
"such as I/O port number to find the card and probe it. Depending on the "
"hardware the driver may be able to discover the other necessary resources "
"automatically. The PnP devices have all the resources pre-set by the PnP "
"subsystem, so the driver does not need to discover them by itself."
msgstr ""
"A rotina de an�lise normalmente precisa de pelo menos um conjunto m�nimo de "
"recursos, como o n�mero da porta I / O para encontrar a placa e sond�-la. "
"Dependendo do hardware, o driver pode descobrir os outros recursos "
"necess�rios automaticamente. Os dispositivos PnP todos os recursos pr�-"
"definidos pelo subsistema PnP, para que o driver n�o precise descobri-los "
"sozinho. "

#. (itstool) path: sect1/para
#: book.translate.xml:18315
#, fuzzy
msgid ""
"Typically the minimal information required to get access to the device is "
"the I/O port number. Then some devices allow to get the rest of information "
"from the device configuration registers (though not all devices do that). So "
"first we try to get the port start value:"
msgstr ""
"Normalmente, a informa��o m�nima necess�ria para obter acesso ao dispositivo "
"� o n�mero da porta de E / S. Ent�o, alguns dispositivos permitem obter o "
"restante das informa��es dos registros de configura��o do dispositivo "
"(embora nem todos os dispositivos fa�am isso). o valor inicial da porta: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18323
#, no-wrap
msgid ""
" sc-&gt;port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;\n"
"        "
msgstr ""
" sc-&gt;port0 = bus_get_resource_start(dev,\n"
"        SYS_RES_IOPORT, 0 /*rid*/); if(sc-&gt;port0 == 0) return ENXIO;\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18327
#, fuzzy
msgid ""
"The base port address is saved in the structure softc for future use. If it "
"will be used very often then calling the resource function each time would "
"be prohibitively slow. If we do not get a port we just return an error. Some "
"device drivers can instead be clever and try to probe all the possible "
"ports, like this:"
msgstr ""
"O endere�o da porta base � salvo na estrutura softc para uso futuro. Se for "
"usado com muita freq��ncia, chamar a fun��o resource a cada vez seria "
"proibitivamente lento. Se n�o obtivermos uma porta, retornaremos um erro. "
"Alguns drivers de dispositivo em vez disso, pode ser inteligente e tentar "
"investigar todas as portas poss�veis, como esta: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18336
#, no-wrap
msgid ""
"\n"
"          /* table of all possible base I/O port addresses for this device */"
"\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit "
"*/\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
"\n"
"          ...\n"
"          int port, i;\n"
"          ...\n"
"\n"
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
"\n"
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
"\n"
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
"\n"
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
"\n"
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;"
msgstr ""
"\n"
"          /* table of all possible base I/O port addresses for this device */"
"\n"
"          static struct xxx_allports {\n"
"              u_short port; /* port address */\n"
"              short used; /* flag: if this port is already used by some unit "
"*/\n"
"          } xxx_allports = {\n"
"              { 0x300, 0 },\n"
"              { 0x320, 0 },\n"
"              { 0x340, 0 },\n"
"              { 0, 0 } /* end of table */\n"
"          };\n"
"\n"
"          ...\n"
"          int port, i;\n"
"          ...\n"
"\n"
"          port =  bus_get_resource_start(dev, SYS_RES_IOPORT, 0 /*rid*/);\n"
"          if(port !=0 ) {\n"
"              for(i=0; xxx_allports[i].port!=0; i++) {\n"
"                  if(xxx_allports[i].used || xxx_allports[i].port != port)\n"
"                      continue;\n"
"\n"
"                  /* found it */\n"
"                  xxx_allports[i].used = 1;\n"
"                  /* do probe on a known port */\n"
"                  return xxx_really_probe(dev, port);\n"
"              }\n"
"              return ENXIO; /* port is unknown or already used */\n"
"          }\n"
"\n"
"          /* we get here only if we need to guess the port */\n"
"          for(i=0; xxx_allports[i].port!=0; i++) {\n"
"              if(xxx_allports[i].used)\n"
"                  continue;\n"
"\n"
"              /* mark as used - even if we find nothing at this port\n"
"               * at least we won't probe it in future\n"
"               */\n"
"               xxx_allports[i].used = 1;\n"
"\n"
"              error = xxx_really_probe(dev, xxx_allports[i].port);\n"
"              if(error == 0) /* found a device at that port */\n"
"                  return 0;\n"
"          }\n"
"          /* probed all possible addresses, none worked */\n"
"          return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18383
#, fuzzy
msgid ""
"Of course, normally the driver's <function>identify()</function> routine "
"should be used for such things. But there may be one valid reason why it may "
"be better to be done in <function>probe()</function>: if this probe would "
"drive some other sensitive device crazy. The probe routines are ordered with "
"consideration of the <literal>sensitive</literal> flag: the sensitive "
"devices get probed first and the rest of the devices later. But the "
"<function>identify()</function> routines are called before any probes, so "
"they show no respect to the sensitive devices and may upset them."
msgstr ""
"Claro, normalmente o motorista <function> identificar() </function> rotina "
"deve ser usada para tais coisas. Mas pode haver uma raz�o v�lida para que "
"seja melhor ser feito <function> sonda () </function> : se esta sonda for�ar "
"algum outro dispositivo sens�vel louco. As rotinas de sondagem s�o ordenadas "
"com a considera��o do <literal> sens�vel </literal> sinalizador: os "
"dispositivos sens�veis s�o examinados primeiro e o restante dos dispositivos "
"posteriormente. Mas o <function> identificar() </function> rotinas s�o "
"chamadas antes de qualquer teste, ent�o elas n�o mostram respeito pelos "
"dispositivos sens�veis e podem perturb�-las. "

#. (itstool) path: sect1/para
#: book.translate.xml:18397
#, fuzzy
msgid ""
"Now, after we got the starting port we need to set the port count (except "
"for PnP devices) because the kernel does not have this information in the "
"configuration file."
msgstr ""
"Agora, depois que tivermos a porta inicial, precisamos configurar a contagem "
"de portas (exceto para dispositivos PnP), porque o kernel n�o tem essas "
"informa��es no arquivo de configura��o."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18403
#, no-wrap
msgid ""
"\n"
"         if(pnperror /* only for non-PnP devices */\n"
"         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,\n"
"         XXX_PORT_COUNT)&lt;0)\n"
"             return ENXIO;"
msgstr ""
"\n"
"         if(pnperror /* only for non-PnP devices */\n"
"         &amp;&amp; bus_set_resource(dev, SYS_RES_IOPORT, 0, sc-&gt;port0,\n"
"         XXX_PORT_COUNT)&lt;0)\n"
"             return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18409
#, fuzzy
msgid ""
"Finally allocate and activate a piece of port address space (special values "
"of start and end mean <quote>use those we set by "
"<function>bus_set_resource()</function></quote>):"
msgstr ""
"Finalmente alocar e ativar um peda�o de espa�o de endere�o de porta (valores "
"especiais de in�cio e t�rmino significam <quote> usar aqueles que "
"estabelecemos <function> bus_set_resource () </function></quote> ): "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18415
#, no-wrap
msgid ""
"\n"
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"              return ENXIO;"
msgstr ""
"\n"
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,\n"
"          &amp;sc-&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18424
#, fuzzy
msgid ""
"Now having access to the port-mapped registers we can poke the device in "
"some way and check if it reacts like it is expected to. If it does not then "
"there is probably some other device or no device at all at this address."
msgstr ""
"Agora, tendo acesso aos registradores mapeados pela porta, podemos cutucar o "
"dispositivo de alguma forma e verificar se ele reage como esperado. Se isso "
"n�o ocorrer, provavelmente haver� algum outro dispositivo ou nenhum "
"dispositivo nesse endere�o."

#. (itstool) path: sect1/para
#: book.translate.xml:18431
#, fuzzy
msgid ""
"Normally drivers do not set up the interrupt handlers until the attach "
"routine. Instead they do probes in the polling mode using the "
"<function>DELAY()</function> function for timeout. The probe routine must "
"never hang forever, all the waits for the device must be done with timeouts. "
"If the device does not respond within the time it is probably broken or "
"misconfigured and the driver must return error. When determining the timeout "
"interval give the device some extra time to be on the safe side: although "
"<function>DELAY()</function> is supposed to delay for the same amount of "
"time on any machine it has some margin of error, depending on the exact CPU."
msgstr ""
"Normalmente, os drivers n�o configuram os manipuladores de interrup��o at� a "
"rotina de anexa��o. Em vez disso, eles fazem sondas no modo de pesquisa "
"<function> DEMORA() </function> fun��o para o tempo limite. A rotina de "
"an�lise nunca deve ser interrompida para sempre, todas as esperas do "
"dispositivo devem ser feitas com tempos limite. Se o dispositivo n�o "
"responder dentro do tempo provavelmente est� quebrado ou mal configurado e o "
"driver deve retornar um erro. Ao determinar o intervalo de timeout, d� ao "
"dispositivo algum tempo extra para estar no lado seguro: <function> DEMORA() "
"</function> � suposto para atrasar a mesma quantidade de tempo em qualquer "
"m�quina que tenha alguma margem de erro, dependendo da CPU exata \""

#. (itstool) path: sect1/para
#: book.translate.xml:18446
#, fuzzy
msgid ""
"If the probe routine really wants to check that the interrupts really work "
"it may configure and probe the interrupts too. But that is not recommended."
msgstr ""
"Se a rotina de an�lise realmente quer verificar se as interrup��es realmente "
"funcionam, pode configurar e investigar as interrup��es tamb�m. Mas isso n�o "
"� recomendado."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18452
#, no-wrap
msgid ""
"\n"
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
"        "
msgstr ""
"\n"
"          /* implemented in some very device-specific way */\n"
"          if(error = xxx_probe_ports(sc))\n"
"              goto bad; /* will deallocate the resources before returning */\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18458
#, fuzzy
msgid ""
"The function <function>xxx_probe_ports()</function> may also set the device "
"description depending on the exact model of device it discovers. But if "
"there is only one supported device model this can be as well done in a "
"hardcoded way. Of course, for the PnP devices the PnP support sets the "
"description from the table automatically."
msgstr ""
"A fun��o <function> xxx_probe_ports () </function> Tamb�m pode definir a "
"descri��o do dispositivo dependendo do modelo exato do dispositivo que ele "
"descobre. Mas se houver apenas um modelo de dispositivo suportado, isso "
"tamb�m pode ser feito de maneira codificada. � claro que, para os "
"dispositivos PnP, o suporte PnP define a descri��o da tabela automaticamente."
" "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18468
#, no-wrap
msgid ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
"        "
msgstr ""
"          if(pnperror)\n"
"              device_set_desc(dev, \"Our device model 1234\");\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18472
#, fuzzy
msgid ""
"Then the probe routine should either discover the ranges of all the "
"resources by reading the device configuration registers or make sure that "
"they were set explicitly by the user. We will consider it with an example of "
"on-board memory. The probe routine should be as non-intrusive as possible, "
"so allocation and check of functionality of the rest of resources (besides "
"the ports) would be better left to the attach routine."
msgstr ""
"Ent�o, a rotina de an�lise deve descobrir os intervalos de todos os recursos "
"lendo os registros de configura��o do dispositivo ou certificar-se de que "
"eles foram definidos explicitamente pelo usu�rio. Vamos consider�-lo com um "
"exemplo de mem�ria on-board. A rotina de an�lise deve ser o mais n�o "
"intrusivo poss�vel, portanto, a aloca��o e a verifica��o da funcionalidade "
"do restante dos recursos (al�m das portas) seriam melhor deixadas para a "
"rotina de anexa��o \""

#. (itstool) path: sect1/para
#: book.translate.xml:18483
#, fuzzy
msgid ""
"The memory address may be specified in the kernel configuration file or on "
"some devices it may be pre-configured in non-volatile configuration "
"registers. If both sources are available and different, which one should be "
"used? Probably if the user bothered to set the address explicitly in the "
"kernel configuration file they know what they are doing and this one should "
"take precedence. An example of implementation could be:"
msgstr ""
"O endere�o de mem�ria pode ser especificado no arquivo de configura��o do "
"kernel ou em alguns dispositivos ele pode ser pr�-configurado em registros "
"de configura��o n�o vol�teis. Se ambas as fontes estiverem dispon�veis e "
"diferentes, qual deve ser usado? Provavelmente se o usu�rio se incomodou em "
"definir o endere�o explicitamente no arquivo de configura��o do kernel eles "
"sabem o que est�o fazendo e este deve ter preced�ncia. Um exemplo de "
"implementa��o poderia ser: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18493
#, no-wrap
msgid ""
"\n"
"          /* try to find out the config address first */\n"
"          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /"
"*rid*/);\n"
"          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */\n"
"              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);\n"
"\n"
"\n"
"          if(sc-&gt;mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
"\n"
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers "
"instead\n"
"           * to accommodate different models of devices. Another option "
"would\n"
"           * be to let the user set the memory size as \"msize\" "
"configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, "
"0 /*rid*/);\n"
"              if(sc-&gt;mem0_size == 0) /* not specified by user */\n"
"                  sc-&gt;mem0_size = "
"xxx_read_mem0_size_from_device_config(sc);\n"
"\n"
"              if(sc-&gt;mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no "
"preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc-&gt;mem0_size = 8*1024;\n"
"              }\n"
"\n"
"              if(xxx_set_mem0_size_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that size */\n"
"\n"
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, "
"0 /*rid*/);\n"
"          }        "
msgstr ""
"\n"
"          /* try to find out the config address first */\n"
"          sc-&gt;mem0_p = bus_get_resource_start(dev, SYS_RES_MEMORY, 0 /"
"*rid*/);\n"
"          if(sc-&gt;mem0_p == 0) { /* nope, not specified by user */\n"
"              sc-&gt;mem0_p = xxx_read_mem0_from_device_config(sc);\n"
"\n"
"\n"
"          if(sc-&gt;mem0_p == 0)\n"
"                  /* can't get it from device config registers either */\n"
"                  goto bad;\n"
"          } else {\n"
"              if(xxx_set_mem0_address_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that address */\n"
"          }\n"
"\n"
"          /* just like the port, set the memory size,\n"
"           * for some devices the memory size would not be constant\n"
"           * but should be read from the device configuration registers "
"instead\n"
"           * to accommodate different models of devices. Another option "
"would\n"
"           * be to let the user set the memory size as \"msize\" "
"configuration\n"
"           * resource which will be automatically handled by the ISA bus.\n"
"           */\n"
"           if(pnperror) { /* only for non-PnP devices */\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, "
"0 /*rid*/);\n"
"              if(sc-&gt;mem0_size == 0) /* not specified by user */\n"
"                  sc-&gt;mem0_size = "
"xxx_read_mem0_size_from_device_config(sc);\n"
"\n"
"              if(sc-&gt;mem0_size == 0) {\n"
"                  /* suppose this is a very old model of device without\n"
"                   * auto-configuration features and the user gave no "
"preference,\n"
"                   * so assume the minimalistic case\n"
"                   * (of course, the real value will vary with the driver)\n"
"                   */\n"
"                  sc-&gt;mem0_size = 8*1024;\n"
"              }\n"
"\n"
"              if(xxx_set_mem0_size_on_device(sc) &lt; 0)\n"
"                  goto bad; /* device does not support that size */\n"
"\n"
"              if(bus_set_resource(dev, SYS_RES_MEMORY, /*rid*/0,\n"
"                      sc-&gt;mem0_p, sc-&gt;mem0_size)&lt;0)\n"
"                  goto bad;\n"
"          } else {\n"
"              sc-&gt;mem0_size = bus_get_resource_count(dev, SYS_RES_MEMORY, "
"0 /*rid*/);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:18539
#, fuzzy
msgid "Resources for IRQ and DRQ are easy to check by analogy."
msgstr "Recursos para IRQ e DRQ s�o f�ceis de verificar por analogia."

#. (itstool) path: sect1/para
#: book.translate.xml:18543
#, fuzzy
msgid "If all went well then release all the resources and return success."
msgstr "Se tudo correu bem, libere todos os recursos e retorne o sucesso."

#. (itstool) path: sect1/programlisting
#. (itstool) path: para/programlisting
#: book.translate.xml:18547 book.translate.xml:18889
#, no-wrap
msgid "          xxx_free_resources(sc);\n"
"          return 0;"
msgstr "          xxx_free_resources(sc);\n"
"          return 0;"

#. (itstool) path: sect1/para
#: book.translate.xml:18550
#, fuzzy
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning. We make use of the fact that before the "
"structure softc is passed to us it gets zeroed out, so we can find out if "
"some resource was allocated: then its descriptor is non-zero."
msgstr ""
"Finalmente, lide com as situa��es problem�ticas. Todos os recursos devem ser "
"desalocados antes de retornar. Usamos o fato de que antes que a estrutura "
"seja passada para n�s, ela � zerada, para que possamos descobrir se algum "
"recurso foi alocado. descritor � diferente de zero. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18558
#, no-wrap
msgid ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"
msgstr ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"                return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18566
#, fuzzy
msgid ""
"That would be all for the probe routine. Freeing of resources is done from "
"multiple places, so it is moved to a function which may look like:"
msgstr ""
"Isso seria tudo para a rotina da sonda. A libera��o de recursos � feita a "
"partir de v�rios lugares, ent�o � movida para uma fun��o que pode parecer:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18572
#, no-wrap
msgid ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
"\n"
"              /* interrupt handler */\n"
"              if(sc-&gt;intr_r) {\n"
"                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-"
"&gt;intr_cookie);\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-"
"&gt;intr_rid,\n"
"                      sc-&gt;intr_r);\n"
"                  sc-&gt;intr_r = 0;\n"
"              }\n"
"\n"
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc-&gt;data_p) {\n"
"                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);\n"
"                  sc-&gt;data_p = 0;\n"
"              }\n"
"               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately "
"equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-"
"&gt;data_map);\n"
"                  sc-&gt;data = 0;\n"
"              }\n"
"              if(sc-&gt;data_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;data_tag);\n"
"                  sc-&gt;data_tag = 0;\n"
"              }\n"
"\n"
"              ... free other maps and tags if we have them ...\n"
"\n"
"              if(sc-&gt;parent_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;parent_tag);\n"
"                  sc-&gt;parent_tag = 0;\n"
"              }\n"
"\n"
"              /* release all the bus resources */\n"
"              if(sc-&gt;mem0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-"
"&gt;mem0_rid,\n"
"                      sc-&gt;mem0_r);\n"
"                  sc-&gt;mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc-&gt;port0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-"
"&gt;port0_rid,\n"
"                      sc-&gt;port0_r);\n"
"                  sc-&gt;port0_r = 0;\n"
"              }\n"
"          }"
msgstr ""
"static void\n"
"           xxx_free_resources(sc)\n"
"              struct xxx_softc *sc;\n"
"          {\n"
"              /* check every resource and free if not zero */\n"
"\n"
"              /* interrupt handler */\n"
"              if(sc-&gt;intr_r) {\n"
"                  bus_teardown_intr(sc-&gt;dev, sc-&gt;intr_r, sc-"
"&gt;intr_cookie);\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IRQ, sc-"
"&gt;intr_rid,\n"
"                      sc-&gt;intr_r);\n"
"                  sc-&gt;intr_r = 0;\n"
"              }\n"
"\n"
"              /* all kinds of memory maps we could have allocated */\n"
"              if(sc-&gt;data_p) {\n"
"                  bus_dmamap_unload(sc-&gt;data_tag, sc-&gt;data_map);\n"
"                  sc-&gt;data_p = 0;\n"
"              }\n"
"               if(sc-&gt;data) { /* sc-&gt;data_map may be legitimately "
"equal to 0 */\n"
"                  /* the map will also be freed */\n"
"                  bus_dmamem_free(sc-&gt;data_tag, sc-&gt;data, sc-"
"&gt;data_map);\n"
"                  sc-&gt;data = 0;\n"
"              }\n"
"              if(sc-&gt;data_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;data_tag);\n"
"                  sc-&gt;data_tag = 0;\n"
"              }\n"
"\n"
"              ... free other maps and tags if we have them ...\n"
"\n"
"              if(sc-&gt;parent_tag) {\n"
"                  bus_dma_tag_destroy(sc-&gt;parent_tag);\n"
"                  sc-&gt;parent_tag = 0;\n"
"              }\n"
"\n"
"              /* release all the bus resources */\n"
"              if(sc-&gt;mem0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_MEMORY, sc-"
"&gt;mem0_rid,\n"
"                      sc-&gt;mem0_r);\n"
"                  sc-&gt;mem0_r = 0;\n"
"              }\n"
"              ...\n"
"              if(sc-&gt;port0_r) {\n"
"                  bus_release_resource(sc-&gt;dev, SYS_RES_IOPORT, sc-"
"&gt;port0_rid,\n"
"                      sc-&gt;port0_r);\n"
"                  sc-&gt;port0_r = 0;\n"
"              }\n"
"          }"

#. (itstool) path: sect1/title
#: book.translate.xml:18625
#, fuzzy
msgid "xxx_isa_attach"
msgstr "xxx_isa_attach"

#. (itstool) path: sect1/para
#: book.translate.xml:18628
#, fuzzy
msgid ""
"The attach routine actually connects the driver to the system if the probe "
"routine returned success and the system had chosen to attach that driver. If "
"the probe routine returned 0 then the attach routine may expect to receive "
"the device structure softc intact, as it was set by the probe routine. Also "
"if the probe routine returns 0 it may expect that the attach routine for "
"this device shall be called at some point in the future. If the probe "
"routine returns a negative value then the driver may make none of these "
"assumptions."
msgstr ""
"A rotina anexar realmente conecta o driver ao sistema se a rotina da sonda "
"tiver retornado sucesso e o sistema tiver escolhido anexar esse driver. Se a "
"rotina da sonda retornasse 0, a rotina de anexa��o poderia receber a "
"estrutura do dispositivo softc intacta, como era Al�m disso, se a rotina da "
"sonda retornar 0, pode-se esperar que a rotina de anexa��o para este "
"dispositivo seja chamada em algum momento no futuro.Se a rotina da sonda "
"retornar um valor negativo, o motorista n�o far� nenhuma dessas suposi��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:18640
#, fuzzy
msgid ""
"The attach routine returns 0 if it completed successfully or error code "
"otherwise."
msgstr ""
"A rotina de anexa��o retorna 0 se foi conclu�da com sucesso ou, caso "
"contr�rio, o c�digo de erro."

#. (itstool) path: sect1/para
#: book.translate.xml:18644
#, fuzzy
msgid ""
"The attach routine starts just like the probe routine, with getting some "
"frequently used data into more accessible variables."
msgstr ""
"A rotina de anexa��o come�a exatamente como a rotina de an�lise, com a "
"obten��o de alguns dados usados ​​com frequ�ncia em vari�veis ​​mais "
"acess�veis."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18649
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int unit = device_get_unit(dev);\n"
"          int error = 0;"

#. (itstool) path: sect1/para
#: book.translate.xml:18653
#, fuzzy
msgid ""
"Then allocate and activate all the necessary resources. Because normally the "
"port range will be released before returning from probe, it has to be "
"allocated again. We expect that the probe routine had properly set all the "
"resource ranges, as well as saved them in the structure softc. If the probe "
"routine had left some resource allocated then it does not need to be "
"allocated again (which would be considered an error)."
msgstr ""
"Em seguida, aloque e ative todos os recursos necess�rios. Como normalmente o "
"intervalo de portas ser� liberado antes de retornar do probe, ele deve ser "
"alocado novamente. Esperamos que a rotina de an�lise tenha definido "
"corretamente todos os intervalos de recursos e os salvou em a estrutura "
"softc.Se a rotina de an�lise tiver deixado algum recurso alocado, ela n�o "
"precisar� ser alocada novamente (o que seria considerado um erro). "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18663
#, no-wrap
msgid ""
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-"
"&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"               return ENXIO;\n"
"\n"
"          /* on-board memory */\n"
"          sc-&gt;mem0_rid = 0;\n"
"          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-"
"&gt;mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;mem0_r == NULL)\n"
"                goto bad;\n"
"\n"
"          /* get its virtual address */\n"
"          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);"
msgstr ""
"          sc-&gt;port0_rid = 0;\n"
"          sc-&gt;port0_r = bus_alloc_resource(dev, SYS_RES_IOPORT,  &amp;sc-"
"&gt;port0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;port0_r == NULL)\n"
"               return ENXIO;\n"
"\n"
"          /* on-board memory */\n"
"          sc-&gt;mem0_rid = 0;\n"
"          sc-&gt;mem0_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-"
"&gt;mem0_rid,\n"
"              /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;mem0_r == NULL)\n"
"                goto bad;\n"
"\n"
"          /* get its virtual address */\n"
"          sc-&gt;mem0_v = rman_get_virtual(sc-&gt;mem0_r);"

#. (itstool) path: sect1/para
#: book.translate.xml:18681
#, fuzzy
msgid ""
"The DMA request channel (DRQ) is allocated likewise. To initialize it use "
"functions of the <function>isa_dma*()</function> family. For example:"
msgstr ""
"O canal de requisi��o DMA (DRQ) � alocado da mesma forma. Para inicializ�-"
"lo, use as fun��es do <function> isa_dma * () </function> fam�lia. Por "
"exemplo:"

#. (itstool) path: sect1/para
#: book.translate.xml:18686
#, fuzzy
msgid "<function>isa_dmacascade(sc-&gt;drq0);</function>"
msgstr " <function> isa_dmacascade (sc-&gt; drq0); </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18688
#, fuzzy
msgid ""
"The interrupt request line (IRQ) is a bit special. Besides allocation the "
"driver's interrupt handler should be associated with it. Historically in the "
"old ISA drivers the argument passed by the system to the interrupt handler "
"was the device unit number. But in modern drivers the convention suggests "
"passing the pointer to structure softc. The important reason is that when "
"the structures softc are allocated dynamically then getting the unit number "
"from softc is easy while getting softc from the unit number is difficult. "
"Also this convention makes the drivers for different buses look more uniform "
"and allows them to share the code: each bus gets its own probe, attach, "
"detach and other bus-specific routines while the bulk of the driver code may "
"be shared among them."
msgstr ""
"A linha de requisi��o de interrup��o (IRQ) � um pouco especial. Al�m da "
"aloca��o, o manipulador de interrup��o do driver deve estar associado a ela. "
"Historicamente, nos antigos drivers ISA, o argumento transmitido pelo "
"sistema ao manipulador de interrup��o era o n�mero da unidade. drivers a "
"conven��o sugere passar o ponteiro para a estrutura softc.A raz�o importante "
"� que quando o softc estruturas s�o alocados dinamicamente, em seguida, "
"obtendo o n�mero da unidade do softc � f�cil, enquanto obtendo softc do "
"n�mero da unidade � dif�cil.Tamb�m esta conven��o faz com que os drivers "
"para diferentes os barramentos parecem mais uniformes e permitem que eles "
"compartilhem o c�digo: cada barramento recebe sua pr�pria sonda, anexar, "
"desconectar e outras rotinas espec�ficas de barramento, enquanto a maior "
"parte do c�digo do driver pode ser compartilhada entre eles. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18704
#, no-wrap
msgid ""
"\n"
"          sc-&gt;intr_rid = 0;\n"
"          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-"
"&gt;intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;intr_r == NULL)\n"
"              goto bad;\n"
"\n"
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type "
"of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-"
"&gt;intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"        "
msgstr ""
"\n"
"          sc-&gt;intr_rid = 0;\n"
"          sc-&gt;intr_r = bus_alloc_resource(dev, SYS_RES_MEMORY,  &amp;sc-"
"&gt;intr_rid,\n"
"                /*start*/ 0, /*end*/ ~0, /*count*/ 0, RF_ACTIVE);\n"
"\n"
"          if(sc-&gt;intr_r == NULL)\n"
"              goto bad;\n"
"\n"
"          /*\n"
"           * XXX_INTR_TYPE is supposed to be defined depending on the type "
"of\n"
"           * the driver, for example as INTR_TYPE_CAM for a CAM driver\n"
"           */\n"
"          error = bus_setup_intr(dev, sc-&gt;intr_r, XXX_INTR_TYPE,\n"
"              (driver_intr_t *) xxx_intr, (void *) sc, &amp;sc-"
"&gt;intr_cookie);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18724
#, fuzzy
msgid ""
"If the device needs to make DMA to the main memory then this memory should "
"be allocated like described before:"
msgstr ""
"Se o dispositivo precisa fazer o DMA para a mem�ria principal, ent�o esta "
"mem�ria deve ser alocada como descrito anteriormente:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18728
#, no-wrap
msgid ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ "
"NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &amp;sc-&gt;parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          /* many things get inherited from the parent tag\n"
"           * sc-&gt;data is supposed to point to the structure with the "
"shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,\n"
"              &amp;sc-&gt;data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* "
"flags*/ 0,\n"
"              &amp;sc-&gt;data_map);\n"
"          if(error)\n"
"               goto bad;\n"
"\n"
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &amp;sc-"
"&gt;data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-"
"&gt;data,\n"
"              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-"
"&gt;data_p,\n"
"              /*flags*/0);"
msgstr ""
"          error=bus_dma_tag_create(NULL, /*alignment*/ 4,\n"
"              /*boundary*/ 0, /*lowaddr*/ BUS_SPACE_MAXADDR_24BIT,\n"
"              /*highaddr*/ BUS_SPACE_MAXADDR, /*filter*/ NULL, /*filterarg*/ "
"NULL,\n"
"              /*maxsize*/ BUS_SPACE_MAXSIZE_24BIT,\n"
"              /*nsegments*/ BUS_SPACE_UNRESTRICTED,\n"
"              /*maxsegsz*/ BUS_SPACE_MAXSIZE_24BIT, /*flags*/ 0,\n"
"              &amp;sc-&gt;parent_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          /* many things get inherited from the parent tag\n"
"           * sc-&gt;data is supposed to point to the structure with the "
"shared data,\n"
"           * for example for a ring buffer it could be:\n"
"           * struct {\n"
"           *   u_short rd_pos;\n"
"           *   u_short wr_pos;\n"
"           *   char    bf[XXX_RING_BUFFER_SIZE]\n"
"           * } *data;\n"
"           */\n"
"          error=bus_dma_tag_create(sc-&gt;parent_tag, 1,\n"
"              0, BUS_SPACE_MAXADDR, 0, /*filter*/ NULL, /*filterarg*/ NULL,\n"
"              /*maxsize*/ sizeof(* sc-&gt;data), /*nsegments*/ 1,\n"
"              /*maxsegsz*/ sizeof(* sc-&gt;data), /*flags*/ 0,\n"
"              &amp;sc-&gt;data_tag);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          error = bus_dmamem_alloc(sc-&gt;data_tag, &amp;sc-&gt;data, /* "
"flags*/ 0,\n"
"              &amp;sc-&gt;data_map);\n"
"          if(error)\n"
"               goto bad;\n"
"\n"
"          /* xxx_alloc_callback() just saves the physical address at\n"
"           * the pointer passed as its argument, in this case &amp;sc-"
"&gt;data_p.\n"
"           * See details in the section on bus memory mapping.\n"
"           * It can be implemented like:\n"
"           *\n"
"           * static void\n"
"           * xxx_alloc_callback(void *arg, bus_dma_segment_t *seg,\n"
"           *     int nseg, int error)\n"
"           * {\n"
"           *    *(bus_addr_t *)arg = seg[0].ds_addr;\n"
"           * }\n"
"           */\n"
"          bus_dmamap_load(sc-&gt;data_tag, sc-&gt;data_map, (void *)sc-"
"&gt;data,\n"
"              sizeof (* sc-&gt;data), xxx_alloc_callback, (void *) &amp;sc-"
"&gt;data_p,\n"
"              /*flags*/0);"

#. (itstool) path: sect1/para
#: book.translate.xml:18777
#, fuzzy
msgid ""
"After all the necessary resources are allocated the device should be "
"initialized. The initialization may include testing that all the expected "
"features are functional."
msgstr ""
"Depois que todos os recursos necess�rios s�o alocados, o dispositivo deve "
"ser inicializado. A inicializa��o pode incluir testes de que todos os "
"recursos esperados s�o funcionais."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18781
#, no-wrap
msgid ""
"          if(xxx_initialize(sc) &lt; 0)\n"
"               goto bad;        "
msgstr ""
"          if(xxx_initialize(sc) &lt; 0)\n"
"               goto bad;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18785
#, fuzzy
msgid ""
"The bus subsystem will automatically print on the console the device "
"description set by probe. But if the driver wants to print some extra "
"information about the device it may do so, for example:"
msgstr ""
"O subsistema de barramento ir� imprimir automaticamente no console a "
"descri��o do dispositivo definida pela sonda. Mas se o motorista quiser "
"imprimir alguma informa��o extra sobre o dispositivo, pode faz�-lo, por "
"exemplo:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18790
#, no-wrap
msgid ""
"\n"
"        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc-"
"&gt;fifosize);\n"
"        "
msgstr ""
"\n"
"        device_printf(dev, \"has on-card FIFO buffer of %d bytes\\n\", sc-"
"&gt;fifosize);\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18794
#, fuzzy
msgid ""
"If the initialization routine experiences any problems then printing "
"messages about them before returning error is also recommended."
msgstr ""
"Se a rotina de inicializa��o apresentar algum problema, a impress�o de "
"mensagens sobre eles antes de retornar o erro tamb�m � recomendada."

#. (itstool) path: sect1/para
#: book.translate.xml:18798
#, fuzzy
msgid ""
"The final step of the attach routine is attaching the device to its "
"functional subsystem in the kernel. The exact way to do it depends on the "
"type of the driver: a character device, a block device, a network device, a "
"CAM SCSI bus device and so on."
msgstr ""
"A etapa final da rotina de anexa��o � anexar o dispositivo ao seu subsistema "
"funcional no kernel. A maneira exata de fazer isso depende do tipo do driver:"
" um dispositivo de caractere, um dispositivo de bloco, um dispositivo de "
"rede, um barramento CAM SCSI dispositivo e assim por diante. "

#. (itstool) path: sect1/para
#: book.translate.xml:18804
#, fuzzy
msgid "If all went well then return success."
msgstr "Se tudo correu bem, ent�o retorne o sucesso."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18806
#, no-wrap
msgid ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          return 0;        "
msgstr ""
"          error = xxx_attach_subsystem(sc);\n"
"          if(error)\n"
"              goto bad;\n"
"\n"
"          return 0;        "

#. (itstool) path: sect1/para
#: book.translate.xml:18812
#, fuzzy
msgid ""
"Finally, handle the troublesome situations. All the resources should be "
"deallocated before returning an error. We make use of the fact that before "
"the structure softc is passed to us it gets zeroed out, so we can find out "
"if some resource was allocated: then its descriptor is non-zero."
msgstr ""
"Finalmente, lide com as situa��es problem�ticas. Todos os recursos devem ser "
"desalocados antes de retornar um erro. Fazemos uso do fato de que antes que "
"a estrutura seja passada para n�s, ela � zerada, para que possamos descobrir "
"se algum recurso foi alocado: ent�o seu descritor � diferente de zero. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18819
#, no-wrap
msgid ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"
msgstr ""
"          bad:\n"
"\n"
"          xxx_free_resources(sc);\n"
"          if(error)\n"
"              return error;\n"
"          else /* exact error is unknown */\n"
"              return ENXIO;"

#. (itstool) path: sect1/para
#: book.translate.xml:18827
#, fuzzy
msgid "That would be all for the attach routine."
msgstr "Isso seria tudo para a rotina de anexar."

#. (itstool) path: sect1/title
#: book.translate.xml:18833
#, fuzzy
msgid "xxx_isa_detach"
msgstr "xxx_isa_detach"

#. (itstool) path: sect1/para
#: book.translate.xml:18835
#, fuzzy
msgid ""
"If this function is present in the driver and the driver is compiled as a "
"loadable module then the driver gets the ability to be unloaded. This is an "
"important feature if the hardware supports hot plug. But the ISA bus does "
"not support hot plug, so this feature is not particularly important for the "
"ISA devices. The ability to unload a driver may be useful when debugging it, "
"but in many cases installation of the new version of the driver would be "
"required only after the old version somehow wedges the system and a reboot "
"will be needed anyway, so the efforts spent on writing the detach routine "
"may not be worth it. Another argument that unloading would allow upgrading "
"the drivers on a production machine seems to be mostly theoretical. "
"Installing a new version of a driver is a dangerous operation which should "
"never be performed on a production machine (and which is not permitted when "
"the system is running in secure mode). Still, the detach routine may be "
"provided for the sake of completeness."
msgstr ""
"Se esta fun��o estiver presente no driver e o driver for compilado como um "
"m�dulo carreg�vel, o driver ter� a capacidade de ser descarregado. Esse � um "
"recurso importante se o hardware suportar hot plug. Mas o barramento ISA n�o "
"suporta hot plug, Portanto, esse recurso n�o � particularmente importante "
"para os dispositivos ISA.A capacidade de descarregar um driver pode ser �til "
"ao depur�-lo, mas em muitos casos a instala��o da nova vers�o do driver "
"seria necess�ria somente depois que a vers�o antiga de alguma forma for�ar o "
"sistema uma reinicializa��o ser� necess�ria de qualquer maneira, ent�o os "
"esfor�os gastos em escrever a rotina de desconex�o podem n�o valer a pena.Um "
"argumento de que descarregar permitiria a atualiza��o dos drivers em uma "
"m�quina de produ��o parece ser mais te�rico.A instala��o de uma nova vers�o "
"de um driver � opera��o perigosa que nunca deve ser executada em uma m�quina "
"de produ��o (e que n�o � permitida quando o sistema est� sendo executado no "
"modo seguro) .Ainda assim, a rotina de separa��o pode ser fornecida para "
"completar ess. "

#. (itstool) path: sect1/para
#: book.translate.xml:18856
#, fuzzy
msgid ""
"The detach routine returns 0 if the driver was successfully detached or the "
"error code otherwise."
msgstr ""
"A rotina de desanexa��o retorna 0 se o driver foi desconectado com sucesso "
"ou o c�digo de erro ocorreu de outra forma."

#. (itstool) path: para/programlisting
#: book.translate.xml:18870
#, no-wrap
msgid ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
"\n"
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;"
msgstr ""
"          struct xxx_softc *sc = device_get_softc(dev);\n"
"          int error;\n"
"\n"
"          error = xxx_detach_subsystem(sc);\n"
"          if(error)\n"
"              return error;"

#. (itstool) path: sect1/para
#: book.translate.xml:18861
#, fuzzy
msgid ""
"The logic of detach is a mirror of the attach. The first thing to do is to "
"detach the driver from its kernel subsystem. If the device is currently open "
"then the driver has two choices: refuse to be detached or forcibly close and "
"proceed with detach. The choice used depends on the ability of the "
"particular kernel subsystem to do a forced close and on the preferences of "
"the driver's author. Generally the forced close seems to be the preferred "
"alternative. <_:programlisting-1/>"
msgstr ""
"A l�gica de desanexar � um espelho da conex�o. A primeira coisa a fazer � "
"separar o driver do subsistema do kernel. Se o dispositivo estiver aberto, o "
"driver tem duas op��es: recusar-se a ser desanexado ou for�osamente fechado "
"e continuar com A escolha usada depende da habilidade do subsistema do "
"kernel em fazer um fechamento for�ado e nas prefer�ncias do autor do driver."
"Geralmente, o fechamento for�ado parece ser a alternativa preferida. <_: "
"programlisting-1 /> "

#. (itstool) path: sect1/para
#: book.translate.xml:18877
#, fuzzy
msgid ""
"Next the driver may want to reset the hardware to some consistent state. "
"That includes stopping any ongoing transfers, disabling the DMA channels and "
"interrupts to avoid memory corruption by the device. For most of the drivers "
"this is exactly what the shutdown routine does, so if it is included in the "
"driver we can just call it."
msgstr ""
"Em seguida, o driver pode querer redefinir o hardware para algum estado "
"consistente. Isso inclui parar qualquer transfer�ncia em andamento, "
"desabilitar os canais DMA e interromper para evitar corrup��o de mem�ria "
"pelo dispositivo. Para a maioria dos drivers, isso � exatamente o que a "
"rotina de desligamento faz. por isso, se estiver inclu�do no driver, podemos "
"cham�-lo. "

#. (itstool) path: sect1/para
#: book.translate.xml:18885
#, fuzzy
msgid "<function>xxx_isa_shutdown(dev);</function>"
msgstr " <function> xxx_isa_shutdown (dev); </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:18887
#, fuzzy
msgid ""
"And finally release all the resources and return success. <_:programlisting-"
"1/>"
msgstr ""
"E, finalmente, liberar todos os recursos e retornar o sucesso. <_: "
"Programlisting-1 />"

#. (itstool) path: sect1/title
#: book.translate.xml:18896
#, fuzzy
msgid "xxx_isa_shutdown"
msgstr "xxx_isa_shutdown"

#. (itstool) path: sect1/para
#: book.translate.xml:18898
#, fuzzy
msgid ""
"This routine is called when the system is about to be shut down. It is "
"expected to bring the hardware to some consistent state. For most of the ISA "
"devices no special action is required, so the function is not really "
"necessary because the device will be re-initialized on reboot anyway. But "
"some devices have to be shut down with a special procedure, to make sure "
"that they will be properly detected after soft reboot (this is especially "
"true for many devices with proprietary identification protocols). In any "
"case disabling DMA and interrupts in the device registers and stopping any "
"ongoing transfers is a good idea. The exact action depends on the hardware, "
"so we do not consider it here in any detail."
msgstr ""
"Essa rotina � chamada quando o sistema est� prestes a ser desligado. Espera-"
"se que o hardware fique em um estado consistente. Para a maioria dos "
"dispositivos ISA, nenhuma a��o especial � necess�ria, portanto, a fun��o n�o "
"� realmente necess�ria porque o dispositivo ser reinicializado na "
"reinicializa��o de qualquer maneira.Mas alguns dispositivos tem que ser "
"desligado com um procedimento especial, para se certificar de que eles ser�o "
"detectados corretamente ap�s a reinicializa��o suave (isso � especialmente "
"verdadeiro para muitos dispositivos com protocolos de identifica��o "
"propriet�rios). desabilitar o DMA e interromper os registros do dispositivo "
"e parar qualquer transfer�ncia em andamento � uma boa id�ia. A a��o exata "
"depende do hardware, portanto, n�o o consideramos aqui em detalhes. "

#. (itstool) path: sect1/title
#: book.translate.xml:18916
#, fuzzy
msgid "xxx_intr"
msgstr "Xxx_intr"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:18918
#, fuzzy
msgid "<primary>interrupt handler</primary>"
msgstr " <primary> manipulador de interrup��es </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:18920
#, fuzzy
msgid ""
"The interrupt handler is called when an interrupt is received which may be "
"from this particular device. The ISA bus does not support interrupt sharing "
"(except in some special cases) so in practice if the interrupt handler is "
"called then the interrupt almost for sure came from its device. Still, the "
"interrupt handler must poll the device registers and make sure that the "
"interrupt was generated by its device. If not it should just return."
msgstr ""
"O manipulador de interrup��o � chamado quando uma interrup��o � recebida, "
"que pode ser deste dispositivo em particular. O barramento ISA n�o suporta o "
"compartilhamento de interrup��es (exceto em alguns casos especiais), ent�o, "
"na pr�tica, se o manipulador de interrup��o for chamado, Ainda assim, o "
"manipulador de interrup��o deve pesquisar os registros do dispositivo e "
"certificar-se de que a interrup��o foi gerada por seu dispositivo. Caso "
"contr�rio, ele deve apenas retornar. "

#. (itstool) path: sect1/para
#: book.translate.xml:18931
#, fuzzy
msgid ""
"The old convention for the ISA drivers was getting the device unit number as "
"an argument. This is obsolete, and the new drivers receive whatever argument "
"was specified for them in the attach routine when calling "
"<function>bus_setup_intr()</function>. By the new convention it should be "
"the pointer to the structure softc. So the interrupt handler commonly starts "
"as:"
msgstr ""
"A antiga conven��o para os drivers ISA estava obtendo o n�mero da unidade do "
"dispositivo como um argumento. Isso � obsoleto e os novos drivers recebem "
"qualquer argumento especificado para eles na rotina anexar ao chamar "
"<function> bus_setup_intr () </function> . Pela nova conven��o deve ser o "
"ponteiro para a estrutura softc. Ent�o, o manipulador de interrup��o "
"geralmente come�a como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18941
#, no-wrap
msgid ""
"\n"
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
"\n"
"        "
msgstr ""
"\n"
"          static void\n"
"          xxx_intr(struct xxx_softc *sc)\n"
"          {\n"
"\n"
"        "

#. (itstool) path: sect1/para
#: book.translate.xml:18948
#, fuzzy
msgid ""
"It runs at the interrupt priority level specified by the interrupt type "
"parameter of <function>bus_setup_intr()</function>. That means that all the "
"other interrupts of the same type as well as all the software interrupts are "
"disabled."
msgstr ""
"Ele � executado no n�vel de prioridade de interrup��o especificado pelo "
"par�metro de tipo de interrup��o de <function> bus_setup_intr () </function> "
". Isso significa que todas as outras interrup��es do mesmo tipo, bem como "
"todas as interrup��es de software, est�o desativadas. "

#. (itstool) path: sect1/para
#: book.translate.xml:18956
#, fuzzy
msgid "To avoid races it is commonly written as a loop:"
msgstr "Para evitar corridas, geralmente � escrito como um loop:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:18960
#, no-wrap
msgid ""
"\n"
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }        "
msgstr ""
"\n"
"          while(xxx_interrupt_pending(sc)) {\n"
"              xxx_process_interrupt(sc);\n"
"              xxx_acknowledge_interrupt(sc);\n"
"          }        "

#. (itstool) path: sect1/para
#: book.translate.xml:18966
#, fuzzy
msgid ""
"The interrupt handler has to acknowledge interrupt to the device only but "
"not to the interrupt controller, the system takes care of the latter."
msgstr ""
"O handler de interrup��o tem que reconhecer a interrup��o apenas para o "
"dispositivo, mas n�o para o controlador de interrup��o, o sistema cuida do "
"�ltimo."

#. (itstool) path: chapter/title
#: book.translate.xml:18982
#, fuzzy
msgid "PCI Devices"
msgstr "Dispositivos PCI"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:18984
#, fuzzy
msgid "<primary>PCI bus</primary>"
msgstr " <primary> Barramento PCI </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:18986
#, fuzzy
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device "
"driver for a device on a PCI bus."
msgstr ""
"Este cap�tulo vai falar sobre os mecanismos do FreeBSD para escrever um "
"driver de dispositivo para um dispositivo em um barramento PCI."

#. (itstool) path: sect1/title
#: book.translate.xml:18990
#, fuzzy
msgid "Probe and Attach"
msgstr "Sonda e Anexar"

#. (itstool) path: sect1/para
#: book.translate.xml:18992
#, fuzzy
msgid ""
"Information here about how the PCI bus code iterates through the unattached "
"devices and see if a newly loaded kld will attach to any of them."
msgstr ""
"Informa��es aqui sobre como o c�digo de barramento PCI percorre os "
"dispositivos n�o conectados e ver se um kld rec�m-carregado ser� anexado a "
"qualquer um deles."

#. (itstool) path: sect2/title
#: book.translate.xml:18997
#, fuzzy
msgid "Sample Driver Source (<filename>mypci.c</filename>)"
msgstr "Exemplo de fonte de driver ( <filename> mypci.c </filename> ) "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:18999
#, no-wrap
msgid ""
"/*\n"
" * Simple KLD to play with the PCI functions.\n"
" *\n"
" * Murray Stokely\n"
" */\n"
"\n"
"#include &lt;sys/param.h&gt;\t\t/* defines used in kernel.h */\n"
"#include &lt;sys/module.h&gt;\n"
"#include &lt;sys/systm.h&gt;\n"
"#include &lt;sys/errno.h&gt;\n"
"#include &lt;sys/kernel.h&gt;\t\t/* types used in module initialization */\n"
"#include &lt;sys/conf.h&gt;\t\t/* cdevsw struct */\n"
"#include &lt;sys/uio.h&gt;\t\t/* uio struct */\n"
"#include &lt;sys/malloc.h&gt;\n"
"#include &lt;sys/bus.h&gt;\t\t/* structs, prototypes for pci bus stuff and "
"DEVMETHOD macros! */\n"
"\n"
"#include &lt;machine/bus.h&gt;\n"
"#include &lt;sys/rman.h&gt;\n"
"#include &lt;machine/resource.h&gt;\n"
"\n"
"#include &lt;dev/pci/pcivar.h&gt;\t/* For pci_get macros! */\n"
"#include &lt;dev/pci/pcireg.h&gt;\n"
"\n"
"/* The softc holds our per-instance data. */\n"
"struct mypci_softc {\n"
"\tdevice_t\tmy_dev;\n"
"\tstruct cdev\t*my_cdev;\n"
"};\n"
"\n"
"/* Function prototypes */\n"
"static d_open_t\t\tmypci_open;\n"
"static d_close_t\tmypci_close;\n"
"static d_read_t\t\tmypci_read;\n"
"static d_write_t\tmypci_write;\n"
"\n"
"/* Character device entry points */\n"
"\n"
"static struct cdevsw mypci_cdevsw = {\n"
"\t.d_version =\tD_VERSION,\n"
"\t.d_open =\tmypci_open,\n"
"\t.d_close =\tmypci_close,\n"
"\t.d_read =\tmypci_read,\n"
"\t.d_write =\tmypci_write,\n"
"\t.d_name =\t\"mypci\",\n"
"};\n"
"\n"
"/*\n"
" * In the cdevsw routines, we find our softc by using the si_drv1 member\n"
" * of struct cdev.  We set this variable to point to our softc in our\n"
" * attach routine when we create the /dev entry.\n"
" */\n"
"\n"
"int\n"
"mypci_open(struct cdev *dev, int oflags, int devtype, struct thread *td)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Opened successfully.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_close(struct cdev *dev, int fflag, int devtype, struct thread *td)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Closed.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_read(struct cdev *dev, struct uio *uio, int ioflag)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Asked to read %zd bytes.\\n\", uio-"
"&gt;uio_resid);\n"
"\treturn (0);\n"
"}\n"
"\n"
"int\n"
"mypci_write(struct cdev *dev, struct uio *uio, int ioflag)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Look up our softc. */\n"
"\tsc = dev-&gt;si_drv1;\n"
"\tdevice_printf(sc-&gt;my_dev, \"Asked to write %zd bytes.\\n\", uio-"
"&gt;uio_resid);\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* PCI Support Functions */\n"
"\n"
"/*\n"
" * Compare the device ID of this device against the IDs that this driver\n"
" * supports.  If there is a match, set the description and return success.\n"
" */\n"
"static int\n"
"mypci_probe(device_t dev)\n"
"{\n"
"\n"
"\tdevice_printf(dev, \"MyPCI Probe\\nVendor ID : 0x%x\\nDevice ID : "
"0x%x\\n\",\n"
"\t    pci_get_vendor(dev), pci_get_device(dev));\n"
"\n"
"\tif (pci_get_vendor(dev) == 0x11c1) {\n"
"\t\tprintf(\"We've got the Winmodem, probe successful!\\n\");\n"
"\t\tdevice_set_desc(dev, \"WinModem\");\n"
"\t\treturn (BUS_PROBE_DEFAULT);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}\n"
"\n"
"/* Attach function is only called if the probe is successful. */\n"
"\n"
"static int\n"
"mypci_attach(device_t dev)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\tprintf(\"MyPCI Attach for : deviceID : 0x%x\\n\", pci_get_devid(dev));\n"
"\n"
"\t/* Look up our softc and initialize its fields. */\n"
"\tsc = device_get_softc(dev);\n"
"\tsc-&gt;my_dev = dev;\n"
"\n"
"\t/*\n"
"\t * Create a /dev entry for this device.  The kernel will assign us\n"
"\t * a major number automatically.  We use the unit number of this\n"
"\t * device as the minor number and name the character device\n"
"\t * \"mypci&lt;unit&gt;\".\n"
"\t */\n"
"\tsc-&gt;my_cdev = make_dev(<literal>&amp;</literal>mypci_cdevsw, "
"device_get_unit(dev),\n"
"\t    UID_ROOT, GID_WHEEL, 0600, \"mypci%u\", device_get_unit(dev));\n"
"\tsc-&gt;my_cdev-&gt;si_drv1 = sc;\n"
"\tprintf(\"Mypci device loaded.\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* Detach device. */\n"
"\n"
"static int\n"
"mypci_detach(device_t dev)\n"
"{\n"
"\tstruct mypci_softc *sc;\n"
"\n"
"\t/* Teardown the state in our softc created in our attach routine. */\n"
"\tsc = device_get_softc(dev);\n"
"\tdestroy_dev(sc-&gt;my_cdev);\n"
"\tprintf(\"Mypci detach!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/* Called during system shutdown after sync. */\n"
"\n"
"static int\n"
"mypci_shutdown(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci shutdown!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * Device suspend routine.\n"
" */\n"
"static int\n"
"mypci_suspend(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci suspend!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"/*\n"
" * Device resume routine.\n"
" */\n"
"static int\n"
"mypci_resume(device_t dev)\n"
"{\n"
"\n"
"\tprintf(\"Mypci resume!\\n\");\n"
"\treturn (0);\n"
"}\n"
"\n"
"static device_method_t mypci_methods[] = {\n"
"\t/* Device interface */\n"
"\tDEVMETHOD(device_probe,\t\tmypci_probe),\n"
"\tDEVMETHOD(device_attach,\tmypci_attach),\n"
"\tDEVMETHOD(device_detach,\tmypci_detach),\n"
"\tDEVMETHOD(device_shutdown,\tmypci_shutdown),\n"
"\tDEVMETHOD(device_suspend,\tmypci_suspend),\n"
"\tDEVMETHOD(device_resume,\tmypci_resume),\n"
"\n"
"\tDEVMETHOD_END\n"
"};\n"
"\n"
"static devclass_t mypci_devclass;\n"
"\n"
"DEFINE_CLASS_0(mypci, mypci_driver, mypci_methods, sizeof(struct "
"mypci_softc));\n"
"DRIVER_MODULE(mypci, pci, mypci_driver, mypci_devclass, 0, 0);"
msgstr ""

#. (itstool) path: sect2/title
#: book.translate.xml:19207
#, fuzzy
msgid "<filename>Makefile</filename> for Sample Driver"
msgstr " <filename> Makefile </filename> para o driver de exemplo "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19209
#, no-wrap
msgid ""
"# Makefile for mypci driver\n"
"\n"
"KMOD=\tmypci\n"
"SRCS=\tmypci.c\n"
"SRCS+=\tdevice_if.h bus_if.h pci_if.h\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"
msgstr ""
"# Makefile for mypci driver\n"
"\n"
"KMOD=\tmypci\n"
"SRCS=\tmypci.c\n"
"SRCS+=\tdevice_if.h bus_if.h pci_if.h\n"
"\n"
".include &lt;bsd.kmod.mk&gt;"

#. (itstool) path: sect2/para
#: book.translate.xml:19217
#, fuzzy
msgid ""
"If you place the above source file and <filename>Makefile</filename> into a "
"directory, you may run <command>make</command> to compile the sample driver. "
"Additionally, you may run <command>make load</command> to load the driver "
"into the currently running kernel and <command>make unload</command> to "
"unload the driver after it is loaded."
msgstr ""
"Se voc� colocar o arquivo de origem acima e <filename> Makefile </filename> "
"em um diret�rio, voc� pode executar <command> fa�o </command> para compilar "
"o driver de exemplo. Al�m disso, voc� pode executar <command> fazer carga </"
"command> para carregar o driver no kernel atualmente em execu��o e <command> "
"descarregar </command> para descarregar o driver depois que ele for "
"carregado. "

#. (itstool) path: sect2/title
#: book.translate.xml:19227
#, fuzzy
msgid "Additional Resources"
msgstr "Recursos adicionais"

#. (itstool) path: listitem/simpara
#: book.translate.xml:19229
#, fuzzy
msgid ""
"<link xlink:href=\"http://www.pcisig.org/\">PCI Special Interest Group</"
"link>"
msgstr ""
" <link xlink:href=\"http://www.pcisig.org/\"> Grupo de Interesse Especial "
"PCI </link> "

#. (itstool) path: listitem/simpara
#: book.translate.xml:19232
#, fuzzy
msgid "PCI System Architecture, Fourth Edition by Tom Shanley, et al."
msgstr "PCI System Architecture, quarta edi��o por Tom Shanley, et al."

#. (itstool) path: sect1/title
#: book.translate.xml:19240
#, fuzzy
msgid "Bus Resources"
msgstr "Recursos de �nibus"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19242
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>resources</secondary>"
msgstr ""
" <primary> Barramento PCI </primary><secondary> Recursos </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19243
#, fuzzy
msgid ""
"FreeBSD provides an object-oriented mechanism for requesting resources from "
"a parent bus. Almost all devices will be a child member of some sort of bus "
"(PCI, ISA, USB, SCSI, etc) and these devices need to acquire resources from "
"their parent bus (such as memory segments, interrupt lines, or DMA channels)."
""
msgstr ""
"O FreeBSD fornece um mecanismo orientado a objeto para solicitar recursos de "
"um barramento pai. Quase todos os dispositivos ser�o um membro filho de "
"algum tipo de barramento (PCI, ISA, USB, SCSI, etc) e esses dispositivos "
"precisam adquirir recursos de seus pais. barramento (como segmentos de "
"mem�ria, linhas de interrup��o ou canais DMA). "

#. (itstool) path: sect2/title
#: book.translate.xml:19250
#, fuzzy
msgid "Base Address Registers"
msgstr "Registros de endere�o base"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19252
#, fuzzy
msgid ""
"<primary>PCI bus</primary><secondary>Base Address Registers</secondary>"
msgstr ""
" <primary> Barramento PCI </primary><secondary> Registradores de endere�os "
"base </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:19254
#, fuzzy
msgid ""
"To do anything particularly useful with a PCI device you will need to obtain "
"the <emphasis>Base Address Registers</emphasis> (BARs) from the PCI "
"Configuration space. The PCI-specific details of obtaining the BAR are "
"abstracted in the <function>bus_alloc_resource()</function> function."
msgstr ""
"Para fazer algo particularmente �til com um dispositivo PCI, voc� precisar� "
"obter o <emphasis> Registradores de endere�os base </emphasis> (BARs) do "
"espa�o de configura��o PCI. Os detalhes espec�ficos do PCI para obter a BAR "
"s�o resumidos no <function> bus_alloc_resource () </function> fun��o."

#. (itstool) path: sect2/para
#: book.translate.xml:19260
#, fuzzy
msgid ""
"For example, a typical driver might have something similar to this in the "
"<function>attach()</function> function:"
msgstr ""
"Por exemplo, um driver t�pico pode ter algo semelhante a isso no <function> "
"anexar() </function> fun��o:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19263
#, no-wrap
msgid ""
"    sc-&gt;bar0id = PCIR_BAR(0);\n"
"    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-"
"&gt;bar0id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar0res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 0 failed!\\n\");\n"
"        error = ENXIO;\n"
"        goto fail1;\n"
"    }\n"
"\n"
"    sc-&gt;bar1id = PCIR_BAR(1);\n"
"    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-"
"&gt;bar1id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar1res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 1 failed!\\n\");\n"
"        error =  ENXIO;\n"
"        goto fail2;\n"
"    }\n"
"    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);\n"
"    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);\n"
"    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);\n"
"    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);"
msgstr ""
"    sc-&gt;bar0id = PCIR_BAR(0);\n"
"    sc-&gt;bar0res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-"
"&gt;bar0id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar0res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 0 failed!\\n\");\n"
"        error = ENXIO;\n"
"        goto fail1;\n"
"    }\n"
"\n"
"    sc-&gt;bar1id = PCIR_BAR(1);\n"
"    sc-&gt;bar1res = bus_alloc_resource(dev, SYS_RES_MEMORY, &amp;sc-"
"&gt;bar1id,\n"
"\t\t\t\t  0, ~0, 1, RF_ACTIVE);\n"
"    if (sc-&gt;bar1res == NULL) {\n"
"        printf(\"Memory allocation of PCI base register 1 failed!\\n\");\n"
"        error =  ENXIO;\n"
"        goto fail2;\n"
"    }\n"
"    sc-&gt;bar0_bt = rman_get_bustag(sc-&gt;bar0res);\n"
"    sc-&gt;bar0_bh = rman_get_bushandle(sc-&gt;bar0res);\n"
"    sc-&gt;bar1_bt = rman_get_bustag(sc-&gt;bar1res);\n"
"    sc-&gt;bar1_bh = rman_get_bushandle(sc-&gt;bar1res);"

#. (itstool) path: sect2/para
#: book.translate.xml:19285
#, fuzzy
msgid ""
"Handles for each base address register are kept in the <varname remap="
"\"structname\">softc</varname> structure so that they can be used to write "
"to the device later."
msgstr ""
"As al�as para cada registro de endere�o base s�o mantidas na <varname remap="
"\"structname\"> softc </varname> estrutura para que eles possam ser usados "
"​​para gravar no dispositivo mais tarde \""

#. (itstool) path: sect2/para
#: book.translate.xml:19289
#, fuzzy
msgid ""
"These handles can then be used to read or write from the device registers "
"with the <function>bus_space_*</function> functions. For example, a driver "
"might contain a shorthand function to read from a board specific register "
"like this:"
msgstr ""
"Essas al�as podem ser usadas para ler ou gravar nos registros do dispositivo "
"com o <function> bus_space_ * </function> fun��es. Por exemplo, um driver "
"pode conter uma fun��o abreviada para ler de um registro espec�fico da placa "
"como este: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19294
#, no-wrap
msgid ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
"}\n"
msgstr ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"    return bus_space_read_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address);\n"
"}\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19301
#, fuzzy
msgid "Similarly, one could write to the registers with:"
msgstr "Da mesma forma, pode-se escrever para os registros com:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19303
#, no-wrap
msgid ""
"void\n"
"board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
"{\n"
"    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
"}\n"
msgstr ""
"void\n"
"board_write(struct ni_softc *sc, uint16_t address, uint16_t value)\n"
"{\n"
"    bus_space_write_2(sc-&gt;bar1_bt, sc-&gt;bar1_bh, address, value);\n"
"}\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19310
#, fuzzy
msgid ""
"These functions exist in 8bit, 16bit, and 32bit versions and you should use "
"<function>bus_space_{read|write}_{1|2|4}</function> accordingly."
msgstr ""
"Estas fun��es existem nas vers�es 8bit, 16bit e 32bit e voc� deve usar "
"<function> bus_space_ {leia | escreva} _ {1 | 2 | 4} </function> "
"adequadamente."

#. (itstool) path: note/para
#: book.translate.xml:19316
#, fuzzy
msgid ""
"In FreeBSD 7.0 and later, you can use the <function>bus_*</function> "
"functions instead of <function>bus_space_*</function>. The <function>bus_*</"
"function> functions take a <type>struct resource *</type> pointer instead of "
"a bus tag and handle. Thus, you could drop the bus tag and bus handle "
"members from the <varname remap=\"structname\">softc</varname> and rewrite "
"the <function>board_read()</function> function as:"
msgstr ""
"No FreeBSD 7.0 e posterior, voc� pode usar o <function> �nibus_* </function> "
"fun��es em vez de <function> bus_space_ * </function> . o <function> "
"�nibus_* </function> fun��es tomar um <type> recurso struct </type> ponteiro "
"em vez de uma marca de barramento e identificador. Assim, voc� pode soltar a "
"tag de barramento e os membros da barra de bus do <varname remap="
"\"structname\"> softc </varname> e reescrever o <function> board_read () </"
"function> funciona como:"

#. (itstool) path: note/programlisting
#: book.translate.xml:19325
#, no-wrap
msgid ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"\treturn (bus_read(sc-&gt;bar1res, address));\n"
"}\n"
msgstr ""
"uint16_t\n"
"board_read(struct ni_softc *sc, uint16_t address)\n"
"{\n"
"\treturn (bus_read(sc-&gt;bar1res, address));\n"
"}\n"

#. (itstool) path: sect2/title
#. (itstool) path: sect1/title
#: book.translate.xml:19334 book.translate.xml:21146
#, fuzzy
msgid "Interrupts"
msgstr "Interrompe"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19336
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>interrupts</secondary>"
msgstr ""
" <primary> Barramento PCI </primary><secondary> interrompe </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:19337
#, fuzzy
msgid ""
"Interrupts are allocated from the object-oriented bus code in a way similar "
"to the memory resources. First an IRQ resource must be allocated from the "
"parent bus, and then the interrupt handler must be set up to deal with this "
"IRQ."
msgstr ""
"As interrup��es s�o alocadas a partir do c�digo de barramento orientado a "
"objetos de maneira semelhante aos recursos de mem�ria. Primeiro, um recurso "
"de IRQ deve ser alocado a partir do barramento pai e, em seguida, o "
"manipulador de interrup��o deve ser configurado para lidar com esse IRQ."

#. (itstool) path: sect2/para
#: book.translate.xml:19342
#, fuzzy
msgid ""
"Again, a sample from a device <function>attach()</function> function says "
"more than words."
msgstr ""
"Mais uma vez, uma amostra de um dispositivo <function> anexar() </function> "
"fun��o diz mais que palavras \""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19346
#, no-wrap
msgid ""
"/* Get the IRQ resource */\n"
"\n"
"    sc-&gt;irqid = 0x0;\n"
"    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-"
"&gt;irqid),\n"
"\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
"    if (sc-&gt;irqres == NULL) {\n"
"\tprintf(\"IRQ allocation failed!\\n\");\n"
"\terror = ENXIO;\n"
"\tgoto fail3;\n"
"    }\n"
"\n"
"    /* Now we should set up the interrupt handler */\n"
"\n"
"    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
"\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
"    if (error) {\n"
"\tprintf(\"Couldn't set up irq\\n\");\n"
"\tgoto fail4;\n"
"    }\n"
msgstr ""
"/* Get the IRQ resource */\n"
"\n"
"    sc-&gt;irqid = 0x0;\n"
"    sc-&gt;irqres = bus_alloc_resource(dev, SYS_RES_IRQ, &amp;(sc-"
"&gt;irqid),\n"
"\t\t\t\t  0, ~0, 1, RF_SHAREABLE | RF_ACTIVE);\n"
"    if (sc-&gt;irqres == NULL) {\n"
"\tprintf(\"IRQ allocation failed!\\n\");\n"
"\terror = ENXIO;\n"
"\tgoto fail3;\n"
"    }\n"
"\n"
"    /* Now we should set up the interrupt handler */\n"
"\n"
"    error = bus_setup_intr(dev, sc-&gt;irqres, INTR_TYPE_MISC,\n"
"\t\t\t   my_handler, sc, &amp;(sc-&gt;handler));\n"
"    if (error) {\n"
"\tprintf(\"Couldn't set up irq\\n\");\n"
"\tgoto fail4;\n"
"    }\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19367
#, fuzzy
msgid ""
"Some care must be taken in the detach routine of the driver. You must "
"quiesce the device's interrupt stream, and remove the interrupt handler. "
"Once <function>bus_teardown_intr()</function> has returned, you know that "
"your interrupt handler will no longer be called and that all threads that "
"might have been executing this interrupt handler have returned. Since this "
"function can sleep, you must not hold any mutexes when calling this function."
""
msgstr ""
"Alguns cuidados devem ser tomados na rotina de desconex�o do driver. Voc� "
"deve desativar o fluxo de interrup��o do dispositivo e remover o manipulador "
"de interrup��o. <function> bus_teardown_intr () </function> retornou, voc� "
"sabe que seu manipulador de interrup��es n�o ser� mais chamado e que todos "
"os encadeamentos que podem estar executando este manipulador de interrup��es "
"retornaram. Como esta fun��o pode dormir, voc� n�o deve manter nenhum mutex "
"ao chamar esta fun��o. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:19381
#, fuzzy
msgid "<primary>PCI bus</primary><secondary>DMA</secondary>"
msgstr " <primary> Barramento PCI </primary><secondary> DMA </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:19382
#, fuzzy
msgid ""
"This section is obsolete, and present only for historical reasons. The "
"proper methods for dealing with these issues is to use the "
"<function>bus_space_dma*()</function> functions instead. This paragraph can "
"be removed when this section is updated to reflect that usage. However, at "
"the moment, the API is in a bit of flux, so once that settles down, it would "
"be good to update this section to reflect that."
msgstr ""
"Esta se��o � obsoleta e est� presente apenas por raz�es hist�ricas. Os "
"m�todos apropriados para lidar com essas quest�es � usar <function> "
"bus_space_dma * () </function> funciona em vez disso. Este par�grafo pode "
"ser removido quando esta se��o for atualizada para refletir esse uso. No "
"entanto, no momento, a API est� em um pouco de fluxo, portanto, uma vez que "
"isso se resolva, seria bom atualizar esta se��o para refletir isso. "

#. (itstool) path: sect2/para
#: book.translate.xml:19390
#, fuzzy
msgid ""
"On the PC, peripherals that want to do bus-mastering DMA must deal with "
"physical addresses. This is a problem since FreeBSD uses virtual memory and "
"deals almost exclusively with virtual addresses. Fortunately, there is a "
"function, <function>vtophys()</function> to help."
msgstr ""
"No PC, perif�ricos que querem fazer bus masteriza��o devem lidar com "
"endere�os f�sicos. Isso � um problema j� que o FreeBSD usa mem�ria virtual e "
"lida quase exclusivamente com endere�os virtuais. Felizmente, existe uma "
"fun��o, <function> vtophys () </function> ajudar."

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19396
#, no-wrap
msgid ""
"#include &lt;vm/vm.h&gt;\n"
"#include &lt;vm/pmap.h&gt;\n"
"\n"
"#define vtophys(virtual_address) (...)\n"
msgstr ""
"#include &lt;vm/vm.h&gt;\n"
"#include &lt;vm/pmap.h&gt;\n"
"\n"
"#define vtophys(virtual_address) (...)\n"

#. (itstool) path: sect2/para
#: book.translate.xml:19402
#, fuzzy
msgid ""
"The solution is a bit different on the alpha however, and what we really "
"want is a function called <function>vtobus()</function>."
msgstr ""
"A solu��o � um pouco diferente no alfa, e o que realmente queremos � uma "
"fun��o chamada <function> vtobus () </function> "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:19406
#, no-wrap
msgid ""
"#if defined(__alpha__)\n"
"#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
"#else\n"
"#define vtobus(va)      vtophys(va)\n"
"#endif\n"
msgstr ""
"#if defined(__alpha__)\n"
"#define vtobus(va)      alpha_XXX_dmamap((vm_offset_t)va)\n"
"#else\n"
"#define vtobus(va)      vtophys(va)\n"
"#endif\n"

#. (itstool) path: sect2/title
#: book.translate.xml:19416
#, fuzzy
msgid "Deallocating Resources"
msgstr "Recursos de desaloca��o"

#. (itstool) path: sect2/para
#: book.translate.xml:19418
#, fuzzy
msgid ""
"It is very important to deallocate all of the resources that were allocated "
"during <function>attach()</function>. Care must be taken to deallocate the "
"correct stuff even on a failure condition so that the system will remain "
"usable while your driver dies."
msgstr ""
"� muito importante desalocar todos os recursos que foram alocados durante a "
"<function> anexar() </function> . � preciso tomar cuidado para desalocar o "
"material correto, mesmo em uma condi��o de falha, para que o sistema "
"permane�a utiliz�vel enquanto o driver morre. "

#. (itstool) path: info/title
#: book.translate.xml:19436
#, fuzzy
msgid "Common Access Method SCSI Controllers"
msgstr "Controladores SCSI do M�todo de Acesso Comum"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19450
#, fuzzy
msgid "<primary>SCSI</primary>"
msgstr " <primary> SCSI </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19451
#, fuzzy
msgid ""
"This document assumes that the reader has a general understanding of device "
"drivers in FreeBSD and of the SCSI protocol. Much of the information in this "
"document was extracted from the drivers:"
msgstr ""
"Este documento pressup�e que o leitor tenha uma compreens�o geral dos "
"drivers de dispositivos no FreeBSD e no protocolo SCSI. Muitas das "
"informa��es contidas neste documento foram extra�das dos drivers:"

#. (itstool) path: listitem/para
#: book.translate.xml:19458
#, fuzzy
msgid ""
"ncr (<filename>/sys/pci/ncr.c</filename>) by Wolfgang Stanglmeier and Stefan "
"Esser"
msgstr ""
"ncr ( <filename> /sys/pci/ncr.c </filename> ) de Wolfgang Stanglmeier e "
"Stefan Esser "

#. (itstool) path: listitem/para
#: book.translate.xml:19462
#, fuzzy
msgid "sym (<filename>/sys/dev/sym/sym_hipd.c</filename>) by Gerard Roudier"
msgstr ""
"sym ( <filename> /sys/dev/sym/sym_hipd.c </filename> ) de Gerard Roudier "

#. (itstool) path: listitem/para
#: book.translate.xml:19467
#, fuzzy
msgid ""
"aic7xxx (<filename>/sys/dev/aic7xxx/aic7xxx.c</filename>) by Justin T. Gibbs"
msgstr ""
"aic7xxx ( <filename> /sys/dev/aic7xxx/aic7xxx.c </filename> ) por Justin T. "
"Gibbs "

#. (itstool) path: sect1/para
#: book.translate.xml:19473
#, fuzzy
msgid ""
"and from the CAM code itself (by Justin T. Gibbs, see <filename>/sys/cam/*</"
"filename>). When some solution looked the most logical and was essentially "
"verbatim extracted from the code by Justin T. Gibbs, I marked it as "
"<quote>recommended</quote>."
msgstr ""
"e do pr�prio c�digo CAM (por Justin T. Gibbs, veja <filename> / sys / cam / "
"* </filename> ). Quando alguma solu��o parecia a mais l�gica e "
"essencialmente extra�da do c�digo por Justin T. Gibbs, eu a marquei como "
"<quote> recomendado </quote> "

#. (itstool) path: sect1/para
#: book.translate.xml:19479
#, fuzzy
msgid ""
"The document is illustrated with examples in pseudo-code. Although sometimes "
"the examples have many details and look like real code, it is still pseudo-"
"code. It was written to demonstrate the concepts in an understandable way. "
"For a real driver other approaches may be more modular and efficient. It "
"also abstracts from the hardware details, as well as issues that would cloud "
"the demonstrated concepts or that are supposed to be described in the other "
"chapters of the developers handbook. Such details are commonly shown as "
"calls to functions with descriptive names, comments or pseudo-statements. "
"Fortunately real life full-size examples with all the details can be found "
"in the real drivers."
msgstr ""
"O documento � ilustrado com exemplos em pseudo-c�digo. Embora algumas vezes "
"os exemplos tenham muitos detalhes e pare�am com c�digo real, ainda � pseudo-"
"c�digo. Foi escrito para demonstrar os conceitos de uma maneira "
"compreens�vel. Para um driver real outras abordagens pode ser mais modular e "
"eficiente, al�m de abstrair os detalhes do hardware, bem como problemas que "
"poderiam ofuscar os conceitos demonstrados ou que deveriam ser descritos nos "
"outros cap�tulos do manual do desenvolvedor.Tais detalhes s�o comumente "
"mostrados como chamadas para fun��es com nomes descritivos, coment�rios ou "
"pseudo-declara��es. Felizmente exemplos em tamanho real com todos os "
"detalhes podem ser encontrados nos drivers reais. "

#. (itstool) path: sect1/title
#: book.translate.xml:19494
#, fuzzy
msgid "General Architecture"
msgstr "Arquitetura Geral"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19496
#, fuzzy
msgid "<primary>Common Access Method (CAM)</primary>"
msgstr " <primary> M�todo de acesso comum (CAM) </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19500
#, fuzzy
msgid ""
"CAM stands for Common Access Method. It is a generic way to address the I/O "
"buses in a SCSI-like way. This allows a separation of the generic device "
"drivers from the drivers controlling the I/O bus: for example the disk "
"driver becomes able to control disks on both SCSI, IDE, and/or any other bus "
"so the disk driver portion does not have to be rewritten (or copied and "
"modified) for every new I/O bus. Thus the two most important active entities "
"are:"
msgstr ""
"CAM significa Common Access Method. � uma maneira gen�rica de endere�ar os "
"barramentos de E / S de maneira SCSI. Isso permite uma separa��o dos drivers "
"de dispositivos gen�ricos dos drivers que controlam o barramento de E / S: "
"por exemplo, o disco O driver torna-se capaz de controlar discos em SCSI, "
"IDE e / ou qualquer outro barramento, portanto a parte do driver de disco "
"n�o precisa ser reescrita (ou copiada e modificada) para cada novo "
"barramento de E / S. estamos:"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19509
#, fuzzy
msgid "<primary>CD-ROM</primary>"
msgstr " <primary> CD-ROM </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19510
#, fuzzy
msgid "<primary>tape</primary>"
msgstr " <primary> fita </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:19511
#, fuzzy
msgid "<primary>IDE</primary>"
msgstr " <primary> AQUI </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:19514
#, fuzzy
msgid ""
"<emphasis>Peripheral Modules</emphasis> - a driver for peripheral devices "
"(disk, tape, CD-ROM, etc.)"
msgstr ""
" <emphasis> M�dulos Perif�ricos </emphasis> - um driver para dispositivos "
"perif�ricos (disco, fita, CD-ROM, etc.) "

#. (itstool) path: listitem/para
#: book.translate.xml:19520
#, fuzzy
msgid ""
"<emphasis>SCSI Interface Modules </emphasis>(SIM) - a Host Bus Adapter "
"drivers for connecting to an I/O bus such as SCSI or IDE."
msgstr ""
" <emphasis> M�dulos de Interface SCSI </emphasis> (SIM) - drivers do Host "
"Bus Adapter para conex�o com um barramento de E / S, como SCSI ou IDE. "

#. (itstool) path: sect1/para
#: book.translate.xml:19526
#, fuzzy
msgid ""
"A peripheral driver receives requests from the OS, converts them to a "
"sequence of SCSI commands and passes these SCSI commands to a SCSI Interface "
"Module. The SCSI Interface Module is responsible for passing these commands "
"to the actual hardware (or if the actual hardware is not SCSI but, for "
"example, IDE then also converting the SCSI commands to the native commands "
"of the hardware)."
msgstr ""
"Um driver perif�rico recebe solicita��es do SO, converte-as em uma sequ�ncia "
"de comandos SCSI e passa esses comandos SCSI para um M�dulo de Interface "
"SCSI. O M�dulo de Interface SCSI � respons�vel por passar esses comandos ao "
"hardware real (ou se o hardware real for n�o SCSI mas, por exemplo, IDE, em "
"seguida, tamb�m convertendo os comandos SCSI para os comandos nativos do "
"hardware). "

#. (itstool) path: sect1/para
#: book.translate.xml:19534
#, fuzzy
msgid ""
"Because we are interested in writing a SCSI adapter driver here, from this "
"point on we will consider everything from the SIM standpoint."
msgstr ""
"Porque estamos interessados ​​em escrever um driver de adaptador SCSI aqui, "
"a partir deste ponto consideraremos tudo do ponto de vista do SIM."

#. (itstool) path: sect1/para
#: book.translate.xml:19538
#, fuzzy
msgid ""
"A typical SIM driver needs to include the following CAM-related header files:"
""
msgstr ""
"Um driver SIM t�pico precisa incluir os seguintes arquivos de cabe�alho "
"relacionados ao CAM:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19541
#, no-wrap
msgid ""
"#include &lt;cam/cam.h&gt;\n"
"#include &lt;cam/cam_ccb.h&gt;\n"
"#include &lt;cam/cam_sim.h&gt;\n"
"#include &lt;cam/cam_xpt_sim.h&gt;\n"
"#include &lt;cam/cam_debug.h&gt;\n"
"#include &lt;cam/scsi/scsi_all.h&gt;"
msgstr ""
"#include &lt;cam/cam.h&gt;\n"
"#include &lt;cam/cam_ccb.h&gt;\n"
"#include &lt;cam/cam_sim.h&gt;\n"
"#include &lt;cam/cam_xpt_sim.h&gt;\n"
"#include &lt;cam/cam_debug.h&gt;\n"
"#include &lt;cam/scsi/scsi_all.h&gt;"

#. (itstool) path: sect1/para
#: book.translate.xml:19548
#, fuzzy
msgid ""
"The first thing each SIM driver must do is register itself with the CAM "
"subsystem. This is done during the driver's <function>xxx_attach()</"
"function> function (here and further xxx_ is used to denote the unique "
"driver name prefix). The <function>xxx_attach()</function> function itself "
"is called by the system bus auto-configuration code which we do not describe "
"here."
msgstr ""
"A primeira coisa que cada driver SIM deve fazer � registrar-se no subsistema "
"CAM. Isso � feito durante o <function> xxx_attach () </function> function "
"(aqui e mais xxx_ � usado para denotar o prefixo do nome do driver "
"exclusivo). o <function> xxx_attach () </function> A pr�pria fun��o � "
"chamada pelo c�digo de configura��o autom�tica do barramento do sistema, que "
"n�o descrevemos aqui. "

#. (itstool) path: sect1/para
#: book.translate.xml:19556
#, fuzzy
msgid ""
"This is achieved in multiple steps: first it is necessary to allocate the "
"queue of requests associated with this SIM:"
msgstr ""
"Isso � conseguido em v�rias etapas: primeiro � necess�rio alocar a fila de "
"solicita��es associadas a este SIM:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19559
#, no-wrap
msgid ""
"    struct cam_devq *devq;\n"
"\n"
"    if(( devq = cam_simq_alloc(SIZE) )==NULL) {\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    struct cam_devq *devq;\n"
"\n"
"    if(( devq = cam_simq_alloc(SIZE) )==NULL) {\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19565
#, fuzzy
msgid ""
"Here <literal>SIZE</literal> is the size of the queue to be allocated, "
"maximal number of requests it could contain. It is the number of requests "
"that the SIM driver can handle in parallel on one SCSI card. Commonly it can "
"be calculated as:"
msgstr ""
"Aqui <literal> TAMANHO </literal> � o tamanho da fila a ser alocada, o "
"n�mero m�ximo de solicita��es que ela pode conter. � o n�mero de "
"solicita��es que o driver do SIM pode manipular em paralelo em uma placa "
"SCSI. Comumente, pode ser calculado como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19571
#, no-wrap
msgid ""
"SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET"
msgstr ""
"SIZE = NUMBER_OF_SUPPORTED_TARGETS * MAX_SIMULTANEOUS_COMMANDS_PER_TARGET"

#. (itstool) path: sect1/para
#: book.translate.xml:19573
#, fuzzy
msgid "Next we create a descriptor of our SIM:"
msgstr "Em seguida, criamos um descritor do nosso SIM:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19575
#, no-wrap
msgid ""
"    struct cam_sim *sim;\n"
"\n"
"    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,\n"
"            softc, unit, mtx, max_dev_transactions,\n"
"            max_tagged_dev_transactions, devq) )==NULL) {\n"
"        cam_simq_free(devq);\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    struct cam_sim *sim;\n"
"\n"
"    if(( sim = cam_sim_alloc(action_func, poll_func, driver_name,\n"
"            softc, unit, mtx, max_dev_transactions,\n"
"            max_tagged_dev_transactions, devq) )==NULL) {\n"
"        cam_simq_free(devq);\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19584
#, fuzzy
msgid ""
"Note that if we are not able to create a SIM descriptor we free the <varname "
"remap=\"structname\">devq</varname> also because we can do nothing else with "
"it and we want to conserve memory."
msgstr ""
"Note que se n�o formos capazes de criar um descritor SIM, n�s liberaremos o "
"<varname remap=\"structname\"> devq </varname> tamb�m porque n�o podemos "
"fazer mais nada e queremos conservar a mem�ria. "

#. (itstool) path: para/indexterm
#: book.translate.xml:19589
#, fuzzy
msgid "<primary>SCSI</primary><secondary>bus</secondary>"
msgstr " <primary> SCSI </primary><secondary> �nibus </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19588
#, fuzzy
msgid ""
"If a SCSI card has multiple SCSI buses<_:indexterm-1/> on it then each bus "
"requires its own <varname remap=\"structname\">cam_sim</varname> structure."
msgstr ""
"Se uma placa SCSI tem v�rios barramentos SCSI <_: indexterm-1 />, cada "
"barramento requer o seu pr�prio <varname remap=\"structname\"> cam_sim </"
"varname> estrutura."

#. (itstool) path: sect1/para
#: book.translate.xml:19593
#, fuzzy
msgid ""
"An interesting question is what to do if a SCSI card has more than one SCSI "
"bus, do we need one <varname remap=\"structname\">devq</varname> structure "
"per card or per SCSI bus? The answer given in the comments to the CAM code "
"is: either way, as the driver's author prefers."
msgstr ""
"Uma quest�o interessante � o que fazer se uma placa SCSI tem mais de um "
"barramento SCSI, precisamos de um <varname remap=\"structname\"> devq </"
"varname> estrutura por cart�o ou por barramento SCSI? A resposta dada nos "
"coment�rios ao c�digo do CAM �: de qualquer forma, como o autor do motorista "
"prefere. "

#. (itstool) path: sect1/para
#: book.translate.xml:19599
#, fuzzy
msgid "The arguments are:"
msgstr "Os argumentos s�o:"

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:19606 book.translate.xml:19796
#, fuzzy
msgid ""
"<funcdef>static void <function>xxx_action</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter>, <parameter>union ccb *ccb</"
"parameter> </paramdef>"
msgstr ""
" <funcdef> vazio est�tico <function> xxx_action </function></"
"funcdef><paramdef><parameter> struct cam_sim * sim </parameter> , "
"<parameter> uni�o ccb * ccb </parameter></paramdef> "

#. (itstool) path: listitem/para
#: book.translate.xml:19603
#, fuzzy
msgid ""
"<function>action_func</function> - pointer to the driver's "
"<function>xxx_action</function> function. <_:funcsynopsis-1/>"
msgstr ""
" <function> action_func </function> - ponteiro para o motorista <function> "
"xxx_action </function> fun��o. <_: funcsynopsis-1 /> "

#. (itstool) path: funcsynopsis/funcprototype
#: book.translate.xml:19622 book.translate.xml:21047
#, fuzzy
msgid ""
"<funcdef>static void <function>xxx_poll</function> </funcdef> <paramdef> "
"<parameter>struct cam_sim *sim</parameter> </paramdef>"
msgstr ""
" <funcdef> vazio est�tico <function> xxx_poll </function></"
"funcdef><paramdef><parameter> struct cam_sim * sim </parameter></paramdef> "

#. (itstool) path: listitem/para
#: book.translate.xml:19619
#, fuzzy
msgid ""
"<function>poll_func</function> - pointer to the driver's "
"<function>xxx_poll()</function> <_:funcsynopsis-1/>"
msgstr ""
" <function> poll_func </function> - ponteiro para o motorista <function> "
"xxx_poll () </function> <_: funcsynopsis-1 /> "

#. (itstool) path: listitem/para
#: book.translate.xml:19634
#, fuzzy
msgid ""
"driver_name - the name of the actual driver, such as <quote>ncr</quote> or "
"<quote>wds</quote>."
msgstr ""
"driver_name - o nome do driver real, como <quote> ncr </quote> ou <quote> "
"wds </quote> "

#. (itstool) path: listitem/para
#: book.translate.xml:19640
#, fuzzy
msgid ""
"<varname remap=\"structname\">softc</varname> - pointer to the driver's "
"internal descriptor for this SCSI card. This pointer will be used by the "
"driver in future to get private data."
msgstr ""
" <varname remap=\"structname\"> softc </varname> - ponteiro para o descritor "
"interno do driver para esta placa SCSI. Esse ponteiro ser� usado pelo driver "
"no futuro para obter dados privados. "

#. (itstool) path: listitem/para
#: book.translate.xml:19647
#, fuzzy
msgid ""
"unit - the controller unit number, for example for controller <quote>mps0</"
"quote> this number will be 0"
msgstr ""
"unidade - o n�mero da unidade do controlador, por exemplo, para o "
"controlador <quote> mps0 </quote> esse n�mero ser� 0 "

#. (itstool) path: listitem/para
#: book.translate.xml:19653
#, fuzzy
msgid ""
"mtx - Lock associated with this SIM. For SIMs that don't know about locking, "
"pass in Giant. For SIMs that do, pass in the lock used to guard this SIM's "
"data structures. This lock will be held when xxx_action and xxx_poll are "
"called."
msgstr ""
"mtx - Bloqueio associado a este SIM. Para SIMs que n�o sabem sobre bloqueio, "
"passe para Gigante. Para os SIMs, passe o bloqueio usado para proteger as "
"estruturas de dados deste SIM. Este bloqueio ser� mantido quando xxx_action "
"e xxx_poll estiverem chamado."

#. (itstool) path: listitem/para
#: book.translate.xml:19660
#, fuzzy
msgid ""
"max_dev_transactions - maximal number of simultaneous transactions per SCSI "
"target in the non-tagged mode. This value will be almost universally equal "
"to 1, with possible exceptions only for the non-SCSI cards. Also the drivers "
"that hope to take advantage by preparing one transaction while another one "
"is executed may set it to 2 but this does not seem to be worth the "
"complexity."
msgstr ""
"max_dev_transactions - n�mero m�ximo de transa��es simult�neas por destino "
"SCSI no modo n�o marcado. Esse valor ser� quase universalmente igual a 1, "
"com poss�veis exce��es apenas para as placas n�o-SCSI. Al�m disso, os "
"drivers que esperam tirar proveito preparando um transa��o enquanto outro � "
"executado pode configur�-lo para 2, mas isso n�o parece valer a complexidade "
"\""

#. (itstool) path: listitem/para
#: book.translate.xml:19670
#, fuzzy
msgid ""
"max_tagged_dev_transactions - the same thing, but in the tagged mode. Tags "
"are the SCSI way to initiate multiple transactions on a device: each "
"transaction is assigned a unique tag and the transaction is sent to the "
"device. When the device completes some transaction it sends back the result "
"together with the tag so that the SCSI adapter (and the driver) can tell "
"which transaction was completed. This argument is also known as the maximal "
"tag depth. It depends on the abilities of the SCSI adapter."
msgstr ""
"max_tagged_dev_transactions - a mesma coisa, mas no modo marcado. Tags s�o a "
"maneira SCSI de iniciar v�rias transa��es em um dispositivo: a cada "
"transa��o � atribu�da uma tag �nica e a transa��o � enviada para o "
"dispositivo. Quando o dispositivo conclui alguma transa��o, ele envia "
"retorne o resultado junto com a tag para que o adaptador SCSI (e o driver) "
"possa dizer qual transa��o foi conclu�da. Esse argumento tamb�m � conhecido "
"como a profundidade m�xima da marca��o. Depende das capacidades do adaptador "
"SCSI. "

#. (itstool) path: para/indexterm
#: book.translate.xml:19684
#, fuzzy
msgid "<primary>SCSI</primary><secondary>adapter</secondary>"
msgstr " <primary> SCSI </primary><secondary> adaptador </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:19683
#, fuzzy
msgid ""
"Finally we register the SCSI buses associated with our SCSI adapter<_:"
"indexterm-1/>:"
msgstr ""
"Finalmente, registramos os barramentos SCSI associados ao nosso adaptador "
"SCSI <_: indexterm-1 />:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19686
#, no-wrap
msgid ""
"    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {\n"
"        cam_sim_free(sim, /*free_devq*/ TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }"
msgstr ""
"    if(xpt_bus_register(sim, softc, bus_number) != CAM_SUCCESS) {\n"
"        cam_sim_free(sim, /*free_devq*/ TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19691
#, fuzzy
msgid ""
"If there is one <varname remap=\"structname\">devq</varname> structure per "
"SCSI bus (i.e., we consider a card with multiple buses as multiple cards "
"with one bus each) then the bus number will always be 0, otherwise each bus "
"on the SCSI card should be get a distinct number. Each bus needs its own "
"separate structure cam_sim."
msgstr ""
"Se houver um <varname remap=\"structname\"> devq </varname> estrutura por "
"barramento SCSI (isto �, consideramos uma placa com m�ltiplos barramentos "
"como m�ltiplas placas com um barramento cada), ent�o o n�mero do barramento "
"ser� sempre 0, caso contr�rio, cada barramento na placa SCSI deve receber um "
"n�mero distinto. Cada �nibus precisa de sua pr�pria estrutura separada, "
"cam_sim. "

#. (itstool) path: sect1/para
#: book.translate.xml:19698
#, fuzzy
msgid ""
"After that our controller is completely hooked to the CAM system. The value "
"of <varname remap=\"structname\">devq</varname> can be discarded now: sim "
"will be passed as an argument in all further calls from CAM and devq can be "
"derived from it."
msgstr ""
"Depois disso, nosso controlador � completamente conectado ao sistema CAM. O "
"valor de <varname remap=\"structname\"> devq </varname> pode ser descartado "
"agora: o sim ser� passado como um argumento em todas as outras chamadas do "
"CAM e o devq pode ser derivado dele. "

#. (itstool) path: sect1/para
#: book.translate.xml:19703
#, fuzzy
msgid ""
"CAM provides the framework for such asynchronous events. Some events "
"originate from the lower levels (the SIM drivers), some events originate "
"from the peripheral drivers, some events originate from the CAM subsystem "
"itself. Any driver can register callbacks for some types of the asynchronous "
"events, so that it would be notified if these events occur."
msgstr ""
"O CAM fornece a estrutura para tais eventos ass�ncronos. Alguns eventos se "
"originam dos n�veis mais baixos (os drivers SIM), alguns eventos s�o "
"originados dos drivers perif�ricos, alguns eventos s�o originados do pr�prio "
"subsistema CAM. Qualquer driver pode registrar retornos de chamada para "
"alguns tipos de eventos. eventos ass�ncronos, para que seja notificado se "
"esses eventos ocorrerem. "

#. (itstool) path: sect1/para
#: book.translate.xml:19710
#, fuzzy
msgid ""
"A typical example of such an event is a device reset. Each transaction and "
"event identifies the devices to which it applies by the means of "
"<quote>path</quote>. The target-specific events normally occur during a "
"transaction with this device. So the path from that transaction may be re-"
"used to report this event (this is safe because the event path is copied in "
"the event reporting routine but not deallocated nor passed anywhere further)."
" Also it is safe to allocate paths dynamically at any time including the "
"interrupt routines, although that incurs certain overhead, and a possible "
"problem with this approach is that there may be no free memory at that time. "
"For a bus reset event we need to define a wildcard path including all "
"devices on the bus. So we can create the path for the future bus reset "
"events in advance and avoid problems with the future memory shortage:"
msgstr ""
"Um exemplo t�pico de tal evento � uma reinicializa��o do dispositivo. Cada "
"transa��o e evento identifica os dispositivos aos quais ele se aplica por "
"meio de <quote> caminho </quote> . Os eventos espec�ficos de destino "
"normalmente ocorrem durante uma transa��o com este dispositivo. Portanto, o "
"caminho dessa transa��o pode ser reutilizado para relatar esse evento (isso "
"� seguro porque o caminho do evento � copiado na rotina de relat�rio de "
"evento, mas n�o desalocado nem transmitido em nenhum outro lugar). Tamb�m � "
"seguro alocar caminhos dinamicamente a qualquer momento, incluindo as "
"rotinas de interrup��o, embora isso incorra em certa sobrecarga, e um "
"poss�vel problema com essa abordagem � que pode n�o haver mem�ria livre "
"naquele momento. Para um evento de redefini��o de barramento, precisamos "
"definir um caminho curinga incluindo todos os dispositivos no barramento. "
"Assim, podemos criar o caminho para os futuros eventos de redefini��o de "
"barramento com anteced�ncia e evitar problemas com a falta de mem�ria futura:"
" "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19726
#, no-wrap
msgid ""
"    struct cam_path *path;\n"
"\n"
"    if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), CAM_TARGET_WILDCARD,\n"
"                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\n"
"        xpt_bus_deregister(cam_sim_path(sim));\n"
"        cam_sim_free(sim, /*free_devq*/TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }\n"
"\n"
"    softc-&gt;wpath = path;\n"
"    softc-&gt;sim = sim;"
msgstr ""
"    struct cam_path *path;\n"
"\n"
"    if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), CAM_TARGET_WILDCARD,\n"
"                CAM_LUN_WILDCARD) != CAM_REQ_CMP) {\n"
"        xpt_bus_deregister(cam_sim_path(sim));\n"
"        cam_sim_free(sim, /*free_devq*/TRUE);\n"
"        error; /* some code to handle the error */\n"
"    }\n"
"\n"
"    softc-&gt;wpath = path;\n"
"    softc-&gt;sim = sim;"

#. (itstool) path: sect1/para
#: book.translate.xml:19739
#, fuzzy
msgid "As you can see the path includes:"
msgstr "Como voc� pode ver o caminho inclui:"

#. (itstool) path: listitem/para
#: book.translate.xml:19743
#, fuzzy
msgid "ID of the peripheral driver (NULL here because we have none)"
msgstr "ID do driver perif�rico (NULL aqui porque n�o temos nenhum)"

#. (itstool) path: listitem/para
#: book.translate.xml:19748
#, fuzzy
msgid "ID of the SIM driver (<function>cam_sim_path(sim)</function>)"
msgstr "ID do driver do SIM ( <function> cam_sim_path (sim) </function> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:19753
#, fuzzy
msgid ""
"SCSI target number of the device (CAM_TARGET_WILDCARD means <quote>all "
"devices</quote>)"
msgstr ""
"N�mero alvo SCSI do dispositivo (CAM_TARGET_WILDCARD significa <quote> todos "
"os dispositivos </quote> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:19758
#, fuzzy
msgid ""
"SCSI LUN number of the subdevice (CAM_LUN_WILDCARD means <quote>all LUNs</"
"quote>)"
msgstr ""
"N�mero SCSI LUN do subdivice (CAM_LUN_WILDCARD significa <quote> todas as "
"LUNs </quote> ) "

#. (itstool) path: sect1/para
#: book.translate.xml:19763
#, fuzzy
msgid ""
"If the driver can not allocate this path it will not be able to work "
"normally, so in that case we dismantle that SCSI bus."
msgstr ""
"Se o driver n�o puder alocar este caminho, ele n�o poder� funcionar "
"normalmente, ent�o, nesse caso, desmontaremos esse barramento SCSI."

#. (itstool) path: sect1/para
#: book.translate.xml:19767
#, fuzzy
msgid ""
"And we save the path pointer in the <varname remap=\"structname\">softc</"
"varname> structure for future use. After that we save the value of sim (or "
"we can also discard it on the exit from <function>xxx_probe()</function> if "
"we wish)."
msgstr ""
"E n�s salvamos o ponteiro do caminho no <varname remap=\"structname\"> softc "
"</varname> estrutura para uso futuro. Depois disso, salvamos o valor de sim "
"(ou tamb�m podemos descart�-lo na sa�da de <function> xxx_probe () </"
"function> se quisermos. "

#. (itstool) path: sect1/para
#: book.translate.xml:19772
#, fuzzy
msgid ""
"That is all for a minimalistic initialization. To do things right there is "
"one more issue left."
msgstr ""
"Isso � tudo para uma inicializa��o minimalista. Para fazer as coisas certas, "
"resta mais uma quest�o."

#. (itstool) path: sect1/para
#: book.translate.xml:19775
#, fuzzy
msgid ""
"For a SIM driver there is one particularly interesting event: when a target "
"device is considered lost. In this case resetting the SCSI negotiations with "
"this device may be a good idea. So we register a callback for this event "
"with CAM. The request is passed to CAM by requesting CAM action on a CAM "
"control block for this type of request:"
msgstr ""
"Para um driver SIM h� um evento particularmente interessante: quando um "
"dispositivo de destino � considerado perdido. Neste caso, a reinicializa��o "
"das negocia��es SCSI com este dispositivo pode ser uma boa id�ia. Portanto, "
"registramos um retorno de chamada para este evento com o CAM. passou para "
"CAM solicitando a��o CAM em um bloco de controle CAM para este tipo de "
"solicita��o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19782
#, no-wrap
msgid ""
"    struct ccb_setasync csa;\n"
"\n"
"    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);\n"
"    csa.ccb_h.func_code = XPT_SASYNC_CB;\n"
"    csa.event_enable = AC_LOST_DEVICE;\n"
"    csa.callback = xxx_async;\n"
"    csa.callback_arg = sim;\n"
"    xpt_action((union ccb *)&amp;csa);"
msgstr ""
"    struct ccb_setasync csa;\n"
"\n"
"    xpt_setup_ccb(&amp;csa.ccb_h, path, /*priority*/5);\n"
"    csa.ccb_h.func_code = XPT_SASYNC_CB;\n"
"    csa.event_enable = AC_LOST_DEVICE;\n"
"    csa.callback = xxx_async;\n"
"    csa.callback_arg = sim;\n"
"    xpt_action((union ccb *)&amp;csa);"

#. (itstool) path: sect1/para
#: book.translate.xml:19791
#, fuzzy
msgid ""
"Now we take a look at the <function>xxx_action()</function> and "
"<function>xxx_poll()</function> driver entry points."
msgstr ""
"Agora vamos dar uma olhada no <function> xxx_action () </function> e "
"<function> xxx_poll () </function> pontos de entrada do motorista. "

#. (itstool) path: sect1/para
#: book.translate.xml:19807
#, fuzzy
msgid ""
"Do some action on request of the CAM subsystem. Sim describes the SIM for "
"the request, CCB is the request itself. CCB stands for <quote>CAM Control "
"Block</quote>. It is a union of many specific instances, each describing "
"arguments for some type of transactions. All of these instances share the "
"CCB header where the common part of arguments is stored."
msgstr ""
"Fa�a alguma a��o a pedido do subsistema CAM. Sim descreve o SIM para o "
"pedido, CCB � o pr�prio pedido. CCB significa <quote> Bloco de Controle CAM "
"</quote> . � uma uni�o de v�rias inst�ncias espec�ficas, cada uma "
"descrevendo argumentos para algum tipo de transa��o. Todas essas inst�ncias "
"compartilham o cabe�alho do CCB onde a parte comum dos argumentos � "
"armazenada. "

#. (itstool) path: sect1/para
#: book.translate.xml:19814
#, fuzzy
msgid ""
"CAM supports the SCSI controllers working in both initiator (<quote>normal</"
"quote>) mode and target (simulating a SCSI device) mode. Here we only "
"consider the part relevant to the initiator mode."
msgstr ""
"O CAM suporta os controladores SCSI que funcionam no iniciador ( <quote> "
"normal </quote> ) Modo e modo de destino (simulando um dispositivo SCSI). "
"Aqui n�s consideramos apenas a parte relevante para o modo iniciador \""

#. (itstool) path: sect1/para
#: book.translate.xml:19819
#, fuzzy
msgid ""
"There are a few function and macros (in other words, methods) defined to "
"access the public data in the struct sim:"
msgstr ""
"Existem algumas fun��es e macros (em outras palavras, m�todos) definidas "
"para acessar os dados p�blicos no struct sim:"

#. (itstool) path: listitem/para
#: book.translate.xml:19825
#, fuzzy
msgid "<function>cam_sim_path(sim)</function> - the path ID (see above)"
msgstr ""
" <function> cam_sim_path (sim) </function> - o ID do caminho (veja acima) "

#. (itstool) path: listitem/para
#: book.translate.xml:19830
#, fuzzy
msgid "<function>cam_sim_name(sim)</function> - the name of the sim"
msgstr " <function> cam_sim_name (sim) </function> - o nome do sim "

#. (itstool) path: listitem/para
#: book.translate.xml:19835
#, fuzzy
msgid ""
"<function>cam_sim_softc(sim)</function> - the pointer to the softc (driver "
"private data) structure"
msgstr ""
" <function> cam_sim_softc (sim) </function> - o ponteiro para a estrutura do "
"softc (driver private data) "

#. (itstool) path: listitem/para
#: book.translate.xml:19840
#, fuzzy
msgid "<function> cam_sim_unit(sim)</function> - the unit number"
msgstr " <function> cam_sim_unit (sim) </function> - o n�mero da unidade "

#. (itstool) path: listitem/para
#: book.translate.xml:19845
#, fuzzy
msgid "<function> cam_sim_bus(sim)</function> - the bus ID"
msgstr " <function> cam_sim_bus (sim) </function> - o ID do �nibus "

#. (itstool) path: sect1/para
#: book.translate.xml:19850
#, fuzzy
msgid ""
"To identify the device, <function>xxx_action()</function> can get the unit "
"number and pointer to its structure softc using these functions."
msgstr ""
"Para identificar o dispositivo, <function> xxx_action () </function> pode "
"obter o n�mero da unidade e o ponteiro para sua estrutura usando essas "
"fun��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:19854
#, fuzzy
msgid ""
"The type of request is stored in <varname remap=\"structfield\">ccb-"
"&gt;ccb_h.func_code</varname>. So generally <function>xxx_action()</"
"function> consists of a big switch:"
msgstr ""
"O tipo de solicita��o � armazenado em <varname remap=\"structfield\"> ccb-"
"&gt; ccb_h.func_code </varname> . Ent�o geralmente <function> xxx_action () "
"</function> consiste em um grande interruptor: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:19859
#, no-wrap
msgid ""
"    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);\n"
"    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;\n"
"    int unit = cam_sim_unit(sim);\n"
"    int bus = cam_sim_bus(sim);\n"
"\n"
"    switch(ccb_h-&gt;func_code) {\n"
"    case ...:\n"
"        ...\n"
"    default:\n"
"        ccb_h-&gt;status = CAM_REQ_INVALID;\n"
"        xpt_done(ccb);\n"
"        break;\n"
"    }"
msgstr ""
"    struct xxx_softc *softc = (struct xxx_softc *) cam_sim_softc(sim);\n"
"    struct ccb_hdr *ccb_h = &amp;ccb-&gt;ccb_h;\n"
"    int unit = cam_sim_unit(sim);\n"
"    int bus = cam_sim_bus(sim);\n"
"\n"
"    switch(ccb_h-&gt;func_code) {\n"
"    case ...:\n"
"        ...\n"
"    default:\n"
"        ccb_h-&gt;status = CAM_REQ_INVALID;\n"
"        xpt_done(ccb);\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:19873
#, fuzzy
msgid ""
"As can be seen from the default case (if an unknown command was received) "
"the return code of the command is set into <varname remap="
"\"structfield\">ccb-&gt;ccb_h.status</varname> and the completed CCB is "
"returned back to CAM by calling <function>xpt_done(ccb)</function>."
msgstr ""
"Como pode ser visto a partir do caso padr�o (se um comando desconhecido foi "
"recebido) o c�digo de retorno do comando � definido em <varname remap="
"\"structfield\"> ccb-&gt; ccb_h.status </varname> e o CCB preenchido � "
"devolvido ao CAM, chamando <function> xpt_done (ccb) </function> "

#. (itstool) path: sect1/para
#: book.translate.xml:19879
#, fuzzy
msgid ""
"<function>xpt_done()</function> does not have to be called from "
"<function>xxx_action()</function>: For example an I/O request may be "
"enqueued inside the SIM driver and/or its SCSI controller. Then when the "
"device would post an interrupt signaling that the processing of this request "
"is complete <function>xpt_done()</function> may be called from the interrupt "
"handling routine."
msgstr ""
" <function> xpt_done () </function> n�o precisa ser chamado de <function> "
"xxx_action () </function> Por exemplo, uma solicita��o de E / S pode ser "
"enfileirada dentro do driver do SIM e / ou seu controlador SCSI. Ent�o, "
"quando o dispositivo postar uma interrup��o, sinalizando que o processamento "
"desta solicita��o est� completo <function> xpt_done () </function> pode ser "
"chamado a partir da rotina de tratamento de interrup��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:19887
#, fuzzy
msgid ""
"Actually, the CCB status is not only assigned as a return code but a CCB has "
"some status all the time. Before CCB is passed to the "
"<function>xxx_action()</function> routine it gets the status CCB_REQ_INPROG "
"meaning that it is in progress. There are a surprising number of status "
"values defined in <filename>/sys/cam/cam.h</filename> which should be able "
"to represent the status of a request in great detail. More interesting yet, "
"the status is in fact a <quote>bitwise or</quote> of an enumerated status "
"value (the lower 6 bits) and possible additional flag-like bits (the upper "
"bits). The enumerated values will be discussed later in more detail. The "
"summary of them can be found in the Errors Summary section. The possible "
"status flags are:"
msgstr ""
"Na verdade, o status do CCB n�o � atribu�do apenas como um c�digo de "
"retorno, mas um CCB tem algum status o tempo todo. Antes de o CCB ser "
"passado para o <function> xxx_action () </function> rotina obt�m o status "
"CCB_REQ_INPROG, o que significa que est� em andamento. H� um n�mero "
"surpreendente de valores de status definidos em <filename> /sys/cam/cam.h </"
"filename> que deve ser capaz de representar o status de uma solicita��o em "
"grande detalhe. Mais interessante ainda, o status � de fato um <quote> bit a "
"bit ou </quote> de um valor de status enumerado (os 6 bits inferiores) e "
"poss�veis bits semelhantes a sinalizadores adicionais (os bits superiores). "
"Os valores enumerados ser�o discutidos mais adiante com mais detalhes. O "
"resumo deles pode ser encontrado na se��o Resumo de Erros. Os poss�veis "
"flags de status s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:19903
#, fuzzy
msgid ""
"<emphasis>CAM_DEV_QFRZN</emphasis> - if the SIM driver gets a serious error "
"(for example, the device does not respond to the selection or breaks the "
"SCSI protocol) when processing a CCB it should freeze the request queue by "
"calling <function>xpt_freeze_simq()</function>, return the other enqueued "
"but not processed yet CCBs for this device back to the CAM queue, then set "
"this flag for the troublesome CCB and call <function>xpt_done()</function>. "
"This flag causes the CAM subsystem to unfreeze the queue after it handles "
"the error."
msgstr ""
" <emphasis> CAM_DEV_QFRZN </emphasis> - se o driver SIM receber um erro "
"grave (por exemplo, o dispositivo n�o responder � sele��o ou quebrar o "
"protocolo SCSI) ao processar um CCB, ele dever� congelar a fila de "
"solicita��o chamando <function> xpt_freeze_simq () </function> , retorne os "
"outros enfileirados mas n�o processados ​​ainda aos CCBs para este "
"dispositivo de volta para a fila do CAM, defina esse sinalizador para o CCB "
"problem�tico e chame <function> xpt_done () </function> . Esse sinalizador "
"faz com que o subsistema CAM descongele a fila depois que ela manipula o "
"erro. "

#. (itstool) path: listitem/para
#: book.translate.xml:19916
#, fuzzy
msgid ""
"<emphasis>CAM_AUTOSNS_VALID</emphasis> - if the device returned an error "
"condition and the flag CAM_DIS_AUTOSENSE is not set in CCB the SIM driver "
"must execute the REQUEST SENSE command automatically to extract the sense "
"(extended error information) data from the device. If this attempt was "
"successful the sense data should be saved in the CCB and this flag set."
msgstr ""
" <emphasis> CAM_AUTOSNS_VALID </emphasis> - se o dispositivo retornou uma "
"condi��o de erro e o sinalizador CAM_DIS_AUTOSENSE n�o est� definido no CCB, "
"o driver SIM deve executar o comando REQUEST SENSE automaticamente para "
"extrair os dados de sentido (informa��es de erro estendidas) do dispositivo. "
"Se esta tentativa foi bem sucedida, os dados do sentido devem ser salvos no "
"CCB e este sinalizador definido. "

#. (itstool) path: listitem/para
#: book.translate.xml:19926
#, fuzzy
msgid ""
"<emphasis>CAM_RELEASE_SIMQ</emphasis> - like CAM_DEV_QFRZN but used in case "
"there is some problem (or resource shortage) with the SCSI controller itself."
" Then all the future requests to the controller should be stopped by "
"<function>xpt_freeze_simq()</function>. The controller queue will be "
"restarted after the SIM driver overcomes the shortage and informs CAM by "
"returning some CCB with this flag set."
msgstr ""
" <emphasis> CAM_RELEASE_SIMQ </emphasis> - como o CAM_DEV_QFRZN mas usado no "
"caso de haver algum problema (ou escassez de recursos) com o pr�prio "
"controlador SCSI. Ent�o todos os pedidos futuros ao controlador devem ser "
"interrompidos por <function> xpt_freeze_simq () </function> . A fila do "
"controlador ser� reiniciada ap�s o driver do SIM superar a falta e informar "
"o CAM retornando algum CCB com este sinalizador definido. "

#. (itstool) path: listitem/para
#: book.translate.xml:19937
#, fuzzy
msgid ""
"<emphasis>CAM_SIM_QUEUED</emphasis> - when SIM puts a CCB into its request "
"queue this flag should be set (and removed when this CCB gets dequeued "
"before being returned back to CAM). This flag is not used anywhere in the "
"CAM code now, so its purpose is purely diagnostic."
msgstr ""
" <emphasis> CAM_SIM_QUEUED </emphasis> - quando o SIM coloca um CCB em sua "
"fila de pedidos, este sinalizador deve ser definido (e removido quando este "
"CCB � retirado da fila antes de ser devolvido ao CAM). Este sinalizador n�o "
"� usado em qualquer lugar no c�digo CAM agora, ent�o seu prop�sito � "
"puramente diagn�stico. "

#. (itstool) path: listitem/para
#: book.translate.xml:19945
#, fuzzy
msgid "<emphasis>CAM_QOS_VALID</emphasis> - The QOS data is now valid."
msgstr ""
" <emphasis> CAM_QOS_VALID </emphasis> - Os dados QOS agora s�o v�lidos. "

#. (itstool) path: sect1/para
#: book.translate.xml:19950
#, fuzzy
msgid ""
"The function <function>xxx_action()</function> is not allowed to sleep, so "
"all the synchronization for resource access must be done using SIM or device "
"queue freezing. Besides the aforementioned flags the CAM subsystem provides "
"functions <function>xpt_release_simq()</function> and "
"<function>xpt_release_devq()</function> to unfreeze the queues directly, "
"without passing a CCB to CAM."
msgstr ""
"A fun��o <function> xxx_action () </function> n�o � permitido dormir, "
"portanto, toda a sincroniza��o para acesso ao recurso deve ser feita usando "
"o congelamento da fila do SIM ou do dispositivo. Al�m das bandeiras acima "
"mencionadas, o subsistema CAM fornece fun��es <function> xpt_release_simq () "
"</function> e <function> xpt_release_devq () </function> para descongelar as "
"filas diretamente, sem passar um CCB para CAM \""

#. (itstool) path: sect1/para
#: book.translate.xml:19958
#, fuzzy
msgid "The CCB header contains the following fields:"
msgstr "O cabe�alho do CCB cont�m os seguintes campos:"

#. (itstool) path: listitem/para
#: book.translate.xml:19962
#, fuzzy
msgid "<emphasis>path</emphasis> - path ID for the request"
msgstr " <emphasis> caminho </emphasis> - ID do caminho para o pedido "

#. (itstool) path: listitem/para
#: book.translate.xml:19967
#, fuzzy
msgid "<emphasis>target_id</emphasis> - target device ID for the request"
msgstr ""
" <emphasis> target_id </emphasis> - ID do dispositivo de destino para o "
"pedido "

#. (itstool) path: listitem/para
#: book.translate.xml:19972
#, fuzzy
msgid "<emphasis>target_lun</emphasis> - LUN ID of the target device"
msgstr ""
" <emphasis> target_lun </emphasis> - ID do LUN do dispositivo de destino "

#. (itstool) path: listitem/para
#: book.translate.xml:19977
#, fuzzy
msgid ""
"<emphasis>timeout</emphasis> - timeout interval for this command, in "
"milliseconds"
msgstr ""
" <emphasis> tempo esgotado </emphasis> - intervalo de tempo limite para este "
"comando, em milissegundos "

#. (itstool) path: listitem/para
#: book.translate.xml:19982
#, fuzzy
msgid ""
"<emphasis>timeout_ch</emphasis> - a convenience place for the SIM driver to "
"store the timeout handle (the CAM subsystem itself does not make any "
"assumptions about it)"
msgstr ""
" <emphasis> timeout_ch </emphasis> - um local de conveni�ncia para o driver "
"do SIM armazenar o identificador de tempo limite (o pr�prio subsistema CAM "
"n�o faz nenhuma suposi��o sobre ele) "

#. (itstool) path: listitem/para
#: book.translate.xml:19989
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - various bits of information about the request "
"spriv_ptr0, spriv_ptr1 - fields reserved for private use by the SIM driver "
"(such as linking to the SIM queues or SIM private control blocks); actually, "
"they exist as unions: spriv_ptr0 and spriv_ptr1 have the type (void *), "
"spriv_field0 and spriv_field1 have the type unsigned long, sim_priv."
"entries[0].bytes and sim_priv.entries[1].bytes are byte arrays of the size "
"consistent with the other incarnations of the union and sim_priv.bytes is "
"one array, twice bigger."
msgstr ""
" <emphasis> bandeiras </emphasis> - v�rios bits de informa��o sobre o pedido "
"spriv_ptr0, spriv_ptr1 - campos reservados para uso privado pelo driver do "
"SIM (como links para as filas do SIM ou blocos de controle privados do SIM); "
"na verdade, eles existem como unions: spriv_ptr0 e spriv_ptr1 tem o tipo "
"(void *), spriv_field0 e spriv_field1 tem o tipo unsigned long, sim_priv."
"entries [0] .bytes e sim_priv.entries [1] .bytes s�o matrizes de byte do "
"tamanho consistente com as outras encarna��es da uni�o e sim_priv.bytes � "
"uma matriz, duas vezes maior \""

#. (itstool) path: sect1/para
#: book.translate.xml:20002
#, fuzzy
msgid ""
"The recommended way of using the SIM private fields of CCB is to define some "
"meaningful names for them and use these meaningful names in the driver, like:"
""
msgstr ""
"A maneira recomendada de usar os campos privados do SIM do CCB � definir "
"alguns nomes significativos para eles e usar esses nomes significativos no "
"driver, como:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:20006
#, no-wrap
msgid ""
"#define ccb_some_meaningful_name    sim_priv.entries[0].bytes\n"
"#define ccb_hcb spriv_ptr1 /* for hardware control block */"
msgstr ""
"#define ccb_some_meaningful_name    sim_priv.entries[0].bytes\n"
"#define ccb_hcb spriv_ptr1 /* for hardware control block */"

#. (itstool) path: sect1/para
#: book.translate.xml:20009
#, fuzzy
msgid "The most common initiator mode requests are:"
msgstr "As solicita��es de modo de iniciador mais comuns s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:20013
#, fuzzy
msgid "<emphasis>XPT_SCSI_IO</emphasis> - execute an I/O transaction"
msgstr ""
" <emphasis> XPT_SCSI_IO </emphasis> - executar uma transa��o de E / S "

#. (itstool) path: listitem/para
#: book.translate.xml:20016
#, fuzzy
msgid ""
"The instance <quote>struct ccb_scsiio csio</quote> of the union ccb is used "
"to transfer the arguments. They are:"
msgstr ""
"A inst�ncia <quote> struct ccb_scsiio csio </quote> da uni�o ccb � usado "
"para transferir os argumentos. Eles s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:20022
#, fuzzy
msgid ""
"<emphasis>cdb_io</emphasis> - pointer to the SCSI command buffer or the "
"buffer itself"
msgstr ""
" <emphasis> cdb_io </emphasis> - ponteiro para o buffer de comando SCSI ou o "
"pr�prio buffer "

#. (itstool) path: listitem/para
#: book.translate.xml:20027
#, fuzzy
msgid "<emphasis>cdb_len</emphasis> - SCSI command length"
msgstr " <emphasis> cdb_len </emphasis> - comprimento do comando SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20032
#, fuzzy
msgid ""
"<emphasis>data_ptr</emphasis> - pointer to the data buffer (gets a bit "
"complicated if scatter/gather is used)"
msgstr ""
" <emphasis> data_ptr </emphasis> - ponteiro para o buffer de dados (fica um "
"pouco complicado se scatter / gather for usado) "

#. (itstool) path: listitem/para
#: book.translate.xml:20038
#, fuzzy
msgid "<emphasis>dxfer_len</emphasis> - length of the data to transfer"
msgstr ""
" <emphasis> dxfer_len </emphasis> - comprimento dos dados a transferir "

#. (itstool) path: listitem/para
#: book.translate.xml:20043
#, fuzzy
msgid ""
"<emphasis>sglist_cnt</emphasis> - counter of the scatter/gather segments"
msgstr ""
" <emphasis> sglist_cnt </emphasis> - contador dos segmentos scatter / gather "
""

#. (itstool) path: listitem/para
#: book.translate.xml:20048
#, fuzzy
msgid "<emphasis>scsi_status</emphasis> - place to return the SCSI status"
msgstr ""
" <emphasis> scsi_status </emphasis> - local para retornar o status SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20053
#, fuzzy
msgid ""
"<emphasis>sense_data</emphasis> - buffer for the SCSI sense information if "
"the command returns an error (the SIM driver is supposed to run the REQUEST "
"SENSE command automatically in this case if the CCB flag CAM_DIS_AUTOSENSE "
"is not set)"
msgstr ""
" <emphasis> sense_data </emphasis> - buffer para as informa��es do sentido "
"SCSI, se o comando retornar um erro (o driver SIM dever� executar o comando "
"REQUEST SENSE automaticamente, neste caso, se o sinalizador do CCB "
"CAM_DIS_AUTOSENSE n�o estiver definido) "

#. (itstool) path: listitem/para
#: book.translate.xml:20061
#, fuzzy
msgid ""
"<emphasis>sense_len</emphasis> - the length of that buffer (if it happens to "
"be higher than size of sense_data the SIM driver must silently assume the "
"smaller value) resid, sense_resid - if the transfer of data or SCSI sense "
"returned an error these are the returned counters of the residual (not "
"transferred) data. They do not seem to be especially meaningful, so in a "
"case when they are difficult to compute (say, counting bytes in the SCSI "
"controller's FIFO buffer) an approximate value will do as well. For a "
"successfully completed transfer they must be set to zero."
msgstr ""
" <emphasis> sense_len </emphasis> - o comprimento desse buffer (se for maior "
"que o tamanho de sense_data que o driver do SIM deve assumir silenciosamente "
"o valor menor) resid, sense_resid - se a transfer�ncia de dados ou o sentido "
"SCSI retornar um erro, esses s�o os contadores retornados do valor residual. "
"dados (n�o transferidos). Eles n�o parecem ser especialmente significativos, "
"portanto, em um caso em que � dif�cil computar (digamos, contar bytes no "
"buffer FIFO do controlador SCSI), um valor aproximado tamb�m funcionar�. "
"Para uma transfer�ncia conclu�da com sucesso, eles devem ser definidos como "
"zero. "

#. (itstool) path: listitem/para
#: book.translate.xml:20076
#, fuzzy
msgid "<emphasis>tag_action</emphasis> - the kind of tag to use:"
msgstr " <emphasis> tag_action </emphasis> - o tipo de tag a usar: "

#. (itstool) path: listitem/para
#: book.translate.xml:20081
#, fuzzy
msgid "CAM_TAG_ACTION_NONE - do not use tags for this transaction"
msgstr "CAM_TAG_ACTION_NONE - n�o use tags para esta transa��o"

#. (itstool) path: listitem/para
#: book.translate.xml:20086
#, fuzzy
msgid ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - value equal to the "
"appropriate tag message (see /sys/cam/scsi/scsi_message.h); this gives only "
"the tag type, the SIM driver must assign the tag value itself"
msgstr ""
"MSG_SIMPLE_Q_TAG, MSG_HEAD_OF_Q_TAG, MSG_ORDERED_Q_TAG - valor igual � "
"mensagem de tag apropriada (consulte /sys/cam/scsi/scsi_message.h); isso "
"fornece apenas o tipo de tag, o driver do SIM deve atribuir o pr�prio valor "
"de tag"

#. (itstool) path: listitem/para
#: book.translate.xml:20096
#, fuzzy
msgid "The general logic of handling this request is the following:"
msgstr "A l�gica geral de lidar com essa solicita��o � a seguinte:"

#. (itstool) path: listitem/para
#: book.translate.xml:20099
#, fuzzy
msgid ""
"The first thing to do is to check for possible races, to make sure that the "
"command did not get aborted when it was sitting in the queue:"
msgstr ""
"A primeira coisa a fazer � verificar poss�veis corridas, para garantir que o "
"comando n�o seja abortado quando estiver na fila:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20103
#, no-wrap
msgid ""
"    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;\n"
"\n"
"    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    struct ccb_scsiio *csio = &amp;ccb-&gt;csio;\n"
"\n"
"    if ((ccb_h-&gt;status &amp; CAM_STATUS_MASK) != CAM_REQ_INPROG) {\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20110
#, fuzzy
msgid "Also we check that the device is supported at all by our controller:"
msgstr ""
"Tamb�m verificamos se o dispositivo � suportado pelo nosso controlador:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20113
#, no-wrap
msgid ""
"    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID\n"
"    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {\n"
"        ccb_h-&gt;status = CAM_TID_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {\n"
"        ccb_h-&gt;status = CAM_LUN_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    if(ccb_h-&gt;target_id &gt; OUR_MAX_SUPPORTED_TARGET_ID\n"
"    || cch_h-&gt;target_id == OUR_SCSI_CONTROLLERS_OWN_ID) {\n"
"        ccb_h-&gt;status = CAM_TID_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"    if(ccb_h-&gt;target_lun &gt; OUR_MAX_SUPPORTED_LUN) {\n"
"        ccb_h-&gt;status = CAM_LUN_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: para/indexterm
#: book.translate.xml:20127
#, fuzzy
msgid "<primary>hardware control block</primary>"
msgstr " <primary> bloco de controle de hardware </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:20125
#, fuzzy
msgid ""
"Then allocate whatever data structures (such as card-dependent hardware "
"control block<_:indexterm-1/>) we need to process this request. If we can "
"not then freeze the SIM queue and remember that we have a pending operation, "
"return the CCB back and ask CAM to re-queue it. Later when the resources "
"become available the SIM queue must be unfrozen by returning a ccb with the "
"<literal>CAM_SIMQ_RELEASE</literal> bit set in its status. Otherwise, if all "
"went well, link the CCB with the hardware control block (HCB) and mark it as "
"queued."
msgstr ""
"Ent�o aloque quaisquer estruturas de dados (como o bloco de controle de "
"hardware dependente de cart�o <_: indexterm-1 />) que precisamos processar "
"esta requisi��o. Se n�o pudermos, congelar a fila do SIM e lembrar que temos "
"uma opera��o pendente, retornar o CCB de volta e pe�a ao CAM para reenvi�-lo."
" Mais tarde, quando os recursos estiverem dispon�veis, a fila do SIM deve "
"ser descongelada retornando um ccb com o <literal> CAM_SIMQ_RELEASE </"
"literal> bit definido em seu status. Caso contr�rio, se tudo correr bem, "
"vincule o CCB ao bloco de controle de hardware (HCB) e marque-o como na fila."
" "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20138
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);\n"
"\n"
"    if(hcb == NULL) {\n"
"        softc-&gt;flags |= RESOURCE_SHORTAGE;\n"
"        xpt_freeze_simq(sim, /*count*/1);\n"
"        ccb_h-&gt;status = CAM_REQUEUE_REQ;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;\n"
"    ccb_h-&gt;status |= CAM_SIM_QUEUED;"
msgstr ""
"    struct xxx_hcb *hcb = allocate_hcb(softc, unit, bus);\n"
"\n"
"    if(hcb == NULL) {\n"
"        softc-&gt;flags |= RESOURCE_SHORTAGE;\n"
"        xpt_freeze_simq(sim, /*count*/1);\n"
"        ccb_h-&gt;status = CAM_REQUEUE_REQ;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb-&gt;ccb = ccb; ccb_h-&gt;ccb_hcb = (void *)hcb;\n"
"    ccb_h-&gt;status |= CAM_SIM_QUEUED;"

#. (itstool) path: listitem/para
#: book.translate.xml:20151
#, fuzzy
msgid ""
"Extract the target data from CCB into the hardware control block. Check if "
"we are asked to assign a tag and if yes then generate an unique tag and "
"build the SCSI tag messages. The SIM driver is also responsible for "
"negotiations with the devices to set the maximal mutually supported bus "
"width, synchronous rate and offset."
msgstr ""
"Extraia os dados de destino do CCB no bloco de controle de hardware. "
"Verifique se somos solicitados a atribuir uma tag e, se sim, gerar uma tag "
"�nica e criar as mensagens de tag SCSI. O driver do SIM tamb�m � respons�vel "
"pelas negocia��es com os dispositivos a serem definidos a largura de "
"barramento m�xima mutuamente suportada, a taxa s�ncrona e o deslocamento \""

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20158
#, no-wrap
msgid ""
"    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-"
"&gt;target_lun;\n"
"    generate_identify_message(hcb);\n"
"    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )\n"
"        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);\n"
"    if( !target_negotiated(hcb) )\n"
"        generate_negotiation_messages(hcb);"
msgstr ""
"    hcb-&gt;target = ccb_h-&gt;target_id; hcb-&gt;lun = ccb_h-"
"&gt;target_lun;\n"
"    generate_identify_message(hcb);\n"
"    if( ccb_h-&gt;tag_action != CAM_TAG_ACTION_NONE )\n"
"        generate_unique_tag_message(hcb, ccb_h-&gt;tag_action);\n"
"    if( !target_negotiated(hcb) )\n"
"        generate_negotiation_messages(hcb);"

#. (itstool) path: listitem/para
#: book.translate.xml:20165
#, fuzzy
msgid ""
"Then set up the SCSI command. The command storage may be specified in the "
"CCB in many interesting ways, specified by the CCB flags. The command buffer "
"can be contained in CCB or pointed to, in the latter case the pointer may be "
"physical or virtual. Since the hardware commonly needs physical address we "
"always convert the address to the physical one, typically using the busdma "
"API."
msgstr ""
"Em seguida, configure o comando SCSI. O armazenamento de comando pode ser "
"especificado no CCB de muitas maneiras interessantes, especificado pelos "
"sinalizadores do CCB. O buffer de comando pode estar contido no CCB ou "
"apontado, no �ltimo caso, o ponteiro pode ser f�sico ou Como o hardware "
"normalmente precisa de endere�o f�sico, sempre convertemos o endere�o para o "
"f�sico, geralmente usando a API busdma. "

#. (itstool) path: listitem/para
#: book.translate.xml:20173
#, fuzzy
msgid ""
"In case if a physical address is requested it is OK to return the CCB with "
"the status <errorname>CAM_REQ_INVALID</errorname>, the current drivers do "
"that. If necessary a physical address can be also converted or mapped back "
"to a virtual address but with big pain, so we do not do that."
msgstr ""
"No caso de um endere�o f�sico ser solicitado, � OK retornar o CCB com o "
"status <errorname> CAM_REQ_INVALID </errorname> , os drivers atuais fazem "
"isso. Se necess�rio, um endere�o f�sico tamb�m pode ser convertido ou "
"mapeado de volta para um endere�o virtual, mas com grande dificuldade, por "
"isso n�o fazemos isso. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20180
#, no-wrap
msgid ""
"    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {\n"
"        /* CDB is a pointer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {\n"
"            /* CDB pointer is virtual */\n"
"            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);\n"
"        } else {\n"
"            /* CDB pointer is physical */\n"
"            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;\n"
"        }\n"
"    } else {\n"
"        /* CDB is in the ccb (buffer) */\n"
"        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);\n"
"    }\n"
"    hcb-&gt;cmdlen = csio-&gt;cdb_len;"
msgstr ""
"    if(ccb_h-&gt;flags &amp; CAM_CDB_POINTER) {\n"
"        /* CDB is a pointer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_CDB_PHYS)) {\n"
"            /* CDB pointer is virtual */\n"
"            hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_ptr);\n"
"        } else {\n"
"            /* CDB pointer is physical */\n"
"            hcb-&gt;cmd = csio-&gt;cdb_io.cdb_ptr ;\n"
"        }\n"
"    } else {\n"
"        /* CDB is in the ccb (buffer) */\n"
"        hcb-&gt;cmd = vtobus(csio-&gt;cdb_io.cdb_bytes);\n"
"    }\n"
"    hcb-&gt;cmdlen = csio-&gt;cdb_len;"

#. (itstool) path: listitem/para
#: book.translate.xml:20195
#, fuzzy
msgid ""
"Now it is time to set up the data. Again, the data storage may be specified "
"in the CCB in many interesting ways, specified by the CCB flags. First we "
"get the direction of the data transfer. The simplest case is if there is no "
"data to transfer:"
msgstr ""
"Agora � hora de configurar os dados. Novamente, o armazenamento de dados "
"pode ser especificado no CCB de muitas maneiras interessantes, especificado "
"pelos sinalizadores do CCB. Primeiro, obtemos a dire��o da transfer�ncia de "
"dados. O caso mais simples � se houver nenhum dado para transferir: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20201
#, no-wrap
msgid ""
"    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);\n"
"\n"
"    if (dir == CAM_DIR_NONE)\n"
"        goto end_data;"
msgstr ""
"    int dir = (ccb_h-&gt;flags &amp; CAM_DIR_MASK);\n"
"\n"
"    if (dir == CAM_DIR_NONE)\n"
"        goto end_data;"

#. (itstool) path: listitem/para
#: book.translate.xml:20206
#, fuzzy
msgid ""
"Then we check if the data is in one chunk or in a scatter-gather list, and "
"the addresses are physical or virtual. The SCSI controller may be able to "
"handle only a limited number of chunks of limited length. If the request "
"hits this limitation we return an error. We use a special function to return "
"the CCB to handle in one place the HCB resource shortages. The functions to "
"add chunks are driver-dependent, and here we leave them without detailed "
"implementation. See description of the SCSI command (CDB) handling for the "
"details on the address-translation issues. If some variation is too "
"difficult or impossible to implement with a particular card it is OK to "
"return the status <errorname>CAM_REQ_INVALID</errorname>. Actually, it seems "
"like the scatter-gather ability is not used anywhere in the CAM code now. "
"But at least the case for a single non-scattered virtual buffer must be "
"implemented, it is actively used by CAM."
msgstr ""
"Em seguida, verificamos se os dados est�o em um fragmento ou em uma lista de "
"dispers�o-coleta, e os endere�os s�o f�sicos ou virtuais. O controlador SCSI "
"pode manipular apenas um n�mero limitado de fragmentos de tamanho limitado. "
"Se a solicita��o atingir esse limita��o n�s retornamos um erro.N�s usamos "
"uma fun��o especial para retornar o CCB para lidar em um lugar a escassez de "
"recursos HCB.As fun��es para adicionar peda�os s�o dependentes do driver, e "
"aqui n�s deix�-los sem implementa��o detalhada.Veja a descri��o do comando "
"SCSI (CDB) tratando dos detalhes sobre os problemas de tradu��o de endere�os."
"Se alguma varia��o for muito dif�cil ou imposs�vel de implementar com um "
"cart�o espec�fico, n�o h� problema em retornar o status <errorname> "
"CAM_REQ_INVALID </errorname> . Na verdade, parece que a habilidade de "
"espalhar-reunir n�o � usada em nenhum lugar no c�digo CAM agora. Mas pelo "
"menos o caso de um �nico buffer virtual n�o disperso deve ser implementado, "
"ele � usado ativamente pelo CAM. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20224
#, no-wrap
msgid ""
"    int rv;\n"
"\n"
"    initialize_hcb_for_data(hcb);\n"
"\n"
"    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {\n"
"        /* single buffer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-"
"&gt;dxfer_len, dir);\n"
"            }\n"
"        } else {\n"
"            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-"
"&gt;dxfer_len, dir);\n"
"        }\n"
"    } else {\n"
"        int i;\n"
"        struct bus_dma_segment *segs;\n"
"        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;\n"
"\n"
"        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {\n"
"            /* The SG list pointer is physical */\n"
"            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-"
"&gt;sglist_cnt);\n"
"        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            /* SG buffer pointers are virtual */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_virtual_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        } else {\n"
"            /* SG buffer pointers are physical */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_physical_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    if(rv != CAM_REQ_CMP) {\n"
"        /* we expect that add_*_chunk() functions return CAM_REQ_CMP\n"
"         * if they added a chunk successfully, CAM_REQ_TOO_BIG if\n"
"         * the request is too big (too many bytes or too many chunks),\n"
"         * CAM_REQ_INVALID in case of other troubles\n"
"         */\n"
"        free_hcb_and_ccb_done(hcb, ccb, rv);\n"
"        return;\n"
"    }\n"
"    end_data:"
msgstr ""
"    int rv;\n"
"\n"
"    initialize_hcb_for_data(hcb);\n"
"\n"
"    if((!(ccb_h-&gt;flags &amp; CAM_SCATTER_VALID)) {\n"
"        /* single buffer */\n"
"        if(!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            rv = add_virtual_chunk(hcb, csio-&gt;data_ptr, csio-"
"&gt;dxfer_len, dir);\n"
"            }\n"
"        } else {\n"
"            rv = add_physical_chunk(hcb, csio-&gt;data_ptr, csio-"
"&gt;dxfer_len, dir);\n"
"        }\n"
"    } else {\n"
"        int i;\n"
"        struct bus_dma_segment *segs;\n"
"        segs = (struct bus_dma_segment *)csio-&gt;data_ptr;\n"
"\n"
"        if ((ccb_h-&gt;flags &amp; CAM_SG_LIST_PHYS) != 0) {\n"
"            /* The SG list pointer is physical */\n"
"            rv = setup_hcb_for_physical_sg_list(hcb, segs, csio-"
"&gt;sglist_cnt);\n"
"        } else if (!(ccb_h-&gt;flags &amp; CAM_DATA_PHYS)) {\n"
"            /* SG buffer pointers are virtual */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_virtual_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        } else {\n"
"            /* SG buffer pointers are physical */\n"
"            for (i = 0; i &lt; csio-&gt;sglist_cnt; i++) {\n"
"                rv = add_physical_chunk(hcb, segs[i].ds_addr,\n"
"                    segs[i].ds_len, dir);\n"
"                if (rv != CAM_REQ_CMP)\n"
"                    break;\n"
"            }\n"
"        }\n"
"    }\n"
"    if(rv != CAM_REQ_CMP) {\n"
"        /* we expect that add_*_chunk() functions return CAM_REQ_CMP\n"
"         * if they added a chunk successfully, CAM_REQ_TOO_BIG if\n"
"         * the request is too big (too many bytes or too many chunks),\n"
"         * CAM_REQ_INVALID in case of other troubles\n"
"         */\n"
"        free_hcb_and_ccb_done(hcb, ccb, rv);\n"
"        return;\n"
"    }\n"
"    end_data:"

#. (itstool) path: listitem/para
#: book.translate.xml:20273
#, fuzzy
msgid ""
"If disconnection is disabled for this CCB we pass this information to the "
"hcb:"
msgstr ""
"Se a desconex�o estiver desativada para este CCB, n�s passamos esta "
"informa��o para o hcb:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20276
#, no-wrap
msgid ""
"    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)\n"
"        hcb_disable_disconnect(hcb);"
msgstr ""
"    if(ccb_h-&gt;flags &amp; CAM_DIS_DISCONNECT)\n"
"        hcb_disable_disconnect(hcb);"

#. (itstool) path: listitem/para
#: book.translate.xml:20279
#, fuzzy
msgid ""
"If the controller is able to run REQUEST SENSE command all by itself then "
"the value of the flag CAM_DIS_AUTOSENSE should also be passed to it, to "
"prevent automatic REQUEST SENSE if the CAM subsystem does not want it."
msgstr ""
"Se o controlador puder executar o comando REQUEST SENSE sozinho, o valor do "
"sinalizador CAM_DIS_AUTOSENSE tamb�m dever� ser passado para ele, para "
"evitar o REQUEST SENSE autom�tico se o subsistema CAM n�o o quiser."

#. (itstool) path: listitem/para
#: book.translate.xml:20284
#, fuzzy
msgid ""
"The only thing left is to set up the timeout, pass our hcb to the hardware "
"and return, the rest will be done by the interrupt handler (or timeout "
"handler)."
msgstr ""
"A �nica coisa que resta � configurar o tempo limite, passar o nosso hcb para "
"o hardware e retornar, o resto ser� feito pelo manipulador de interrup��o "
"(ou manipulador de tempo limite)."

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20288
#, no-wrap
msgid ""
"    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,\n"
"        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */"
"\n"
"    put_hcb_into_hardware_queue(hcb);\n"
"    return;"
msgstr ""
"    ccb_h-&gt;timeout_ch = timeout(xxx_timeout, (caddr_t) hcb,\n"
"        (ccb_h-&gt;timeout * hz) / 1000); /* convert milliseconds to ticks */"
"\n"
"    put_hcb_into_hardware_queue(hcb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20293
#, fuzzy
msgid "And here is a possible implementation of the function returning CCB:"
msgstr "E aqui est� uma implementa��o poss�vel da fun��o que retorna o CCB:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20296
#, no-wrap
msgid ""
"    static void\n"
"    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t "
"status)\n"
"    {\n"
"        struct xxx_softc *softc = hcb-&gt;softc;\n"
"\n"
"        ccb-&gt;ccb_h.ccb_hcb = 0;\n"
"        if(hcb != NULL) {\n"
"            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);\n"
"            /* we're about to free a hcb, so the shortage has ended */\n"
"            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {\n"
"                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;\n"
"                status |= CAM_RELEASE_SIMQ;\n"
"            }\n"
"            free_hcb(hcb); /* also removes hcb from any internal lists */\n"
"        }\n"
"        ccb-&gt;ccb_h.status = status |\n"
"            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));\n"
"        xpt_done(ccb);\n"
"    }"
msgstr ""
"    static void\n"
"    free_hcb_and_ccb_done(struct xxx_hcb *hcb, union ccb *ccb, u_int32_t "
"status)\n"
"    {\n"
"        struct xxx_softc *softc = hcb-&gt;softc;\n"
"\n"
"        ccb-&gt;ccb_h.ccb_hcb = 0;\n"
"        if(hcb != NULL) {\n"
"            untimeout(xxx_timeout, (caddr_t) hcb, ccb-&gt;ccb_h.timeout_ch);\n"
"            /* we're about to free a hcb, so the shortage has ended */\n"
"            if(softc-&gt;flags &amp; RESOURCE_SHORTAGE)  {\n"
"                softc-&gt;flags &amp;= ~RESOURCE_SHORTAGE;\n"
"                status |= CAM_RELEASE_SIMQ;\n"
"            }\n"
"            free_hcb(hcb); /* also removes hcb from any internal lists */\n"
"        }\n"
"        ccb-&gt;ccb_h.status = status |\n"
"            (ccb-&gt;ccb_h.status &amp; ~(CAM_STATUS_MASK|CAM_SIM_QUEUED));\n"
"        xpt_done(ccb);\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20318
#, fuzzy
msgid ""
"<emphasis>XPT_RESET_DEV</emphasis> - send the SCSI <quote>BUS DEVICE RESET</"
"quote> message to a device"
msgstr ""
" <emphasis> XPT_RESET_DEV </emphasis> - enviar o SCSI <quote> REDU��O DO "
"DISPOSITIVO DE BARRAMENTO </quote> mensagem para um dispositivo "

#. (itstool) path: listitem/para
#: book.translate.xml:20321
#, fuzzy
msgid ""
"There is no data transferred in CCB except the header and the most "
"interesting argument of it is target_id. Depending on the controller "
"hardware a hardware control block just like for the XPT_SCSI_IO request may "
"be constructed (see XPT_SCSI_IO request description) and sent to the "
"controller or the SCSI controller may be immediately programmed to send this "
"RESET message to the device or this request may be just not supported (and "
"return the status <errorname>CAM_REQ_INVALID</errorname>). Also on "
"completion of the request all the disconnected transactions for this target "
"must be aborted (probably in the interrupt routine)."
msgstr ""
"N�o h� dados transferidos no CCB, exceto o cabe�alho e o argumento mais "
"interessante dele � target_id. Dependendo do hardware do controlador, um "
"bloco de controle de hardware como para o pedido XPT_SCSI_IO pode ser "
"constru�do (ver descri��o da solicita��o XPT_SCSI_IO) e enviado ao "
"controlador ou o controlador SCSI pode ser programado imediatamente para "
"enviar esta mensagem RESET para o dispositivo ou esta solicita��o pode n�o "
"ser suportada (e retornar o status <errorname> CAM_REQ_INVALID </errorname> "
"). Tamb�m na conclus�o da solicita��o, todas as transa��es desconectadas "
"para este destino devem ser abortadas (provavelmente na rotina de "
"interrup��o). "

#. (itstool) path: listitem/para
#: book.translate.xml:20334
#, fuzzy
msgid ""
"Also all the current negotiations for the target are lost on reset, so they "
"might be cleaned too. Or they clearing may be deferred, because anyway the "
"target would request re-negotiation on the next transaction."
msgstr ""
"Al�m disso, todas as negocia��es atuais para a meta s�o perdidas na "
"redefini��o, para que possam ser limpas tamb�m. Ou a compensa��o pode ser "
"adiada, porque, de qualquer maneira, a meta solicitaria a renegocia��o na "
"pr�xima transa��o."

#. (itstool) path: listitem/para
#: book.translate.xml:20342
#, fuzzy
msgid ""
"<emphasis>XPT_RESET_BUS</emphasis> - send the RESET signal to the SCSI bus"
msgstr ""
" <emphasis> XPT_RESET_BUS </emphasis> - envie o sinal RESET para o "
"barramento SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20345
#, fuzzy
msgid ""
"No arguments are passed in the CCB, the only interesting argument is the "
"SCSI bus indicated by the struct sim pointer."
msgstr ""
"Nenhum argumento � passado no CCB, o �nico argumento interessante � o "
"barramento SCSI indicado pelo ponteiro struct sim."

#. (itstool) path: listitem/para
#: book.translate.xml:20349
#, fuzzy
msgid ""
"A minimalistic implementation would forget the SCSI negotiations for all the "
"devices on the bus and return the status CAM_REQ_CMP."
msgstr ""
"Uma implementa��o minimalista esqueceria as negocia��es do SCSI para todos "
"os dispositivos no barramento e retornaria o status CAM_REQ_CMP."

#. (itstool) path: listitem/para
#: book.translate.xml:20353
#, fuzzy
msgid ""
"The proper implementation would in addition actually reset the SCSI bus "
"(possible also reset the SCSI controller) and mark all the CCBs being "
"processed, both those in the hardware queue and those being disconnected, as "
"done with the status CAM_SCSI_BUS_RESET. Like:"
msgstr ""
"A implementa��o adequada, al�m disso, realmente redefinir o barramento SCSI "
"(poss�vel tamb�m redefinir o controlador SCSI) e marcar todos os CCBs sendo "
"processados, tanto aqueles na fila de hardware quanto aqueles desconectados, "
"como feito com o status CAM_SCSI_BUS_RESET. Como:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20359
#, no-wrap
msgid ""
"    int targ, lun;\n"
"    struct xxx_hcb *h, *hh;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    /* The SCSI bus reset may take a long time, in this case its completion\n"
"     * should be checked by interrupt or timeout. But for simplicity\n"
"     * we assume here that it is really fast.\n"
"     */\n"
"    reset_scsi_bus(softc);\n"
"\n"
"    /* drop all enqueued CCBs */\n"
"    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"        hh = h-&gt;next;\n"
"        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"    }\n"
"\n"
"    /* the clean values of negotiations to report */\n"
"    neg.bus_width = 8;\n"
"    neg.sync_period = neg.sync_offset = 0;\n"
"    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"    /* drop all disconnected CCBs and clean negotiations  */\n"
"    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"        clean_negotiations(softc, targ);\n"
"\n"
"        /* report the event if possible */\n"
"        if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), targ,\n"
"                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"            xpt_free_path(path);\n"
"        }\n"
"\n"
"        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = "
"hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"            }\n"
"    }\n"
"\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"\n"
"    /* report the event */\n"
"    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"    return;"
msgstr ""
"    int targ, lun;\n"
"    struct xxx_hcb *h, *hh;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    /* The SCSI bus reset may take a long time, in this case its completion\n"
"     * should be checked by interrupt or timeout. But for simplicity\n"
"     * we assume here that it is really fast.\n"
"     */\n"
"    reset_scsi_bus(softc);\n"
"\n"
"    /* drop all enqueued CCBs */\n"
"    for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"        hh = h-&gt;next;\n"
"        free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"    }\n"
"\n"
"    /* the clean values of negotiations to report */\n"
"    neg.bus_width = 8;\n"
"    neg.sync_period = neg.sync_offset = 0;\n"
"    neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"        | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"    /* drop all disconnected CCBs and clean negotiations  */\n"
"    for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"        clean_negotiations(softc, targ);\n"
"\n"
"        /* report the event if possible */\n"
"        if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                cam_sim_path(sim), targ,\n"
"                CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"            xpt_free_path(path);\n"
"        }\n"
"\n"
"        for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"            for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h = "
"hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"            }\n"
"    }\n"
"\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"\n"
"    /* report the event */\n"
"    xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20408
#, fuzzy
msgid ""
"Implementing the SCSI bus reset as a function may be a good idea because it "
"would be re-used by the timeout function as a last resort if the things go "
"wrong."
msgstr ""
"Implementar a reinicializa��o do barramento SCSI como uma fun��o pode ser "
"uma boa id�ia, porque ela seria reutilizada pela fun��o de tempo limite como "
"�ltimo recurso se as coisas derem errado."

#. (itstool) path: listitem/para
#: book.translate.xml:20415
#, fuzzy
msgid "<emphasis>XPT_ABORT</emphasis> - abort the specified CCB"
msgstr " <emphasis> XPT_ABORT </emphasis> - abortar o CCB especificad"

#. (itstool) path: listitem/para
#: book.translate.xml:20418
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct ccb_abort cab</"
"quote> of the union ccb. The only argument field in it is:"
msgstr ""
"Os argumentos s�o transferidos na inst�ncia <quote> t�xi do struct ccb_abort "
"</quote> da uni�o ccb. O �nico campo de argumento �: "

#. (itstool) path: listitem/para
#: book.translate.xml:20422
#, fuzzy
msgid "<emphasis>abort_ccb</emphasis> - pointer to the CCB to be aborted"
msgstr ""
" <emphasis> abort_ccb </emphasis> - apontador para o CCB ser abortado "

#. (itstool) path: listitem/para
#: book.translate.xml:20425
#, fuzzy
msgid ""
"If the abort is not supported just return the status CAM_UA_ABORT. This is "
"also the easy way to minimally implement this call, return CAM_UA_ABORT in "
"any case."
msgstr ""
"Se o cancelamento n�o for suportado, apenas retorne o status CAM_UA_ABORT. "
"Esta � tamb�m a maneira mais f�cil de implementar minimamente esta chamada, "
"retornando CAM_UA_ABORT em qualquer caso."

#. (itstool) path: listitem/para
#: book.translate.xml:20429
#, fuzzy
msgid ""
"The hard way is to implement this request honestly. First check that abort "
"applies to a SCSI transaction:"
msgstr ""
"A maneira mais dif�cil � implementar essa solicita��o com honestidade. "
"Primeiro, verifique se a anula��o se aplica a uma transa��o SCSI:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20432
#, no-wrap
msgid ""
"    struct ccb *abort_ccb;\n"
"    abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"        ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"
msgstr ""
"    struct ccb *abort_ccb;\n"
"    abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"    if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"        ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20441
#, fuzzy
msgid ""
"Then it is necessary to find this CCB in our queue. This can be done by "
"walking the list of all our hardware control blocks in search for one "
"associated with this CCB:"
msgstr ""
"Ent�o � necess�rio encontrar este CCB em nossa fila. Isso pode ser feito "
"andando a lista de todos os nossos blocos de controle de hardware em busca "
"de um associado a este CCB:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20446
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb, *h;\n"
"\n"
"    hcb = NULL;\n"
"\n"
"    /* We assume that softc-&gt;first_hcb is the head of the list of all\n"
"     * HCBs associated with this bus, including those enqueued for\n"
"     * processing, being processed by hardware and disconnected ones.\n"
"     */\n"
"    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {\n"
"        if(h-&gt;ccb == abort_ccb) {\n"
"            hcb = h;\n"
"            break;\n"
"        }\n"
"    }\n"
"\n"
"    if(hcb == NULL) {\n"
"        /* no such CCB in our queue */\n"
"        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb=found_hcb;"
msgstr ""
"    struct xxx_hcb *hcb, *h;\n"
"\n"
"    hcb = NULL;\n"
"\n"
"    /* We assume that softc-&gt;first_hcb is the head of the list of all\n"
"     * HCBs associated with this bus, including those enqueued for\n"
"     * processing, being processed by hardware and disconnected ones.\n"
"     */\n"
"    for(h = softc-&gt;first_hcb; h != NULL; h = h-&gt;next) {\n"
"        if(h-&gt;ccb == abort_ccb) {\n"
"            hcb = h;\n"
"            break;\n"
"        }\n"
"    }\n"
"\n"
"    if(hcb == NULL) {\n"
"        /* no such CCB in our queue */\n"
"        ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        xpt_done(ccb);\n"
"        return;\n"
"    }\n"
"\n"
"    hcb=found_hcb;"

#. (itstool) path: listitem/para
#: book.translate.xml:20470
#, fuzzy
msgid ""
"Now we look at the current processing status of the HCB. It may be either "
"sitting in the queue waiting to be sent to the SCSI bus, being transferred "
"right now, or disconnected and waiting for the result of the command, or "
"actually completed by hardware but not yet marked as done by software. To "
"make sure that we do not get in any races with hardware we mark the HCB as "
"being aborted, so that if this HCB is about to be sent to the SCSI bus the "
"SCSI controller will see this flag and skip it."
msgstr ""
"Agora olhamos para o status atual do processamento do HCB. Ele pode estar na "
"fila esperando para ser enviado para o barramento SCSI, sendo transferido "
"agora ou desconectado e aguardando o resultado do comando, ou realmente "
"conclu�do por hardware, mas ainda n�o marcado como feito por software.Para "
"ter certeza de que n�o entraremos em nenhuma corrida com hardware, "
"marcaremos o HCB como sendo abortado, de modo que, se esse HCB estiver "
"prestes a ser enviado para o barramento SCSI, o controlador SCSI ver� esta "
"bandeira e pule-a. "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20480
#, no-wrap
msgid ""
"    int hstatus;\n"
"\n"
"    /* shown as a function, in case special action is needed to make\n"
"     * this flag visible to hardware\n"
"     */\n"
"    set_hcb_flags(hcb, HCB_BEING_ABORTED);\n"
"\n"
"    abort_again:\n"
"\n"
"    hstatus = get_hcb_status(hcb);\n"
"    switch(hstatus) {\n"
"    case HCB_SITTING_IN_QUEUE:\n"
"        remove_hcb_from_hardware_queue(hcb);\n"
"        /* FALLTHROUGH */\n"
"    case HCB_COMPLETED:\n"
"        /* this is an easy case */\n"
"        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);\n"
"        break;"
msgstr ""
"    int hstatus;\n"
"\n"
"    /* shown as a function, in case special action is needed to make\n"
"     * this flag visible to hardware\n"
"     */\n"
"    set_hcb_flags(hcb, HCB_BEING_ABORTED);\n"
"\n"
"    abort_again:\n"
"\n"
"    hstatus = get_hcb_status(hcb);\n"
"    switch(hstatus) {\n"
"    case HCB_SITTING_IN_QUEUE:\n"
"        remove_hcb_from_hardware_queue(hcb);\n"
"        /* FALLTHROUGH */\n"
"    case HCB_COMPLETED:\n"
"        /* this is an easy case */\n"
"        free_hcb_and_ccb_done(hcb, abort_ccb, CAM_REQ_ABORTED);\n"
"        break;"

#. (itstool) path: listitem/para
#: book.translate.xml:20499
#, fuzzy
msgid ""
"If the CCB is being transferred right now we would like to signal to the "
"SCSI controller in some hardware-dependent way that we want to abort the "
"current transfer. The SCSI controller would set the SCSI ATTENTION signal "
"and when the target responds to it send an ABORT message. We also reset the "
"timeout to make sure that the target is not sleeping forever. If the command "
"would not get aborted in some reasonable time like 10 seconds the timeout "
"routine would go ahead and reset the whole SCSI bus. Because the command "
"will be aborted in some reasonable time we can just return the abort request "
"now as successfully completed, and mark the aborted CCB as aborted (but not "
"mark it as done yet)."
msgstr ""
"Se o CCB est� sendo transferido agora, gostar�amos de sinalizar para o "
"controlador SCSI de alguma maneira dependente de hardware que queremos "
"abortar a transfer�ncia atual. O controlador SCSI configuraria o sinal SCSI "
"ATTENTION e quando o destino responder a ele, enviar�amos uma mensagem ABORT."
"N�s tamb�m redefinimos o tempo limite para ter certeza de que o alvo n�o "
"est� dormindo para sempre.Se o comando n�o fosse abortado em algum tempo "
"razo�vel como 10 segundos, a rotina de tempo limite iria adiante e "
"reinicializaria todo o barramento SCSI. ser� abortado em algum tempo "
"razo�vel, podemos simplesmente retornar a requisi��o abortar agora como "
"conclu�da com sucesso, e marcar o CCB abortado como abortado (mas n�o marc�-"
"lo como feito ainda). "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20513
#, no-wrap
msgid ""
"    case HCB_BEING_TRANSFERRED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h."
"timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;\n"
"        /* ask the controller to abort that HCB, then generate\n"
"         * an interrupt and stop\n"
"         */\n"
"        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {\n"
"            /* oops, we missed the race with hardware, this transaction\n"
"             * got off the bus before we aborted it, try again */\n"
"            goto abort_again;\n"
"        }\n"
"\n"
"        break;"
msgstr ""
"    case HCB_BEING_TRANSFERRED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h."
"timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        abort_ccb-&gt;ccb_h.status = CAM_REQ_ABORTED;\n"
"        /* ask the controller to abort that HCB, then generate\n"
"         * an interrupt and stop\n"
"         */\n"
"        if(signal_hardware_to_abort_hcb_and_stop(hcb) &lt; 0) {\n"
"            /* oops, we missed the race with hardware, this transaction\n"
"             * got off the bus before we aborted it, try again */\n"
"            goto abort_again;\n"
"        }\n"
"\n"
"        break;"

#. (itstool) path: listitem/para
#: book.translate.xml:20529
#, fuzzy
msgid ""
"If the CCB is in the list of disconnected then set it up as an abort request "
"and re-queue it at the front of hardware queue. Reset the timeout and report "
"the abort request to be completed."
msgstr ""
"Se o CCB estiver na lista de desconectados, configure-o como uma solicita��o "
"de interrup��o e enfileire-o novamente na frente da fila de hardware. "
"Redefina o tempo limite e informe a solicita��o de interrup��o a ser "
"conclu�da."

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20534
#, no-wrap
msgid ""
"    case HCB_DISCONNECTED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h."
"timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        put_abort_message_into_hcb(hcb);\n"
"        put_hcb_at_the_front_of_hardware_queue(hcb);\n"
"        break;\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    case HCB_DISCONNECTED:\n"
"        untimeout(xxx_timeout, (caddr_t) hcb, abort_ccb-&gt;ccb_h."
"timeout_ch);\n"
"        abort_ccb-&gt;ccb_h.timeout_ch =\n"
"            timeout(xxx_timeout, (caddr_t) hcb, 10 * hz);\n"
"        put_abort_message_into_hcb(hcb);\n"
"        put_hcb_at_the_front_of_hardware_queue(hcb);\n"
"        break;\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20546
#, fuzzy
msgid ""
"That is all for the ABORT request, although there is one more issue. Because "
"the ABORT message cleans all the ongoing transactions on a LUN we have to "
"mark all the other active transactions on this LUN as aborted. That should "
"be done in the interrupt routine, after the transaction gets aborted."
msgstr ""
"Isso � tudo para o pedido ABORT, embora haja mais um problema. Como a "
"mensagem ABORT limpa todas as transa��es em andamento em um LUN, temos que "
"marcar todas as outras transa��es ativas neste LUN como abortadas. Isso deve "
"ser feito na interrup��o rotina, ap�s a transa��o ser anulada. "

#. (itstool) path: listitem/para
#: book.translate.xml:20553
#, fuzzy
msgid ""
"Implementing the CCB abort as a function may be quite a good idea, this "
"function can be re-used if an I/O transaction times out. The only difference "
"would be that the timed out transaction would return the status "
"CAM_CMD_TIMEOUT for the timed out request. Then the case XPT_ABORT would be "
"small, like that:"
msgstr ""
"Implementar o cancelamento do CCB como uma fun��o pode ser uma boa id�ia, "
"essa fun��o pode ser reutilizada se uma transa��o de E / S atingir o tempo "
"limite. A �nica diferen�a seria que a transa��o expirada retornaria o status "
"CAM_CMD_TIMEOUT para o tempo limite esgotado. Ent�o, o caso XPT_ABORT seria "
"pequeno, assim: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20560
#, no-wrap
msgid ""
"    case XPT_ABORT:\n"
"        struct ccb *abort_ccb;\n"
"        abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"            ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"            xpt_done(ccb);\n"
"            return;\n"
"        }\n"
"        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)\n"
"            /* no such CCB in our queue */\n"
"            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        else\n"
"            ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"        xpt_done(ccb);\n"
"        return;"
msgstr ""
"    case XPT_ABORT:\n"
"        struct ccb *abort_ccb;\n"
"        abort_ccb = ccb-&gt;cab.abort_ccb;\n"
"\n"
"        if(abort_ccb-&gt;ccb_h.func_code != XPT_SCSI_IO) {\n"
"            ccb-&gt;ccb_h.status = CAM_UA_ABORT;\n"
"            xpt_done(ccb);\n"
"            return;\n"
"        }\n"
"        if(xxx_abort_ccb(abort_ccb, CAM_REQ_ABORTED) &lt; 0)\n"
"            /* no such CCB in our queue */\n"
"            ccb-&gt;ccb_h.status = CAM_PATH_INVALID;\n"
"        else\n"
"            ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"        xpt_done(ccb);\n"
"        return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20579
#, fuzzy
msgid ""
"<emphasis>XPT_SET_TRAN_SETTINGS</emphasis> - explicitly set values of SCSI "
"transfer settings"
msgstr ""
" <emphasis> XPT_SET_TRAN_SETTINGS </emphasis> - definir explicitamente "
"valores de configura��es de transfer�ncia SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20582
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct "
"ccb_trans_setting cts</quote> of the union ccb:"
msgstr ""
"Os argumentos s�o transferidos na inst�ncia <quote> struct ccb_trans_setting "
"cts </quote> da uni�o ccb: "

#. (itstool) path: listitem/para
#: book.translate.xml:20588
#, fuzzy
msgid ""
"<emphasis>valid</emphasis> - a bitmask showing which settings should be "
"updated:"
msgstr ""
" <emphasis> v�lido </emphasis> - uma bitmask mostrando quais configura��es "
"devem ser atualizadas: "

#. (itstool) path: listitem/para
#: book.translate.xml:20593
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_SYNC_RATE_VALID</emphasis> - synchronous transfer rate"
msgstr ""
" <emphasis> CCB_TRANS_SYNC_RATE_VALID </emphasis> - taxa de transfer�ncia "
"s�ncrona "

#. (itstool) path: listitem/para
#: book.translate.xml:20598
#, fuzzy
msgid "<emphasis>CCB_TRANS_SYNC_OFFSET_VALID</emphasis> - synchronous offset"
msgstr ""
" <emphasis> CCB_TRANS_SYNC_OFFSET_VALID </emphasis> - deslocamento s�ncrono "

#. (itstool) path: listitem/para
#: book.translate.xml:20603
#, fuzzy
msgid "<emphasis>CCB_TRANS_BUS_WIDTH_VALID</emphasis> - bus width"
msgstr " <emphasis> CCB_TRANS_BUS_WIDTH_VALID </emphasis> - largura do �nibus"

#. (itstool) path: listitem/para
#: book.translate.xml:20608
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_DISC_VALID</emphasis> - set enable/disable disconnection"
msgstr ""
" <emphasis> CCB_TRANS_DISC_VALID </emphasis> - definir ativar / desativar a "
"desconex�o "

#. (itstool) path: listitem/para
#: book.translate.xml:20613
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_TQ_VALID</emphasis> - set enable/disable tagged queuing"
msgstr ""
" <emphasis> CCB_TRANS_TQ_VALID </emphasis> - definir ativar / desativar "
"enfileiramento marcado "

#. (itstool) path: listitem/para
#: book.translate.xml:20618
#, fuzzy
msgid ""
"<emphasis>flags</emphasis> - consists of two parts, binary arguments and "
"identification of sub-operations. The binary arguments are:"
msgstr ""
" <emphasis> bandeiras </emphasis> - consiste em duas partes, argumentos "
"bin�rios e identifica��o de subopera��es. Os argumentos bin�rios s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:20624
#, fuzzy
msgid "<emphasis>CCB_TRANS_DISC_ENB</emphasis> - enable disconnection"
msgstr " <emphasis> CCB_TRANS_DISC_ENB </emphasis> - habilitar a desconex�o "

#. (itstool) path: listitem/para
#: book.translate.xml:20629
#, fuzzy
msgid "<emphasis>CCB_TRANS_TAG_ENB</emphasis> - enable tagged queuing"
msgstr ""
" <emphasis> CCB_TRANS_TAG_ENB </emphasis> - ativar enfileiramento marcado "

#. (itstool) path: listitem/para
#: book.translate.xml:20636
#, fuzzy
msgid "the sub-operations are:"
msgstr "as subopera��es s�o:"

#. (itstool) path: listitem/para
#: book.translate.xml:20640
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_CURRENT_SETTINGS</emphasis> - change the current "
"negotiations"
msgstr ""
" <emphasis> CCB_TRANS_CURRENT_SETTINGS </emphasis> - mudar as negocia��es "
"atuais "

#. (itstool) path: listitem/para
#: book.translate.xml:20645
#, fuzzy
msgid ""
"<emphasis>CCB_TRANS_USER_SETTINGS</emphasis> - remember the desired user "
"values sync_period, sync_offset - self-explanatory, if sync_offset==0 then "
"the asynchronous mode is requested bus_width - bus width, in bits (not "
"bytes)"
msgstr ""
" <emphasis> CCB_TRANS_USER_SETTINGS </emphasis> - lembre-se dos valores de "
"usu�rio desejados sync_period, sync_offset - autoexplicativos, se "
"sync_offset == 0 ent�o o modo ass�ncrono � solicitado bus_width - largura do "
"barramento, em bits (n�o bytes) "

#. (itstool) path: listitem/para
#: book.translate.xml:20655
#, fuzzy
msgid ""
"Two sets of negotiated parameters are supported, the user settings and the "
"current settings. The user settings are not really used much in the SIM "
"drivers, this is mostly just a piece of memory where the upper levels can "
"store (and later recall) its ideas about the parameters. Setting the user "
"parameters does not cause re-negotiation of the transfer rates. But when the "
"SCSI controller does a negotiation it must never set the values higher than "
"the user parameters, so it is essentially the top boundary."
msgstr ""
"Dois conjuntos de par�metros negociados s�o suportados, as configura��es do "
"usu�rio e as configura��es atuais. As configura��es do usu�rio n�o s�o muito "
"usadas nos drivers do SIM, isso � apenas uma parte da mem�ria onde os n�veis "
"superiores podem armazenar (e mais tarde chamar) id�ias sobre os par�metros. "
"Definir os par�metros do usu�rio n�o causa renegocia��o das taxas de "
"transfer�ncia. Mas quando o controlador SCSI faz uma negocia��o, ele nunca "
"deve definir os valores mais altos que os par�metros do usu�rio, portanto, � "
"essencialmente o limite superior. "

#. (itstool) path: listitem/para
#: book.translate.xml:20666
#, fuzzy
msgid ""
"The current settings are, as the name says, current. Changing them means "
"that the parameters must be re-negotiated on the next transfer. Again, these "
"<quote>new current settings</quote> are not supposed to be forced on the "
"device, just they are used as the initial step of negotiations. Also they "
"must be limited by actual capabilities of the SCSI controller: for example, "
"if the SCSI controller has 8-bit bus and the request asks to set 16-bit wide "
"transfers this parameter must be silently truncated to 8-bit transfers "
"before sending it to the device."
msgstr ""
"As configura��es atuais s�o, como o nome diz, atuais. Alter�-las significa "
"que os par�metros devem ser renegociados na pr�xima transfer�ncia. "
"Novamente, esses <quote> novas configura��es atuais </quote> N�o � suposto "
"ser for�ado no dispositivo, apenas eles s�o usados ​​como o passo inicial "
"das negocia��es. Al�m disso, eles devem ser limitados pelos recursos reais "
"do controlador SCSI: por exemplo, se o controlador SCSI tiver um barramento "
"de 8 bits e a solicita��o solicitar a configura��o de transfer�ncias de 16 "
"bits, esse par�metro deve ser silenciosamente truncado para transfer�ncias "
"de 8 bits antes de envi�-lo para o dispositivo. "

#. (itstool) path: listitem/para
#: book.translate.xml:20678
#, fuzzy
msgid ""
"One caveat is that the bus width and synchronous parameters are per target "
"while the disconnection and tag enabling parameters are per lun."
msgstr ""
"Uma ressalva � que a largura do barramento e os par�metros s�ncronos s�o por "
"alvo enquanto os par�metros de habilita��o de desconex�o e tag s�o por lun."

#. (itstool) path: listitem/para
#: book.translate.xml:20682
#, fuzzy
msgid ""
"The recommended implementation is to keep 3 sets of negotiated (bus width "
"and synchronous transfer) parameters:"
msgstr ""
"A implementa��o recomendada � manter 3 conjuntos de par�metros negociados "
"(largura de barramento e transfer�ncia s�ncrona):"

#. (itstool) path: listitem/para
#: book.translate.xml:20688
#, fuzzy
msgid "<emphasis>user</emphasis> - the user set, as above"
msgstr ""
" <emphasis> do utilizador </emphasis> - o usu�rio definido, como acima "

#. (itstool) path: listitem/para
#: book.translate.xml:20693
#, fuzzy
msgid "<emphasis>current</emphasis> - those actually in effect"
msgstr " <emphasis> atual </emphasis> - aqueles realmente em vigor "

#. (itstool) path: listitem/para
#: book.translate.xml:20698
#, fuzzy
msgid ""
"<emphasis>goal</emphasis> - those requested by setting of the "
"<quote>current</quote> parameters"
msgstr ""
" <emphasis> objetivo </emphasis> - os pedidos pela fixa��o do <quote> atual "
"</quote> par�metros "

#. (itstool) path: listitem/para
#: book.translate.xml:20704
#, fuzzy
msgid "The code looks like:"
msgstr "O c�digo parece:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20706
#, no-wrap
msgid ""
"    struct ccb_trans_settings *cts;\n"
"    int targ, lun;\n"
"    int flags;\n"
"\n"
"    cts = &amp;ccb-&gt;cts;\n"
"    targ = ccb_h-&gt;target_id;\n"
"    lun = ccb_h-&gt;target_lun;\n"
"    flags = cts-&gt;flags;\n"
"    if(flags &amp; CCB_TRANS_USER_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;goal_sync_period[targ] =\n"
"                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;goal_sync_offset[targ] =\n"
"                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, "
"OUR_BUS_WIDTH);\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    struct ccb_trans_settings *cts;\n"
"    int targ, lun;\n"
"    int flags;\n"
"\n"
"    cts = &amp;ccb-&gt;cts;\n"
"    targ = ccb_h-&gt;target_id;\n"
"    lun = ccb_h-&gt;target_lun;\n"
"    flags = cts-&gt;flags;\n"
"    if(flags &amp; CCB_TRANS_USER_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;user_sync_period[targ] = cts-&gt;sync_period;\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;user_sync_offset[targ] = cts-&gt;sync_offset;\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;user_bus_width[targ] = cts-&gt;bus_width;\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;user_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;user_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    if(flags &amp; CCB_TRANS_CURRENT_SETTINGS) {\n"
"        if(flags &amp; CCB_TRANS_SYNC_RATE_VALID)\n"
"            softc-&gt;goal_sync_period[targ] =\n"
"                max(cts-&gt;sync_period, OUR_MIN_SUPPORTED_PERIOD);\n"
"        if(flags &amp; CCB_TRANS_SYNC_OFFSET_VALID)\n"
"            softc-&gt;goal_sync_offset[targ] =\n"
"                min(cts-&gt;sync_offset, OUR_MAX_SUPPORTED_OFFSET);\n"
"        if(flags &amp; CCB_TRANS_BUS_WIDTH_VALID)\n"
"            softc-&gt;goal_bus_width[targ] = min(cts-&gt;bus_width, "
"OUR_BUS_WIDTH);\n"
"\n"
"        if(flags &amp; CCB_TRANS_DISC_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_DISC_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_DISC_ENB;\n"
"        }\n"
"        if(flags &amp; CCB_TRANS_TQ_VALID) {\n"
"            softc-&gt;current_tflags[targ][lun] &amp;= ~CCB_TRANS_TQ_ENB;\n"
"            softc-&gt;current_tflags[targ][lun] |= flags &amp; "
"CCB_TRANS_TQ_ENB;\n"
"        }\n"
"    }\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20754
#, fuzzy
msgid ""
"Then when the next I/O request will be processed it will check if it has to "
"re-negotiate, for example by calling the function target_negotiated(hcb). It "
"can be implemented like this:"
msgstr ""
"Ent�o, quando a pr�xima requisi��o de I / O for processada, ela verificar� "
"se ela precisa renegociar, por exemplo, chamando a fun��o target_negotiated "
"(hcb). Ela pode ser implementada assim:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20759
#, no-wrap
msgid ""
"    int\n"
"    target_negotiated(struct xxx_hcb *hcb)\n"
"    {\n"
"        struct softc *softc = hcb-&gt;softc;\n"
"        int targ = hcb-&gt;targ;\n"
"\n"
"        if( softc-&gt;current_sync_period[targ] != softc-"
"&gt;goal_sync_period[targ]\n"
"        || softc-&gt;current_sync_offset[targ] != softc-"
"&gt;goal_sync_offset[targ]\n"
"        || softc-&gt;current_bus_width[targ] != softc-"
"&gt;goal_bus_width[targ] )\n"
"            return 0; /* FALSE */\n"
"        else\n"
"            return 1; /* TRUE */\n"
"    }"
msgstr ""
"    int\n"
"    target_negotiated(struct xxx_hcb *hcb)\n"
"    {\n"
"        struct softc *softc = hcb-&gt;softc;\n"
"        int targ = hcb-&gt;targ;\n"
"\n"
"        if( softc-&gt;current_sync_period[targ] != softc-"
"&gt;goal_sync_period[targ]\n"
"        || softc-&gt;current_sync_offset[targ] != softc-"
"&gt;goal_sync_offset[targ]\n"
"        || softc-&gt;current_bus_width[targ] != softc-"
"&gt;goal_bus_width[targ] )\n"
"            return 0; /* FALSE */\n"
"        else\n"
"            return 1; /* TRUE */\n"
"    }"

#. (itstool) path: listitem/para
#: book.translate.xml:20773
#, fuzzy
msgid ""
"After the values are re-negotiated the resulting values must be assigned to "
"both current and goal parameters, so for future I/O transactions the current "
"and goal parameters would be the same and <function>target_negotiated()</"
"function> would return TRUE. When the card is initialized (in "
"<function>xxx_attach()</function>) the current negotiation values must be "
"initialized to narrow asynchronous mode, the goal and current values must be "
"initialized to the maximal values supported by controller."
msgstr ""
"Depois que os valores s�o renegociados, os valores resultantes devem ser "
"atribu�dos aos par�metros atuais e de meta, portanto, para futuras "
"transa��es de E / S, os par�metros atuais e de meta seriam os mesmos e "
"<function> target_negotiated () </function> retornaria TRUE. Quando o cart�o "
"� inicializado (em <function> xxx_attach () </function> ) os valores de "
"negocia��o atuais devem ser inicializados para restringir o modo ass�ncrono, "
"a meta e os valores atuais devem ser inicializados para os valores m�ximos "
"suportados pelo controlador. "

#. (itstool) path: listitem/para
#: book.translate.xml:20784
#, fuzzy
msgid ""
"<emphasis>XPT_GET_TRAN_SETTINGS</emphasis> - get values of SCSI transfer "
"settings"
msgstr ""
" <emphasis> XPT_GET_TRAN_SETTINGS </emphasis> - obter valores de "
"configura��es de transfer�ncia SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:20787
#, fuzzy
msgid ""
"This operations is the reverse of XPT_SET_TRAN_SETTINGS. Fill up the CCB "
"instance <quote>struct ccb_trans_setting cts</quote> with data as requested "
"by the flags CCB_TRANS_CURRENT_SETTINGS or CCB_TRANS_USER_SETTINGS (if both "
"are set then the existing drivers return the current settings). Set all the "
"bits in the valid field."
msgstr ""
"Esta opera��o � o contr�rio de XPT_SET_TRAN_SETTINGS. Preencha a inst�ncia "
"do CCB <quote> struct ccb_trans_setting cts </quote> com dados conforme "
"solicitado pelos sinalizadores CCB_TRANS_CURRENT_SETTINGS ou "
"CCB_TRANS_USER_SETTINGS (se ambos estiverem configurados, os drivers "
"existentes retornar�o as configura��es atuais). Defina todos os bits no "
"campo v�lido. "

#. (itstool) path: listitem/para
#: book.translate.xml:20795
#, fuzzy
msgid ""
"<emphasis>XPT_CALC_GEOMETRY</emphasis> - calculate logical (BIOS)<_:"
"indexterm-1/> geometry of the disk"
msgstr ""
" <emphasis> XPT_CALC_GEOMETRY </emphasis> - calcular l�gica (BIOS) <_: "
"indexterm-1 /> geometria do disco "

#. (itstool) path: listitem/para
#: book.translate.xml:20799
#, fuzzy
msgid ""
"The arguments are transferred in the instance <quote>struct "
"ccb_calc_geometry ccg</quote> of the union ccb:"
msgstr ""
"Os argumentos s�o transferidos na inst�ncia <quote> struct ccb_calc_geometry "
"ccg </quote> da uni�o ccb: "

#. (itstool) path: listitem/para
#: book.translate.xml:20806
#, fuzzy
msgid ""
"<emphasis>block_size</emphasis> - input, block (A.K.A sector) size in bytes"
msgstr ""
" <emphasis> tamanho do bloco </emphasis> - entrada, bloco (setor AKA) "
"tamanho em bytes "

#. (itstool) path: listitem/para
#: book.translate.xml:20811
#, fuzzy
msgid "<emphasis>volume_size</emphasis> - input, volume size in bytes"
msgstr ""
" <emphasis> volume_size </emphasis> - entrada, tamanho do volume em bytes "

#. (itstool) path: listitem/para
#: book.translate.xml:20816
#, fuzzy
msgid "<emphasis>cylinders</emphasis> - output, logical cylinders"
msgstr " <emphasis> cilindros </emphasis> - sa�da, cilindros l�gicos "

#. (itstool) path: listitem/para
#: book.translate.xml:20821
#, fuzzy
msgid "<emphasis>heads</emphasis> - output, logical heads"
msgstr " <emphasis> cabe�as </emphasis> - sa�da, cabe�as l�gicas "

#. (itstool) path: listitem/para
#: book.translate.xml:20826
#, fuzzy
msgid ""
"<emphasis>secs_per_track</emphasis> - output, logical sectors per track"
msgstr ""
" <emphasis> secs_per_track </emphasis> - sa�da, setores l�gicos por trilha "

#. (itstool) path: para/indexterm
#: book.translate.xml:20832
#, fuzzy
msgid "<primary>SCSI</primary> <secondary>BIOS</secondary>"
msgstr " <primary> SCSI </primary><secondary> BIOS </secondary> "

#. (itstool) path: listitem/para
#: book.translate.xml:20831
#, fuzzy
msgid ""
"If the returned geometry differs much enough from what the SCSI controller "
"BIOS<_:indexterm-1/> thinks and a disk on this SCSI controller is used as "
"bootable the system may not be able to boot. The typical calculation example "
"taken from the aic7xxx driver is:"
msgstr ""
"Se a geometria retornada difere o suficiente do que o BIOS do controlador "
"SCSI <_: indexterm-1 /> pensa e um disco neste controlador SCSI � usado como "
"inicializ�vel, o sistema pode n�o ser capaz de inicializar. O exemplo de "
"c�lculo t�pico obtido do driver aic7xxx �: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20838
#, no-wrap
msgid ""
"    struct    ccb_calc_geometry *ccg;\n"
"    u_int32_t size_mb;\n"
"    u_int32_t secs_per_cylinder;\n"
"    int   extended;\n"
"\n"
"    ccg = &amp;ccb-&gt;ccg;\n"
"    size_mb = ccg-&gt;volume_size\n"
"        / ((1024L * 1024L) / ccg-&gt;block_size);\n"
"    extended = check_cards_EEPROM_for_extended_geometry(softc);\n"
"\n"
"    if (size_mb &gt; 1024 &amp;&amp; extended) {\n"
"        ccg-&gt;heads = 255;\n"
"        ccg-&gt;secs_per_track = 63;\n"
"    } else {\n"
"        ccg-&gt;heads = 64;\n"
"        ccg-&gt;secs_per_track = 32;\n"
"    }\n"
"    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;\n"
"    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"
msgstr ""
"    struct    ccb_calc_geometry *ccg;\n"
"    u_int32_t size_mb;\n"
"    u_int32_t secs_per_cylinder;\n"
"    int   extended;\n"
"\n"
"    ccg = &amp;ccb-&gt;ccg;\n"
"    size_mb = ccg-&gt;volume_size\n"
"        / ((1024L * 1024L) / ccg-&gt;block_size);\n"
"    extended = check_cards_EEPROM_for_extended_geometry(softc);\n"
"\n"
"    if (size_mb &gt; 1024 &amp;&amp; extended) {\n"
"        ccg-&gt;heads = 255;\n"
"        ccg-&gt;secs_per_track = 63;\n"
"    } else {\n"
"        ccg-&gt;heads = 64;\n"
"        ccg-&gt;secs_per_track = 32;\n"
"    }\n"
"    secs_per_cylinder = ccg-&gt;heads * ccg-&gt;secs_per_track;\n"
"    ccg-&gt;cylinders = ccg-&gt;volume_size / secs_per_cylinder;\n"
"    ccb-&gt;ccb_h.status = CAM_REQ_CMP;\n"
"    xpt_done(ccb);\n"
"    return;"

#. (itstool) path: listitem/para
#: book.translate.xml:20861
#, fuzzy
msgid ""
"This gives the general idea, the exact calculation depends on the quirks of "
"the particular BIOS. If BIOS provides no way set the <quote>extended "
"translation</quote> flag in EEPROM this flag should normally be assumed "
"equal to 1. Other popular geometries are:"
msgstr ""
"Isso d� a id�ia geral, o c�lculo exato depende das peculiaridades do BIOS em "
"particular. Se o BIOS n�o fornece nenhuma maneira de definir o <quote> "
"tradu��o estendida </quote> flag na EEPROM este sinalizador deve normalmente "
"ser assumido igual a 1. Outras geometrias populares s�o: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:20867
#, no-wrap
msgid ""
"    128 heads, 63 sectors - Symbios controllers\n"
"    16 heads, 63 sectors - old controllers"
msgstr ""
"    128 heads, 63 sectors - Symbios controllers\n"
"    16 heads, 63 sectors - old controllers"

#. (itstool) path: listitem/para
#: book.translate.xml:20870
#, fuzzy
msgid ""
"Some system BIOSes and SCSI BIOSes fight with each other with variable "
"success, for example a combination of Symbios 875/895 SCSI and Phoenix BIOS "
"can give geometry 128/63 after power up and 255/63 after a hard reset or "
"soft reboot."
msgstr ""
"Algumas BIOS de sistema e BIOS SCSI lutam entre si com sucesso vari�vel, por "
"exemplo, uma combina��o de Symbios 875/895 SCSI e Phoenix BIOS pode fornecer "
"uma geometria de 128/63 ap�s a energiza��o e 255/63 ap�s uma reinicializa��o "
"a frio ou reinicializa��o suave."

#. (itstool) path: listitem/para
#: book.translate.xml:20878
#, fuzzy
msgid ""
"<emphasis>XPT_PATH_INQ</emphasis> - path inquiry, in other words get the SIM "
"driver and SCSI controller (also known as HBA - Host Bus Adapter) properties"
msgstr ""
" <emphasis> XPT_PATH_INQ </emphasis> - consulta de caminho, em outras "
"palavras, obtenha o driver SIM e as propriedades do controlador SCSI (tamb�m "
"conhecido como HBA - Host Bus Adapter) "

#. (itstool) path: listitem/para
#: book.translate.xml:20882
#, fuzzy
msgid ""
"The properties are returned in the instance <quote>struct ccb_pathinq cpi</"
"quote> of the union ccb:"
msgstr ""
"As propriedades s�o retornadas na inst�ncia <quote> struct ccb_pathinq cpi </"
"quote> da uni�o ccb: "

#. (itstool) path: listitem/para
#: book.translate.xml:20888
#, fuzzy
msgid "version_num - the SIM driver version number, now all drivers use 1"
msgstr ""
"version_num - o n�mero da vers�o do driver do SIM, agora todos os drivers "
"usam 1"

#. (itstool) path: listitem/para
#: book.translate.xml:20893
#, fuzzy
msgid "hba_inquiry - bitmask of features supported by the controller:"
msgstr "hba_inquiry - bitmask de recursos suportados pelo controlador:"

#. (itstool) path: listitem/para
#: book.translate.xml:20898
#, fuzzy
msgid "PI_MDP_ABLE - supports MDP message (something from SCSI3?)"
msgstr "PI_MDP_ABLE - suporta mensagem MDP (algo do SCSI3?)"

#. (itstool) path: listitem/para
#: book.translate.xml:20903
#, fuzzy
msgid "PI_WIDE_32 - supports 32 bit wide SCSI"
msgstr "PI_WIDE_32 - suporta SCSI de 32 bits de largura"

#. (itstool) path: listitem/para
#: book.translate.xml:20908
#, fuzzy
msgid "PI_WIDE_16 - supports 16 bit wide SCSI"
msgstr "PI_WIDE_16 - suporta SCSI de 16 bits de largura"

#. (itstool) path: listitem/para
#: book.translate.xml:20913
#, fuzzy
msgid "PI_SDTR_ABLE - can negotiate synchronous transfer rate"
msgstr "PI_SDTR_ABLE - pode negociar taxa de transfer�ncia s�ncrona"

#. (itstool) path: listitem/para
#: book.translate.xml:20918
#, fuzzy
msgid "PI_LINKED_CDB - supports linked commands"
msgstr "PI_LINKED_CDB - suporta comandos vinculados"

#. (itstool) path: listitem/para
#: book.translate.xml:20923
#, fuzzy
msgid "PI_TAG_ABLE - supports tagged commands"
msgstr "PI_TAG_ABLE - suporta comandos marcados"

#. (itstool) path: listitem/para
#: book.translate.xml:20928
#, fuzzy
msgid ""
"PI_SOFT_RST - supports soft reset alternative (hard reset and soft reset are "
"mutually exclusive within a SCSI bus)"
msgstr ""
"PI_SOFT_RST - suporta alternativa de redefini��o suave (hard reset e soft "
"reset s�o mutuamente exclusivos dentro de um barramento SCSI)"

#. (itstool) path: listitem/para
#: book.translate.xml:20934
#, fuzzy
msgid "target_sprt - flags for target mode support, 0 if unsupported"
msgstr ""
"target_sprt - sinalizadores para suporte ao modo de destino, 0 se n�o "
"suportado"

#. (itstool) path: listitem/para
#: book.translate.xml:20939
#, fuzzy
msgid "hba_misc - miscellaneous controller features:"
msgstr "hba_misc - recursos diversos do controlador:"

#. (itstool) path: listitem/para
#: book.translate.xml:20944
#, fuzzy
msgid "PIM_SCANHILO - bus scans from high ID to low ID"
msgstr "PIM_SCANHILO - bus varre de alta identifica��o para baixa ID"

#. (itstool) path: listitem/para
#: book.translate.xml:20949
#, fuzzy
msgid "PIM_NOREMOVE - removable devices not included in scan"
msgstr "PIM_NOREMOVE - dispositivos remov�veis n�o inclu�dos na verifica��o"

#. (itstool) path: listitem/para
#: book.translate.xml:20954
#, fuzzy
msgid "PIM_NOINITIATOR - initiator role not supported"
msgstr "PIM_NOINITIATOR - fun��o do iniciador n�o suportada"

#. (itstool) path: listitem/para
#: book.translate.xml:20959
#, fuzzy
msgid "PIM_NOBUSRESET - user has disabled initial BUS RESET"
msgstr "PIM_NOBUSRESET - usu�rio desabilitou inicial BUS RESET"

#. (itstool) path: listitem/para
#: book.translate.xml:20964
#, fuzzy
msgid ""
"hba_eng_cnt - mysterious HBA engine count, something related to compression, "
"now is always set to 0"
msgstr ""
"hba_eng_cnt - misteriosa contagem de mecanismos do HBA, algo relacionado � "
"compacta��o, agora est� sempre definido como 0"

#. (itstool) path: listitem/para
#: book.translate.xml:20969
#, fuzzy
msgid "vuhba_flags - vendor-unique flags, unused now"
msgstr "vuhba_flags - bandeiras exclusivas de fornecedores, n�o usadas agora"

#. (itstool) path: listitem/para
#: book.translate.xml:20973
#, fuzzy
msgid ""
"max_target - maximal supported target ID (7 for 8-bit bus, 15 for 16-bit "
"bus, 127 for Fibre Channel)"
msgstr ""
"max_target - ID de alvo suportado maximal (7 para bus de 8 bits, 15 para bus "
"de 16 bits, 127 para o Fibre Channel)"

#. (itstool) path: listitem/para
#: book.translate.xml:20979
#, fuzzy
msgid ""
"max_lun - maximal supported LUN ID (7 for older SCSI controllers, 63 for "
"newer ones)"
msgstr ""
"max_lun - maximal LUN ID suportado (7 para controladores SCSI mais antigos, "
"63 para os mais novos)"

#. (itstool) path: listitem/para
#: book.translate.xml:20984
#, fuzzy
msgid "async_flags - bitmask of installed Async handler, unused now"
msgstr "async_flags - bitmask do manipulador Async instalado, n�o usado agora"

#. (itstool) path: listitem/para
#: book.translate.xml:20989
#, fuzzy
msgid "hpath_id - highest Path ID in the subsystem, unused now"
msgstr "hpath_id - maior ID do caminho no subsistema, n�o usado agora"

#. (itstool) path: listitem/para
#: book.translate.xml:20994
#, fuzzy
msgid "unit_number - the controller unit number, cam_sim_unit(sim)"
msgstr "unit_number - o n�mero da unidade controladora, cam_sim_unit (sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:20999
#, fuzzy
msgid "bus_id - the bus number, cam_sim_bus(sim)"
msgstr "bus_id - o n�mero do barramento, cam_sim_bus (sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21003
#, fuzzy
msgid "initiator_id - the SCSI ID of the controller itself"
msgstr "initiator_id - o ID SCSI do pr�prio controlador"

#. (itstool) path: listitem/para
#: book.translate.xml:21008
#, fuzzy
msgid ""
"base_transfer_speed - nominal transfer speed in KB/s for asynchronous narrow "
"transfers, equals to 3300 for SCSI"
msgstr ""
"base_transfer_speed - velocidade de transfer�ncia nominal em KB / s para "
"transfer�ncias estreitas ass�ncronas, igual a 3300 para SCSI"

#. (itstool) path: listitem/para
#: book.translate.xml:21014
#, fuzzy
msgid ""
"sim_vid - SIM driver's vendor id, a zero-terminated string of maximal length "
"SIM_IDLEN including the terminating zero"
msgstr ""
"sim_vid - ID do fornecedor do driver SIM, uma string terminada em zero de "
"comprimento m�ximo SIM_IDLEN incluindo o zero de finaliza��o"

#. (itstool) path: listitem/para
#: book.translate.xml:21020
#, fuzzy
msgid ""
"hba_vid - SCSI controller's vendor id, a zero-terminated string of maximal "
"length HBA_IDLEN including the terminating zero"
msgstr ""
"hba_vid - ID do fornecedor do controlador SCSI, uma cadeia terminada em zero "
"de comprimento m�ximo HBA_IDLEN incluindo o zero de finaliza��o"

#. (itstool) path: listitem/para
#: book.translate.xml:21026
#, fuzzy
msgid ""
"dev_name - device driver name, a zero-terminated string of maximal length "
"DEV_IDLEN including the terminating zero, equal to cam_sim_name(sim)"
msgstr ""
"dev_name - nome do driver de dispositivo, uma cadeia terminada em zero de "
"comprimento m�ximo DEV_IDLEN incluindo o zero final, igual a cam_sim_name "
"(sim)"

#. (itstool) path: listitem/para
#: book.translate.xml:21032
#, fuzzy
msgid ""
"The recommended way of setting the string fields is using strncpy, like:"
msgstr ""
"A maneira recomendada de configurar os campos de string � usando strncpy, "
"como:"

#. (itstool) path: listitem/programlisting
#: book.translate.xml:21035
#, no-wrap
msgid "    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);"
msgstr "    strncpy(cpi-&gt;dev_name, cam_sim_name(sim), DEV_IDLEN);"

#. (itstool) path: listitem/para
#: book.translate.xml:21037
#, fuzzy
msgid ""
"After setting the values set the status to CAM_REQ_CMP and mark the CCB as "
"done."
msgstr ""
"Depois de definir os valores, defina o status como CAM_REQ_CMP e marque o "
"CCB como conclu�do."

#. (itstool) path: sect1/title
#: book.translate.xml:21044
#, fuzzy
msgid "Polling"
msgstr "Polling"

#. (itstool) path: sect1/para
#: book.translate.xml:21057
#, fuzzy
msgid ""
"The poll function is used to simulate the interrupts when the interrupt "
"subsystem is not functioning (for example, when the system has crashed and "
"is creating the system dump). The CAM subsystem sets the proper interrupt "
"level before calling the poll routine. So all it needs to do is to call the "
"interrupt routine (or the other way around, the poll routine may be doing "
"the real action and the interrupt routine would just call the poll routine). "
"Why bother about a separate function then? Because of different calling "
"conventions. The <function>xxx_poll</function> routine gets the struct "
"cam_sim pointer as its argument when the PCI interrupt routine by common "
"convention gets pointer to the struct <varname remap="
"\"structname\">xxx_softc</varname> and the ISA interrupt routine gets just "
"the device unit number. So the poll routine would normally look as:"
msgstr ""
"A fun��o de pesquisa � usada para simular as interrup��es quando o "
"subsistema de interrup��o n�o est� funcionando (por exemplo, quando o "
"sistema travou e est� criando o dump do sistema). O subsistema CAM define o "
"n�vel de interrup��o adequado antes de chamar a rotina de pesquisa. ele "
"precisa fazer � chamar a rotina de interrup��o (ou vice-versa, a rotina de "
"poll pode estar fazendo a a��o real e a rotina de interrup��o apenas "
"chamaria a rotina de poll) Por que se preocupar com uma fun��o separada "
"ent�o? conven��es. <function> xxx_poll </function> rotina obt�m o ponteiro "
"struct cam_sim como seu argumento quando a rotina de interrup��o PCI por "
"conven��o comum obt�m ponteiro para a estrutura <varname remap="
"\"structname\"> xxx_softc </varname> e a rotina de interrup��o ISA obt�m "
"apenas o n�mero da unidade do dispositivo. Ent�o a rotina de pesquisa "
"normalmente seria como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21073
#, no-wrap
msgid ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */\n"
"}"
msgstr ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr((struct xxx_softc *)cam_sim_softc(sim)); /* for PCI device */\n"
"}"

#. (itstool) path: sect1/para
#: book.translate.xml:21079
#, fuzzy
msgid "or"
msgstr "ou"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21081
#, no-wrap
msgid ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr(cam_sim_unit(sim)); /* for ISA device */\n"
"}"
msgstr ""
"static void\n"
"xxx_poll(struct cam_sim *sim)\n"
"{\n"
"    xxx_intr(cam_sim_unit(sim)); /* for ISA device */\n"
"}"

#. (itstool) path: sect1/title
#: book.translate.xml:21089
#, fuzzy
msgid "Asynchronous Events"
msgstr "Eventos ass�ncronos"

#. (itstool) path: sect1/para
#: book.translate.xml:21091
#, fuzzy
msgid ""
"If an asynchronous event callback has been set up then the callback function "
"should be defined."
msgstr ""
"Se um retorno de chamada de evento ass�ncrono tiver sido configurado, a "
"fun��o de retorno de chamada dever� ser definida."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21094
#, no-wrap
msgid ""
"static void\n"
"ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void "
"*arg)"
msgstr ""
"static void\n"
"ahc_async(void *callback_arg, u_int32_t code, struct cam_path *path, void "
"*arg)"

#. (itstool) path: listitem/para
#: book.translate.xml:21099
#, fuzzy
msgid "callback_arg - the value supplied when registering the callback"
msgstr "callback_arg - o valor fornecido ao registrar o retorno de chamada"

#. (itstool) path: listitem/para
#: book.translate.xml:21104
#, fuzzy
msgid "code - identifies the type of event"
msgstr "c�digo - identifica o tipo de evento"

#. (itstool) path: listitem/para
#: book.translate.xml:21108
#, fuzzy
msgid "path - identifies the devices to which the event applies"
msgstr "caminho - identifica os dispositivos aos quais o evento se aplica"

#. (itstool) path: listitem/para
#: book.translate.xml:21113
#, fuzzy
msgid "arg - event-specific argument"
msgstr "arg - argumento espec�fico do evento"

#. (itstool) path: sect1/para
#: book.translate.xml:21117
#, fuzzy
msgid "Implementation for a single type of event, AC_LOST_DEVICE, looks like:"
msgstr ""
"Implementa��o para um �nico tipo de evento, AC_LOST_DEVICE, se parece com:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21120
#, no-wrap
msgid ""
"    struct xxx_softc *softc;\n"
"    struct cam_sim *sim;\n"
"    int targ;\n"
"    struct ccb_trans_settings neg;\n"
"\n"
"    sim = (struct cam_sim *)callback_arg;\n"
"    softc = (struct xxx_softc *)cam_sim_softc(sim);\n"
"    switch (code) {\n"
"    case AC_LOST_DEVICE:\n"
"        targ = xpt_path_target_id(path);\n"
"        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {\n"
"            clean_negotiations(softc, targ);\n"
"            /* send indication to CAM */\n"
"            neg.bus_width = 8;\n"
"            neg.sync_period = neg.sync_offset = 0;\n"
"            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"        }\n"
"        break;\n"
"    default:\n"
"        break;\n"
"    }"
msgstr ""
"    struct xxx_softc *softc;\n"
"    struct cam_sim *sim;\n"
"    int targ;\n"
"    struct ccb_trans_settings neg;\n"
"\n"
"    sim = (struct cam_sim *)callback_arg;\n"
"    softc = (struct xxx_softc *)cam_sim_softc(sim);\n"
"    switch (code) {\n"
"    case AC_LOST_DEVICE:\n"
"        targ = xpt_path_target_id(path);\n"
"        if(targ &lt;= OUR_MAX_SUPPORTED_TARGET) {\n"
"            clean_negotiations(softc, targ);\n"
"            /* send indication to CAM */\n"
"            neg.bus_width = 8;\n"
"            neg.sync_period = neg.sync_offset = 0;\n"
"            neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"                | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"            xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"        }\n"
"        break;\n"
"    default:\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21148
#, fuzzy
msgid "<primary>SCSI</primary><secondary>interrupts</secondary>"
msgstr " <primary> SCSI </primary><secondary> interrompe </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21150
#, fuzzy
msgid ""
"The exact type of the interrupt routine depends on the type of the "
"peripheral bus (PCI, ISA and so on) to which the SCSI controller is "
"connected."
msgstr ""
"O tipo exato da rotina de interrup��o depende do tipo de barramento do "
"perif�rico (PCI, ISA e assim por diante) ao qual o controlador SCSI est� "
"conectado."

#. (itstool) path: sect1/para
#: book.translate.xml:21154
#, fuzzy
msgid ""
"The interrupt routines of the SIM drivers run at the interrupt level splcam. "
"So <function>splcam()</function> should be used in the driver to synchronize "
"activity between the interrupt routine and the rest of the driver (for a "
"multiprocessor-aware driver things get yet more interesting but we ignore "
"this case here). The pseudo-code in this document happily ignores the "
"problems of synchronization. The real code must not ignore them. A simple-"
"minded approach is to set <function>splcam()</function> on the entry to the "
"other routines and reset it on return thus protecting them by one big "
"critical section. To make sure that the interrupt level will be always "
"restored a wrapper function can be defined, like:"
msgstr ""
"As rotinas de interrup��o dos drivers SIM s�o executadas no splcam do n�vel "
"de interrup��o. <function> splcam () </function> deve ser usado no driver "
"para sincronizar a atividade entre a rotina de interrup��o e o restante do "
"driver (para um driver com reconhecimento de multiprocessador, as coisas "
"ficam ainda mais interessantes, mas ignoramos este caso aqui). O pseudo-"
"c�digo neste documento ignora felizmente os problemas de sincroniza��o. O "
"c�digo real n�o deve ignor�-los. Uma abordagem simplista � definir "
"<function> splcam () </function> na entrada para as outras rotinas e "
"redefini-lo no retorno, protegendo-as por uma grande se��o cr�tica. Para ter "
"certeza de que o n�vel de interrup��o ser� sempre restaurado, uma fun��o "
"wrapper pode ser definida, como: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21167
#, no-wrap
msgid ""
"    static void\n"
"    xxx_action(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        int s;\n"
"        s = splcam();\n"
"        xxx_action1(sim, ccb);\n"
"        splx(s);\n"
"    }\n"
"\n"
"    static void\n"
"    xxx_action1(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        ... process the request ...\n"
"    }"
msgstr ""
"    static void\n"
"    xxx_action(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        int s;\n"
"        s = splcam();\n"
"        xxx_action1(sim, ccb);\n"
"        splx(s);\n"
"    }\n"
"\n"
"    static void\n"
"    xxx_action1(struct cam_sim *sim, union ccb *ccb)\n"
"    {\n"
"        ... process the request ...\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21182
#, fuzzy
msgid ""
"This approach is simple and robust but the problem with it is that "
"interrupts may get blocked for a relatively long time and this would "
"negatively affect the system's performance. On the other hand the functions "
"of the <function>spl()</function> family have rather high overhead, so vast "
"amount of tiny critical sections may not be good either."
msgstr ""
"Esta abordagem � simples e robusta, mas o problema � que as interrup��es "
"podem ficar bloqueadas por um tempo relativamente longo e isso afetaria "
"negativamente o desempenho do sistema. Por outro lado, as fun��es do "
"<function> spl () </function> a fam�lia tem uma sobrecarga bastante alta, "
"uma quantidade t�o grande de se��es cr�ticas min�sculas pode n�o ser boa "
"tamb�m \""

#. (itstool) path: sect1/para
#: book.translate.xml:21189
#, fuzzy
msgid ""
"The conditions handled by the interrupt routine and the details depend very "
"much on the hardware. We consider the set of <quote>typical</quote> "
"conditions."
msgstr ""
"As condi��es manipuladas pela rotina de interrup��o e os detalhes dependem "
"muito do hardware. Consideramos o conjunto de <quote> t�pica </quote> "
"condi��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:21193
#, fuzzy
msgid ""
"First, we check if a SCSI reset was encountered on the bus (probably caused "
"by another SCSI controller on the same SCSI bus). If so we drop all the "
"enqueued and disconnected requests, report the events and re-initialize our "
"SCSI controller. It is important that during this initialization the "
"controller will not issue another reset or else two controllers on the same "
"SCSI bus could ping-pong resets forever. The case of fatal controller error/"
"hang could be handled in the same place, but it will probably need also "
"sending RESET signal to the SCSI bus to reset the status of the connections "
"with the SCSI devices."
msgstr ""
"Primeiro, verificamos se uma reinicializa��o SCSI foi encontrada no "
"barramento (provavelmente causada por outro controlador SCSI no mesmo "
"barramento SCSI). Se assim for, descartamos todas as solicita��es "
"enfileiradas e desconectadas, relatamos os eventos e reinicializamos nosso "
"controlador SCSI. � importante que durante esta inicializa��o o controlador "
"n�o emita outra reinicializa��o ou ent�o dois controladores no mesmo "
"barramento SCSI possam reiniciar o ping pong para sempre O caso de erro / "
"travamento do controlador fatal pode ser tratado no mesmo local, mas "
"provavelmente tamb�m precisa enviar o sinal RESET ao barramento SCSI para "
"redefinir o status das conex�es com os dispositivos SCSI. "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21205
#, no-wrap
msgid ""
"    int fatal=0;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    if( detected_scsi_reset(softc)\n"
"    || (fatal = detected_fatal_controller_error(softc)) ) {\n"
"        int targ, lun;\n"
"        struct xxx_hcb *h, *hh;\n"
"\n"
"        /* drop all enqueued CCBs */\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"        }\n"
"\n"
"        /* the clean values of negotiations to report */\n"
"        neg.bus_width = 8;\n"
"        neg.sync_period = neg.sync_offset = 0;\n"
"        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"        /* drop all disconnected CCBs and clean negotiations  */\n"
"        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"            clean_negotiations(softc, targ);\n"
"\n"
"            /* report the event if possible */\n"
"            if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                    cam_sim_path(sim), targ,\n"
"                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"                xpt_free_path(path);\n"
"            }\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h ="
" hh) {\n"
"                    hh=h-&gt;next;\n"
"                    if(fatal)\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, "
"CAM_UNREC_HBA_ERROR);\n"
"                    else\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, "
"CAM_SCSI_BUS_RESET);\n"
"                }\n"
"        }\n"
"\n"
"        /* report the event */\n"
"        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"\n"
"        /* re-initialization may take a lot of time, in such case\n"
"         * its completion should be signaled by another interrupt or\n"
"         * checked on timeout - but for simplicity we assume here that\n"
"         * it is really fast\n"
"         */\n"
"        if(!fatal) {\n"
"            reinitialize_controller_without_scsi_reset(softc);\n"
"        } else {\n"
"            reinitialize_controller_with_scsi_reset(softc);\n"
"        }\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"    int fatal=0;\n"
"    struct ccb_trans_settings neg;\n"
"    struct cam_path *path;\n"
"\n"
"    if( detected_scsi_reset(softc)\n"
"    || (fatal = detected_fatal_controller_error(softc)) ) {\n"
"        int targ, lun;\n"
"        struct xxx_hcb *h, *hh;\n"
"\n"
"        /* drop all enqueued CCBs */\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"            free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"        }\n"
"\n"
"        /* the clean values of negotiations to report */\n"
"        neg.bus_width = 8;\n"
"        neg.sync_period = neg.sync_offset = 0;\n"
"        neg.valid = (CCB_TRANS_BUS_WIDTH_VALID\n"
"            | CCB_TRANS_SYNC_RATE_VALID | CCB_TRANS_SYNC_OFFSET_VALID);\n"
"\n"
"        /* drop all disconnected CCBs and clean negotiations  */\n"
"        for(targ=0; targ &lt;= OUR_MAX_SUPPORTED_TARGET; targ++) {\n"
"            clean_negotiations(softc, targ);\n"
"\n"
"            /* report the event if possible */\n"
"            if(xpt_create_path(&amp;path, /*periph*/NULL,\n"
"                    cam_sim_path(sim), targ,\n"
"                    CAM_LUN_WILDCARD) == CAM_REQ_CMP) {\n"
"                xpt_async(AC_TRANSFER_NEG, path, &amp;neg);\n"
"                xpt_free_path(path);\n"
"            }\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[targ][lun]; h != NULL; h ="
" hh) {\n"
"                    hh=h-&gt;next;\n"
"                    if(fatal)\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, "
"CAM_UNREC_HBA_ERROR);\n"
"                    else\n"
"                        free_hcb_and_ccb_done(h, h-&gt;ccb, "
"CAM_SCSI_BUS_RESET);\n"
"                }\n"
"        }\n"
"\n"
"        /* report the event */\n"
"        xpt_async(AC_BUS_RESET, softc-&gt;wpath, NULL);\n"
"\n"
"        /* re-initialization may take a lot of time, in such case\n"
"         * its completion should be signaled by another interrupt or\n"
"         * checked on timeout - but for simplicity we assume here that\n"
"         * it is really fast\n"
"         */\n"
"        if(!fatal) {\n"
"            reinitialize_controller_without_scsi_reset(softc);\n"
"        } else {\n"
"            reinitialize_controller_with_scsi_reset(softc);\n"
"        }\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21265
#, fuzzy
msgid ""
"If interrupt is not caused by a controller-wide condition then probably "
"something has happened to the current hardware control block. Depending on "
"the hardware there may be other non-HCB-related events, we just do not "
"consider them here. Then we analyze what happened to this HCB:"
msgstr ""
"Se a interrup��o n�o � causada por uma condi��o de controle geral, "
"provavelmente algo aconteceu com o bloco de controle de hardware atual. "
"Dependendo do hardware, pode haver outros eventos n�o relacionados ao HCB, "
"n�s n�o os consideramos aqui. Ent�o analisamos o que aconteceu com este HCB: "
""

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21271
#, no-wrap
msgid ""
"    struct xxx_hcb *hcb, *h, *hh;\n"
"    int hcb_status, scsi_status;\n"
"    int ccb_status;\n"
"    int targ;\n"
"    int lun_to_freeze;\n"
"\n"
"    hcb = get_current_hcb(softc);\n"
"    if(hcb == NULL) {\n"
"        /* either stray interrupt or something went very wrong\n"
"         * or this is something hardware-dependent\n"
"         */\n"
"        handle as necessary;\n"
"        return;\n"
"    }\n"
"\n"
"    targ = hcb-&gt;target;\n"
"    hcb_status = get_status_of_current_hcb(softc);"
msgstr ""
"    struct xxx_hcb *hcb, *h, *hh;\n"
"    int hcb_status, scsi_status;\n"
"    int ccb_status;\n"
"    int targ;\n"
"    int lun_to_freeze;\n"
"\n"
"    hcb = get_current_hcb(softc);\n"
"    if(hcb == NULL) {\n"
"        /* either stray interrupt or something went very wrong\n"
"         * or this is something hardware-dependent\n"
"         */\n"
"        handle as necessary;\n"
"        return;\n"
"    }\n"
"\n"
"    targ = hcb-&gt;target;\n"
"    hcb_status = get_status_of_current_hcb(softc);"

#. (itstool) path: sect1/para
#: book.translate.xml:21289
#, fuzzy
msgid ""
"First we check if the HCB has completed and if so we check the returned SCSI "
"status."
msgstr ""
"Primeiro, verificamos se o HCB foi conclu�do e, nesse caso, verificamos o "
"status do SCSI retornado."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21292
#, no-wrap
msgid ""
"    if(hcb_status == COMPLETED) {\n"
"        scsi_status = get_completion_status(hcb);"
msgstr ""
"    if(hcb_status == COMPLETED) {\n"
"        scsi_status = get_completion_status(hcb);"

#. (itstool) path: sect1/para
#: book.translate.xml:21295
#, fuzzy
msgid ""
"Then look if this status is related to the REQUEST SENSE command and if so "
"handle it in a simple way."
msgstr ""
"Ent�o olhe se este status est� relacionado ao comando REQUEST SENSE e, se "
"for o caso, manipule-o de maneira simples."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21298
#, no-wrap
msgid ""
"        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {\n"
"            if(scsi_status == GOOD) { /* autosense was successful */\n"
"                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, "
"CAM_SCSI_STATUS_ERROR);\n"
"            } else {\n"
"        autosense_failed:\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);\n"
"            }\n"
"            schedule_next_hcb(softc);\n"
"            return;\n"
"        }"
msgstr ""
"        if(hcb-&gt;flags &amp; DOING_AUTOSENSE) {\n"
"            if(scsi_status == GOOD) { /* autosense was successful */\n"
"                hcb-&gt;ccb-&gt;ccb_h.status |= CAM_AUTOSNS_VALID;\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, "
"CAM_SCSI_STATUS_ERROR);\n"
"            } else {\n"
"        autosense_failed:\n"
"                free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_AUTOSENSE_FAIL);\n"
"            }\n"
"            schedule_next_hcb(softc);\n"
"            return;\n"
"        }"

#. (itstool) path: sect1/para
#: book.translate.xml:21310
#, fuzzy
msgid ""
"Else the command itself has completed, pay more attention to details. If "
"auto-sense is not disabled for this CCB and the command has failed with "
"sense data then run REQUEST SENSE command to receive that data."
msgstr ""
"Se o comando em si tiver sido conclu�do, preste mais aten��o aos detalhes. "
"Se o auto-sentido n�o estiver desativado para este CCB e o comando falhar "
"com dados de detec��o, execute o comando REQUEST SENSE para receber esses "
"dados."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21315
#, no-wrap
msgid ""
"        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;\n"
"        calculate_residue(hcb);\n"
"\n"
"        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0\n"
"        &amp;&amp; ( scsi_status == CHECK_CONDITION\n"
"                || scsi_status == COMMAND_TERMINATED) ) {\n"
"            /* start auto-SENSE */\n"
"            hcb-&gt;flags |= DOING_AUTOSENSE;\n"
"            setup_autosense_command_in_hcb(hcb);\n"
"            restart_current_hcb(softc);\n"
"            return;\n"
"        }\n"
"        if(scsi_status == GOOD)\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);\n"
"        else\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"        hcb-&gt;ccb-&gt;csio.scsi_status = scsi_status;\n"
"        calculate_residue(hcb);\n"
"\n"
"        if( (hcb-&gt;ccb-&gt;ccb_h.flags &amp; CAM_DIS_AUTOSENSE)==0\n"
"        &amp;&amp; ( scsi_status == CHECK_CONDITION\n"
"                || scsi_status == COMMAND_TERMINATED) ) {\n"
"            /* start auto-SENSE */\n"
"            hcb-&gt;flags |= DOING_AUTOSENSE;\n"
"            setup_autosense_command_in_hcb(hcb);\n"
"            restart_current_hcb(softc);\n"
"            return;\n"
"        }\n"
"        if(scsi_status == GOOD)\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_REQ_CMP);\n"
"        else\n"
"            free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, CAM_SCSI_STATUS_ERROR);\n"
"        schedule_next_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21335
#, fuzzy
msgid ""
"One typical thing would be negotiation events: negotiation messages received "
"from a SCSI target (in answer to our negotiation attempt or by target's "
"initiative) or the target is unable to negotiate (rejects our negotiation "
"messages or does not answer them)."
msgstr ""
"Uma coisa t�pica seria eventos de negocia��o: mensagens de negocia��o "
"recebidas de um alvo SCSI (em resposta � nossa tentativa de negocia��o ou "
"por iniciativa do alvo) ou o alvo � incapaz de negociar (rejeita nossas "
"mensagens de negocia��o ou n�o as responde)."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21341
#, no-wrap
msgid ""
"    switch(hcb_status) {\n"
"    case TARGET_REJECTED_WIDE_NEG:\n"
"        /* revert to 8-bit bus */\n"
"        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = "
"8;\n"
"        /* report the event */\n"
"        neg.bus_width = 8;\n"
"        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_ANSWERED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {\n"
"                /* answer is acceptable */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, "
"&amp;neg);\n"
"            } else {\n"
"                prepare_reject_message(hcb);\n"
"            }\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_REQUESTED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            wd = min (wd, OUR_BUS_WIDTH);\n"
"            wd = min (wd, softc-&gt;user_bus_width[targ]);\n"
"\n"
"            if(wd != softc-&gt;current_bus_width[targ]) {\n"
"                /* the bus width has changed */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, "
"&amp;neg);\n"
"            }\n"
"            prepare_width_nego_rsponse(hcb, wd);\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    }"
msgstr ""
"    switch(hcb_status) {\n"
"    case TARGET_REJECTED_WIDE_NEG:\n"
"        /* revert to 8-bit bus */\n"
"        softc-&gt;current_bus_width[targ] = softc-&gt;goal_bus_width[targ] = "
"8;\n"
"        /* report the event */\n"
"        neg.bus_width = 8;\n"
"        neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_ANSWERED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            if(wd &lt;= softc-&gt;goal_bus_width[targ]) {\n"
"                /* answer is acceptable */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, "
"&amp;neg);\n"
"            } else {\n"
"                prepare_reject_message(hcb);\n"
"            }\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    case TARGET_REQUESTED_WIDE_NEG:\n"
"        {\n"
"            int wd;\n"
"\n"
"            wd = get_target_bus_width_request(softc);\n"
"            wd = min (wd, OUR_BUS_WIDTH);\n"
"            wd = min (wd, softc-&gt;user_bus_width[targ]);\n"
"\n"
"            if(wd != softc-&gt;current_bus_width[targ]) {\n"
"                /* the bus width has changed */\n"
"                softc-&gt;current_bus_width[targ] =\n"
"                softc-&gt;goal_bus_width[targ] = neg.bus_width = wd;\n"
"\n"
"                /* report the event */\n"
"                neg.valid = CCB_TRANS_BUS_WIDTH_VALID;\n"
"                xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, "
"&amp;neg);\n"
"            }\n"
"            prepare_width_nego_rsponse(hcb, wd);\n"
"        }\n"
"        continue_current_hcb(softc);\n"
"        return;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21393
#, fuzzy
msgid ""
"Then we handle any errors that could have happened during auto-sense in the "
"same simple-minded way as before. Otherwise we look closer at the details "
"again."
msgstr ""
"Ent�o, lidamos com quaisquer erros que poderiam ter ocorrido durante a "
"detec��o autom�tica da mesma maneira simpl�ria de antes. Caso contr�rio, "
"veremos mais de perto os detalhes novamente."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21397
#, no-wrap
msgid ""
"    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)\n"
"        goto autosense_failed;\n"
"\n"
"    switch(hcb_status) {"
msgstr ""
"    if(hcb-&gt;flags &amp; DOING_AUTOSENSE)\n"
"        goto autosense_failed;\n"
"\n"
"    switch(hcb_status) {"

#. (itstool) path: sect1/para
#: book.translate.xml:21402
#, fuzzy
msgid ""
"The next event we consider is unexpected disconnect. Which is considered "
"normal after an ABORT or BUS DEVICE RESET message and abnormal in other "
"cases."
msgstr ""
"O pr�ximo evento que consideramos � uma desconex�o inesperada. O que � "
"considerado normal ap�s uma mensagem ABORT ou BUS DEVICE RESET e anormal em "
"outros casos."

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21406
#, no-wrap
msgid ""
"    case UNEXPECTED_DISCONNECT:\n"
"        if(requested_abort(hcb)) {\n"
"            /* abort affects all commands on that target+LUN, so\n"
"             * mark all disconnected HCBs on that target+LUN as aborted too\n"
"             */\n"
"            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];\n"
"                    h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);\n"
"            }\n"
"            ccb_status = CAM_REQ_ABORTED;\n"
"        } else if(requested_bus_device_reset(hcb)) {\n"
"            int lun;\n"
"\n"
"            /* reset affects all commands on that target, so\n"
"             * mark all disconnected HCBs on that target+LUN as reset\n"
"             */\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];\n"
"                        h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"\n"
"            /* send event */\n"
"            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);\n"
"\n"
"            /* this was the CAM_RESET_DEV request itself, it is completed */\n"
"            ccb_status = CAM_REQ_CMP;\n"
"        } else {\n"
"            calculate_residue(hcb);\n"
"            ccb_status = CAM_UNEXP_BUSFREE;\n"
"            /* request the further code to freeze the queue */\n"
"            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"            lun_to_freeze = hcb-&gt;lun;\n"
"        }\n"
"        break;"
msgstr ""
"    case UNEXPECTED_DISCONNECT:\n"
"        if(requested_abort(hcb)) {\n"
"            /* abort affects all commands on that target+LUN, so\n"
"             * mark all disconnected HCBs on that target+LUN as aborted too\n"
"             */\n"
"            for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][hcb-&gt;lun];\n"
"                    h != NULL; h = hh) {\n"
"                hh=h-&gt;next;\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQ_ABORTED);\n"
"            }\n"
"            ccb_status = CAM_REQ_ABORTED;\n"
"        } else if(requested_bus_device_reset(hcb)) {\n"
"            int lun;\n"
"\n"
"            /* reset affects all commands on that target, so\n"
"             * mark all disconnected HCBs on that target+LUN as reset\n"
"             */\n"
"\n"
"            for(lun=0; lun &lt;= OUR_MAX_SUPPORTED_LUN; lun++)\n"
"                for(h = softc-&gt;first_discon_hcb[hcb-&gt;target][lun];\n"
"                        h != NULL; h = hh) {\n"
"                    hh=h-&gt;next;\n"
"                    free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_SCSI_BUS_RESET);\n"
"                }\n"
"\n"
"            /* send event */\n"
"            xpt_async(AC_SENT_BDR, hcb-&gt;ccb-&gt;ccb_h.path_id, NULL);\n"
"\n"
"            /* this was the CAM_RESET_DEV request itself, it is completed */\n"
"            ccb_status = CAM_REQ_CMP;\n"
"        } else {\n"
"            calculate_residue(hcb);\n"
"            ccb_status = CAM_UNEXP_BUSFREE;\n"
"            /* request the further code to freeze the queue */\n"
"            hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"            lun_to_freeze = hcb-&gt;lun;\n"
"        }\n"
"        break;"

#. (itstool) path: sect1/para
#: book.translate.xml:21445
#, fuzzy
msgid ""
"If the target refuses to accept tags we notify CAM about that and return "
"back all commands for this LUN:"
msgstr ""
"Se o destino se recusar a aceitar tags, n�s notificaremos o CAM sobre isso e "
"retornaremos todos os comandos para este LUN:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21448
#, no-wrap
msgid ""
"    case TAGS_REJECTED:\n"
"        /* report the event */\n"
"        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;\n"
"        neg.valid = CCB_TRANS_TQ_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"\n"
"        ccb_status = CAM_MSG_REJECT_REC;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = hcb-&gt;lun;\n"
"        break;"
msgstr ""
"    case TAGS_REJECTED:\n"
"        /* report the event */\n"
"        neg.flags = 0 &amp; ~CCB_TRANS_TAG_ENB;\n"
"        neg.valid = CCB_TRANS_TQ_VALID;\n"
"        xpt_async(AC_TRANSFER_NEG, hcb-&gt;ccb.ccb_h.path_id, &amp;neg);\n"
"\n"
"        ccb_status = CAM_MSG_REJECT_REC;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = hcb-&gt;lun;\n"
"        break;"

#. (itstool) path: sect1/para
#: book.translate.xml:21460
#, fuzzy
msgid ""
"Then we check a number of other conditions, with processing basically "
"limited to setting the CCB status:"
msgstr ""
"Em seguida, verificamos v�rias outras condi��es, com o processamento "
"basicamente limitado � configura��o do status do CCB:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21463
#, no-wrap
msgid ""
"    case SELECTION_TIMEOUT:\n"
"        ccb_status = CAM_SEL_TIMEOUT;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    case PARITY_ERROR:\n"
"        ccb_status = CAM_UNCOR_PARITY;\n"
"        break;\n"
"    case DATA_OVERRUN:\n"
"    case ODD_WIDE_TRANSFER:\n"
"        ccb_status = CAM_DATA_RUN_ERR;\n"
"        break;\n"
"    default:\n"
"        /* all other errors are handled in a generic way */\n"
"        ccb_status = CAM_REQ_CMP_ERR;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    }"
msgstr ""
"    case SELECTION_TIMEOUT:\n"
"        ccb_status = CAM_SEL_TIMEOUT;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    case PARITY_ERROR:\n"
"        ccb_status = CAM_UNCOR_PARITY;\n"
"        break;\n"
"    case DATA_OVERRUN:\n"
"    case ODD_WIDE_TRANSFER:\n"
"        ccb_status = CAM_DATA_RUN_ERR;\n"
"        break;\n"
"    default:\n"
"        /* all other errors are handled in a generic way */\n"
"        ccb_status = CAM_REQ_CMP_ERR;\n"
"        /* request the further code to freeze the queue */\n"
"        hcb-&gt;ccb-&gt;ccb_h.status |= CAM_DEV_QFRZN;\n"
"        lun_to_freeze = CAM_LUN_WILDCARD;\n"
"        break;\n"
"    }"

#. (itstool) path: sect1/para
#: book.translate.xml:21485
#, fuzzy
msgid ""
"Then we check if the error was serious enough to freeze the input queue "
"until it gets proceeded and do so if it is:"
msgstr ""
"Em seguida, verificamos se o erro foi grave o suficiente para congelar a "
"fila de entrada at� que ela continue e fa�a isso, se for:"

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21488
#, no-wrap
msgid ""
"    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {\n"
"        /* freeze the queue */\n"
"        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);\n"
"\n"
"        /* re-queue all commands for this target/LUN back to CAM */\n"
"\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"\n"
"            if(targ == h-&gt;targ\n"
"            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze =="
" h-&gt;lun) )\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);\n"
"        }\n"
"    }\n"
"    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);\n"
"    schedule_next_hcb(softc);\n"
"    return;"
msgstr ""
"    if(hcb-&gt;ccb-&gt;ccb_h.status &amp; CAM_DEV_QFRZN) {\n"
"        /* freeze the queue */\n"
"        xpt_freeze_devq(ccb-&gt;ccb_h.path, /*count*/1);\n"
"\n"
"        /* re-queue all commands for this target/LUN back to CAM */\n"
"\n"
"        for(h = softc-&gt;first_queued_hcb; h != NULL; h = hh) {\n"
"            hh = h-&gt;next;\n"
"\n"
"            if(targ == h-&gt;targ\n"
"            &amp;&amp; (lun_to_freeze == CAM_LUN_WILDCARD || lun_to_freeze =="
" h-&gt;lun) )\n"
"                free_hcb_and_ccb_done(h, h-&gt;ccb, CAM_REQUEUE_REQ);\n"
"        }\n"
"    }\n"
"    free_hcb_and_ccb_done(hcb, hcb-&gt;ccb, ccb_status);\n"
"    schedule_next_hcb(softc);\n"
"    return;"

#. (itstool) path: sect1/para
#: book.translate.xml:21506
#, fuzzy
msgid ""
"This concludes the generic interrupt handling although specific controllers "
"may require some additions."
msgstr ""
"Isso conclui o tratamento gen�rico de interrup��o, embora os controladores "
"espec�ficos possam exigir algumas adi��es."

#. (itstool) path: sect1/title
#: book.translate.xml:21511
#, fuzzy
msgid "Errors Summary"
msgstr "Resumo de Erros"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21513
#, fuzzy
msgid "<primary>SCSI</primary><secondary>errors</secondary>"
msgstr " <primary> SCSI </primary><secondary> erros </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21515
#, fuzzy
msgid ""
"When executing an I/O request many things may go wrong. The reason of error "
"can be reported in the CCB status with great detail. Examples of use are "
"spread throughout this document. For completeness here is the summary of "
"recommended responses for the typical error conditions:"
msgstr ""
"Ao executar uma solicita��o de E / S, muitas coisas podem dar errado. O "
"motivo do erro pode ser relatado no status CCB com muitos detalhes. Exemplos "
"de uso est�o espalhados por este documento. Para completar, aqui est� o "
"resumo das respostas recomendadas para o t�pico condi��es de erro: "

#. (itstool) path: listitem/para
#: book.translate.xml:21523
#, fuzzy
msgid ""
"<emphasis>CAM_RESRC_UNAVAIL</emphasis> - some resource is temporarily "
"unavailable and the SIM driver cannot generate an event when it will become "
"available. An example of this resource would be some intra-controller "
"hardware resource for which the controller does not generate an interrupt "
"when it becomes available."
msgstr ""
" <emphasis> CAM_RESRC_UNAVAIL </emphasis> - algum recurso est� "
"temporariamente indispon�vel e o driver do SIM n�o pode gerar um evento "
"quando ele estiver dispon�vel. Um exemplo desse recurso seria algum recurso "
"de hardware intra-controlador para o qual o controlador n�o gera uma "
"interrup��o quando se torna dispon�vel. "

#. (itstool) path: listitem/para
#: book.translate.xml:21532
#, fuzzy
msgid ""
"<emphasis>CAM_UNCOR_PARITY</emphasis> - unrecovered parity error occurred"
msgstr ""
" <emphasis> CAM_UNCOR_PARITY </emphasis> - erro de paridade n�o recuperado "
"ocorrido "

#. (itstool) path: listitem/para
#: book.translate.xml:21537
#, fuzzy
msgid ""
"<emphasis>CAM_DATA_RUN_ERR</emphasis> - data overrun or unexpected data "
"phase (going in other direction than specified in CAM_DIR_MASK) or odd "
"transfer length for wide transfer"
msgstr ""
" <emphasis> CAM_DATA_RUN_ERR </emphasis> - satura��o de dados ou fase de "
"dados inesperada (indo em outra dire��o que n�o a especificada em "
"CAM_DIR_MASK) ou comprimento de transfer�ncia �mpar para transfer�ncia ampla "
""

#. (itstool) path: listitem/para
#: book.translate.xml:21544
#, fuzzy
msgid ""
"<emphasis>CAM_SEL_TIMEOUT</emphasis> - selection timeout occurred (target "
"does not respond)"
msgstr ""
" <emphasis> CAM_SEL_TIMEOUT </emphasis> - tempo limite de sele��o ocorreu (o "
"alvo n�o responde) "

#. (itstool) path: listitem/para
#: book.translate.xml:21549
#, fuzzy
msgid ""
"<emphasis>CAM_CMD_TIMEOUT</emphasis> - command timeout occurred (the timeout "
"function ran)"
msgstr ""
" <emphasis> CAM_CMD_TIMEOUT </emphasis> - ocorreu o tempo limite do comando "
"(a fun��o de tempo limite foi executada) "

#. (itstool) path: listitem/para
#: book.translate.xml:21554
#, fuzzy
msgid "<emphasis>CAM_SCSI_STATUS_ERROR</emphasis> - the device returned error"
msgstr ""
" <emphasis> CAM_SCSI_STATUS_ERROR </emphasis> - o dispositivo retornou o "
"erro "

#. (itstool) path: listitem/para
#: book.translate.xml:21559
#, fuzzy
msgid ""
"<emphasis>CAM_AUTOSENSE_FAIL</emphasis> - the device returned error and the "
"REQUEST SENSE COMMAND failed"
msgstr ""
" <emphasis> CAM_AUTOSENSE_FAIL </emphasis> - o dispositivo retornou um erro "
"e o comando REQUEST SENSE COMMAND falhou "

#. (itstool) path: listitem/para
#: book.translate.xml:21564
#, fuzzy
msgid ""
"<emphasis>CAM_MSG_REJECT_REC</emphasis> - MESSAGE REJECT message was "
"received"
msgstr ""
" <emphasis> CAM_MSG_REJECT_REC </emphasis> - Mensagem de REJEI��O DE "
"MENSAGEM foi recebida "

#. (itstool) path: listitem/para
#: book.translate.xml:21569
#, fuzzy
msgid "<emphasis>CAM_SCSI_BUS_RESET</emphasis> - received SCSI bus reset"
msgstr ""
" <emphasis> CAM_SCSI_BUS_RESET </emphasis> - reset do barramento SCSI "
"recebid"

#. (itstool) path: listitem/para
#: book.translate.xml:21574
#, fuzzy
msgid ""
"<emphasis>CAM_REQ_CMP_ERR</emphasis> - <quote>impossible</quote> SCSI phase "
"occurred or something else as weird or just a generic error if further "
"detail is not available"
msgstr ""
" <emphasis> CAM_REQ_CMP_ERR </emphasis> - <quote> imposs�vel </quote> Fase "
"SCSI ocorreu ou algo mais estranho ou apenas um erro gen�rico se mais "
"detalhes n�o estiverem dispon�veis "

#. (itstool) path: listitem/para
#: book.translate.xml:21581
#, fuzzy
msgid ""
"<emphasis>CAM_UNEXP_BUSFREE</emphasis> - unexpected disconnect occurred"
msgstr ""
" <emphasis> CAM_UNEXP_BUSFREE </emphasis> - desconex�o inesperada ocorreu "

#. (itstool) path: listitem/para
#: book.translate.xml:21586
#, fuzzy
msgid ""
"<emphasis>CAM_BDR_SENT</emphasis> - BUS DEVICE RESET message was sent to the "
"target"
msgstr ""
" <emphasis> CAM_BDR_SENT </emphasis> - A mensagem BUS DEVICE RESET foi "
"enviada para o alvo "

#. (itstool) path: listitem/para
#: book.translate.xml:21591
#, fuzzy
msgid ""
"<emphasis>CAM_UNREC_HBA_ERROR</emphasis> - unrecoverable Host Bus Adapter "
"Error"
msgstr ""
" <emphasis> CAM_UNREC_HBA_ERROR </emphasis> - erro de adaptador de "
"barramento de host irrecuper�vel "

#. (itstool) path: listitem/para
#: book.translate.xml:21596
#, fuzzy
msgid ""
"<emphasis>CAM_REQ_TOO_BIG</emphasis> - the request was too large for this "
"controller"
msgstr ""
" <emphasis> CAM_REQ_TOO_BIG </emphasis> - o pedido era muito grande para "
"esse controlador "

#. (itstool) path: listitem/para
#: book.translate.xml:21601
#, fuzzy
msgid ""
"<emphasis>CAM_REQUEUE_REQ</emphasis> - this request should be re-queued to "
"preserve transaction ordering. This typically occurs when the SIM recognizes "
"an error that should freeze the queue and must place other queued requests "
"for the target at the sim level back into the XPT queue. Typical cases of "
"such errors are selection timeouts, command timeouts and other like "
"conditions. In such cases the troublesome command returns the status "
"indicating the error, the and the other commands which have not be sent to "
"the bus yet get re-queued."
msgstr ""
" <emphasis> CAM_REQUEUE_REQ </emphasis> - essa solicita��o deve ser "
"enfileirada novamente para preservar a ordem de transa��o. Isso normalmente "
"ocorre quando o SIM reconhece um erro que deve congelar a fila e deve "
"colocar outras solicita��es na fila para o destino no n�vel do sim de volta "
"na fila do XPT. Casos t�picos de tais erros s�o tempos limite de sele��o, "
"tempos limite de comando e outras condi��es semelhantes. Em tais casos, o "
"comando problem�tico retorna o status indicando o erro, oe os outros "
"comandos que n�o foram enviados para o barramento ainda s�o re-enfileirados. "
""

#. (itstool) path: listitem/para
#: book.translate.xml:21614
#, fuzzy
msgid ""
"<emphasis>CAM_LUN_INVALID</emphasis> - the LUN ID in the request is not "
"supported by the SCSI controller"
msgstr ""
" <emphasis> CAM_LUN_INVALID </emphasis> - o ID do LUN na solicita��o n�o � "
"suportado pelo controlador SCSI "

#. (itstool) path: listitem/para
#: book.translate.xml:21619
#, fuzzy
msgid ""
"<emphasis>CAM_TID_INVALID</emphasis> - the target ID in the request is not "
"supported by the SCSI controller"
msgstr ""
" <emphasis> CAM_TID_INVALID </emphasis> - o ID de destino na solicita��o n�o "
"� suportado pelo controlador SCSI "

#. (itstool) path: sect1/title
#: book.translate.xml:21626
#, fuzzy
msgid "Timeout Handling"
msgstr "Timeout Handling"

#. (itstool) path: sect1/para
#: book.translate.xml:21628
#, fuzzy
msgid ""
"When the timeout for an HCB expires that request should be aborted, just "
"like with an XPT_ABORT request. The only difference is that the returned "
"status of aborted request should be CAM_CMD_TIMEOUT instead of "
"CAM_REQ_ABORTED (that is why implementation of the abort better be done as a "
"function). But there is one more possible problem: what if the abort request "
"itself will get stuck? In this case the SCSI bus should be reset, just like "
"with an XPT_RESET_BUS request (and the idea about implementing it as a "
"function called from both places applies here too). Also we should reset the "
"whole SCSI bus if a device reset request got stuck. So after all the timeout "
"function would look like:"
msgstr ""
"Quando o tempo limite de um HCB expira, o pedido deve ser abortado, assim "
"como com um pedido XPT_ABORT. A �nica diferen�a � que o status retornado do "
"pedido abortado deve ser CAM_CMD_TIMEOUT ao inv�s de CAM_REQ_ABORTED (� por "
"isso que a implementa��o do aborto deve ser feita como Mas h� mais um "
"problema poss�vel: e se o pr�prio pedido de abortar ficar preso? Nesse caso, "
"o barramento SCSI deve ser redefinido, assim como com uma solicita��o "
"XPT_RESET_BUS (e a id�ia de implement�-lo como uma fun��o chamada de ambos "
"os lugares se aplicam aqui tamb�m. Tamb�m devemos redefinir todo o "
"barramento SCSI se uma solicita��o de reinicializa��o do dispositivo ficar "
"travada. Ent�o, depois de toda a fun��o de tempo limite, seria: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:21641
#, no-wrap
msgid ""
"static void\n"
"xxx_timeout(void *arg)\n"
"{\n"
"    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;\n"
"    struct xxx_softc *softc;\n"
"    struct ccb_hdr *ccb_h;\n"
"\n"
"    softc = hcb-&gt;softc;\n"
"    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;\n"
"\n"
"    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED\n"
"    || ccb_h-&gt;func_code == XPT_RESET_DEV) {\n"
"        xxx_reset_bus(softc);\n"
"    } else {\n"
"        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);\n"
"    }\n"
"}"
msgstr ""
"static void\n"
"xxx_timeout(void *arg)\n"
"{\n"
"    struct xxx_hcb *hcb = (struct xxx_hcb *)arg;\n"
"    struct xxx_softc *softc;\n"
"    struct ccb_hdr *ccb_h;\n"
"\n"
"    softc = hcb-&gt;softc;\n"
"    ccb_h = &amp;hcb-&gt;ccb-&gt;ccb_h;\n"
"\n"
"    if(hcb-&gt;flags &amp; HCB_BEING_ABORTED\n"
"    || ccb_h-&gt;func_code == XPT_RESET_DEV) {\n"
"        xxx_reset_bus(softc);\n"
"    } else {\n"
"        xxx_abort_ccb(hcb-&gt;ccb, CAM_CMD_TIMEOUT);\n"
"    }\n"
"}"

#. (itstool) path: sect1/para
#: book.translate.xml:21659
#, fuzzy
msgid ""
"When we abort a request all the other disconnected requests to the same "
"target/LUN get aborted too. So there appears a question, should we return "
"them with status CAM_REQ_ABORTED or CAM_CMD_TIMEOUT? The current drivers use "
"CAM_CMD_TIMEOUT. This seems logical because if one request got timed out "
"then probably something really bad is happening to the device, so if they "
"would not be disturbed they would time out by themselves."
msgstr ""
"Quando abortamos um pedido, todos os outros pedidos desconectados para o "
"mesmo destino / LUN s�o abortados tamb�m. Ent�o, aparece uma pergunta, "
"devemos devolv�-los com status CAM_REQ_ABORTED ou CAM_CMD_TIMEOUT? Os "
"drivers atuais usam CAM_CMD_TIMEOUT. Isso parece l�gico porque se um pedido "
"Se o tempo expirar, � prov�vel que algo realmente ruim esteja acontecendo "
"com o dispositivo, por isso, se eles n�o forem incomodados, eles perder�o o "
"tempo sozinhos \""

#. (itstool) path: info/title
#: book.translate.xml:21677
#, fuzzy
msgid "USB Devices"
msgstr "Dispositivos USB"

#. (itstool) path: authorgroup/author
#: book.translate.xml:21680
#, fuzzy
msgid ""
"<personname> <firstname>Nick</firstname> <surname>Hibma</surname> </"
"personname> <contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Nick </firstname><surname> Hibma </surname></"
"personname><contrib> Escrito por </contrib> "

#. (itstool) path: authorgroup/author
#: book.translate.xml:21689
#, fuzzy
msgid ""
"<personname> <firstname>Murray</firstname> <surname>Stokely</surname> </"
"personname> <contrib>Modifications for Handbook made by </contrib>"
msgstr ""
" <personname><firstname> Murray </firstname><surname> Stokely </surname></"
"personname><contrib> Modifica��es para o manual feito por </contrib> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21702
#, fuzzy
msgid "<primary>Universal Serial Bus (USB)</primary>"
msgstr " <primary> Barramento Serial Universal (USB) </primary> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21704
#, fuzzy
msgid "<primary>NetBSD</primary>"
msgstr " <primary> NetBSD </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21706
#, fuzzy
msgid ""
"The Universal Serial Bus (USB) is a new way of attaching devices to personal "
"computers. The bus architecture features two-way communication and has been "
"developed as a response to devices becoming smarter and requiring more "
"interaction with the host. USB support is included in all current PC "
"chipsets and is therefore available in all recently built PCs. Apple's "
"introduction of the USB-only iMac has been a major incentive for hardware "
"manufacturers to produce USB versions of their devices. The future PC "
"specifications specify that all legacy connectors on PCs should be replaced "
"by one or more USB connectors, providing generic plug and play capabilities. "
"Support for USB hardware was available at a very early stage in NetBSD and "
"was developed by Lennart Augustsson for the NetBSD project. The code has "
"been ported to FreeBSD and we are currently maintaining a shared code base. "
"For the implementation of the USB subsystem a number of features of USB are "
"important."
msgstr ""
"O Universal Serial Bus (USB) � uma nova maneira de conectar dispositivos a "
"computadores pessoais. A arquitetura de barramento possui comunica��o "
"bidirecional e foi desenvolvida como uma resposta a dispositivos que se "
"tornam mais inteligentes e exigem mais intera��o com o host. O suporte USB "
"est� inclu�do em todos os atuais chipsets para PC e, portanto, est� "
"dispon�vel em todos os PCs rec�m-constru�dos.A introdu��o do iMac apenas "
"para USB tem sido um grande incentivo para fabricantes de hardware "
"produzirem vers�es USB de seus dispositivos.As especifica��es futuras do PC "
"especificam que todos os conectores legados em PCs deve ser substitu�do por "
"um ou mais conectores USB, fornecendo capacidades gen�ricas de plug and play "
"O suporte para hardware USB estava dispon�vel em um est�gio muito inicial no "
"NetBSD e foi desenvolvido por Lennart Augustsson para o projeto NetBSD O "
"c�digo foi portado para o FreeBSD e n�s Atualmente, est�o mantendo uma base "
"de c�digo compartilhada. Para a implementa��o do subsistema USB, um n�mero "
"de recursos de USB � importante. "

#. (itstool) path: sect1/para
#: book.translate.xml:21723
#, fuzzy
msgid ""
"<emphasis>Lennart Augustsson has done most of the implementation of the USB "
"support for the NetBSD project. Many thanks for this incredible amount of "
"work. Many thanks also to Ardy and Dirk for their comments and proofreading "
"of this paper.</emphasis>"
msgstr ""
" <emphasis> Lennart Augustsson fez a maior parte da implementa��o do suporte "
"a USB para o projeto NetBSD. Muito obrigado por esta incr�vel quantidade de "
"trabalho. Muito obrigado tamb�m a Ardy e Dirk por seus coment�rios e revis�o "
"deste artigo. </emphasis> "

#. (itstool) path: listitem/para
#: book.translate.xml:21732
#, fuzzy
msgid ""
"Devices connect to ports on the computer directly or on devices called hubs, "
"forming a treelike device structure."
msgstr ""
"Os dispositivos se conectam a portas no computador diretamente ou em "
"dispositivos chamados hubs, formando uma estrutura de dispositivo semelhante "
"a uma �rvore."

#. (itstool) path: listitem/para
#: book.translate.xml:21738
#, fuzzy
msgid "The devices can be connected and disconnected at run time."
msgstr ""
"Os dispositivos podem ser conectados e desconectados em tempo de execu��o."

#. (itstool) path: listitem/para
#: book.translate.xml:21743
#, fuzzy
msgid "Devices can suspend themselves and trigger resumes of the host system"
msgstr "Dispositivos podem se suspender e acionar curr�culos do sistema host"

#. (itstool) path: listitem/para
#: book.translate.xml:21748
#, fuzzy
msgid ""
"As the devices can be powered from the bus, the host software has to keep "
"track of power budgets for each hub."
msgstr ""
"Como os dispositivos podem ser alimentados pelo barramento, o software "
"hospedeiro precisa monitorar os or�amentos de energia de cada hub\""

#. (itstool) path: listitem/para
#: book.translate.xml:21754
#, fuzzy
msgid ""
"Different quality of service requirements by the different device types "
"together with the maximum of 126 devices that can be connected to the same "
"bus, require proper scheduling of transfers on the shared bus to take full "
"advantage of the 12Mbps bandwidth available. (over 400Mbps with USB 2.0)"
msgstr ""
"Diferentes exig�ncias de qualidade de servi�o pelos diferentes tipos de "
"dispositivos, juntamente com o m�ximo de 126 dispositivos que podem ser "
"conectados ao mesmo barramento, requerem agendamento adequado de "
"transfer�ncias no barramento compartilhado para aproveitar ao m�ximo a "
"largura de banda de 12Mbps dispon�vel. USB 2.0) "

#. (itstool) path: listitem/para
#: book.translate.xml:21763
#, fuzzy
msgid ""
"Devices are intelligent and contain easily accessible information about "
"themselves"
msgstr ""
"Os dispositivos s�o inteligentes e cont�m informa��es facilmente acess�veis "
"sobre si mesmos"

#. (itstool) path: sect1/para
#: book.translate.xml:21769
#, fuzzy
msgid ""
"The development of drivers for the USB subsystem and devices connected to it "
"is supported by the specifications that have been developed and will be "
"developed. These specifications are publicly available from the USB home "
"pages. Apple has been very strong in pushing for standards based drivers, by "
"making drivers for the generic classes available in their operating system "
"MacOS and discouraging the use of separate drivers for each new device. This "
"chapter tries to collate essential information for a basic understanding of "
"the USB 2.0 implementation stack in FreeBSD/NetBSD. It is recommended "
"however to read it together with the relevant 2.0 specifications and other "
"developer resources:"
msgstr ""
"O desenvolvimento de drivers para o subsistema USB e dispositivos conectados "
"a ele � suportado pelas especifica��es que foram desenvolvidas e que ser�o "
"desenvolvidas. Essas especifica��es est�o dispon�veis publicamente nas home "
"pages USB. A Apple tem sido muito forte em pressionar por drivers baseados "
"em padr�es. , fazendo drivers para as classes gen�ricas dispon�veis em seu "
"sistema operacional MacOS e desencorajando o uso de drivers separados para "
"cada novo dispositivo.Este cap�tulo tenta coletar informa��es essenciais "
"para uma compreens�o b�sica da pilha de implementa��o USB 2.0 no FreeBSD / "
"NetBSD. recomendado, no entanto, para l�-lo em conjunto com as "
"especifica��es relevantes 2.0 e outros recursos do desenvolvedor: "

#. (itstool) path: listitem/para
#: book.translate.xml:21784
#, fuzzy
msgid ""
"USB 2.0 Specification (<link xlink:href=\"http://www.usb.org/developers/docs/"
"usb20_docs/\">http://www.usb.org/developers/docs/usb20_docs/</link>)"
msgstr ""
"Especifica��o USB 2.0 ( <link xlink:href=\"http://www.usb.org/developers/"
"docs/usb20_docs/\"> http://www.usb.org/developers/docs/usb20_docs/ </link> ) "
""

#. (itstool) path: listitem/para
#: book.translate.xml:21788
#, fuzzy
msgid ""
"Universal Host Controller Interface (<acronym>UHCI</acronym>) Specification "
"(<link xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d."
"pdf\">ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf)</link>"
msgstr ""
"Especifica��o <acronym>UHCI</acronym> (Universal Host Controller Interface) "
"<link xlink:href=\"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf\"> "
"ftp://ftp.netbsd.org/pub/NetBSD/misc/blymn/uhci11d.pdf) </link> "

#. (itstool) path: listitem/para
#: book.translate.xml:21793
#, fuzzy
msgid ""
"Open Host Controller Interface (<acronym>OHCI</acronym>) Specification(<link "
"xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a."
"pdf\">ftp://ftp.compaq.com/pub/supportinformation/papers/hcir1_0a.pdf</"
"link>)"
msgstr ""
"Especifica��o da Interface do Controlador de Host Aberto ( <acronym>OHCI</"
"acronym> ) ( <link xlink:href=\"ftp://ftp.compaq.com/pub/supportinformation/"
"papers/hcir1_0a.pdf\"> ftp://ftp.compaq.com/pub/supportinformation/papers/"
"hcir1_0a.pdf </link> ) "

#. (itstool) path: listitem/para
#: book.translate.xml:21798
#, fuzzy
msgid ""
"Developer section of <acronym>USB</acronym> home page (<link xlink:href="
"\"http://www.usb.org/developers/\">http://www.usb.org/developers/</link>)"
msgstr ""
"Se��o do desenvolvedor da home page do <acronym>USB</acronym> ( <link xlink:"
"href=\"http://www.usb.org/developers/\"> http://www.usb.org/developers/ </"
"link> ) "

#. (itstool) path: sect2/title
#: book.translate.xml:21804
#, fuzzy
msgid "Structure of the USB Stack"
msgstr "Estrutura da pilha USB"

#. (itstool) path: sect2/para
#: book.translate.xml:21806
#, fuzzy
msgid ""
"The USB support in FreeBSD can be split into three layers. The lowest layer "
"contains the host controller driver, providing a generic interface to the "
"hardware and its scheduling facilities. It supports initialisation of the "
"hardware, scheduling of transfers and handling of completed and/or failed "
"transfers. Each host controller driver implements a virtual hub providing "
"hardware independent access to the registers controlling the root ports on "
"the back of the machine."
msgstr ""
"O suporte USB no FreeBSD pode ser dividido em tr�s camadas. A camada mais "
"baixa cont�m o driver controlador host, fornecendo uma interface gen�rica "
"para o hardware e suas facilidades de agendamento. Suporta inicializa��o do "
"hardware, agendamento de transfer�ncias e tratamento de Cada controlador de "
"host implementa um hub virtual fornecendo acesso independente de hardware "
"aos registros que controlam as portas raiz na parte traseira da m�quina. "

#. (itstool) path: sect2/para
#: book.translate.xml:21816
#, fuzzy
msgid ""
"The middle layer handles the device connection and disconnection, basic "
"initialisation of the device, driver selection, the communication channels "
"(pipes) and does resource management. This services layer also controls the "
"default pipes and the device requests transferred over them."
msgstr ""
"A camada intermedi�ria lida com a conex�o e desconex�o do dispositivo, "
"inicializa��o b�sica do dispositivo, sele��o de driver, canais de "
"comunica��o (pipes) e gerenciamento de recursos. Essa camada de servi�os "
"tamb�m controla os pipes padr�o e as solicita��es de dispositivos "
"transferidos."

#. (itstool) path: sect2/para
#: book.translate.xml:21823
#, fuzzy
msgid ""
"The top layer contains the individual drivers supporting specific (classes "
"of) devices. These drivers implement the protocol that is used over the "
"pipes other than the default pipe. They also implement additional "
"functionality to make the device available to other parts of the kernel or "
"userland. They use the USB driver interface (USBDI) exposed by the services "
"layer."
msgstr ""
"A camada superior cont�m os drivers individuais que suportam dispositivos "
"espec�ficos (classes de). Esses drivers implementam o protocolo que � usado "
"nos pipes diferentes do padr�o. Eles tamb�m implementam funcionalidade "
"adicional para disponibilizar o dispositivo para outras partes do kernel ou "
"Eles usam a interface do driver USB (USBDI) exposta pela camada de servi�os. "
""

#. (itstool) path: sect1/title
#: book.translate.xml:21834
#, fuzzy
msgid "Host Controllers"
msgstr "Host Controllers"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:21836
#, fuzzy
msgid "<primary>USB</primary><secondary>host controllers</secondary>"
msgstr ""
" <primary> USB </primary><secondary> controladores de host </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:21838
#, fuzzy
msgid ""
"The host controller (HC) controls the transmission of packets on the bus. "
"Frames of 1 millisecond are used. At the start of each frame the host "
"controller generates a Start of Frame (SOF) packet."
msgstr ""
"O controlador host (HC) controla a transmiss�o de pacotes no barramento. S�o "
"usados ​​quadros de 1 milissegundo. No in�cio de cada quadro, o controlador "
"host gera um pacote Start of Frame (SOF)."

#. (itstool) path: sect1/para
#: book.translate.xml:21843
#, fuzzy
msgid ""
"The SOF packet is used to synchronise to the start of the frame and to keep "
"track of the frame number. Within each frame packets are transferred, either "
"from host to device (out) or from device to host (in). Transfers are always "
"initiated by the host (polled transfers). Therefore there can only be one "
"host per USB bus. Each transfer of a packet has a status stage in which the "
"recipient of the data can return either ACK (acknowledge reception), NAK "
"(retry), STALL (error condition) or nothing (garbled data stage, device not "
"available or disconnected). Section 8.5 of the USB 2.0 Specification "
"explains the details of packets in more detail. Four different types of "
"transfers can occur on a USB bus: control, bulk, interrupt and isochronous. "
"The types of transfers and their characteristics are described below."
msgstr ""
"O pacote SOF � usado para sincronizar com o in�cio do quadro e para "
"acompanhar o n�mero do quadro. Dentro de cada pacote de quadros s�o "
"transferidos, de host para dispositivo (out) ou de dispositivo para host "
"(in). As transfer�ncias s�o sempre Portanto, s� pode haver um host por "
"barramento USB Cada transfer�ncia de um pacote tem um est�gio de status no "
"qual o destinat�rio dos dados pode retornar ou ACK (recep��o de "
"confirma��o), NAK (repeti��o), STALL (condi��o de erro) ou nada (est�gio de "
"dados truncados, dispositivo n�o dispon�vel ou desconectado). A Se��o 8.5 da "
"Especifica��o USB 2.0 explica os detalhes dos pacotes em mais detalhes. "
"Quatro tipos diferentes de transfer�ncias podem ocorrer em um barramento USB:"
" controle, volume , interrup��es e is�cronas. Os tipos de transfer�ncias e "
"suas caracter�sticas s�o descritas a seguir. "

#. (itstool) path: sect1/para
#: book.translate.xml:21858
#, fuzzy
msgid ""
"Large transfers between the device on the USB bus and the device driver are "
"split up into multiple packets by the host controller or the HC driver."
msgstr ""
"Grandes transfer�ncias entre o dispositivo no barramento USB e o driver do "
"dispositivo s�o divididas em v�rios pacotes pelo controlador host ou pelo "
"driver HC."

#. (itstool) path: sect1/para
#: book.translate.xml:21862
#, fuzzy
msgid ""
"Device requests (control transfers) to the default endpoints are special. "
"They consist of two or three phases: SETUP, DATA (optional) and STATUS. The "
"set-up packet is sent to the device. If there is a data phase, the direction "
"of the data packet(s) is given in the set-up packet. The direction in the "
"status phase is the opposite of the direction during the data phase, or IN "
"if there was no data phase. The host controller hardware also provides "
"registers with the current status of the root ports and the changes that "
"have occurred since the last reset of the status change register. Access to "
"these registers is provided through a virtualised hub as suggested in the "
"USB specification. The virtual hub must comply with the hub device class "
"given in chapter 11 of that specification. It must provide a default pipe "
"through which device requests can be sent to it. It returns the standard "
"andhub class specific set of descriptors. It should also provide an "
"interrupt pipe that reports changes happening at its ports. There are "
"currently two specifications for host controllers available: Universal Host "
"Controller Interface (<acronym>UHCI</acronym>) from Intel and Open Host "
"Controller Interface (<acronym>OHCI</acronym>) from Compaq, Microsoft, and "
"National Semiconductor. The <acronym>UHCI</acronym> specification has been "
"designed to reduce hardware complexity by requiring the host controller "
"driver to supply a complete schedule of the transfers for each frame. OHCI "
"type controllers are much more independent by providing a more abstract "
"interface doing a lot of work themselves."
msgstr ""
"As solicita��es de dispositivos (transfer�ncias de controle) para os "
"terminais padr�o s�o especiais. Elas consistem em duas ou tr�s fases: "
"CONFIGURA��O, DADOS (opcional) e STATUS. O pacote de configura��o � enviado "
"para o dispositivo. Se houver uma fase de dados, o A dire��o do (s) pacote "
"(s) de dados � dada no pacote de configura��o A dire��o na fase de status � "
"o oposto da dire��o durante a fase de dados, ou IN se n�o houver fase de "
"dados O hardware controlador de host tamb�m fornece registros com o status "
"atual das portas raiz e as mudan�as ocorridas desde a �ltima reconfigura��o "
"do registro de mudan�a de status.O acesso a esses registros � fornecido por "
"meio de um hub virtualizado, conforme sugerido na especifica��o USB.O hub "
"virtual deve estar de acordo com o dispositivo de hub classe dada no "
"cap�tulo 11 da especifica��o.Ele deve fornecer um pipe padr�o atrav�s do "
"qual as solicita��es de dispositivo podem ser enviadas para ele.Ele retorna "
"o conjunto de descritores de classe andhub padr�o.Ele tamb�m deve fornecer "
"um pipe de interrup��o que relata mudan�as happe nos seus portos. Existem "
"atualmente duas especifica��es para controladores host dispon�veis: "
"Interface <acronym>UHCI</acronym> (Universal Host Controller Interface) da "
"Intel e <acronym>OHCI</acronym> (Open Host Controller Interface) da Compaq, "
"Microsoft e National Semiconductor. A especifica��o <acronym>UHCI</acronym> "
"foi projetada para reduzir a complexidade do hardware exigindo que o driver "
"do controlador host forne�a uma programa��o completa das transfer�ncias para "
"cada quadro. Os controladores do tipo OHCI s�o muito mais independentes, "
"fornecendo uma interface mais abstrata, fazendo muito trabalho por conta "
"pr�pria. "

#. (itstool) path: sect2/title
#: book.translate.xml:21891
#, fuzzy
msgid "UHCI"
msgstr "UHCI"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:21893
#, fuzzy
msgid "<primary>USB</primary> <secondary>UHCI</secondary>"
msgstr " <primary> USB </primary><secondary> UHCI </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:21898
#, fuzzy
msgid ""
"The UHCI host controller maintains a framelist with 1024 pointers to per "
"frame data structures. It understands two different data types: transfer "
"descriptors (TD) and queue heads (QH). Each TD represents a packet to be "
"communicated to or from a device endpoint. QHs are a means to groupTDs (and "
"QHs) together."
msgstr ""
"O controlador host UHCI mant�m uma lista de quadros com 1024 ponteiros para "
"estruturas de dados por quadro. Ele entende dois tipos de dados diferentes: "
"descritores de transfer�ncia (TD) e cabe�alhos de fila (QH). Cada TD "
"representa um pacote a ser comunicado para ou de um terminal de dispositivo "
"QHs s�o um meio para agrupar os DTs (e os QHs) juntos. "

#. (itstool) path: sect2/para
#: book.translate.xml:21905
#, fuzzy
msgid ""
"Each transfer consists of one or more packets. The UHCI driver splits large "
"transfers into multiple packets. For every transfer, apart from isochronous "
"transfers, a QH is allocated. For every type of transfer these QHs are "
"collected at a QH for that type. Isochronous transfers have to be executed "
"first because of the fixed latency requirement and are directly referred to "
"by the pointer in the framelist. The last isochronous TD refers to the QH "
"for interrupt transfers for that frame. All QHs for interrupt transfers "
"point at the QH for control transfers, which in turn points at the QH for "
"bulk transfers. The following diagram gives a graphical overview of this:"
msgstr ""
"Cada transfer�ncia consiste em um ou mais pacotes. O driver UHCI divide "
"grandes transfer�ncias em v�rios pacotes. Para cada transfer�ncia, al�m das "
"transfer�ncias is�cronas, um QH � alocado. Para cada tipo de transfer�ncia, "
"esses QHs s�o coletados em um QH para esse tipo. Transfer�ncias is�cronas "
"t�m que ser executadas primeiro por causa do requisito de lat�ncia fixa e "
"s�o diretamente referenciadas pelo ponteiro na lista de quadros.O �ltimo TD "
"is�crono refere-se ao QH para transfer�ncias de interrup��o para esse quadro."
"Todos os QHs para transfer�ncias interrompidas apontam para o QH para "
"controle de transfer�ncias, que por sua vez, aponta para o QH para "
"transfer�ncias em massa. O diagrama a seguir d� uma vis�o geral do gr�fico: "

#. (itstool) path: sect2/para
#: book.translate.xml:21918
#, fuzzy
msgid ""
"This results in the following schedule being run in each frame. After "
"fetching the pointer for the current frame from the framelist the controller "
"first executes the TDs for all the isochronous packets in that frame. The "
"last of these TDs refers to the QH for the interrupt transfers for thatframe."
" The host controller will then descend from that QH to the QHs for the "
"individual interrupt transfers. After finishing that queue, the QH for the "
"interrupt transfers will refer the controller to the QH for all control "
"transfers. It will execute all the subqueues scheduled there, followed by "
"all the transfers queued at the bulk QH. To facilitate the handling of "
"finished or failed transfers different types of interrupts are generated by "
"the hardware at the end of each frame. In the last TD for a transfer the "
"Interrupt-On Completion bit is set by the HC driver to flag an interrupt "
"when the transfer has completed. An error interrupt is flagged if a TD "
"reaches its maximum error count. If the short packet detect bit is set in a "
"TD and less than the set packet length is transferred this interrupt is "
"flagged to notify the controller driver of the completed transfer. It is the "
"host controller driver's task to find out which transfer has completed or "
"produced an error. When called the interrupt service routine will locate all "
"the finished transfers and call their callbacks."
msgstr ""
"Isso resulta no seguinte cronograma sendo executado em cada quadro. Depois "
"de buscar o ponteiro para o quadro atual a partir da lista de quadros, o "
"controlador primeiro executa os TDs para todos os pacotes is�cronos naquele "
"quadro. O �ltimo desses TDs refere-se ao QH para o quadro. interromper "
"transfer�ncias para aquele frame.O controlador host ent�o descer� daquele QH "
"para os QHs para as transfer�ncias de interrup��es individuais.Depois de "
"terminar essa fila, o QH para as transfer�ncias de interrup��es ir� "
"referenciar o controlador para o QH para todas as transfer�ncias de controle."
" as subfilas programadas l�, seguidas por todas as transfer�ncias "
"enfileiradas no QH em massa Para facilitar o processamento de transfer�ncias "
"conclu�das ou com falha, diferentes tipos de interrup��es s�o gerados pelo "
"hardware no final de cada quadro. -On O bit de conclus�o � definido pelo "
"driver HC para sinalizar uma interrup��o quando a transfer�ncia for "
"conclu�da.Uma interrup��o de erro � sinalizada se um TD atingir sua contagem "
"m�xima de erros. bit de detec��o de pacote � definido em um TD e menor que o "
"comprimento do pacote configurado � transferido, essa interrup��o � marcada "
"para notificar o driver do controlador da transfer�ncia conclu�da. � a "
"tarefa do driver do controlador host descobrir qual transfer�ncia concluiu "
"ou produziu um erro. Quando chamada, a rotina de servi�o de interrup��o "
"localizar� todas as transfer�ncias conclu�das e chamar� seus retornos de "
"chamada. "

#. (itstool) path: sect2/para
#: book.translate.xml:21942
#, fuzzy
msgid ""
"Refer to the <acronym>UHCI</acronym> Specification for a more elaborate "
"description."
msgstr ""
"Consulte a Especifica��o <acronym>UHCI</acronym> para uma descri��o mais "
"elaborada."

#. (itstool) path: sect2/title
#: book.translate.xml:21948
#, fuzzy
msgid "OHCI"
msgstr "OHCI"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:21950
#, fuzzy
msgid "<primary>USB</primary> <secondary>OHCI</secondary>"
msgstr " <primary> USB </primary><secondary> OHCI </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:21955
#, fuzzy
msgid ""
"Programming an OHCI host controller is much simpler. The controller assumes "
"that a set of endpoints is available, and is aware of scheduling priorities "
"and the ordering of the types of transfers in a frame. The main data "
"structure used by the host controller is the endpoint descriptor (ED) to "
"which a queue of transfer descriptors (TDs) is attached. The ED contains the "
"maximum packet size allowed for an endpoint and the controller hardware does "
"the splitting into packets. The pointers to the data buffers are updated "
"after each transfer and when the start and end pointer are equal, the TD is "
"retired to the done-queue. The four types of endpoints (interrupt, "
"isochronous, control, and bulk) have their own queues. Control and bulk "
"endpoints are queued each at their own queue. Interrupt EDs are queued in a "
"tree, with the level in the tree defining the frequency at which they run."
msgstr ""
"A programa��o de um controlador host OHCI � muito mais simples. O "
"controlador assume que um conjunto de terminais est� dispon�vel e est� "
"ciente das prioridades de planejamento e da ordena��o dos tipos de "
"transfer�ncias em um quadro. A estrutura de dados principal usada pelo "
"controlador host � a descritor de endpoint (ED) ao qual uma fila de "
"descritores de transfer�ncia (TDs) � anexada.O ED cont�m o tamanho m�ximo de "
"pacote permitido para um endpoint e o hardware do controlador faz a divis�o "
"em pacotes.Os ponteiros para os buffers de dados s�o atualizados ap�s cada "
"transfer�ncia e quando o ponteiro inicial e final s�o iguais, o TD � "
"retirado para a fila done.Os quatro tipos de endpoints (interrup��o, "
"is�crono, controle e bulk) t�m suas pr�prias filas.Os endpoints de controle "
"e em massa s�o enfileirados cada um em suas pr�prias filas. Os EDs de "
"interrup��o s�o enfileirados em uma �rvore, com o n�vel na �rvore definindo "
"a frequ�ncia na qual eles s�o executados. "

#. (itstool) path: sect2/para
#: book.translate.xml:21971
#, fuzzy
msgid ""
"The schedule being run by the host controller in each frame looks as follows."
" The controller will first run the non-periodic control and bulk queues, up "
"to a time limit set by the HC driver. Then the interrupt transfers for that "
"frame number are run, by using the lower five bits of the frame number as an "
"index into level 0 of the tree of interrupts EDs. At the end of this tree "
"the isochronous EDs are connected and these are traversed subsequently. The "
"isochronous TDs contain the frame number of the first frame the transfer "
"should be run in. After all the periodic transfers have been run, the "
"control and bulk queues are traversed again. Periodically the interrupt "
"service routine is called to process the done queue and call the callbacks "
"for each transfer and reschedule interrupt and isochronous endpoints."
msgstr ""
"O agendamento que est� sendo executado pelo controlador host em cada quadro "
"� o seguinte. O controlador primeiro executar� o controle n�o peri�dico e as "
"filas em massa, at� um limite de tempo definido pelo driver HC. Ent�o as "
"transfer�ncias de interrup��o para esse n�mero de quadros s�o executado, "
"usando os cinco bits inferiores do n�mero do quadro como um �ndice no n�vel "
"0 da �rvore de interrup��es EDs. No final desta �rvore os EDs is�cronos s�o "
"conectados e estes s�o percorridos subseq�entemente.Os TDs is�cronos cont�m "
"o n�mero do quadro de interrup��es. o primeiro quadro em que a transfer�ncia "
"deve ser executada. Depois que todas as transfer�ncias peri�dicas tiverem "
"sido executadas, as filas de controle e em massa ser�o novamente percorridas."
" Periodicamente, a rotina de servi�o de interrup��o � chamada para processar "
"a fila conclu�da e chamar os retornos de chamada para cada interrup��o de "
"transfer�ncia e reprograma��o e pontos finais is�cronos \""

#. (itstool) path: sect2/para
#: book.translate.xml:21986
#, fuzzy
msgid ""
"See the <acronym>UHCI</acronym> Specification for a more elaborate "
"description. The middle layer provides access to the device in a controlled "
"way and maintains resources in use by the different drivers and the services "
"layer. The layer takes care of the following aspects:"
msgstr ""
"Veja a Especifica��o <acronym>UHCI</acronym> para uma descri��o mais "
"elaborada. A camada intermedi�ria fornece acesso ao dispositivo de maneira "
"controlada e mant�m os recursos em uso pelos diferentes drivers e pela "
"camada de servi�os. A camada cuida dos seguintes aspectos:"

#. (itstool) path: listitem/para
#: book.translate.xml:21994
#, fuzzy
msgid "The device configuration information"
msgstr "A informa��o de configura��o do dispositivo"

#. (itstool) path: listitem/para
#: book.translate.xml:21997
#, fuzzy
msgid "The pipes to communicate with a device"
msgstr "Os canais para se comunicar com um dispositivo"

#. (itstool) path: listitem/para
#: book.translate.xml:22000
#, fuzzy
msgid "Probing and attaching and detaching form a device."
msgstr "Sondar e anexar e desanexar formam um dispositivo."

#. (itstool) path: sect1/title
#: book.translate.xml:22008
#, fuzzy
msgid "USB Device Information"
msgstr "Informa��es do dispositivo USB"

#. (itstool) path: sect2/title
#: book.translate.xml:22011
#, fuzzy
msgid "Device Configuration Information"
msgstr "Informa��es de configura��o do dispositivo"

#. (itstool) path: sect2/para
#: book.translate.xml:22013
#, fuzzy
msgid ""
"Each device provides different levels of configuration information. Each "
"device has one or more configurations, of which one is selected during probe/"
"attach. A configuration provides power and bandwidth requirements. Within "
"each configuration there can be multiple interfaces. A device interface is a "
"collection of endpoints. For example USB speakers can have an interface for "
"the audio data (Audio Class) and an interface for the knobs, dials and "
"buttons (HID Class). All interfaces in a configuration are active at the "
"same time and can be attached to by different drivers. Each interface can "
"have alternates, providing different quality of service parameters. In for "
"example cameras this is used to provide different frame sizes and numbers of "
"frames per second."
msgstr ""
"Cada dispositivo fornece diferentes n�veis de informa��es de configura��o. "
"Cada dispositivo tem uma ou mais configura��es, uma das quais � selecionada "
"durante a sonda / conex�o. Uma configura��o fornece requisitos de pot�ncia e "
"largura de banda. Dentro de cada configura��o pode haver v�rias interfaces. "
"Uma interface de dispositivo � uma cole��o de pontos de extremidade.Por "
"exemplo, os alto-falantes USB podem ter uma interface para os dados de �udio "
"(classe de �udio) e uma interface para os bot�es, bot�es e mostradores "
"(classe HID) .Todas as interfaces em uma configura��o est�o ativas ao mesmo "
"tempo por diferentes drivers. Cada interface pode ter alternativas, "
"fornecendo diferentes par�metros de qualidade de servi�o. Em c��meras, por "
"exemplo, isso � usado para fornecer diferentes tamanhos de quadros e n�meros "
"de quadros por segundo. "

#. (itstool) path: sect2/para
#: book.translate.xml:22028
#, fuzzy
msgid ""
"Within each interface, 0 or more endpoints can be specified. Endpoints are "
"the unidirectional access points for communicating with a device. They "
"provide buffers to temporarily store incoming or outgoing data from the "
"device. Each endpoint has a unique address within a configuration, the "
"endpoint's number plus its direction. The default endpoint, endpoint 0, is "
"not part of any interface and available in all configurations. It is managed "
"by the services layer and not directly available to device drivers."
msgstr ""
"Dentro de cada interface, 0 ou mais n�s de extremidade podem ser "
"especificados. Os pontos de extremidade s�o os pontos de acesso "
"unidirecionais para comunica��o com um dispositivo. Eles fornecem buffers "
"para armazenar temporariamente dados de entrada ou sa�da do dispositivo. "
"Cada n� de extremidade possui um endere�o exclusivo dentro de uma "
"configura��o. O n�mero do n� de extremidade mais sua dire��o. O ponto de "
"extremidade padr�o, ponto de extremidade 0, n�o faz parte de nenhuma "
"interface e est� dispon�vel em todas as configura��es. Ele � gerenciado pela "
"camada de servi�os e n�o est� diretamente dispon�vel para os drivers de "
"dispositivos. "

#. (itstool) path: sect2/para
#: book.translate.xml:22044
#, fuzzy
msgid ""
"This hierarchical configuration information is described in the device by a "
"standard set of descriptors (see section 9.6 of the USB specification). They "
"can be requested through the Get Descriptor Request. The services layer "
"caches these descriptors to avoid unnecessary transfers on the USB bus. "
"Access to the descriptors is provided through function calls."
msgstr ""
"Essas informa��es de configura��o hier�rquica s�o descritas no dispositivo "
"por um conjunto padr�o de descritores (consulte a se��o 9.6 da especifica��o "
"USB). Elas podem ser solicitadas por meio da solicita��o Get Descriptor. A "
"camada de servi�os armazena esses descritores para evitar transfer�ncias "
"desnecess�rias no barramento USB O acesso aos descritores � fornecido "
"atrav�s de chamadas de fun��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:22054
#, fuzzy
msgid ""
"Device descriptors: General information about the device, like Vendor, "
"Product and Revision Id, supported device class, subclass and protocol if "
"applicable, maximum packet size for the default endpoint, etc."
msgstr ""
"Descritores de dispositivo: informa��es gerais sobre o dispositivo, como "
"fornecedor, produto e ID de revis�o, classe de dispositivo compat�vel, "
"subclasse e protocolo, se aplic�vel, tamanho m�ximo de pacote para o "
"endpoint padr�o etc."

#. (itstool) path: listitem/para
#: book.translate.xml:22061
#, fuzzy
msgid ""
"Configuration descriptors: The number of interfaces in this configuration, "
"suspend and resume functionality supported and power requirements."
msgstr ""
"Descritores de configura��o: o n�mero de interfaces nesta configura��o, "
"suspender e retomar a funcionalidade suportada e os requisitos de energia."

#. (itstool) path: listitem/para
#: book.translate.xml:22067
#, fuzzy
msgid ""
"Interface descriptors: interface class, subclass and protocol if applicable, "
"number of alternate settings for the interface and the number of endpoints."
msgstr ""
"Descritores de interface: classe de interface, subclasse e protocolo, se "
"aplic�vel, n�mero de configura��es alternativas para a interface e o n�mero "
"de pontos de extremidade."

#. (itstool) path: listitem/para
#: book.translate.xml:22073
#, fuzzy
msgid ""
"Endpoint descriptors: Endpoint address, direction and type, maximum packet "
"size supported and polling frequency if type is interrupt endpoint. There is "
"no descriptor for the default endpoint (endpoint 0) and it is never counted "
"in an interface descriptor."
msgstr ""
"Endpoint descriptors: Endere�o, dire��o e tipo do endpoint, tamanho m�ximo "
"do pacote suportado e frequ�ncia de sondagem se o tipo for ponto final de "
"interrup��o. N�o h� um descritor para o endpoint padr�o (endpoint 0) e ele "
"nunca � contado em um descritor de interface."

#. (itstool) path: listitem/para
#: book.translate.xml:22081
#, fuzzy
msgid ""
"String descriptors: In the other descriptors string indices are supplied for "
"some fields.These can be used to retrieve descriptive strings, possibly in "
"multiple languages."
msgstr ""
"Descritores de strings: Nos outros descritores, s�o fornecidos �ndices de "
"strings para alguns campos. Eles podem ser usados ​​para recuperar strings "
"descritivas, possivelmente em m�ltiplos idiomas."

#. (itstool) path: sect2/para
#: book.translate.xml:22088
#, fuzzy
msgid ""
"Class specifications can add their own descriptor types that are available "
"through the GetDescriptor Request."
msgstr ""
"As especifica��es de classe podem adicionar seus pr�prios tipos de "
"descritores que est�o dispon�veis por meio da solicita��o GetDescriptor."

#. (itstool) path: sect2/para
#: book.translate.xml:22091
#, fuzzy
msgid ""
"Pipes Communication to end points on a device flows through so-called pipes. "
"Drivers submit transfers to endpoints to a pipe and provide a callback to be "
"called on completion or failure of the transfer (asynchronous transfers) or "
"wait for completion (synchronous transfer). Transfers to an endpoint are "
"serialised in the pipe. A transfer can either complete, fail or time-out (if "
"a time-out has been set). There are two types of time-outs for transfers. "
"Time-outs can happen due to time-out on the USBbus (milliseconds). These "
"time-outs are seen as failures and can be due to disconnection of the device."
" A second form of time-out is implemented in software and is triggered when "
"a transfer does not complete within a specified amount of time (seconds). "
"These are caused by a device acknowledging negatively (NAK) the transferred "
"packets. The cause for this is the device not being ready to receive data, "
"buffer under- or overrun or protocol errors."
msgstr ""
"Pipes Comunica��o para pontos finais em um dispositivo flui atrav�s de "
"chamados pipes. Drivers enviam transfer�ncias para pontos de extremidade "
"para um pipe e fornecem um retorno de chamada a ser chamado na conclus�o ou "
"falha da transfer�ncia (transfer�ncias ass�ncronas) ou aguardar conclus�o "
"(transfer�ncia s�ncrona) Transfer�ncias para um endpoint s�o serializadas no "
"pipe Uma transfer�ncia pode ser completada, falha ou time-out (se um time-"
"out tiver sido definido) Existem dois tipos de time-outs para transfer�ncias."
" para time-out no USBbus (milissegundos). Estes tempos debitados s�o vistos "
"como falhas e podem ser devidos � desconex�o do dispositivo.Uma segunda "
"forma de time-out � implementada no software e � disparada quando uma "
"transfer�ncia n�o � conclu�da dentro um determinado per�odo de tempo "
"(segundos). Eles s�o causados ​​por um dispositivo que reconhece "
"negativamente (NAK) os pacotes transferidos. A causa para isso � o "
"dispositivo n�o estar pronto para receber dados, erros de buffer ou de sub "
"ou de protocolo. "

#. (itstool) path: sect2/para
#: book.translate.xml:22109
#, fuzzy
msgid ""
"If a transfer over a pipe is larger than the maximum packet size specified "
"in the associated endpoint descriptor, the host controller (OHCI) or the HC "
"driver (UHCI) will split the transfer into packets of maximum packet size, "
"with the last packet possibly smaller than the maximum packet size."
msgstr ""
"Se uma transfer�ncia em um pipe for maior que o tamanho m�ximo de pacote "
"especificado no descritor de terminal associado, o controlador host (OHCI) "
"ou o driver HC (UHCI) dividir� a transfer�ncia em pacotes de tamanho m�ximo "
"de pacote, com o �ltimo pacote possivelmente menor que o tamanho m�ximo do "
"pacote. "

#. (itstool) path: sect2/para
#: book.translate.xml:22116
#, fuzzy
msgid ""
"Sometimes it is not a problem for a device to return less data than "
"requested. For example abulk-in-transfer to a modem might request 200 bytes "
"of data, but the modem has only 5 bytes available at that time. The driver "
"can set the short packet (SPD) flag. It allows the host controller to accept "
"a packet even if the amount of data transferred is less than requested. This "
"flag is only valid for in-transfers, as the amount of data to be sent to a "
"device is always known beforehand. If an unrecoverable error occurs in a "
"device during a transfer the pipe is stalled. Before any more data is "
"accepted or sent the driver needs to resolve the cause of the stall and "
"clear the endpoint stall condition through send the clear endpoint halt "
"device request over the default pipe. The default endpoint should never "
"stall."
msgstr ""
"�s vezes, n�o � um problema para um dispositivo retornar menos dados do que "
"o solicitado. Por exemplo, a transfer�ncia de dados em um modem pode "
"solicitar 200 bytes de dados, mas o modem tem apenas 5 bytes dispon�veis no "
"momento. O driver pode definir O sinalizador de pacote curto (SPD) permite "
"que o controlador host aceite um pacote, mesmo que a quantidade de dados "
"transferidos seja menor que a solicitada, este sinalizador s� � v�lido para "
"transfer�ncias, como a quantidade de dados a ser enviada para um dispositivo."
" Se um erro irrecuper�vel ocorrer em um dispositivo durante uma "
"transfer�ncia, o tubo ser� paralisado.Antes de mais dados serem aceitos ou "
"enviados, o driver precisa resolver a causa da paralisa��o e limpar a "
"condi��o de parada do endpoint atrav�s do envio do ponto de extremidade "
"limpo interromper a solicita��o do dispositivo pelo canal padr�o. O ponto de "
"extremidade padr�o nunca deve parar. "

#. (itstool) path: sect2/para
#: book.translate.xml:22131
#, fuzzy
msgid ""
"There are four different types of endpoints and corresponding pipes: - "
"Control pipe / default pipe: There is one control pipe per device, connected "
"to the default endpoint (endpoint 0). The pipe carries the device requests "
"and associated data. The difference between transfers over the default pipe "
"and other pipes is that the protocol for the transfers is described in the "
"USB specification. These requests are used to reset and configure the device."
" A basic set of commands that must be supported by each device is provided "
"in chapter 9 of the USB specification. The commands supported on this pipe "
"can be extended by a device class specification to support additional "
"functionality."
msgstr ""
"Existem quatro tipos diferentes de terminais e canais correspondentes: - "
"Canal de controle / canal padr�o: H� um canal de controle por dispositivo, "
"conectado ao ponto de extremidade padr�o (ponto de extremidade 0). O canal "
"transporta as solicita��es de dispositivo e dados associados. A diferen�a "
"entre transfer�ncias atrav�s do pipe padr�o e outros canais � que o "
"protocolo para as transfer�ncias � descrito na especifica��o USB.Esses "
"pedidos s�o usados ​​para redefinir e configurar o dispositivo.Um conjunto "
"b�sico de comandos que devem ser suportados por cada dispositivo � fornecido "
"no cap�tulo 9 da especifica��o USB. Os comandos suportados neste pipe podem "
"ser estendidos por uma especifica��o de classe de dispositivo para suportar "
"funcionalidades adicionais. "

#. (itstool) path: listitem/para
#: book.translate.xml:22146
#, fuzzy
msgid "Bulk pipe: This is the USB equivalent to a raw transmission medium."
msgstr ""
"Tubo em massa: este � o equivalente USB a um meio de transmiss�o bruto."

#. (itstool) path: listitem/para
#: book.translate.xml:22151
#, fuzzy
msgid ""
"Interrupt pipe: The host sends a request for data to the device and if the "
"device has nothing to send, it will NAK the data packet. Interrupt transfers "
"are scheduled at a frequency specified when creating the pipe."
msgstr ""
"Interrupt pipe: O host envia uma solicita��o de dados para o dispositivo e "
"se o dispositivo n�o tiver nada para enviar, ele NAK o pacote de dados. "
"Interromper transfer�ncias s�o agendadas em uma freq��ncia especificada ao "
"criar o pipe."

#. (itstool) path: listitem/para
#: book.translate.xml:22159
#, fuzzy
msgid ""
"Isochronous pipe: These pipes are intended for isochronous data, for example "
"video or audio streams, with fixed latency, but no guaranteed delivery. Some "
"support for pipes of this type is available in the current implementation. "
"Packets in control, bulk and interrupt transfers are retried if an error "
"occurs during transmission or the device acknowledges the packet negatively "
"(NAK) due to for example lack of buffer space to store the incoming data. "
"Isochronous packets are however not retried in case of failed delivery or "
"NAK of a packet as this might violate the timing constraints."
msgstr ""
"Tubo Is�crono: Esses canos s�o destinados a dados is�cronos, por exemplo, "
"fluxos de v�deo ou �udio, com lat�ncia fixa, mas sem entrega garantida. "
"Algum suporte para tubos deste tipo est� dispon�vel na implementa��o atual. "
"Pacotes no controle, em massa e interrup��o de transfer�ncias s�o repetidos "
"se ocorrer um erro durante a transmiss�o ou o dispositivo reconhecer o "
"pacote negativamente (NAK) devido a, por exemplo, falta de espa�o no buffer "
"para armazenar os dados recebidos.N�o � poss�vel tentar novamente pacotes "
"is�cronos em caso de falha na entrega ou NAK de um pacote. pode violar as "
"restri��es de tempo. "

#. (itstool) path: sect2/para
#: book.translate.xml:22174
#, fuzzy
msgid ""
"The availability of the necessary bandwidth is calculated during the "
"creation of the pipe. Transfers are scheduled within frames of 1 millisecond."
" The bandwidth allocation within a frame is prescribed by the USB "
"specification, section 5.6 [ 2]. Isochronous and interrupt transfers are "
"allowed to consume up to 90% of the bandwidth within a frame. Packets for "
"control and bulk transfers are scheduled after all isochronous and interrupt "
"packets and will consume all the remaining bandwidth."
msgstr ""
"A disponibilidade da largura de banda necess�ria � calculada durante a "
"cria��o do pipe. As transfer�ncias s�o programadas em quadros de 1 "
"milissegundo. A aloca��o de largura de banda dentro de um quadro � prescrita "
"pela especifica��o USB, se��o 5.6 [2]. S�o permitidas transfer�ncias "
"is�cronas e de interrup��o para consumir at� 90% da largura de banda dentro "
"de um quadro. Pacotes para controle e transfer�ncias em massa s�o agendados "
"ap�s todos os pacotes is�cronos e de interrup��o e consumir�o toda a largura "
"de banda restante. "

#. (itstool) path: sect2/para
#: book.translate.xml:22184
#, fuzzy
msgid ""
"More information on scheduling of transfers and bandwidth reclamation can be "
"found in chapter 5 of the USB specification, section 1.3 of the UHCI "
"specification, and section 3.4.2 of the OHCI specification."
msgstr ""
"Mais informa��es sobre o agendamento de transfer�ncias e a recupera��o de "
"banda podem ser encontradas no cap�tulo 5 da especifica��o USB, na se��o 1.3 "
"da especifica��o UHCI e na se��o 3.4.2 da especifica��o OHCI."

#. (itstool) path: sect1/title
#: book.translate.xml:22192
#, fuzzy
msgid "Device Probe and Attach"
msgstr "Device Probe and Attach"

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22194
#, fuzzy
msgid "<primary>USB</primary> <secondary>probe</secondary>"
msgstr " <primary> USB </primary><secondary> sonda </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22199
#, fuzzy
msgid ""
"After the notification by the hub that a new device has been connected, the "
"service layer switches on the port, providing the device with 100 mA of "
"current. At this point the device is in its default state and listening to "
"device address 0. The services layer will proceed to retrieve the various "
"descriptors through the default pipe. After that it will send a Set Address "
"request to move the device away from the default device address (address 0). "
"Multiple device drivers might be able to support the device. For example a "
"modem driver might be able to support an ISDN TA through the AT "
"compatibility interface. A driver for that specific model of the ISDN "
"adapter might however be able to provide much better support for this device."
" To support this flexibility, the probes return priorities indicating their "
"level of support. Support for a specific revision of a product ranks the "
"highest and the generic driver the lowest priority. It might also be that "
"multiple drivers could attach to one device if there are multiple interfaces "
"within one configuration. Each driver only needs to support a subset of the "
"interfaces."
msgstr ""
"Ap�s a notifica��o pelo hub de que um novo dispositivo foi conectado, a "
"camada de servi�o liga a porta, fornecendo ao dispositivo 100 mA de corrente."
" Neste ponto, o dispositivo est� no estado padr�o e escutando o endere�o 0 "
"do dispositivo. A camada de servi�os proceder� � recupera��o dos v�rios "
"descritores por meio do canal padr�o e, depois disso, enviar� uma "
"solicita��o Set Address para afastar o dispositivo do endere�o padr�o do "
"dispositivo (endere�o 0). V�rios drivers de dispositivo podem ser "
"compat�veis com o dispositivo. Por exemplo, um driver de modem pode ser "
"capaz de suportar um ISDN TA atrav�s da interface de compatibilidade AT Um "
"driver para esse modelo espec�fico do adaptador ISDN pode, no entanto, ser "
"capaz de fornecer um suporte muito melhor para este dispositivo Para "
"suportar essa flexibilidade, as sondas retornam prioridades indicando o seu "
"n�vel de suporte Suporte para uma revis�o espec�fica de um produto "
"classifica o mais alto eo driver gen�rico a menor prioridade.Pode tamb�m ser "
"que v�rios drivers poderiam anexar a um dev gelo se houver v�rias interfaces "
"dentro de uma configura��o. Cada driver precisa apenas suportar um "
"subconjunto das interfaces. "

#. (itstool) path: sect1/para
#: book.translate.xml:22218
#, fuzzy
msgid ""
"The probing for a driver for a newly attached device checks first for device "
"specific drivers. If not found, the probe code iterates over all supported "
"configurations until a driver attaches in a configuration. To support "
"devices with multiple drivers on different interfaces, the probe iterates "
"over all interfaces in a configuration that have not yet been claimed by a "
"driver. Configurations that exceed the power budget for the hub are ignored. "
"During attach the driver should initialise the device to its proper state, "
"but not reset it, as this will make the device disconnect itself from the "
"bus and restart the probing process for it. To avoid consuming unnecessary "
"bandwidth should not claim the interrupt pipe at attach time, but should "
"postpone allocating the pipe until the file is opened and the data is "
"actually used. When the file is closed the pipe should be closed again, even "
"though the device might still be attached."
msgstr ""
"A detec��o de um driver para um dispositivo rec�m-conectado verifica "
"primeiro os drivers espec�ficos do dispositivo. Se n�o encontrado, o c�digo "
"do probe repete todas as configura��es suportadas at� que um driver seja "
"anexado em uma configura��o. Para suportar dispositivos com v�rios drivers "
"em diferentes interfaces itera em todas as interfaces em uma configura��o "
"que ainda n�o foi reivindicada por um driver. As configura��es que excedem o "
"or�amento de energia para o hub s�o ignoradas. Durante a conex�o, o driver "
"deve inicializar o dispositivo no estado correto, mas n�o redefini-lo, pois "
"isso fa�a com que o dispositivo desconecte-se do barramento e reinicie o "
"processo de teste para evitar o consumo de largura de banda desnecess�ria "
"n�o deve reivindicar o pipe de interrup��o no momento da conex�o, mas deve "
"adiar a aloca��o do canal at� que o arquivo seja aberto e os dados realmente "
"usados. o arquivo est� fechado, o tubo deve ser fechado novamente, mesmo que "
"o dispositivo ainda possa estar conectado. "

#. (itstool) path: sect2/title
#: book.translate.xml:22236
#, fuzzy
msgid "Device Disconnect and Detach"
msgstr "Desconectar e desanexar o dispositivo"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:22238
#, fuzzy
msgid "<primary>USB</primary> <secondary>disconnect</secondary>"
msgstr " <primary> USB </primary><secondary> desconectar </secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:22243
#, fuzzy
msgid ""
"A device driver should expect to receive errors during any transaction with "
"the device. The design of USB supports and encourages the disconnection of "
"devices at any point in time. Drivers should make sure that they do the "
"right thing when the device disappears."
msgstr ""
"Um driver de dispositivo deve esperar receber erros durante qualquer "
"transa��o com o dispositivo. O design do USB suporta e encoraja a desconex�o "
"de dispositivos a qualquer momento. Os drivers devem garantir que eles fa�am "
"a coisa certa quando o dispositivo desaparecer."

#. (itstool) path: sect2/para
#: book.translate.xml:22249
#, fuzzy
msgid ""
"Furthermore a device that has been disconnected and reconnected will not be "
"reattached at the same device instance. This might change in the future when "
"more devices support serial numbers (see the device descriptor) or other "
"means of defining an identity for a device have been developed."
msgstr ""
"Al�m disso, um dispositivo que tenha sido desconectado e reconectado n�o "
"ser� reconectado na mesma inst�ncia do dispositivo. Isso pode mudar no "
"futuro quando mais dispositivos suportarem n�meros de s�rie (consulte o "
"descritor de dispositivo) ou outros meios de definir uma identidade para um "
"dispositivo. desenvolvido."

#. (itstool) path: sect2/para
#: book.translate.xml:22256
#, fuzzy
msgid ""
"The disconnection of a device is signaled by a hub in the interrupt packet "
"delivered to the hub driver. The status change information indicates which "
"port has seen a connection change. The device detach method for all device "
"drivers for the device connected on that port are called and the structures "
"cleaned up. If the port status indicates that in the mean time a device has "
"been connected to that port, the procedure for probing and attaching the "
"device will be started. A device reset will produce a disconnect-connect "
"sequence on the hub and will be handled as described above."
msgstr ""
"A desconex�o de um dispositivo � sinalizada por um hub no pacote de "
"interrup��o entregue ao driver do hub. As informa��es de mudan�a de status "
"indicam qual porta detectou uma altera��o de conex�o. O m�todo de remo��o de "
"dispositivo para todos os drivers de dispositivos conectados ao dispositivo "
"est� Se o status da porta indicar que, nesse meio tempo, um dispositivo foi "
"conectado a essa porta, ser� iniciado o procedimento para sondar e conectar "
"o dispositivo.Uma reinicializa��o do dispositivo produzir� uma sequ�ncia de "
"conex�o de desconex�o no sistema. hub e ser� tratado conforme descrito acima."
" "

#. (itstool) path: sect1/title
#: book.translate.xml:22271
#, fuzzy
msgid "USB Drivers Protocol Information"
msgstr "Informa��es do protocolo de drivers USB"

#. (itstool) path: sect1/para
#: book.translate.xml:22273
#, fuzzy
msgid ""
"The protocol used over pipes other than the default pipe is undefined by the "
"USB specification. Information on this can be found from various sources. "
"The most accurate source is the developer's section on the USB home pages. "
"From these pages, a growing number of deviceclass specifications are "
"available. These specifications specify what a compliant device should look "
"like from a driver perspective, basic functionality it needs to provide and "
"the protocol that is to be used over the communication channels. The USB "
"specification includes the description of the Hub Class. A class "
"specification for Human Interface Devices (HID) has been created to cater "
"for keyboards, tablets, bar-code readers, buttons, knobs, switches, etc. A "
"third example is the class specification for mass storage devices. For a "
"full list of device classes see the developers section on the USB home pages."
""
msgstr ""
"O protocolo usado em outros pipes al�m do pipe padr�o � indefinido pela "
"especifica��o USB. Informa��es sobre isso podem ser encontradas em v�rias "
"fontes. A fonte mais precisa � a se��o do desenvolvedor nas home pages USB. "
"A partir dessas p�ginas, um n�mero crescente de Est�o dispon�veis "
"especifica��es deviceclass Estas especifica��es especificam como deve ser um "
"dispositivo compat�vel do ponto de vista do driver, a funcionalidade b�sica "
"que ele precisa fornecer e o protocolo que deve ser usado nos canais de "
"comunica��o.A especifica��o USB inclui a descri��o da Classe Hub. Uma "
"especifica��o de classe para dispositivos de interface humana (HID) foi "
"criada para atender a teclados, tablets, leitores de c�digo de barras, "
"bot�es, bot�es, switches, etc. Um terceiro exemplo � a especifica��o de "
"classe para dispositivos de armazenamento em massa. classes de dispositivos, "
"consulte a se��o de desenvolvedores nas p�ginas iniciais do USB. "

#. (itstool) path: sect1/para
#: book.translate.xml:22289
#, fuzzy
msgid ""
"For many devices the protocol information has not yet been published however."
" Information on the protocol being used might be available from the company "
"making the device. Some companies will require you to sign a Non -Disclosure "
"Agreement (NDA) before giving you the specifications. This in most cases "
"precludes making the driver open source."
msgstr ""
"Para muitos dispositivos, as informa��es do protocolo ainda n�o foram "
"publicadas. Informa��es sobre o protocolo usado podem estar dispon�veis na "
"empresa que faz o dispositivo. Algumas empresas exigir�o que voc� assine um "
"Acordo de N�o-Divulga��o (NDA) antes de fornecer as especifica��es. Isso, na "
"maioria dos casos, impede que o driver seja open source. "

#. (itstool) path: sect1/para
#: book.translate.xml:22296
#, fuzzy
msgid ""
"Another good source of information is the Linux driver sources, as a number "
"of companies have started to provide drivers for Linux for their devices. It "
"is always a good idea to contact the authors of those drivers for their "
"source of information."
msgstr ""
"Outra boa fonte de informa��o s�o as fontes de drivers do Linux, j� que "
"v�rias empresas come�aram a fornecer drivers para o Linux em seus "
"dispositivos. � sempre uma boa id�ia entrar em contato com os autores desses "
"drivers para obter informa��es."

#. (itstool) path: sect1/para
#: book.translate.xml:22302
#, fuzzy
msgid ""
"Example: Human Interface Devices The specification for the Human Interface "
"Devices like keyboards, mice, tablets, buttons, dials,etc. is referred to in "
"other device class specifications and is used in many devices."
msgstr ""
"Exemplo: dispositivos de interface humana A especifica��o para dispositivos "
"de interface humana como teclados, mouses, tablets, bot�es, dials, etc. � "
"referida em outras especifica��es de classe de dispositivo e � usada em "
"muitos dispositivos."

#. (itstool) path: sect1/para
#: book.translate.xml:22307
#, fuzzy
msgid ""
"For example audio speakers provide endpoints to the digital to analogue "
"converters and possibly an extra pipe for a microphone. They also provide a "
"HID endpoint in a separate interface for the buttons and dials on the front "
"of the device. The same is true for the monitor control class. It is "
"straightforward to build support for these interfaces through the available "
"kernel and userland libraries together with the HID class driver or the "
"generic driver. Another device that serves as an example for interfaces "
"within one configuration driven by different device drivers is a cheap "
"keyboard with built-in legacy mouse port. To avoid having the cost of "
"including the hardware for a USB hub in the device, manufacturers combined "
"the mouse data received from the PS/2 port on the back of the keyboard and "
"the key presses from the keyboard into two separate interfaces in the same "
"configuration. The mouse and keyboard drivers each attach to the appropriate "
"interface and allocate the pipes to the two independent endpoints."
msgstr ""
"Por exemplo, os alto-falantes de �udio fornecem pontos finais para os "
"conversores digitais para anal�gicos e possivelmente um tubo extra para um "
"microfone. Eles tamb�m fornecem um ponto de extremidade HID em uma interface "
"separada para os bot�es e mostradores na frente do dispositivo. O mesmo vale "
"para o � f�cil criar suporte para essas interfaces por meio das bibliotecas "
"kernel e userland dispon�veis, juntamente com o driver de classe HID ou o "
"driver gen�rico.Um outro dispositivo que serve como exemplo para interfaces "
"dentro de uma configura��o controlada por drivers de dispositivo diferentes "
"� um Teclado barato com porta de mouse legado integrada Para evitar o custo "
"de incluir o hardware de um hub USB no dispositivo, os fabricantes "
"combinaram os dados do mouse recebidos da porta PS / 2 na parte de tr�s do "
"teclado e as teclas pressionadas de o teclado em duas interfaces separadas "
"na mesma configura��o.Os drivers de mouse e teclado cada um anexar � "
"interface apropriada e alocar os tubos para os dois endpoints independentes. "
""

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22326
#, fuzzy
msgid "<primary>USB</primary> <secondary>firmware</secondary>"
msgstr " <primary> USB </primary><secondary> firmware </secondary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22331
#, fuzzy
msgid ""
"Example: Firmware download Many devices that have been developed are based "
"on a general purpose processor with an additional USB core added to it. "
"Because the development of drivers and firmware for USB devices is still "
"very new, many devices require the downloading of the firmware after they "
"have been connected."
msgstr ""
"Exemplo: download de firmware Muitos dispositivos que foram desenvolvidos "
"s�o baseados em um processador de uso geral com um n�cleo USB adicional. "
"Como o desenvolvimento de drivers e firmware para dispositivos USB ainda � "
"muito novo, muitos dispositivos exigem o download do firmware depois de "
"terem sido conectados \""

#. (itstool) path: sect1/para
#: book.translate.xml:22338
#, fuzzy
msgid ""
"The procedure followed is straightforward. The device identifies itself "
"through a vendor and product Id. The first driver probes and attaches to it "
"and downloads the firmware into it. After that the device soft resets itself "
"and the driver is detached. After a short pause the device announces its "
"presence on the bus. The device will have changed its vendor/product/"
"revision Id to reflect the fact that it has been supplied with firmware and "
"as a consequence a second driver will probe it and attach to it."
msgstr ""
"O procedimento seguido � direto. O dispositivo se identifica por meio de um "
"fornecedor e um ID do produto. O primeiro driver detecta e anexa a ele e faz "
"o download do firmware. Depois disso, o dispositivo � reiniciado e o driver "
"� desconectado. Ap�s uma breve pausa o dispositivo anuncia sua presen�a no "
"barramento. O dispositivo ter� mudado seu ID de fornecedor / produto / "
"revis�o para refletir o fato de que ele foi fornecido com firmware e, como "
"conseq��ncia, um segundo driver ir� sond�-lo e anex�-lo. "

#. (itstool) path: sect1/para
#: book.translate.xml:22348
#, fuzzy
msgid ""
"An example of these types of devices is the ActiveWire I/O board, based on "
"the EZ-USB chip. For this chip a generic firmware downloader is available. "
"The firmware downloaded into the ActiveWire board changes the revision Id. "
"It will then perform a soft reset of the USB part of the EZ-USB chip to "
"disconnect from the USB bus and again reconnect."
msgstr ""
"Um exemplo desses tipos de dispositivos � a placa de E / S do ActiveWire, "
"baseada no chip EZ-USB. Para este chip, um downloader de firmware gen�rico "
"est� dispon�vel. O firmware baixado no quadro do ActiveWire altera o ID da "
"revis�o. uma reinicializa��o suave da parte USB do chip EZ-USB para "
"desconectar do barramento USB e reconectar novamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:22355
#, fuzzy
msgid ""
"Example: Mass Storage Devices Support for mass storage devices is mainly "
"built around existing protocols. The Iomega USB Zipdrive is based on the "
"SCSI version of their drive. The SCSI commands and status messages are "
"wrapped in blocks and transferred over the bulk pipes to and from the "
"device, emulating a SCSI controller over the USB wire. ATAPI and UFI "
"commands are supported in a similar fashion."
msgstr ""
"Exemplo: Dispositivos de armazenamento em massa O suporte para dispositivos "
"de armazenamento em massa � constru�do principalmente em torno dos "
"protocolos existentes. O Iomega USB Zipdrive � baseado na vers�o SCSI da "
"unidade. Os comandos SCSI e as mensagens de status s�o agrupados em blocos e "
"transferidos para a partir do dispositivo, emulando um controlador SCSI "
"atrav�s do cabo USB. Os comandos ATAPI e UFI s�o suportados de forma "
"semelhante. "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22363
#, fuzzy
msgid "<primary>ATAPI</primary>"
msgstr " <primary> ATAPI </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22365
#, fuzzy
msgid ""
"The Mass Storage Specification supports 2 different types of wrapping of the "
"command block.The initial attempt was based on sending the command and "
"status through the default pipe and using bulk transfers for the data to be "
"moved between the host and the device. Based on experience a second approach "
"was designed that was based on wrapping the command and status blocks and "
"sending them over the bulk out and in endpoint. The specification specifies "
"exactly what has to happen when and what has to be done in case an error "
"condition is encountered. The biggest challenge when writing drivers for "
"these devices is to fit USB based protocol into the existing support for "
"mass storage devices. CAM provides hooks to do this in a fairly straight "
"forward way. ATAPI is less simple as historically the IDE interface has "
"never had many different appearances."
msgstr ""
"A especifica��o de armazenamento em massa suporta dois tipos diferentes de "
"quebra autom�tica do bloco de comando. A tentativa inicial foi baseada no "
"envio do comando e status atrav�s do pipe padr�o e usando transfer�ncias em "
"massa para os dados a serem movidos entre o host e o dispositivo. "
"experi�ncia uma segunda abordagem foi projetada com base em agrupar os "
"blocos de comando e status e envi�-los pelo bulk out e no endpoint.A "
"especifica��o especifica exatamente o que deve acontecer quando e o que deve "
"ser feito no caso de uma condi��o de erro ser encontrada. O maior desafio ao "
"escrever drivers para esses dispositivos � adequar o protocolo baseado em "
"USB ao suporte existente para dispositivos de armazenamento em massa.AMPI � "
"mais simples, j� que historicamente a interface IDE nunca teve muitos "
"recursos. apar�ncias diferentes \""

#. (itstool) path: sect1/para
#: book.translate.xml:22380
#, fuzzy
msgid ""
"The support for the USB floppy from Y-E Data is again less straightforward "
"as a new command set has been designed."
msgstr ""
"O suporte para o disquete USB da YE Data � novamente menos simples, j� que "
"um novo conjunto de comandos foi projetado."

#. (itstool) path: info/title
#: book.translate.xml:22411
#, fuzzy
msgid "Newbus"
msgstr "Newbus"

#. (itstool) path: affiliation/address
#: book.translate.xml:22420
#, fuzzy, no-wrap
msgid "\n"
"\t    <email>asmodai@FreeBSD.org</email>\n"
"\t  "
msgstr "<email>asmodai@FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22414
#, fuzzy
msgid ""
"<personname> <firstname>Jeroen</firstname> <surname>Ruigrok van der Werven "
"(asmodai)</surname> </personname> <affiliation> <_:address-1/> </"
"affiliation> <contrib>Written by </contrib>"
msgstr ""
" <personname><firstname> Jeroen </firstname><surname> Ruigrok van der Werven "
"(asmodai) </surname></personname><affiliation> <_: endere�o-1 /> </"
"affiliation><contrib> Escrito por </contrib> "

#. (itstool) path: affiliation/address
#: book.translate.xml:22432
#, fuzzy, no-wrap
msgid "\n"
"\t    <email>hiten@uk.FreeBSD.org</email>\n"
"\t  "
msgstr "<email>hiten@uk.FreeBSD.org</email>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22426
#, fuzzy
msgid ""
"<personname> <firstname>Hiten</firstname> <surname>Pandya</surname> </"
"personname> <affiliation> <_:address-1/> </affiliation>"
msgstr ""
" <personname><firstname> Hiten </firstname><surname> Pandya </surname></"
"personname><affiliation> <_: endere�o-1 /> </affiliation> "

#. (itstool) path: chapter/para
#: book.translate.xml:22440
#, fuzzy
msgid ""
"<emphasis>Special thanks to Matthew N. Dodd, Warner Losh, Bill Paul, Doug "
"Rabson, Mike Smith, Peter Wemm and Scott Long</emphasis>."
msgstr ""
" <emphasis> Agradecimentos especiais a Matthew N. Dodd, Warner Losh, Bill "
"Paul, Doug Rabson, Mike Smith, Peter Wemm e Scott Long </emphasis> "

#. (itstool) path: chapter/para
#: book.translate.xml:22444
#, fuzzy
msgid "This chapter explains the Newbus device framework in detail."
msgstr "Este cap�tulo explica a estrutura do dispositivo Newbus em detalhes."

#. (itstool) path: sect2/title
#: book.translate.xml:22451
#, fuzzy
msgid "Purpose of a Device Driver"
msgstr "Prop�sito de um driver de dispositivo"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:22455
#, fuzzy
msgid "<primary>device driver</primary><secondary>introduction</secondary>"
msgstr ""
" <primary> driver do dispositivo </primary><secondary> introdu��o </"
"secondary> "

#. (itstool) path: sect2/para
#: book.translate.xml:22458
#, fuzzy
msgid ""
"A device driver is a software component which provides the interface between "
"the kernel's generic view of a peripheral (e.g., disk, network adapter) and "
"the actual implementation of the peripheral. The <emphasis>device driver "
"interface (DDI)</emphasis> is the defined interface between the kernel and "
"the device driver component."
msgstr ""
"Um driver de dispositivo � um componente de software que fornece a interface "
"entre a vis�o gen�rica do kernel de um perif�rico (por exemplo, disco, "
"adaptador de rede) ea implementa��o real do perif�rico. <emphasis> interface "
"de driver de dispositivo (DDI) </emphasis> � a interface definida entre o "
"kernel e o componente do driver de dispositivo. "

#. (itstool) path: sect2/title
#: book.translate.xml:22467
#, fuzzy
msgid "Types of Device Drivers"
msgstr "Tipos de drivers de dispositivos"

#. (itstool) path: sect2/para
#: book.translate.xml:22469
#, fuzzy
msgid ""
"There used to be days in <trademark class=\"registered\">UNIX</trademark>, "
"and thus FreeBSD, in which there were four types of devices defined:"
msgstr ""
"Costumava haver dias em <trademark class=\"registered\"> UNIX </trademark> "
"e, portanto, FreeBSD, em que havia quatro tipos de dispositivos definidos: "

#. (itstool) path: listitem/para
#: book.translate.xml:22473
#, fuzzy
msgid "block device drivers"
msgstr "bloquear drivers de dispositivo"

#. (itstool) path: listitem/para
#: book.translate.xml:22474
#, fuzzy
msgid "character device drivers"
msgstr "drivers de dispositivo de caractere"

#. (itstool) path: listitem/para
#: book.translate.xml:22475
#, fuzzy
msgid "network device drivers"
msgstr "drivers de dispositivo de rede"

#. (itstool) path: listitem/para
#: book.translate.xml:22476
#, fuzzy
msgid "pseudo-device drivers"
msgstr "drivers de pseudo-dispositivo"

#. (itstool) path: sect2/para
#: book.translate.xml:22481
#, fuzzy
msgid ""
"<emphasis>Block devices</emphasis> performed in a way that used fixed size "
"blocks [of data]. This type of driver depended on the so-called "
"<emphasis>buffer cache</emphasis>, which had cached accessed blocks of data "
"in a dedicated part of memory. Often this buffer cache was based on write-"
"behind, which meant that when data was modified in memory it got synced to "
"disk whenever the system did its periodical disk flushing, thus optimizing "
"writes."
msgstr ""
" <emphasis> Dispositivos de bloco </emphasis> realizada de maneira que "
"usasse blocos de tamanho fixo [de dados]. Este tipo de driver dependia do "
"chamado <emphasis> cache de buffer </emphasis> , que armazenou em cache "
"blocos de dados acessados ​​em uma parte dedicada da mem�ria. Muitas vezes, "
"esse cache de buffer era baseado em write-behind, o que significava que "
"quando os dados eram modificados na mem�ria, ele era sincronizado com o "
"disco sempre que o sistema fazia a limpeza peri�dica do disco, otimizando as "
"grava��es. "

#. (itstool) path: sect2/para
#: book.translate.xml:22496
#, fuzzy
msgid ""
"However, in the versions of FreeBSD 4.0 and onward the distinction between "
"block and character devices became non-existent."
msgstr ""
"No entanto, nas vers�es do FreeBSD 4.0 e em diante a distin��o entre os "
"dispositivos de bloco e de caractere tornou-se inexistente."

#. (itstool) path: sect1/title
#: book.translate.xml:22507
#, fuzzy
msgid "Overview of Newbus"
msgstr "Vis�o geral do Newbus"

#. (itstool) path: sect1/para
#: book.translate.xml:22511
#, fuzzy
msgid ""
"<emphasis>Newbus</emphasis> is the implementation of a new bus architecture "
"based on abstraction layers which saw its introduction in FreeBSD 3.0 when "
"the Alpha port was imported into the source tree. It was not until 4.0 "
"before it became the default system to use for device drivers. Its goals are "
"to provide a more object-oriented means of interconnecting the various "
"busses and devices which a host system provides to the <emphasis>Operating "
"System</emphasis>."
msgstr ""
" <emphasis> Newbus </emphasis> � a implementa��o de uma nova arquitetura de "
"barramento baseada em camadas de abstra��o que viu sua introdu��o no FreeBSD "
"3.0 quando a porta Alpha foi importada para a �rvore de fontes. N�o era at� "
"4.0 antes de se tornar o sistema padr�o para usar drivers de dispositivo. "
"Seus objetivos s�o fornecer meios mais orientados a objeto de interconectar "
"os v�rios barramentos e dispositivos que um sistema host fornece ao "
"<emphasis> Sistema operacional </emphasis> "

#. (itstool) path: sect1/para
#: book.translate.xml:22520
#, fuzzy
msgid "Its main features include amongst others:"
msgstr "Suas principais caracter�sticas incluem entre outras:"

#. (itstool) path: listitem/para
#: book.translate.xml:22523
#, fuzzy
msgid "dynamic attaching"
msgstr "anexa��o din�mica"

#. (itstool) path: listitem/para
#: book.translate.xml:22524
#, fuzzy
msgid "easy modularization of drivers"
msgstr "modulariza��o f�cil de drivers"

#. (itstool) path: listitem/para
#: book.translate.xml:22525
#, fuzzy
msgid "pseudo-busses"
msgstr "pseudo-�nibus"

#. (itstool) path: sect1/para
#: book.translate.xml:22528
#, fuzzy
msgid ""
"One of the most prominent changes is the migration from the flat and ad-hoc "
"system to a device tree layout."
msgstr ""
"Uma das mudan�as mais proeminentes � a migra��o do sistema plano e ad-hoc "
"para o layout de uma �rvore de dispositivos."

#. (itstool) path: sect1/para
#: book.translate.xml:22531
#, fuzzy
msgid ""
"At the top level resides the <emphasis><quote>root</quote></emphasis> device "
"which is the parent to hang all other devices on. For each architecture, "
"there is typically a single child of <quote>root</quote> which has such "
"things as <emphasis>host-to-PCI bridges</emphasis>, etc. attached to it. For "
"x86, this <quote>root</quote> device is the <emphasis><quote>nexus</quote></"
"emphasis> device. For Alpha, various different models of Alpha have "
"different top-level devices corresponding to the different hardware "
"chipsets, including <emphasis>lca</emphasis>, <emphasis>apecs</emphasis>, "
"<emphasis>cia</emphasis> and <emphasis>tsunami</emphasis>."
msgstr ""
"No n�vel superior reside o <emphasis><quote> raiz </quote></emphasis> "
"dispositivo que � o pai para pendurar todos os outros dispositivos. Para "
"cada arquitetura, normalmente h� um �nico filho de <quote> raiz </quote> que "
"tem coisas como <emphasis> pontes host-para-PCI </emphasis> , etc. anexado a "
"ele. Para x86, isso <quote> raiz </quote> dispositivo � o <emphasis><quote> "
"nexo </quote></emphasis> dispositivo. Para Alpha, v�rios modelos diferentes "
"de Alpha t�m diferentes dispositivos de n�vel superior correspondentes aos "
"diferentes chipsets de hardware, incluindo <emphasis> lca </emphasis> , "
"<emphasis> apecs </emphasis> , <emphasis> cia </emphasis> e <emphasis> "
"tsunami </emphasis> "

#. (itstool) path: sect1/para
#: book.translate.xml:22544
#, fuzzy
msgid ""
"A device in the Newbus context represents a single hardware entity in the "
"system. For instance each PCI device is represented by a Newbus device. Any "
"device in the system can have children; a device which has children is often "
"called a <emphasis><quote>bus</quote></emphasis>. Examples of common busses "
"in the system are ISA and PCI, which manage lists of devices attached to ISA "
"and PCI busses respectively."
msgstr ""
"Um dispositivo no contexto Newbus representa uma �nica entidade de hardware "
"no sistema. Por exemplo, cada dispositivo PCI � representado por um "
"dispositivo Newbus. Qualquer dispositivo no sistema pode ter filhos; um "
"dispositivo que tem filhos � muitas vezes chamado de <emphasis><quote> "
"�nibus </quote></emphasis> . Exemplos de barramentos comuns no sistema s�o "
"ISA e PCI, que gerenciam listas de dispositivos conectados aos barramentos "
"ISA e PCI, respectivamente. "

#. (itstool) path: sect1/para
#: book.translate.xml:22552
#, fuzzy
msgid ""
"Often, a connection between different kinds of bus is represented by a "
"<emphasis><quote>bridge</quote></emphasis> device, which normally has one "
"child for the attached bus. An example of this is a <emphasis>PCI-to-PCI "
"bridge</emphasis> which is represented by a device "
"<emphasis><filename>pcibN</filename></emphasis> on the parent PCI bus and "
"has a child <emphasis><filename>pciN</filename></emphasis> for the attached "
"bus. This layout simplifies the implementation of the PCI bus tree, allowing "
"common code to be used for both top-level and bridged busses."
msgstr ""
"Muitas vezes, uma conex�o entre diferentes tipos de �nibus � representada "
"por um <emphasis><quote> ponte </quote></emphasis> dispositivo, que "
"normalmente tem um filho para o barramento conectado. Um exemplo disso � um "
"<emphasis> Ponte PCI-para-PCI </emphasis> que � representado por um "
"dispositivo <emphasis><filename> pcibN </filename></emphasis> no barramento "
"PCI pai e tem um filho <emphasis><filename> pciN </filename></emphasis> para "
"o barramento anexado. Esse layout simplifica a implementa��o da �rvore de "
"barramento PCI, permitindo que c�digo comum seja usado para barramentos de "
"n�vel superior e em ponte. "

#. (itstool) path: sect1/para
#: book.translate.xml:22564
#, fuzzy
msgid ""
"Each device in the Newbus architecture asks its parent to map its resources. "
"The parent then asks its own parent until the nexus is reached. So, "
"basically the nexus is the only part of the Newbus system which knows about "
"all resources."
msgstr ""
"Cada dispositivo na arquitetura Newbus pede ao seu pai para mapear seus "
"recursos. O pai ent�o pergunta ao seu pr�prio pai at� que o nexo seja "
"alcan�ado. Ent�o, basicamente, o nexo � a �nica parte do sistema Newbus que "
"conhece todos os recursos."

#. (itstool) path: tip/para
#: book.translate.xml:22569
#, fuzzy
msgid ""
"An ISA device might want to map its IO port at <literal>0x230</literal>, so "
"it asks its parent, in this case the ISA bus. The ISA bus hands it over to "
"the PCI-to-ISA bridge which in its turn asks the PCI bus, which reaches the "
"host-to-PCI bridge and finally the nexus. The beauty of this transition "
"upwards is that there is room to translate the requests. For example, the "
"<literal>0x230</literal> IO port request might become memory-mapped at "
"<literal>0xb0000230</literal> on a <acronym>MIPS</acronym> box by the PCI "
"bridge."
msgstr ""
"Um dispositivo ISA pode querer mapear sua porta IO em <literal> 0x230 </"
"literal> , ent�o ele pergunta a seus pais, neste caso, o barramento ISA. O "
"barramento ISA passa para a ponte PCI-para-ISA, que, por sua vez, solicita o "
"barramento PCI, que alcan�a a ponte host-para-PCI e, finalmente, o nexus. A "
"beleza dessa transi��o para cima � que h� espa�o para traduzir os pedidos. "
"Por exemplo, o <literal> 0x230 </literal> A solicita��o de porta IO pode se "
"tornar mapeada na mem�ria em <literal> 0xb0000230 </literal> em uma caixa "
"<acronym>MIPS</acronym> pela ponte PCI \""

#. (itstool) path: sect1/para
#: book.translate.xml:22580
#, fuzzy
msgid ""
"Resource allocation can be controlled at any place in the device tree. For "
"instance on many Alpha platforms, ISA interrupts are managed separately from "
"PCI interrupts and resource allocations for ISA interrupts are managed by "
"the Alpha's ISA bus device. On IA-32, ISA and PCI interrupts are both "
"managed by the top-level nexus device. For both ports, memory and port "
"address space is managed by a single entity - nexus for IA-32 and the "
"relevant chipset driver on Alpha (e.g., CIA or tsunami)."
msgstr ""
"A aloca��o de recursos pode ser controlada em qualquer lugar na �rvore de "
"dispositivos. Por exemplo, em muitas plataformas Alpha, as interrup��es do "
"ISA s�o gerenciadas separadamente das interrup��es PCI e as aloca��es de "
"recursos para as interrup��es do ISA s�o gerenciadas pelo dispositivo de "
"barramento ISA do Alpha. e interrup��es PCI s�o gerenciadas pelo dispositivo "
"nexus de n�vel superior.Para as duas portas, mem�ria e espa�o de endere�o de "
"porta s�o gerenciados por uma �nica entidade - nexo para IA-32 e o driver do "
"chipset relevante em Alpha (por exemplo, CIA ou tsunami). "

#. (itstool) path: sect1/para
#: book.translate.xml:22590
#, fuzzy
msgid ""
"In order to normalize access to memory and port mapped resources, Newbus "
"integrates the <literal>bus_space</literal> APIs from NetBSD. These provide "
"a single API to replace inb/outb and direct memory reads/writes. The "
"advantage of this is that a single driver can easily use either memory-"
"mapped registers or port-mapped registers (some hardware supports both)."
msgstr ""
"Para normalizar o acesso � mem�ria e aos recursos mapeados pela porta, o "
"Newbus integra <literal> bus_space </literal> APIs do NetBSD. Eles fornecem "
"uma �nica API para substituir leituras / grava��es de mem�ria inb / outb e "
"direta. A vantagem disso � que um �nico driver pode facilmente usar "
"registradores mapeados na mem�ria ou registradores mapeados pela porta "
"(alguns suportam hardware ambos). "

#. (itstool) path: sect1/para
#: book.translate.xml:22597
#, fuzzy
msgid ""
"This support is integrated into the resource allocation mechanism. When a "
"resource is allocated, a driver can retrieve the associated <varname remap="
"\"structfield\">bus_space_tag_t</varname> and <varname remap="
"\"structfield\">bus_space_handle_t</varname> from the resource."
msgstr ""
"Esse suporte � integrado ao mecanismo de aloca��o de recursos. Quando um "
"recurso � alocado, um driver pode recuperar <varname remap=\"structfield\"> "
"bus_space_tag_t </varname> e <varname remap=\"structfield\"> "
"bus_space_handle_t </varname> do recurso \""

#. (itstool) path: sect1/para
#: book.translate.xml:22602
#, fuzzy
msgid ""
"Newbus also allows for definitions of interface methods in files dedicated "
"to this purpose. These are the <filename>.m</filename> files that are found "
"under the <filename>src/sys</filename> hierarchy."
msgstr ""
"O Newbus tamb�m permite defini��es de m�todos de interface em arquivos "
"dedicados a este prop�sito. Estes s�o os <filename> .m </filename> arquivos "
"que s�o encontrados sob o <filename> src / sys </filename> hierarquia."

#. (itstool) path: sect1/para
#: book.translate.xml:22607
#, fuzzy
msgid ""
"The core of the Newbus system is an extensible <quote>object-based "
"programming</quote> model. Each device in the system has a table of methods "
"which it supports. The system and other devices uses those methods to "
"control the device and request services. The different methods supported by "
"a device are defined by a number of <quote>interfaces</quote>. An "
"<quote>interface</quote> is simply a group of related methods which can be "
"implemented by a device."
msgstr ""
"O n�cleo do sistema Newbus � um extens�vel <quote> programa��o baseada em "
"objetos </quote> modelo. Cada dispositivo no sistema possui uma tabela de "
"m�todos que ele suporta. O sistema e outros dispositivos usam esses m�todos "
"para controlar o dispositivo e solicitar servi�os. Os diferentes m�todos "
"suportados por um dispositivo s�o definidos por um n�mero de <quote> "
"interfaces </quote> . A <quote> interface </quote> � simplesmente um grupo "
"de m�todos relacionados que podem ser implementados por um dispositivo \""

#. (itstool) path: sect1/para
#: book.translate.xml:22616
#, fuzzy
msgid ""
"In the Newbus system, the methods for a device are provided by the various "
"device drivers in the system. When a device is attached to a driver during "
"<emphasis>auto-configuration</emphasis>, it uses the method table declared "
"by the driver. A device can later <emphasis>detach</emphasis> from its "
"driver and <emphasis>re-attach</emphasis> to a new driver with a new method "
"table. This allows dynamic replacement of drivers which can be useful for "
"driver development."
msgstr ""
"No sistema Newbus, os m�todos para um dispositivo s�o fornecidos pelos "
"v�rios drivers de dispositivo no sistema. Quando um dispositivo � conectado "
"a um driver durante <emphasis> configura��o autom�tica </emphasis> , ele usa "
"a tabela de m�todos declarada pelo driver. Um dispositivo pode mais tarde "
"<emphasis> desanexar </emphasis> do seu motorista e <emphasis> re-anexar </"
"emphasis> para um novo driver com uma nova tabela de m�todos. Isso permite a "
"substitui��o din�mica de drivers, o que pode ser �til para o desenvolvimento "
"de drivers. "

#. (itstool) path: sect1/para
#: book.translate.xml:22626
#, fuzzy
msgid ""
"The interfaces are described by an interface definition language similar to "
"the language used to define vnode operations for file systems. The interface "
"would be stored in a methods file (which would normally be named "
"<filename>foo_if.m</filename>)."
msgstr ""
"As interfaces s�o descritas por uma linguagem de defini��o de interface "
"semelhante � linguagem usada para definir opera��es de vnode para sistemas "
"de arquivos. A interface seria armazenada em um arquivo de m�todos (que "
"normalmente seria nomeado <filename> foo_if.m </filename> ) "

#. (itstool) path: example/title
#: book.translate.xml:22633
#, fuzzy
msgid "Newbus Methods"
msgstr "M�todos Newbus"

#. (itstool) path: example/programlisting
#: book.translate.xml:22635
#, no-wrap
msgid ""
"      # Foo subsystem/driver (a comment...)\n"
"\n"
"\t  INTERFACE foo\n"
"\n"
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
"\n"
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
"\n"
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;"
msgstr ""
"      # Foo subsystem/driver (a comment...)\n"
"\n"
"\t  INTERFACE foo\n"
"\n"
"\tMETHOD int doit {\n"
"\t\tdevice_t dev;\n"
"\t};\n"
"\n"
"\t# DEFAULT is the method that will be used, if a method was not\n"
"\t# provided via: DEVMETHOD()\n"
"\n"
"\tMETHOD void doit_to_child {\n"
"\t\tdevice_t dev;\n"
"\t\tdriver_t child;\n"
"\t} DEFAULT doit_generic_to_child;"

#. (itstool) path: sect1/para
#: book.translate.xml:22652
#, fuzzy
msgid ""
"When this interface is compiled, it generates a header file "
"<quote><filename>foo_if.h</filename></quote> which contains function "
"declarations:"
msgstr ""
"Quando esta interface � compilada, ela gera um arquivo de cabe�alho "
"<quote><filename> foo_if.h </filename></quote> que cont�m declara��es de "
"fun��o: "

#. (itstool) path: sect1/programlisting
#: book.translate.xml:22656
#, no-wrap
msgid ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);"
msgstr ""
"      int FOO_DOIT(device_t dev);\n"
"      int FOO_DOIT_TO_CHILD(device_t dev, device_t child);"

#. (itstool) path: sect1/para
#: book.translate.xml:22659
#, fuzzy
msgid ""
"A source file, <quote><filename>foo_if.c</filename></quote> is also created "
"to accompany the automatically generated header file; it contains "
"implementations of those functions which look up the location of the "
"relevant functions in the object's method table and call that function."
msgstr ""
"Um arquivo de origem, <quote><filename> foo_if.c </filename></quote> tamb�m "
"� criado para acompanhar o arquivo de cabe�alho gerado automaticamente; "
"cont�m implementa��es dessas fun��es que procuram a localiza��o das fun��es "
"relevantes na tabela de m�todos do objeto e chamam essa fun��o. "

#. (itstool) path: sect1/para
#: book.translate.xml:22665
#, fuzzy
msgid ""
"The system defines two main interfaces. The first fundamental interface is "
"called <emphasis><quote>device</quote></emphasis> and includes methods which "
"are relevant to all devices. Methods in the <emphasis><quote>device</quote></"
"emphasis> interface include <emphasis><quote>probe</quote></emphasis>, "
"<emphasis><quote>attach</quote></emphasis> and <emphasis><quote>detach</"
"quote></emphasis> to control detection of hardware and "
"<emphasis><quote>shutdown</quote></emphasis>, <emphasis><quote>suspend</"
"quote></emphasis> and <emphasis><quote>resume</quote></emphasis> for "
"critical event notification."
msgstr ""
"O sistema define duas interfaces principais. A primeira interface "
"fundamental � chamada <emphasis><quote> dispositivo </quote></emphasis> e "
"inclui m�todos relevantes para todos os dispositivos. M�todos no "
"<emphasis><quote> dispositivo </quote></emphasis> interface incluem "
"<emphasis><quote> sonda </quote></emphasis> , <emphasis><quote> anexar </"
"quote></emphasis> e <emphasis><quote> desanexar </quote></emphasis> para "
"controlar a detec��o de hardware e <emphasis><quote> desligar </quote></"
"emphasis> , <emphasis><quote> suspender </quote></emphasis> e "
"<emphasis><quote> curr�culo </quote></emphasis> para notifica��o de eventos "
"cr�ticos. "

#. (itstool) path: footnote/para
#: book.translate.xml:22682
#, fuzzy
msgid ""
"<citerefentry><refentrytitle>bus_generic_read_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry> and "
"<citerefentry><refentrytitle>bus_generic_write_ivar</"
"refentrytitle><manvolnum>9</manvolnum></citerefentry>"
msgstr ""
" <citerefentry><refentrytitle> bus_generic_read_ivar </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> e "
"<citerefentry><refentrytitle> bus_generic_write_ivar </"
"refentrytitle><manvolnum> 9 </manvolnum></citerefentry> "

#. (itstool) path: sect1/para
#: book.translate.xml:22678
#, fuzzy
msgid ""
"The second, more complex interface is <emphasis><quote>bus</quote></"
"emphasis>. This interface contains methods suitable for devices which have "
"children, including methods to access bus specific per-device information <_:"
"footnote-1/>, event notification (<emphasis><literal>child_detached</"
"literal></emphasis>, <emphasis><literal>driver_added</literal></emphasis>) "
"and resource management (<emphasis><literal>alloc_resource</literal></"
"emphasis>, <emphasis><literal>activate_resource</literal></emphasis>, "
"<emphasis><literal>deactivate_resource</literal></emphasis>, "
"<emphasis><literal>release_resource</literal></emphasis>)."
msgstr ""
"A segunda interface mais complexa � <emphasis><quote> �nibus </quote></"
"emphasis> . Essa interface cont�m m�todos adequados para dispositivos que "
"t�m filhos, incluindo m�todos para acessar informa��es espec�ficas do "
"barramento por dispositivo <_: footnote-1 />, notifica��o de eventos ( "
"<emphasis><literal> child_detached </literal></emphasis> , "
"<emphasis><literal> driver_added </literal></emphasis> ) e gest�o de "
"recursos ( <emphasis><literal> alloc_resource </literal></emphasis> , "
"<emphasis><literal> activate_resource </literal></emphasis> , "
"<emphasis><literal> deactivate_resource </literal></emphasis> , "
"<emphasis><literal> release_resource </literal></emphasis> ) "

#. (itstool) path: sect1/para
#: book.translate.xml:22693
#, fuzzy
msgid ""
"Many methods in the <quote>bus</quote> interface are performing services for "
"some child of the bus device. These methods would normally use the first two "
"arguments to specify the bus providing the service and the child device "
"which is requesting the service. To simplify driver code, many of these "
"methods have accessor functions which lookup the parent and call a method on "
"the parent. For instance the method <literal>BUS_TEARDOWN_INTR(device_t dev, "
"device_t child, ...)</literal> can be called using the function "
"<literal>bus_teardown_intr(device_t child, ...)</literal>."
msgstr ""
"Muitos m�todos no <quote> �nibus </quote> interface est�o executando "
"servi�os para algum filho do dispositivo de barramento. Esses m�todos "
"normalmente usariam os dois primeiros argumentos para especificar o "
"barramento que fornece o servi�o e o dispositivo filho que est� solicitando "
"o servi�o. Para simplificar o c�digo do driver, muitos desses m�todos t�m "
"fun��es de acesso que procuram o pai e chamam um m�todo no pai. Por exemplo, "
"o m�todo <literal> BUS_TEARDOWN_INTR (device_t dev, device_t filho, ...) </"
"literal> pode ser chamado usando a fun��o <literal> bus_teardown_intr (filho "
"device_t, ...) </literal> "

#. (itstool) path: sect1/para
#: book.translate.xml:22705
#, fuzzy
msgid ""
"Some bus types in the system define additional interfaces to provide access "
"to bus-specific functionality. For instance, the PCI bus driver defines the "
"<quote>pci</quote> interface which has two methods "
"<emphasis><literal>read_config</literal></emphasis> and "
"<emphasis><literal>write_config</literal></emphasis> for accessing the "
"configuration registers of a PCI device."
msgstr ""
"Alguns tipos de barramento no sistema definem interfaces adicionais para "
"fornecer acesso � funcionalidade espec�fica do barramento. Por exemplo, o "
"driver de barramento PCI define <quote> pci </quote> interface que tem dois "
"m�todos <emphasis><literal> read_config </literal></emphasis> e "
"<emphasis><literal> write_config </literal></emphasis> para acessar os "
"registros de configura��o de um dispositivo PCI. "

#. (itstool) path: sect1/title
#: book.translate.xml:22715
#, fuzzy
msgid "Newbus API"
msgstr "Newbus API"

#. (itstool) path: sect1/para
#: book.translate.xml:22717
#, fuzzy
msgid ""
"As the Newbus API is huge, this section makes some effort at documenting it. "
"More information to come in the next revision of this document."
msgstr ""
"Como a API Newbus � enorme, esta se��o faz algum esfor�o para document�-la. "
"Mais informa��es est�o na pr�xima revis�o deste documento."

#. (itstool) path: sect2/title
#: book.translate.xml:22722
#, fuzzy
msgid "Important Locations in the Source Hierarchy"
msgstr "Locais importantes na hierarquia de origem"

#. (itstool) path: sect2/para
#: book.translate.xml:22724
#, fuzzy
msgid ""
"<filename>src/sys/[arch]/[arch]</filename> - Kernel code for a specific "
"machine architecture resides in this directory. For example, the "
"<literal>i386</literal> architecture, or the <literal>SPARC64</literal> "
"architecture."
msgstr ""
" <filename> src / sys / [arco] / [arco] </filename> - O c�digo do kernel "
"para uma arquitetura de m�quina espec�fica reside neste diret�rio. Por "
"exemplo, o <literal> i386 </literal> arquitetura, ou o <literal> SPARC64 </"
"literal> arquitetura."

#. (itstool) path: sect2/para
#: book.translate.xml:22729
#, fuzzy
msgid ""
"<filename>src/sys/dev/[bus]</filename> - device support for a specific "
"<literal>[bus]</literal> resides in this directory."
msgstr ""
" <filename> src / sys / dev / [barramento] </filename> - suporte de "
"dispositivo para um espec�fico <literal> [�nibus] </literal> reside neste "
"diret�rio. "

#. (itstool) path: sect2/para
#: book.translate.xml:22733
#, fuzzy
msgid ""
"<filename>src/sys/dev/pci</filename> - PCI bus support code resides in this "
"directory."
msgstr ""
" <filename> src / sys / dev / pci </filename> - O c�digo de suporte do "
"barramento PCI reside neste diret�rio. "

#. (itstool) path: sect2/para
#: book.translate.xml:22736
#, fuzzy
msgid ""
"<filename>src/sys/[isa|pci]</filename> - PCI/ISA device drivers reside in "
"this directory. The PCI/ISA bus support code used to exist in this directory "
"in FreeBSD version <literal>4.0</literal>."
msgstr ""
" <filename> src / sys / [isa | pci] </filename> - Os drivers de dispositivos "
"PCI / ISA residem nesse diret�rio. O c�digo de suporte do barramento PCI / "
"ISA costumava existir neste diret�rio na vers�o FreeBSD <literal> 4,0 </"
"literal> "

#. (itstool) path: sect2/title
#: book.translate.xml:22743
#, fuzzy
msgid "Important Structures and Type Definitions"
msgstr "Estruturas importantes e defini��es de tipo"

#. (itstool) path: sect2/para
#: book.translate.xml:22745
#, fuzzy
msgid ""
"<literal>devclass_t</literal> - This is a type definition of a pointer to a "
"<literal>struct devclass</literal>."
msgstr ""
" <literal> devclass_t </literal> - Esta � uma defini��o de tipo de um "
"ponteiro para um <literal> struct devclass </literal> "

#. (itstool) path: sect2/para
#: book.translate.xml:22748
#, fuzzy
msgid ""
"<literal>device_method_t</literal> - This is the same as "
"<literal>kobj_method_t</literal> (see <filename>src/sys/kobj.h</filename>)."
msgstr ""
" <literal> device_method_t </literal> - Isso � o mesmo que <literal> "
"kobj_method_t </literal> (Vejo <filename> src / sys / kobj.h </filename> ) "

#. (itstool) path: sect2/para
#: book.translate.xml:22752
#, fuzzy
msgid ""
"<literal>device_t</literal> - This is a type definition of a pointer to a "
"<literal>struct device</literal>. <literal>device_t</literal> represents a "
"device in the system. It is a kernel object. See <filename>src/sys/sys/"
"bus_private.h</filename> for implementation details."
msgstr ""
" <literal> device_t </literal> - Esta � uma defini��o de tipo de um ponteiro "
"para um <literal> dispositivo struct </literal> . <literal> device_t </"
"literal> representa um dispositivo no sistema. � um objeto do kernel. Vejo "
"<filename> src / sys / sys / bus_private.h </filename> para detalhes de "
"implementa��o. "

#. (itstool) path: sect2/para
#: book.translate.xml:22759
#, fuzzy
msgid ""
"<literal>driver_t</literal> - This is a type definition which references "
"<literal>struct driver</literal>. The <literal>driver</literal> struct is a "
"class of the <literal>device</literal> kernel object; it also holds data "
"private to the driver."
msgstr ""
" <literal> driver_t </literal> - Esta � uma defini��o de tipo que referencia "
"<literal> driver struct </literal> . o <literal> motorista </literal> struct "
"� uma classe do <literal> dispositivo </literal> objeto do kernel; ele "
"tamb�m mant�m dados privados para o driver \""

#. (itstool) path: figure/title
#: book.translate.xml:22766
#, fuzzy
msgid "<emphasis>driver_t</emphasis> Implementation"
msgstr " <emphasis> driver_t </emphasis> Implementa��o"

#. (itstool) path: figure/programlisting
#: book.translate.xml:22768
#, no-wrap
msgid ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };"
msgstr ""
"\t  struct driver {\n"
"\t\tKOBJ_CLASS_FIELDS;\n"
"\t\tvoid\t*priv;\t\t\t/* driver private data */\n"
"\t  };"

#. (itstool) path: sect2/para
#: book.translate.xml:22774
#, fuzzy
msgid ""
"A <literal>device_state_t</literal> type, which is an enumeration, "
"<literal>device_state</literal>. It contains the possible states of a Newbus "
"device before and after the autoconfiguration process."
msgstr ""
"UMA <literal> device_state_t </literal> tipo, que � uma enumera��o, "
"<literal> device_state </literal> . Ele cont�m os estados poss�veis de um "
"dispositivo Newbus antes e depois do processo de configura��o autom�tica. "

#. (itstool) path: figure/title
#: book.translate.xml:22780
#, fuzzy
msgid "Device States <emphasis>device_state_t</emphasis>"
msgstr "Estados do dispositivo <emphasis> device_state_t </emphasis> "

#. (itstool) path: figure/programlisting
#: book.translate.xml:22783
#, no-wrap
msgid ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;"
msgstr ""
"\t  /*\n"
"\t   * src/sys/sys/bus.h\n"
"\t   */\n"
"\t  typedef enum device_state {\n"
"\t\tDS_NOTPRESENT,\t/* not probed or probe failed */\n"
"\t\tDS_ALIVE,\t\t/* probe succeeded */\n"
"\t\tDS_ATTACHED,\t/* attach method called */\n"
"\t\tDS_BUSY\t\t\t/* device is open */\n"
"\t  } device_state_t;"

#. (itstool) path: info/title
#: book.translate.xml:22805
#, fuzzy
msgid "Sound Subsystem"
msgstr "Subsistema de Som"

#. (itstool) path: authorgroup/author
#: book.translate.xml:22807
#, fuzzy
msgid ""
"<personname><firstname>Jean-Francois</firstname><surname>Dockes</surname></"
"personname><contrib>Contributed by </contrib>"
msgstr ""
" <personname><firstname> Jean-Fran�ois </firstname><surname> Dockes </"
"surname></personname><contrib> Contribu�ram por </contrib> "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22817
#, fuzzy
msgid "<primary>sound subsystem</primary>"
msgstr " <primary> subsistema de som </primary> "

#. (itstool) path: sect1/para
#: book.translate.xml:22819
#, fuzzy
msgid ""
"The FreeBSD sound subsystem cleanly separates generic sound handling issues "
"from device-specific ones. This makes it easier to add support for new "
"hardware."
msgstr ""
"O subsistema de som do FreeBSD separa de forma limpa os problemas gen�ricos "
"de manipula��o de som dos espec�ficos do dispositivo. Isso facilita a adi��o "
"de suporte para novo hardware."

#. (itstool) path: sect1/para
#: book.translate.xml:22823
#, fuzzy
msgid ""
"The <citerefentry><refentrytitle>pcm</refentrytitle><manvolnum>4</"
"manvolnum></citerefentry> framework is the central piece of the sound "
"subsystem. It mainly implements the following elements:"
msgstr ""
"O <citerefentry><refentrytitle> pcm </refentrytitle><manvolnum> 4 </"
"manvolnum></citerefentry> framework � a pe�a central do subsistema de som. "
"Ele implementa principalmente os seguintes elementos: "

#. (itstool) path: sect1/indexterm
#: book.translate.xml:22826
#, fuzzy
msgid "<primary>system call interface</primary>"
msgstr " <primary> interface de chamada do sistema </primary> "

#. (itstool) path: listitem/para
#: book.translate.xml:22830
#, fuzzy
msgid ""
"A system call interface (read, write, ioctls) to digitized sound and mixer "
"functions. The ioctl command set is compatible with the legacy "
"<emphasis>OSS</emphasis> or <emphasis>Voxware</emphasis> interface, allowing "
"common multimedia applications to be ported without modification."
msgstr ""
"Uma interface de chamada do sistema (leitura, grava��o, ioctls) para fun��es "
"de som e mixer digitalizadas. O conjunto de comandos ioctl � compat�vel com "
"o legado <emphasis> OSS </emphasis> ou <emphasis> Voxware </emphasis> "
"interface, permitindo que aplica��es multim�dia comuns sejam portadas sem "
"modifica��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:22839
#, fuzzy
msgid ""
"Common code for processing sound data (format conversions, virtual channels)."
""
msgstr ""
"C�digo comum para processamento de dados sonoros (convers�es de formato, "
"canais virtuais)."

#. (itstool) path: listitem/para
#: book.translate.xml:22844
#, fuzzy
msgid ""
"A uniform software interface to hardware-specific audio interface modules."
msgstr ""
"Uma interface de software uniforme para m�dulos de interface de �udio "
"espec�ficos de hardware."

#. (itstool) path: listitem/para
#: book.translate.xml:22849
#, fuzzy
msgid ""
"Additional support for some common hardware interfaces (ac97), or shared "
"hardware-specific code (ex: ISA DMA routines)."
msgstr ""
"Suporte adicional para algumas interfaces comuns de hardware (ac97), ou "
"c�digo espec�fico de hardware compartilhado (ex: rotinas ISA DMA)."

#. (itstool) path: sect1/para
#: book.translate.xml:22855
#, fuzzy
msgid ""
"The support for specific sound cards is implemented by hardware-specific "
"drivers, which provide channel and mixer interfaces to plug into the generic "
"<filename>pcm</filename> code."
msgstr ""
"O suporte para placas de som espec�ficas � implementado por drivers "
"espec�ficos de hardware, que fornecem interfaces de canal e mixer para serem "
"plugados no gen�rico. <filename> pcm </filename> c�digo."

#. (itstool) path: sect1/para
#: book.translate.xml:22860
#, fuzzy
msgid ""
"In this chapter, the term <filename>pcm</filename> will refer to the "
"central, common part of the sound driver, as opposed to the hardware-"
"specific modules."
msgstr ""
"Neste cap�tulo, o termo <filename> pcm </filename> referir-se-� � parte "
"central e comum do driver de som, ao contr�rio dos m�dulos espec�ficos de "
"hardware. "

#. (itstool) path: sect1/para
#: book.translate.xml:22864
#, fuzzy
msgid ""
"The prospective driver writer will of course want to start from an existing "
"module and use the code as the ultimate reference. But, while the sound code "
"is nice and clean, it is also mostly devoid of comments. This document tries "
"to give an overview of the framework interface and answer some questions "
"that may arise while adapting the existing code."
msgstr ""
"Naturalmente, o candidato a driver dever� iniciar a partir de um m�dulo "
"existente e usar o c�digo como a refer�ncia final. Mas, embora o c�digo de "
"som seja bom e limpo, ele tamb�m � desprovido de coment�rios. Este documento "
"tenta fornecer uma vis�o geral. da interface do framework e responder a "
"algumas perguntas que possam surgir durante a adapta��o do c�digo existente. "
""

#. (itstool) path: sect1/para
#: book.translate.xml:22871
#, fuzzy
msgid ""
"As an alternative, or in addition to starting from a working example, you "
"can find a commented driver template at <link xlink:href=\"https://people."
"FreeBSD.org/~cg/template.c\"> https://people.FreeBSD.org/~cg/template.c</"
"link>"
msgstr ""
"Como alternativa, ou al�m de partir de um exemplo de trabalho, voc� pode "
"encontrar um modelo de driver <link xlink:href=\"https://people.FreeBSD.org/"
"~cg/template.c\"> https://people.FreeBSD.org/~cg/template.c </link> "

#. (itstool) path: sect1/title
#: book.translate.xml:22878
#, fuzzy
msgid "Files"
msgstr "Arquivos"

#. (itstool) path: sect1/para
#: book.translate.xml:22880
#, fuzzy
msgid ""
"All the relevant code lives in <filename>/usr/src/sys/dev/sound/</filename>, "
"except for the public ioctl interface definitions, found in <filename>/usr/"
"src/sys/sys/soundcard.h</filename>"
msgstr ""
"Todo o c�digo relevante vive em <filename> / usr / src / sys / dev / sound / "
"</filename> , exceto para as defini��es de interface p�blica do ioctl, "
"encontradas em <filename> /usr/src/sys/sys/soundcard.h </filename> "

#. (itstool) path: sect1/para
#: book.translate.xml:22885
#, fuzzy
msgid ""
"Under <filename>/usr/src/sys/dev/sound/</filename>, the <filename>pcm/</"
"filename> directory holds the central code, while the <filename>pci/</"
"filename>, <filename>isa/</filename> and <filename>usb/</filename> "
"directories have the drivers for PCI and ISA boards, and for USB audio "
"devices."
msgstr ""
"Sob <filename> / usr / src / sys / dev / sound / </filename> , a <filename> "
"pcm / </filename> diret�rio mant�m o c�digo central, enquanto o <filename> "
"pci / </filename> , <filename> � um/ </filename> e <filename> USB/ </"
"filename> diret�rios t�m os drivers para placas PCI e ISA, e para "
"dispositivos de �udio USB \""

#. (itstool) path: sect1/title
#: book.translate.xml:22893
#, fuzzy
msgid "Probing, Attaching, etc."
msgstr "Sondando, Anexando, etc."

#. (itstool) path: sect1/para
#: book.translate.xml:22895
#, fuzzy
msgid ""
"Sound drivers probe and attach in almost the same way as any hardware driver "
"module. You might want to look at the <link linkend=\"isa-driver\"> ISA</"
"link> or <link linkend=\"pci\">PCI</link> specific sections of the handbook "
"for more information."
msgstr ""
"Drivers de som sondam e conectam quase da mesma maneira que qualquer m�dulo "
"de driver de hardware. Voc� pode querer <link linkend=\"isa-driver\"> � UM </"
"link> ou <link linkend=\"pci\"> PCI </link> se��es espec�ficas do manual "
"para mais informa��es. "

#. (itstool) path: sect1/para
#: book.translate.xml:22899
#, fuzzy
msgid "However, sound drivers differ in some ways:"
msgstr "No entanto, os drivers de som diferem em alguns aspectos:"

#. (itstool) path: listitem/para
#: book.translate.xml:22903
#, fuzzy
msgid ""
"They declare themselves as <filename>pcm</filename> class devices, with a "
"<varname remap=\"structname\">struct snddev_info</varname> device private "
"structure:"
msgstr ""
"Eles se declaram como <filename> pcm </filename> dispositivos de classe, com "
"um <varname remap=\"structname\"> struct snddev_info </varname> estrutura "
"privada do dispositivo: "

#. (itstool) path: listitem/programlisting
#: book.translate.xml:22908
#, no-wrap
msgid ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
"\n"
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, "
"PCM_PREFVER,PCM_MAXVER);"
msgstr ""
"          static driver_t xxx_driver = {\n"
"              \"pcm\",\n"
"              xxx_methods,\n"
"              sizeof(struct snddev_info)\n"
"          };\n"
"\n"
"          DRIVER_MODULE(snd_xxxpci, pci, xxx_driver, pcm_devclass, 0, 0);\n"
"          MODULE_DEPEND(snd_xxxpci, snd_pcm, PCM_MINVER, "
"PCM_PREFVER,PCM_MAXVER);"

#. (itstool) path: para/indexterm
#: book.translate.xml:22917
#, fuzzy
msgid "<primary>device drivers</primary><secondary>sound</secondary>"
msgstr ""
" <primary> drivers de dispositivo </primary><secondary> som </secondary> "

#. (itstool) path: listitem/para
#: book.translate.xml:22917
#, fuzzy
msgid ""
"Most sound drivers<_:indexterm-1/> need to store additional private "
"information about their device. A private data structure is usually "
"allocated in the attach routine. Its address is passed to <filename>pcm</"
"filename> by the calls to <function>pcm_register()</function> and "
"<function>mixer_init()</function>. <filename>pcm</filename> later passes "
"back this address as a parameter in calls to the sound driver interfaces."
msgstr ""
"A maioria dos drivers de som <_: indexterm-1 /> precisa armazenar "
"informa��es particulares adicionais sobre o dispositivo. Geralmente, uma "
"estrutura de dados privada � alocada na rotina de anexa��o. Seu endere�o � "
"passado para <filename> pcm </filename> pelas chamadas para <function> "
"pcm_register () </function> e <function> mixer_init () </function> . "
"<filename> pcm </filename> mais tarde passa de volta este endere�o como um "
"par�metro em chamadas para as interfaces do driver de som. "

#. (itstool) path: listitem/para
#: book.translate.xml:22931
#, fuzzy
msgid ""
"The sound driver attach routine should declare its MIXER or AC97 interface "
"to <filename>pcm</filename> by calling <function>mixer_init()</function>. "
"For a MIXER interface, this causes in turn a call to <link linkend="
"\"xxxmixer-init\"><function>xxxmixer_init()</function></link>."
msgstr ""
"A rotina de anexa��o do driver de som deve declarar sua interface MIXER ou "
"AC97 <filename> pcm </filename> chamando <function> mixer_init () </"
"function> . Para uma interface MIXER, isso faz com que uma chamada para "
"<link linkend=\"xxxmixer-init\"><function> xxxmixer_init () </function></"
"link> "

#. (itstool) path: listitem/para
#: book.translate.xml:22938
#, fuzzy
msgid ""
"The sound driver attach routine declares its general CHANNEL configuration "
"to <filename>pcm</filename> by calling <function>pcm_register(dev, sc, "
"nplay, nrec)</function>, where <varname>sc</varname> is the address for the "
"device data structure, used in further calls from <filename>pcm</filename>, "
"and <varname>nplay</varname> and <varname>nrec</varname> are the number of "
"play and record channels."
msgstr ""
"A rotina de anexa��o do driver de som declara sua configura��o geral de "
"CHANNEL <filename> pcm </filename> chamando <function> pcm_register (dev, "
"sc, nplay, nrec) </function> , Onde <varname> sc </varname> � o endere�o da "
"estrutura de dados do dispositivo, usado em outras chamadas <filename> pcm </"
"filename> e <varname> nplay </varname> e <varname> nrec </varname> s�o o "
"n�mero de canais de reprodu��o e grava��o. "

#. (itstool) path: listitem/para
#: book.translate.xml:22949
#, fuzzy
msgid ""
"The sound driver attach routine declares each of its channel objects by "
"calls to <function>pcm_addchan()</function>. This sets up the channel glue "
"in <filename>pcm</filename> and causes in turn a call to <link linkend="
"\"xxxchannel-init\"> <function>xxxchannel_init()</function></link>."
msgstr ""
"A rotina de anexa��o do driver de som declara cada um dos seus objetos de "
"canal <function> pcm_addchan () </function> . Isso configura a cola do canal "
"<filename> pcm </filename> e provoca por sua vez uma chamada para <link "
"linkend=\"xxxchannel-init\"><function> xxxchannel_init () </function></link> "
""

#. (itstool) path: listitem/para
#: book.translate.xml:22959
#, fuzzy
msgid ""
"The sound driver detach routine should call <function>pcm_unregister()</"
"function> before releasing its resources."
msgstr ""
"A rotina de desconex�o do driver de som deve chamar <function> "
"pcm_unregister () </function> antes de liberar seus recursos \""

#. (itstool) path: sect1/para
#: book.translate.xml:22965
#, fuzzy
msgid "There are two possible methods to handle non-PnP devices:"
msgstr "Existem dois m�todos poss�veis para lidar com dispositivos n�o-PnP:"

#. (itstool) path: listitem/para
#: book.translate.xml:22970
#, fuzzy
msgid ""
"Use a <function>device_identify()</function> method (example: "
"<filename>sound/isa/es1888.c</filename>). The <function>device_identify()</"
"function> method probes for the hardware at known addresses and, if it finds "
"a supported device, creates a new pcm device which is then passed to probe/"
"attach."
msgstr ""
"Use um <function> device_identify () </function> m�todo (exemplo: <filename> "
"som / isa / es1888.c </filename> ). o <function> device_identify () </"
"function> m�todo investiga o hardware em endere�os conhecidos e, se "
"encontrar um dispositivo suportado, cria um novo dispositivo pcm que � ent�o "
"passado para o probe / attach. "

#. (itstool) path: listitem/para
#: book.translate.xml:22979
#, fuzzy
msgid ""
"Use a custom kernel configuration with appropriate hints for pcm devices "
"(example: <filename>sound/isa/mss.c</filename>)."
msgstr ""
"Use uma configura��o de kernel personalizada com dicas apropriadas para "
"dispositivos pcm (exemplo: <filename> som / isa / mss.c </filename> ) "

#. (itstool) path: sect1/para
#: book.translate.xml:22985
#, fuzzy
msgid ""
"<filename>pcm</filename> drivers should implement <function>device_suspend</"
"function>, <function>device_resume</function> and <function>device_shutdown</"
"function> routines, so that power management and module unloading function "
"correctly."
msgstr ""
" <filename> pcm </filename> motoristas devem implementar <function> "
"device_suspend </function> , <function> device_resume </function> e "
"<function> device_shutdown </function> rotinas, para que o gerenciamento de "
"energia e o descarregamento do m�dulo funcionem corretamente. "

#. (itstool) path: sect1/title
#: book.translate.xml:22993
#, fuzzy
msgid "Interfaces"
msgstr "Interfaces"

#. (itstool) path: sect1/para
#: book.translate.xml:22995
#, fuzzy
msgid ""
"The interface between the <filename>pcm</filename> core and the sound "
"drivers is defined in terms of <link linkend=\"kernel-objects\">kernel "
"objects</link>."
msgstr ""
"A interface entre o <filename> pcm </filename> n�cleo e os drivers de som � "
"definido em termos de <link linkend=\"kernel-objects\"> objetos do kernel </"
"link> "

#. (itstool) path: sect1/para
#: book.translate.xml:22998
#, fuzzy
msgid ""
"There are two main interfaces that a sound driver will usually provide: "
"<emphasis>CHANNEL</emphasis> and either <emphasis>MIXER</emphasis> or "
"<emphasis>AC97</emphasis>."
msgstr ""
"Existem duas interfaces principais que um driver de som geralmente fornece: "
"<emphasis> CANAL </emphasis> e tamb�m <emphasis> MISTURADOR </emphasis> ou "
"<emphasis> AC97 </emphasis> "

#. (itstool) path: sect1/para
#: book.translate.xml:23002
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is a very small hardware access "
"(register read/write) interface, implemented by drivers for hardware with an "
"AC97 codec. In this case, the actual MIXER interface is provided by the "
"shared AC97 code in <filename>pcm</filename>."
msgstr ""
"O <emphasis> AC97 </emphasis> interface � uma interface muito pequena de "
"acesso ao hardware (registra leitura / grava��o), implementada por drivers "
"para hardware com um codec AC97. Nesse caso, a interface MIXER real � "
"fornecida pelo c�digo AC97 compartilhado <filename> pcm </filename> "

#. (itstool) path: sect2/title
#: book.translate.xml:23009
#, fuzzy
msgid "The CHANNEL Interface"
msgstr "A interface do canal"

#. (itstool) path: sect3/title
#: book.translate.xml:23012
#, fuzzy
msgid "Common Notes for Function Parameters"
msgstr "Notas comuns para par�metros de fun��o"

#. (itstool) path: sect3/para
#: book.translate.xml:23014
#, fuzzy
msgid ""
"Sound drivers usually have a private data structure to describe their "
"device, and one structure for each play and record data channel that it "
"supports."
msgstr ""
"Os drivers de som geralmente t�m uma estrutura de dados privada para "
"descrever seu dispositivo e uma estrutura para cada canal de dados de "
"reprodu��o e grava��o que ele suporta."

#. (itstool) path: sect3/para
#: book.translate.xml:23018
#, fuzzy
msgid ""
"For all CHANNEL interface functions, the first parameter is an opaque "
"pointer."
msgstr ""
"Para todas as fun��es da interface CHANNEL, o primeiro par�metro � um "
"ponteiro opaco."

#. (itstool) path: sect3/para
#: book.translate.xml:23021
#, fuzzy
msgid ""
"The second parameter is a pointer to the private channel data structure, "
"except for <function>channel_init()</function> which has a pointer to the "
"private device structure (and returns the channel pointer for further use by "
"<filename>pcm</filename>)."
msgstr ""
"O segundo par�metro � um ponteiro para a estrutura de dados do canal "
"privado, exceto <function> channel_init () </function> que tem um ponteiro "
"para a estrutura do dispositivo privado (e retorna o ponteiro do canal para "
"uso posterior por <filename> pcm </filename> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:23030
#, fuzzy
msgid "Overview of Data Transfer Operations"
msgstr "Vis�o geral das opera��es de transfer�ncia de dados"

#. (itstool) path: sect3/para
#: book.translate.xml:23032
#, fuzzy
msgid ""
"For sound data transfers, the <filename>pcm</filename> core and the sound "
"drivers communicate through a shared memory area, described by a <varname "
"remap=\"structname\">struct snd_dbuf</varname>."
msgstr ""
"Para transfer�ncias de dados de som, o <filename> pcm </filename> n�cleo e "
"os drivers de som se comunicam atrav�s de uma �rea de mem�ria compartilhada, "
"<varname remap=\"structname\"> struct snd_dbuf </varname> "

#. (itstool) path: sect3/para
#: book.translate.xml:23037
#, fuzzy
msgid ""
"<varname remap=\"structname\">struct snd_dbuf</varname> is private to "
"<filename>pcm</filename>, and sound drivers obtain values of interest by "
"calls to accessor functions (<function>sndbuf_getxxx()</function>)."
msgstr ""
" <varname remap=\"structname\"> struct snd_dbuf </varname> � privado para "
"<filename> pcm </filename> , e os drivers de som obt�m valores de interesse "
"por chamadas para fun��es acessadoras ( <function> sndbuf_getxxx () </"
"function> ) "

#. (itstool) path: sect3/para
#: book.translate.xml:23042
#, fuzzy
msgid ""
"The shared memory area has a size of <function>sndbuf_getsize()</function> "
"and is divided into fixed size blocks of <function>sndbuf_getblksz()</"
"function> bytes."
msgstr ""
"A �rea de mem�ria compartilhada tem um tamanho de <function> sndbuf_getsize "
"() </function> e � dividido em blocos de tamanho fixo <function> "
"sndbuf_getblksz () </function> bytes. "

#. (itstool) path: sect3/para
#: book.translate.xml:23047
#, fuzzy
msgid ""
"When playing, the general transfer mechanism is as follows (reverse the idea "
"for recording):"
msgstr ""
"Ao jogar, o mecanismo geral de transfer�ncia � o seguinte (inverter a ideia "
"de grava��o):"

#. (itstool) path: listitem/para
#: book.translate.xml:23052
#, fuzzy
msgid ""
"<filename>pcm</filename> initially fills up the buffer, then calls the sound "
"driver's <link linkend=\"channel-trigger\"> <function>xxxchannel_trigger()</"
"function></link> function with a parameter of PCMTRIG_START."
msgstr ""
" <filename> pcm </filename> inicialmente preenche o buffer, em seguida, "
"chama o driver do som <link linkend=\"channel-trigger\"><function> "
"xxxchannel_trigger () </function></link> fun��o com um par�metro de "
"PCMTRIG_START. "

#. (itstool) path: listitem/para
#: book.translate.xml:23059
#, fuzzy
msgid ""
"The sound driver then arranges to repeatedly transfer the whole memory area "
"(<function>sndbuf_getbuf()</function>, <function>sndbuf_getsize()</"
"function>) to the device, in blocks of <function>sndbuf_getblksz()</"
"function> bytes. It calls back the <function>chn_intr()</function> "
"<filename>pcm</filename> function for each transferred block (this will "
"typically happen at interrupt time)."
msgstr ""
"O driver de som ent�o organiza repetidamente a transfer�ncia de toda a �rea "
"de mem�ria ( <function> sndbuf_getbuf () </function> , <function> "
"sndbuf_getsize () </function> ) ao dispositivo, em blocos de <function> "
"sndbuf_getblksz () </function> bytes. Ele chama de volta o <function> "
"chn_intr () </function><filename> pcm </filename> fun��o para cada bloco "
"transferido (isso normalmente acontece no momento da interrup��o). "

#. (itstool) path: listitem/para
#: book.translate.xml:23071
#, fuzzy
msgid ""
"<function>chn_intr()</function> arranges to copy new data to the area that "
"was transferred to the device (now free), and make appropriate updates to "
"the <varname remap=\"structname\">snd_dbuf</varname> structure."
msgstr ""
" <function> chn_intr () </function> organiza a c�pia de novos dados para a "
"�rea que foi transferida para o dispositivo (agora livre) e faz as "
"atualiza��es apropriadas <varname remap=\"structname\"> snd_dbuf </varname> "
"estrutura."

#. (itstool) path: sect3/title
#: book.translate.xml:23080
#, fuzzy
msgid "channel_init"
msgstr "channel_init"

#. (itstool) path: sect3/para
#: book.translate.xml:23082
#, fuzzy
msgid ""
"<function>xxxchannel_init()</function> is called to initialize each of the "
"play or record channels. The calls are initiated from the sound driver "
"attach routine. (See the <link linkend=\"pcm-probe-and-attach\">probe and "
"attach section</link>)."
msgstr ""
" <function> xxxchannel_init () </function> � chamado para inicializar cada "
"um dos canais de reprodu��o ou grava��o. As chamadas s�o iniciadas a partir "
"da rotina de anexa��o do driver de som. (Veja o <link linkend=\"pcm-probe-"
"and-attach\"> sonda e anexar se��o </link> ) "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23088
#, no-wrap
msgid ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir)<co xml:id="
"\"co-chinit-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch;<co xml:id=\"co-chinit-return\"/>\n"
"           }"
msgstr ""
"          static void *\n"
"          xxxchannel_init(kobj_t obj, void *data,\n"
"             struct snd_dbuf *b, struct pcm_channel *c, int dir)<co xml:id="
"\"co-chinit-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = data;\n"
"              struct xxx_chinfo *ch;\n"
"               ...\n"
"              return ch;<co xml:id=\"co-chinit-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23100
#, fuzzy
msgid ""
"<varname>b</varname> is the address for the channel <varname remap="
"\"structname\">struct snd_dbuf</varname>. It should be initialized in the "
"function by calling <function>sndbuf_alloc()</function>. The buffer size to "
"use is normally a small multiple of the 'typical' unit transfer size for "
"your device."
msgstr ""
" <varname> b </varname> � o endere�o do canal <varname remap=\"structname\"> "
"struct snd_dbuf </varname> . Deve ser inicializado na fun��o chamando "
"<function> sndbuf_alloc () </function> . O tamanho do buffer a ser usado � "
"normalmente um pequeno m�ltiplo do tamanho de transfer�ncia da unidade "
"';t�pica'; para o seu dispositivo. "

#. (itstool) path: callout/para
#: book.translate.xml:23107
#, fuzzy
msgid ""
"<varname>c</varname> is the <filename>pcm</filename> channel control "
"structure pointer. This is an opaque object. The function should store it in "
"the local channel structure, to be used in later calls to <filename>pcm</"
"filename> (ie: <function>chn_intr(c)</function>)."
msgstr ""
" <varname> c </varname> � o <filename> pcm </filename> ponteiro de estrutura "
"de controle de canal. Este � um objeto opaco. A fun��o deve armazen�-lo na "
"estrutura do canal local, para ser usado em chamadas posteriores <filename> "
"pcm </filename> (ie: <function> chn_intr (c) </function> ) "

#. (itstool) path: callout/para
#: book.translate.xml:23114
#, fuzzy
msgid ""
"<varname>dir</varname> indicates the channel direction "
"(<literal>PCMDIR_PLAY</literal> or <literal>PCMDIR_REC</literal>)."
msgstr ""
" <varname> dir </varname> indica a dire��o do canal ( <literal> PCMDIR_PLAY "
"</literal> ou <literal> PCMDIR_REC </literal> ) "

#. (itstool) path: callout/para
#: book.translate.xml:23120
#, fuzzy
msgid ""
"The function should return a pointer to the private area used to control "
"this channel. This will be passed as a parameter to other channel interface "
"calls."
msgstr ""
"A fun��o deve retornar um ponteiro para a �rea privada usada para controlar "
"este canal. Isso ser� passado como um par�metro para outras chamadas de "
"interface de canal."

#. (itstool) path: sect3/title
#: book.translate.xml:23128
#, fuzzy
msgid "channel_setformat"
msgstr "channel_setformat"

#. (itstool) path: sect3/para
#: book.translate.xml:23130
#, fuzzy
msgid ""
"<function>xxxchannel_setformat()</function> should set up the hardware for "
"the specified channel for the specified sound format."
msgstr ""
" <function> xxxchannel_setformat () </function> deve configurar o hardware "
"para o canal especificado para o formato de som especificado. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23134
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<co "
"xml:id=\"co-chsetformat-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setformat(kobj_t obj, void *data, u_int32_t format)<co "
"xml:id=\"co-chsetformat-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23144
#, fuzzy
msgid ""
"<varname>format</varname> is specified as an <literal>AFMT_XXX value</"
"literal> (<filename>soundcard.h</filename>)."
msgstr ""
" <varname> formato </varname> � especificado como um <literal> Valor "
"AFMT_XXX </literal> ( <filename> soundcard.h </filename> ) "

#. (itstool) path: sect3/title
#: book.translate.xml:23152
#, fuzzy
msgid "channel_setspeed"
msgstr "channel_setspeed"

#. (itstool) path: sect3/para
#: book.translate.xml:23154
#, fuzzy
msgid ""
"<function>xxxchannel_setspeed()</function> sets up the channel hardware for "
"the specified sampling speed, and returns the possibly adjusted speed."
msgstr ""
" <function> xxxchannel_setspeed () </function> configura o hardware do canal "
"para a velocidade de amostragem especificada e retorna a velocidade "
"possivelmente ajustada. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23158
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setspeed(kobj_t obj, void *data, u_int32_t speed)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return speed;\n"
"           }"

#. (itstool) path: sect3/title
#: book.translate.xml:23168
#, fuzzy
msgid "channel_setblocksize"
msgstr "channel_setblocksize"

#. (itstool) path: sect3/para
#: book.translate.xml:23170
#, fuzzy
msgid ""
"<function>xxxchannel_setblocksize()</function> sets the block size, which is "
"the size of unit transactions between <filename>pcm</filename> and the sound "
"driver, and between the sound driver and the device. Typically, this would "
"be the number of bytes transferred before an interrupt occurs. During a "
"transfer, the sound driver should call <filename>pcm</filename>'s "
"<function>chn_intr()</function> every time this size has been transferred."
msgstr ""
" <function> xxxchannel_setblocksize () </function> define o tamanho do "
"bloco, que � o tamanho das transa��es unit�rias entre <filename> pcm </"
"filename> e o driver de som e entre o driver de som e o dispositivo. "
"Normalmente, isso seria o n�mero de bytes transferidos antes de ocorrer uma "
"interrup��o. Durante uma transfer�ncia, o driver de som deve ligar "
"<filename> pcm </filename> ';s <function> chn_intr () </function> cada vez "
"que esse tamanho foi transferido. "

#. (itstool) path: sect3/para
#: book.translate.xml:23180
#, fuzzy
msgid ""
"Most sound drivers only take note of the block size here, to be used when an "
"actual transfer will be started."
msgstr ""
"A maioria dos drivers de som s� toma nota do tamanho do bloco aqui, para ser "
"usado quando uma transfer�ncia real for iniciada."

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23184
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t "
"blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize;<co xml:id=\"co-chsetblocksize-return\"/>\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_setblocksize(kobj_t obj, void *data, u_int32_t "
"blocksize)\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"                ...\n"
"              return blocksize;<co xml:id=\"co-chsetblocksize-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23194
#, fuzzy
msgid ""
"The function returns the possibly adjusted block size. In case the block "
"size is indeed changed, <function>sndbuf_resize()</function> should be "
"called to adjust the buffer."
msgstr ""
"A fun��o retorna o tamanho do bloco possivelmente ajustado. Caso o tamanho "
"do bloco seja realmente alterado, <function> sndbuf_resize () </function> "
"deve ser chamado para ajustar o buffer \""

#. (itstool) path: sect3/title
#: book.translate.xml:23203
#, fuzzy
msgid "channel_trigger"
msgstr "channel_trigger"

#. (itstool) path: sect3/para
#: book.translate.xml:23205
#, fuzzy
msgid ""
"<function>xxxchannel_trigger()</function> is called by <filename>pcm</"
"filename> to control data transfer operations in the driver."
msgstr ""
" <function> xxxchannel_trigger () </function> � chamado por <filename> pcm </"
"filename> para controlar as opera��es de transfer�ncia de dados no driver \""

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23209
#, no-wrap
msgid ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go)<co xml:id=\"co-"
"chtrigger-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"
msgstr ""
"          static int\n"
"          xxxchannel_trigger(kobj_t obj, void *data, int go)<co xml:id=\"co-"
"chtrigger-params\"/>\n"
"          {\n"
"              struct xxx_chinfo *ch = data;\n"
"               ...\n"
"              return 0;\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23219
#, fuzzy
msgid ""
"<varname>go</varname> defines the action for the current call. The possible "
"values are:"
msgstr ""
" <varname> ir </varname> define a a��o para a chamada atual. Os valores "
"poss�veis s�o: "

#. (itstool) path: listitem/para
#: book.translate.xml:23224
#, fuzzy
msgid ""
"<literal>PCMTRIG_START</literal>: the driver should start a data transfer "
"from or to the channel buffer. If needed, the buffer base and size can be "
"retrieved through <function>sndbuf_getbuf()</function> and "
"<function>sndbuf_getsize()</function>."
msgstr ""
" <literal> PCMTRIG_START </literal> : o driver deve iniciar uma "
"transfer�ncia de dados de ou para o buffer do canal. Se necess�rio, a base e "
"o tamanho do buffer podem ser recuperados <function> sndbuf_getbuf () </"
"function> e <function> sndbuf_getsize () </function> "

#. (itstool) path: listitem/para
#: book.translate.xml:23233
#, fuzzy
msgid ""
"<literal>PCMTRIG_EMLDMAWR</literal> / <literal>PCMTRIG_EMLDMARD</literal>: "
"this tells the driver that the input or output buffer may have been updated. "
"Most drivers just ignore these calls."
msgstr ""
" <literal> PCMTRIG_EMLDMAWR </literal> / <literal> PCMTRIG_EMLDMARD </"
"literal> : diz ao driver que o buffer de entrada ou sa�da pode ter sido "
"atualizado. A maioria dos motoristas simplesmente ignora essas chamadas. "

#. (itstool) path: listitem/para
#: book.translate.xml:23241
#, fuzzy
msgid ""
"<literal>PCMTRIG_STOP</literal> / <literal>PCMTRIG_ABORT</literal>: the "
"driver should stop the current transfer."
msgstr ""
" <literal> PCMTRIG_STOP </literal> / <literal> PCMTRIG_ABORT </literal> : o "
"motorista deve parar a transfer�ncia atual \""

#. (itstool) path: note/para
#: book.translate.xml:23250
#, fuzzy
msgid ""
"If the driver uses ISA DMA, <function>sndbuf_isadma()</function> should be "
"called before performing actions on the device, and will take care of the "
"DMA chip side of things."
msgstr ""
"Se o driver usa o ISA DMA, <function> sndbuf_isadma () </function> deve ser "
"chamado antes de executar a��es no dispositivo, e vai cuidar do lado do chip "
"DMA das coisas \""

#. (itstool) path: sect3/title
#: book.translate.xml:23258
#, fuzzy
msgid "channel_getptr"
msgstr "channel_getptr"

#. (itstool) path: sect3/para
#: book.translate.xml:23260
#, fuzzy
msgid ""
"<function>xxxchannel_getptr()</function> returns the current offset in the "
"transfer buffer. This will typically be called by <function>chn_intr()</"
"function>, and this is how <filename>pcm</filename> knows where it can "
"transfer new data."
msgstr ""
" <function> xxxchannel_getptr () </function> retorna o deslocamento atual no "
"buffer de transfer�ncia. Isso normalmente ser� chamado por <function> "
"chn_intr () </function> e � assim <filename> pcm </filename> sabe onde pode "
"transferir novos dados. "

#. (itstool) path: sect3/title
#: book.translate.xml:23268
#, fuzzy
msgid "channel_free"
msgstr "channel_free"

#. (itstool) path: sect3/para
#: book.translate.xml:23270
#, fuzzy
msgid ""
"<function>xxxchannel_free()</function> is called to free up channel "
"resources, for example when the driver is unloaded, and should be "
"implemented if the channel data structures are dynamically allocated or if "
"<function>sndbuf_alloc()</function> was not used for buffer allocation."
msgstr ""
" <function> xxxchannel_free () </function> � chamado para liberar recursos "
"do canal, por exemplo, quando o driver � descarregado, e deve ser "
"implementado se as estruturas de dados do canal forem alocadas dinamicamente "
"ou se <function> sndbuf_alloc () </function> n�o foi usado para aloca��o de "
"buffer. "

#. (itstool) path: sect3/title
#: book.translate.xml:23279
#, fuzzy
msgid "channel_getcaps"
msgstr "channel_getcaps"

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23281
#, no-wrap
msgid ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &amp;xxx_caps;<co xml:id=\"co-chgetcaps-return\"/>\n"
"           }"
msgstr ""
"          struct pcmchan_caps *\n"
"          xxxchannel_getcaps(kobj_t obj, void *data)\n"
"          {\n"
"              return &amp;xxx_caps;<co xml:id=\"co-chgetcaps-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23290
#, fuzzy
msgid ""
"The routine returns a pointer to a (usually statically-defined) <varname "
"remap=\"structname\">pcmchan_caps</varname> structure (defined in "
"<filename>sound/pcm/channel.h</filename>. The structure holds the minimum "
"and maximum sampling frequencies, and the accepted sound formats. Look at "
"any sound driver for an example."
msgstr ""
"A rotina retorna um ponteiro para um (geralmente definido estaticamente) "
"<varname remap=\"structname\"> pcmchan_caps </varname> estrutura (definida "
"em <filename> som / pcm / channel.h </filename> . A estrutura cont�m as "
"freq��ncias de amostragem m�nima e m�xima e os formatos de som aceitos. Olhe "
"para qualquer driver de som como exemplo. "

#. (itstool) path: sect3/title
#: book.translate.xml:23302
#, fuzzy
msgid "More Functions"
msgstr "Mais fun��es"

#. (itstool) path: sect3/para
#: book.translate.xml:23304
#, fuzzy
msgid ""
"<function>channel_reset()</function>, <function>channel_resetdone()</"
"function>, and <function>channel_notify()</function> are for special "
"purposes and should not be implemented in a driver without discussing it on "
"the <link xlink:href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-"
"multimedia\">FreeBSD multimedia mailing list</link>."
msgstr ""
" <function> channel_reset () </function> , <function> channel_resetdone () </"
"function> e <function> channel_notify () </function> s�o para fins especiais "
"e n�o devem ser implementados em um driver sem discuti-lo no <link xlink:"
"href=\"http://lists.FreeBSD.org/mailman/listinfo/freebsd-multimedia\"> Lista "
"de discuss�o multim�dia do FreeBSD </link> "

#. (itstool) path: sect3/para
#: book.translate.xml:23310
#, fuzzy
msgid "<function>channel_setdir()</function> is deprecated."
msgstr " <function> channel_setdir () </function> est� obsoleto. "

#. (itstool) path: sect2/title
#: book.translate.xml:23316
#, fuzzy
msgid "The MIXER Interface"
msgstr "A interface MIXER"

#. (itstool) path: sect3/title
#: book.translate.xml:23319
#, fuzzy
msgid "mixer_init"
msgstr "mixer_init"

#. (itstool) path: sect3/para
#: book.translate.xml:23321
#, fuzzy
msgid ""
"<function>xxxmixer_init()</function> initializes the hardware and tells "
"<filename>pcm</filename> what mixer devices are available for playing and "
"recording"
msgstr ""
" <function> xxxmixer_init () </function> inicializa o hardware e informa "
"<filename> pcm </filename> quais dispositivos de mixagem est�o dispon�veis "
"para tocar e gravar "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23325
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
"\n"
"              [Initialize hardware]\n"
"\n"
"              [Set appropriate bits in v for play mixers]<co xml:id=\"co-"
"mxini-sd\"/>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
"\n"
"              return 0;\n"
"          }"
msgstr ""
"          static int\n"
"          xxxmixer_init(struct snd_mixer *m)\n"
"          {\n"
"              struct xxx_info   *sc = mix_getdevinfo(m);\n"
"              u_int32_t v;\n"
"\n"
"              [Initialize hardware]\n"
"\n"
"              [Set appropriate bits in v for play mixers]<co xml:id=\"co-"
"mxini-sd\"/>\n"
"              mix_setdevs(m, v);\n"
"              [Set appropriate bits in v for record mixers]\n"
"              mix_setrecdevs(m, v)\n"
"\n"
"              return 0;\n"
"          }"

#. (itstool) path: callout/para
#: book.translate.xml:23343
#, fuzzy
msgid ""
"Set bits in an integer value and call <function>mix_setdevs()</function> and "
"<function>mix_setrecdevs()</function> to tell <filename>pcm</filename> what "
"devices exist."
msgstr ""
"Definir bits em um valor inteiro e chamar <function> mix_setdevs () </"
"function> e <function> mix_setrecdevs () </function> contar <filename> pcm </"
"filename> quais dispositivos existem \""

#. (itstool) path: sect3/para
#: book.translate.xml:23350
#, fuzzy
msgid ""
"Mixer bits definitions can be found in <filename>soundcard.h</filename> "
"(<literal>SOUND_MASK_XXX</literal> values and <literal>SOUND_MIXER_XXX</"
"literal> bit shifts)."
msgstr ""
"As defini��es dos misturadores podem ser encontradas em <filename> soundcard."
"h </filename> ( <literal> SOUND_MASK_XXX </literal> valores e <literal> "
"SOUND_MIXER_XXX </literal> mudan�as de bit). "

#. (itstool) path: sect3/title
#: book.translate.xml:23357
#, fuzzy
msgid "mixer_set"
msgstr "mixer_set"

#. (itstool) path: sect3/para
#: book.translate.xml:23359
#, fuzzy
msgid ""
"<function>xxxmixer_set()</function> sets the volume level for one mixer "
"device."
msgstr ""
" <function> xxxmixer_set () </function> define o n�vel de volume para um "
"dispositivo de mixagem. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23362
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right)<co xml:id=\"co-"
"mxset-params\"/>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right &lt;&lt; 8);<co xml:id=\"co-mxset-"
"return\"/>\n"
"          }"
msgstr ""
"          static int\n"
"          xxxmixer_set(struct snd_mixer *m, unsigned dev,\n"
"                           unsigned left, unsigned right)<co xml:id=\"co-"
"mxset-params\"/>\n"
"          {\n"
"              struct sc_info *sc = mix_getdevinfo(m);\n"
"              [set volume level]\n"
"              return left | (right &lt;&lt; 8);<co xml:id=\"co-mxset-"
"return\"/>\n"
"          }"

#. (itstool) path: callout/para
#: book.translate.xml:23373
#, fuzzy
msgid "The device is specified as a <literal>SOUND_MIXER_XXX</literal> value"
msgstr ""
"O dispositivo � especificado como <literal> SOUND_MIXER_XXX </literal> valor"

#. (itstool) path: callout/para
#: book.translate.xml:23376
#, fuzzy
msgid ""
"The volume values are specified in range [0-100]. A value of zero should "
"mute the device."
msgstr ""
"Os valores de volume s�o especificados no intervalo [0-100]. Um valor de "
"zero deve silenciar o dispositivo."

#. (itstool) path: callout/para
#: book.translate.xml:23381
#, fuzzy
msgid ""
"As the hardware levels probably will not match the input scale, and some "
"rounding will occur, the routine returns the actual level values (in range 0-"
"100) as shown."
msgstr ""
"Como os n�veis de hardware provavelmente n�o corresponder�o � escala de "
"entrada, e algum arredondamento ocorrer�, a rotina retornar� os valores "
"reais de n�vel (no intervalo de 0 a 100), como mostrado."

#. (itstool) path: sect3/title
#: book.translate.xml:23391
#, fuzzy
msgid "mixer_setrecsrc"
msgstr "mixer_setrecsrc"

#. (itstool) path: sect3/para
#: book.translate.xml:23393
#, fuzzy
msgid ""
"<function>xxxmixer_setrecsrc()</function> sets the recording source device."
msgstr ""
" <function> xxxmixer_setrecsrc () </function> define o dispositivo de origem "
"de grava��o. "

#. (itstool) path: sect3/programlisting
#: book.translate.xml:23396
#, no-wrap
msgid ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<co xml:id="
"\"co-mxsr-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
"\n"
"              [look for non zero bit(s) in src, set up hardware]\n"
"\n"
"              [update src to reflect actual action]\n"
"              return src;<co xml:id=\"co-mxsr-return\"/>\n"
"           }"
msgstr ""
"          static int\n"
"          xxxmixer_setrecsrc(struct snd_mixer *m, u_int32_t src)<co xml:id="
"\"co-mxsr-params\"/>\n"
"          {\n"
"              struct xxx_info *sc = mix_getdevinfo(m);\n"
"\n"
"              [look for non zero bit(s) in src, set up hardware]\n"
"\n"
"              [update src to reflect actual action]\n"
"              return src;<co xml:id=\"co-mxsr-return\"/>\n"
"           }"

#. (itstool) path: callout/para
#: book.translate.xml:23409
#, fuzzy
msgid "The desired recording devices are specified as a bit field"
msgstr ""
"Os dispositivos de grava��o desejados s�o especificados como um campo de "
"bits"

#. (itstool) path: callout/para
#: book.translate.xml:23414
#, fuzzy
msgid ""
"The actual devices set for recording are returned. Some drivers can only set "
"one device for recording. The function should return -1 if an error occurs."
msgstr ""
"Os dispositivos atuais configurados para grava��o s�o retornados. Alguns "
"drivers podem apenas configurar um dispositivo para grava��o. A fun��o deve "
"retornar -1 se ocorrer um erro."

#. (itstool) path: sect3/title
#: book.translate.xml:23422
#, fuzzy
msgid "mixer_uninit, mixer_reinit"
msgstr "mixer_uninit, mixer_reinit"

#. (itstool) path: sect3/para
#: book.translate.xml:23424
#, fuzzy
msgid ""
"<function>xxxmixer_uninit()</function> should ensure that all sound is muted "
"and if possible mixer hardware should be powered down"
msgstr ""
" <function> xxxmixer_uninit () </function> deve garantir que todo o som seja "
"silenciado e, se poss�vel, o hardware do mixer deve ser desligado "

#. (itstool) path: sect3/para
#: book.translate.xml:23428
#, fuzzy
msgid ""
"<function>xxxmixer_reinit()</function> should ensure that the mixer hardware "
"is powered up and any settings not controlled by <function>mixer_set()</"
"function> or <function>mixer_setrecsrc()</function> are restored."
msgstr ""
" <function> xxxmixer_reinit () </function> deve garantir que o hardware do "
"mixer esteja ligado e quaisquer configura��es n�o <function> mixer_set () </"
"function> ou <function> mixer_setrecsrc () </function> s�o restaurados \""

#. (itstool) path: sect2/title
#: book.translate.xml:23436
#, fuzzy
msgid "The AC97 Interface"
msgstr "A interface do AC97"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23438
#, fuzzy
msgid "<primary>AC97</primary>"
msgstr " <primary> AC97 </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:23440
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is implemented by drivers with an "
"AC97 codec. It only has three methods:"
msgstr ""
"O <emphasis> AC97 </emphasis> A interface � implementada por drivers com um "
"codec AC97. Tem apenas tr�s m�todos: "

#. (itstool) path: listitem/para
#: book.translate.xml:23446
#, fuzzy
msgid ""
"<function>xxxac97_init()</function> returns the number of ac97 codecs found."
msgstr ""
" <function> xxxac97_init () </function> retorna o n�mero de codecs ac97 "
"encontrados. "

#. (itstool) path: listitem/para
#: book.translate.xml:23451
#, fuzzy
msgid ""
"<function>ac97_read()</function> and <function>ac97_write()</function> read "
"or write a specified register."
msgstr ""
" <function> ac97_read () </function> e <function> ac97_write () </function> "
"ler ou escrever um registro especificado. "

#. (itstool) path: sect2/para
#: book.translate.xml:23457
#, fuzzy
msgid ""
"The <emphasis>AC97</emphasis> interface is used by the AC97 code in "
"<filename>pcm</filename> to perform higher level operations. Look at "
"<filename>sound/pci/maestro3.c</filename> or many others under "
"<filename>sound/pci/</filename> for an example."
msgstr ""
"O <emphasis> AC97 </emphasis> interface � usada pelo c�digo AC97 em "
"<filename> pcm </filename> para executar opera��es de n�vel superior. Olhe "
"para <filename> som / pci / maestro3.c </filename> ou muitos outros sob "
"<filename> som / pci / </filename> Por exemplo."

#. (itstool) path: chapter/title
#: book.translate.xml:23473
#, fuzzy
msgid "PC Card"
msgstr "PC Card"

#. (itstool) path: chapter/indexterm
#: book.translate.xml:23475
#, fuzzy
msgid "<primary>PC Card</primary>"
msgstr " <primary> Cart�o PC </primary> "

#. (itstool) path: chapter/indexterm
#: book.translate.xml:23476
#, fuzzy
msgid "<primary>CardBus</primary>"
msgstr " <primary> CardBus </primary> "

#. (itstool) path: chapter/para
#: book.translate.xml:23478
#, fuzzy
msgid ""
"This chapter will talk about the FreeBSD mechanisms for writing a device "
"driver for a PC Card or CardBus device. However, at present it just "
"documents how to add a new device to an existing pccard driver."
msgstr ""
"Este cap�tulo vai falar sobre os mecanismos do FreeBSD para escrever um "
"driver de dispositivo para um PC Card ou um dispositivo CardBus. No entanto, "
"no momento ele apenas documenta como adicionar um novo dispositivo a um "
"driver de placa pc existente."

#. (itstool) path: sect1/title
#: book.translate.xml:23484
#, fuzzy
msgid "Adding a Device"
msgstr "Adicionando um dispositivo"

#. (itstool) path: sect1/para
#: book.translate.xml:23486
#, fuzzy
msgid ""
"Device drivers know what devices they support. There is a table of supported "
"devices in the kernel that drivers use to attach to a device."
msgstr ""
"Os drivers de dispositivos sabem quais dispositivos eles suportam. H� uma "
"tabela de dispositivos suportados no kernel que os drivers usam para "
"conectar a um dispositivo."

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23493
#, fuzzy
msgid "<primary>CIS</primary>"
msgstr " <primary> CIS </primary> "

#. (itstool) path: sect2/para
#: book.translate.xml:23494
#, fuzzy
msgid ""
"PC Cards are identified in one of two ways, both based on the "
"<firstterm>Card Information Structure</firstterm> (<acronym role=\"Card "
"Information Structure\">CIS</acronym>) stored on the card. The first method "
"is to use numeric manufacturer and product numbers. The second method is to "
"use the human readable strings that are also contained in the CIS. The PC "
"Card bus uses a centralized database and some macros to facilitate a design "
"pattern to help the driver writer match devices to his driver."
msgstr ""
"PC Cards s�o identificados de duas maneiras, ambas baseadas no <firstterm> "
"Estrutura de informa��es do cart�o </firstterm> ( <acronym role=\"Card "
"Information Structure\">CIS</acronym> ) armazenado no cart�o. O primeiro "
"m�todo � usar n�meros num�ricos de fabricantes e produtos. O segundo m�todo "
"� usar as cadeias humanas leg�veis que tamb�m est�o contidas no CIS. O "
"barramento da placa de PC usa um banco de dados centralizado e algumas "
"macros para facilitar um padr�o de projeto para ajudar o gravador do driver "
"a combinar os dispositivos com o driver. "

#. (itstool) path: sect2/para
#: book.translate.xml:23505
#, fuzzy
msgid ""
"Original equipment manufacturers (<acronym>OEM</acronym>s) often develop a "
"reference design for a PC Card product, then sell this design to other "
"companies to market. Those companies refine the design, market the product "
"to their target audience or geographic area, and put their own name plate "
"onto the card. The refinements to the physical card are typically very "
"minor, if any changes are made at all. To strengthen their brand, these "
"vendors place their company name in the human readable strings in the CIS "
"space, but leave the manufacturer and product IDs unchanged."
msgstr ""
"Fabricantes de equipamentos originais ( <acronym>OEMs</acronym> ) "
"frequentemente desenvolvem um design de refer�ncia para um produto de PC "
"Card e vendem esse projeto para outras empresas. Essas empresas refinam o "
"design, comercializam o produto para seu p�blico-alvo ou �rea geogr�fica e "
"placa de identifica��o para o cart�o.Os refinamentos para o cart�o f�sico "
"s�o normalmente muito pequenas, se forem feitas altera��es a todos.Para "
"fortalecer sua marca, esses fornecedores colocam o nome da empresa nas "
"seq��ncias leg�veis para humanos no espa�o CIS, mas deixam o fabricante e "
"IDs de produto inalterados. "

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23516
msgid "<primary>NetGear</primary>"
msgstr "<primary>NetGear</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23517
msgid "<primary>Linksys</primary>"
msgstr "<primary>Linksys</primary>"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23518
msgid "<primary>D-Link</primary>"
msgstr "<primary>D-Link</primary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23520
#, fuzzy
msgid ""
"Because of this practice, FreeBSD drivers usually rely on numeric IDs for "
"device identification. Using numeric IDs and a centralized database "
"complicates adding IDs and support for cards to the system. One must "
"carefully check to see who really made the card, especially when it appears "
"that the vendor who made the card might already have a different "
"manufacturer ID listed in the central database. Linksys, D-Link, and NetGear "
"are a number of US manufacturers of LAN hardware that often sell the same "
"design. These same designs can be sold in Japan under names such as Buffalo "
"and Corega. Often, these devices will all have the same manufacturer and "
"product IDs."
msgstr ""
"Devido a essa pr�tica, os drivers do FreeBSD geralmente dependem de IDs "
"num�ricos para identifica��o do dispositivo. O uso de IDs num�ricos e um "
"banco de dados centralizado dificulta a adi��o de IDs e suporte a cart�es no "
"sistema. � preciso verificar cuidadosamente quem realmente fez o cart�o, "
"especialmente quando Parece que o fornecedor que fez o cart�o j� pode ter um "
"ID de fabricante diferente listado no banco de dados central.A Linksys, D-"
"Link e NetGear s�o um n�mero de fabricantes dos EUA de hardware de rede "
"local que muitas vezes vendem o mesmo design. vendidos no Jap�o sob nomes "
"como Buffalo e Corega. Muitas vezes, esses dispositivos ter�o todos os "
"mesmos IDs de fabricantes e produtos. "

#. (itstool) path: sect2/para
#: book.translate.xml:23533
#, fuzzy
msgid ""
"The PC Card bus code keeps a central database of card information, but not "
"which driver is associated with them, in <filename>/sys/dev/pccard/"
"pccarddevs</filename>. It also provides a set of macros that allow one to "
"easily construct simple entries in the table the driver uses to claim "
"devices."
msgstr ""
"O c�digo de barramento do PC Card mant�m um banco de dados central de "
"informa��es do cart�o, mas n�o qual driver est� associado a eles, <filename> "
"/ sys / dev / pccard / pccarddevs </filename> . Ele tamb�m fornece um "
"conjunto de macros que permitem construir facilmente entradas simples na "
"tabela que o driver usa para reivindicar dispositivos. "

#. (itstool) path: sect2/para
#: book.translate.xml:23540
#, fuzzy
msgid ""
"Finally, some really low end devices do not contain manufacturer "
"identification at all. These devices must be detected by matching the human "
"readable CIS strings. While it would be nice if we did not need this method "
"as a fallback, it is necessary for some very low end CD-ROM players and "
"Ethernet cards. This method should generally be avoided, but a number of "
"devices are listed in this section because they were added prior to the "
"recognition of the <acronym>OEM</acronym> nature of the PC Card business. "
"When adding new devices, prefer using the numeric method."
msgstr ""
"Finalmente, alguns dispositivos realmente low-end n�o cont�m identifica��o "
"do fabricante. Esses dispositivos devem ser detectados combinando as strings "
"CIS leg�veis. Embora seja bom se n�o precisarmos desse m�todo como um "
"fallback, � necess�rio que alguns reprodutores de CD-ROM e placas Ethernet "
"muito low end Esse m�todo deve ser geralmente evitado, mas v�rios "
"dispositivos s�o listados nesta se��o porque foram adicionados antes do "
"reconhecimento da natureza <acronym>OEM</acronym> do neg�cio do PC Card. , "
"prefira usar o m�todo num�rico. "

#. (itstool) path: sect2/title
#: book.translate.xml:23553
#, fuzzy
msgid "Format of <filename>pccarddevs</filename>"
msgstr "Formato de <filename> pccarddevs </filename> "

#. (itstool) path: sect2/para
#: book.translate.xml:23555
#, fuzzy
msgid ""
"There are four sections in the <filename>pccarddevs</filename> files. The "
"first section lists the manufacturer numbers for vendors that use them. This "
"section is sorted in numerical order. The next section has all of the "
"products that are used by these vendors, along with their product ID numbers "
"and a description string. The description string typically is not used "
"(instead we set the device's description based on the human readable CIS, "
"even if we match on the numeric version). These two sections are then "
"repeated for devices that use the string matching method. Finally, C-style "
"comments enclosed in <literal>/*</literal> and <literal>*/</literal> "
"characters are allowed anywhere in the file."
msgstr ""
"H� quatro se��es no <filename> pccarddevs </filename> arquivos. A primeira "
"se��o lista os n�meros do fabricante dos fornecedores que os utilizam. Esta "
"se��o � classificada em ordem num�rica. A pr�xima se��o tem todos os "
"produtos usados ​​por esses fornecedores, juntamente com seus n�meros de "
"identifica��o de produto e uma string de descri��o. A string de descri��o "
"geralmente n�o � usada (em vez disso, definimos a descri��o do dispositivo "
"com base no CIS leg�vel, mesmo se correspondermos � vers�o num�rica). Essas "
"duas se��es s�o repetidas para dispositivos que usam o m�todo de "
"correspond�ncia de seq��ncia de caracteres. Finalmente, coment�rios no "
"estilo C inclu�dos <literal> / * </literal> e <literal> * / </literal> "
"caracteres s�o permitidos em qualquer lugar do arquivo. "

#. (itstool) path: sect2/para
#: book.translate.xml:23569
#, fuzzy
msgid ""
"The first section of the file contains the vendor IDs. Please keep this list "
"sorted in numeric order. Also, please coordinate changes to this file "
"because we share it with NetBSD to help facilitate a common clearing house "
"for this information. For example, here are the first few vendor IDs:"
msgstr ""
"A primeira se��o do arquivo cont�m os IDs do fornecedor. Por favor, mantenha "
"esta lista classificada em ordem num�rica. Al�m disso, coordene as "
"altera��es neste arquivo, porque o compartilhamos com o NetBSD para ajudar a "
"facilitar uma c�mara de compensa��o comum para essas informa��es. Por "
"exemplo, aqui s�o os primeiros poucos IDs de fornecedores: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23576
#, no-wrap
msgid ""
"vendor FUJITSU\t\t\t0x0004  Fujitsu Corporation\n"
"vendor NETGEAR_2\t\t0x000b  Netgear\n"
"vendor PANASONIC\t\t0x0032\tMatsushita Electric Industrial Co.\n"
"vendor SANDISK\t\t\t0x0045\tSandisk Corporation"
msgstr ""
"vendor FUJITSU\t\t\t0x0004  Fujitsu Corporation\n"
"vendor NETGEAR_2\t\t0x000b  Netgear\n"
"vendor PANASONIC\t\t0x0032\tMatsushita Electric Industrial Co.\n"
"vendor SANDISK\t\t\t0x0045\tSandisk Corporation"

#. (itstool) path: sect2/para
#: book.translate.xml:23581
#, fuzzy
msgid ""
"Chances are very good that the <literal>NETGEAR_2</literal> entry is really "
"an OEM that NETGEAR purchased cards from and the author of support for those "
"cards was unaware at the time that Netgear was using someone else's ID. "
"These entries are fairly straightforward. The vendor keyword denotes the "
"kind of line that this is, followed by the name of the vendor. This name "
"will be repeated later in <filename>pccarddevs</filename>, as well as used "
"in the driver's match tables, so keep it short and a valid C identifier. A "
"numeric ID in hex identifies the manufacturer. Do not add IDs of the form "
"<literal>0xffffffff</literal> or <literal>0xffff</literal> because these are "
"reserved IDs (the former is <quote>no ID set</quote> while the latter is "
"sometimes seen in extremely poor quality cards to try to indicate "
"<quote>none</quote>). Finally there is a string description of the company "
"that makes the card. This string is not used in FreeBSD for anything but "
"commentary purposes."
msgstr ""
"As chances s�o muito boas que o <literal> NETGEAR_2 </literal> A entrada � "
"realmente um OEM do qual a NETGEAR comprou cart�es e o autor do suporte para "
"esses cart�es n�o sabia no momento em que a Netgear usava o ID de outra "
"pessoa. Essas entradas s�o bastante simples. A palavra-chave do fornecedor "
"indica o tipo de linha que � seguido pelo nome do fornecedor. Este nome ser� "
"repetido mais tarde <filename> pccarddevs </filename> , bem como usado nas "
"tabelas de correspond�ncia do driver, portanto, mantenha-o curto e um "
"identificador C v�lido. Um ID num�rico em hex identifica o fabricante. N�o "
"adicione IDs do formul�rio <literal> 0xffffffff </literal> ou <literal> "
"0xffff </literal> porque estes s�o IDs reservados (o primeiro � <quote> "
"nenhum conjunto de ID </quote> enquanto o �ltimo � visto �s vezes em cart�es "
"de extrema baixa qualidade para tentar indicar <quote> Nenhum </quote> ). "
"Finalmente, h� uma descri��o da string da empresa que faz o cart�o. Esta "
"string n�o � usada no FreeBSD para fins que n�o sejam coment�rios. "

#. (itstool) path: sect2/para
#: book.translate.xml:23600
#, fuzzy
msgid ""
"The second section of the file contains the products. As shown in this "
"example, the format is similar to the vendor lines:"
msgstr ""
"A segunda se��o do arquivo cont�m os produtos. Conforme mostrado neste "
"exemplo, o formato � semelhante �s linhas do fornecedor:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23604
#, no-wrap
msgid ""
"/* Allied Telesis K.K. */\n"
"product ALLIEDTELESIS LA_PCM\t0x0002 Allied Telesis LA-PCM\n"
"\n"
"/* Archos */\n"
"product\tARCHOS ARC_ATAPI\t0x0043 MiniCD"
msgstr ""
"/* Allied Telesis K.K. */\n"
"product ALLIEDTELESIS LA_PCM\t0x0002 Allied Telesis LA-PCM\n"
"\n"
"/* Archos */\n"
"product\tARCHOS ARC_ATAPI\t0x0043 MiniCD"

#. (itstool) path: sect2/para
#: book.translate.xml:23610
#, fuzzy
msgid ""
"The <literal>product</literal> keyword is followed by the vendor name, "
"repeated from above. This is followed by the product name, which is used by "
"the driver and should be a valid C identifier, but may also start with a "
"number. As with the vendors, the hex product ID for this card follows the "
"same convention for <literal>0xffffffff</literal> and <literal>0xffff</"
"literal>. Finally, there is a string description of the device itself. This "
"string typically is not used in FreeBSD, since FreeBSD's pccard bus driver "
"will construct a string from the human readable CIS entries, but it can be "
"used in the rare cases where this is somehow insufficient. The products are "
"in alphabetical order by manufacturer, then numerical order by product ID. "
"They have a C comment before each manufacturer's entries and there is a "
"blank line between entries."
msgstr ""
"O <literal> produtos </literal> palavra-chave � seguida pelo nome do "
"fornecedor, repetido de cima. Isto � seguido pelo nome do produto, que � "
"usado pelo driver e deve ser um identificador C v�lido, mas tamb�m pode "
"come�ar com um n�mero. Tal como acontece com os fornecedores, o ID do "
"produto hexadecimal para este cart�o segue a mesma conven��o para <literal> "
"0xffffffff </literal> e <literal> 0xffff </literal> . Finalmente, h� uma "
"descri��o de string do pr�prio dispositivo. Esta string normalmente n�o � "
"usada no FreeBSD, j� que o driver de barramento de pccard do FreeBSD ir� "
"construir uma string a partir das entradas do CIS leg�vel, mas pode ser "
"usado nos raros casos em que isso � de alguma forma insuficiente. Os "
"produtos est�o em ordem alfab�tica por fabricante, em seguida, ordem "
"num�rica por ID do produto. Eles t�m um coment�rio C antes das entradas de "
"cada fabricante e h� uma linha em branco entre as entradas. "

#. (itstool) path: sect2/para
#: book.translate.xml:23627
#, fuzzy
msgid ""
"The third section is like the previous vendor section, but with all of the "
"manufacturer numeric IDs set to <literal>-1</literal>, meaning <quote>match "
"anything found</quote> in the FreeBSD pccard bus code. Since these are C "
"identifiers, their names must be unique. Otherwise the format is identical "
"to the first section of the file."
msgstr ""
"A terceira se��o � como a se��o anterior do fornecedor, mas com todas as IDs "
"num�ricas do fabricante configuradas como <literal> -1 </literal> "
"significado <quote> coincidir com qualquer coisa encontrada </quote> no "
"c�digo de barramento do pccard do FreeBSD. Como esses s�o identificadores C, "
"seus nomes devem ser exclusivos. Caso contr�rio, o formato � id�ntico � "
"primeira se��o do arquivo. "

#. (itstool) path: sect2/para
#: book.translate.xml:23635
#, fuzzy
msgid ""
"The final section contains the entries for those cards that must be "
"identified by string entries. This section's format is a little different "
"from the generic section:"
msgstr ""
"A se��o final cont�m as entradas para as placas que devem ser identificadas "
"por entradas de string. O formato desta se��o � um pouco diferente da se��o "
"gen�rica:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23639
#, no-wrap
msgid ""
"product ADDTRON AWP100\t\t{ \"Addtron\", \"AWP-"
"100&amp;spWireless&amp;spPCMCIA\", \"Version&amp;sp01.02\", NULL }\n"
"product ALLIEDTELESIS WR211PCM\t{ \"Allied&amp;spTelesis&amp;spK.K.\", "
"\"WR211PCM\", NULL, NULL } Allied Telesis WR211PCM"
msgstr ""
"product ADDTRON AWP100\t\t{ \"Addtron\", \"AWP-"
"100&amp;spWireless&amp;spPCMCIA\", \"Version&amp;sp01.02\", NULL }\n"
"product ALLIEDTELESIS WR211PCM\t{ \"Allied&amp;spTelesis&amp;spK.K.\", "
"\"WR211PCM\", NULL, NULL } Allied Telesis WR211PCM"

#. (itstool) path: sect2/para
#: book.translate.xml:23642
#, fuzzy
msgid ""
"The familiar <literal>product</literal> keyword is followed by the vendor "
"name and the card name, just as in the second section of the file. Here the "
"format deviates from that used earlier. There is a {} grouping, followed by "
"a number of strings. These strings correspond to the vendor, product, and "
"extra information that is defined in a CIS_INFO tuple. These strings are "
"filtered by the program that generates <filename>pccarddevs.h</filename> to "
"replace &amp;sp with a real space. NULL strings mean that the corresponding "
"part of the entry should be ignored. The example shown here contains a bad "
"entry. It should not contain the version number unless that is critical for "
"the operation of the card. Sometimes vendors will have many different "
"versions of the card in the field that all work, in which case that "
"information only makes it harder for someone with a similar card to use it "
"with FreeBSD. Sometimes it is necessary when a vendor wishes to sell many "
"different parts under the same brand due to market considerations "
"(availability, price, and so forth). Then it can be critical to "
"disambiguating the card in those rare cases where the vendor kept the same "
"manufacturer/product pair. Regular expression matching is not available at "
"this time."
msgstr ""
"O familiar <literal> produtos </literal> A palavra-chave � seguida pelo nome "
"do fornecedor e pelo nome do cart�o, assim como na segunda se��o do arquivo. "
"Aqui o formato se desvia do usado anteriormente. H� um {} agrupamento, "
"seguido por v�rias sequ�ncias. Essas sequ�ncias correspondem ao fornecedor, "
"ao produto e �s informa��es extras definidas em uma tupla CIS_INFO. Essas "
"strings s�o filtradas pelo programa que gera <filename> pccarddevs.h </"
"filename> para substituir o sp por um espa�o real. Strings NULL significam "
"que a parte correspondente da entrada deve ser ignorada. O exemplo mostrado "
"aqui cont�m uma entrada incorreta. Ele n�o deve conter o n�mero da vers�o, a "
"menos que isso seja cr�tico para a opera��o do cart�o. �s vezes, os "
"fornecedores ter�o muitas vers�es diferentes do cart�o no campo que "
"funcionam, e nesse caso essa informa��o s� dificulta que algu�m com um "
"cart�o semelhante o use com o FreeBSD. �s vezes � necess�rio quando um "
"fornecedor deseja vender muitas pe�as diferentes sob a mesma marca devido a "
"considera��es de mercado (disponibilidade, pre�o e assim por diante). Ent�o, "
"pode ser cr�tico desambiguar o cart�o nos raros casos em que o fornecedor "
"manteve o mesmo par fabricante / produto. A correspond�ncia de express�o "
"regular n�o est� dispon�vel no momento. "

#. (itstool) path: sect2/title
#: book.translate.xml:23667
#, fuzzy
msgid "Sample Probe Routine"
msgstr "Rotina da Sonda de Amostra"

#. (itstool) path: sect2/indexterm
#: book.translate.xml:23669
msgid "<primary>PC Card</primary> <secondary>probe</secondary>"
msgstr "<primary>PC Card</primary> <secondary>probe</secondary>"

#. (itstool) path: sect2/para
#: book.translate.xml:23674
#, fuzzy
msgid ""
"To understand how to add a device to the list of supported devices, one must "
"understand the probe and/or match routines that many drivers have. It is "
"complicated a little in FreeBSD 5.x because there is a compatibility layer "
"for OLDCARD present as well. Since only the window-dressing is different, an "
"idealized version will be presented here."
msgstr ""
"Para entender como adicionar um dispositivo � lista de dispositivos "
"suportados, deve-se entender a sonda e / ou combinar as rotinas que muitos "
"drivers possuem. � um pouco complicado no FreeBSD 5.x porque existe uma "
"camada de compatibilidade para OLDCARD presente como Bem, uma vez que apenas "
"a janela de vestir � diferente, uma vers�o idealizada ser� apresentada aqui "
"\""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23681
#, no-wrap
msgid ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};\n"
"\n"
"static int\n"
"wi_pccard_probe(dev)\n"
"\tdevice_t\tdev;\n"
"{\n"
"\tconst struct pccard_product *pp;\n"
"\n"
"\tif ((pp = pccard_product_lookup(dev, wi_pccard_products,\n"
"\t    sizeof(wi_pccard_products[0]), NULL)) != NULL) {\n"
"\t\tif (pp-&gt;pp_name != NULL)\n"
"\t\t\tdevice_set_desc(dev, pp-&gt;pp_name);\n"
"\t\treturn (0);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}"
msgstr ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};\n"
"\n"
"static int\n"
"wi_pccard_probe(dev)\n"
"\tdevice_t\tdev;\n"
"{\n"
"\tconst struct pccard_product *pp;\n"
"\n"
"\tif ((pp = pccard_product_lookup(dev, wi_pccard_products,\n"
"\t    sizeof(wi_pccard_products[0]), NULL)) != NULL) {\n"
"\t\tif (pp-&gt;pp_name != NULL)\n"
"\t\t\tdevice_set_desc(dev, pp-&gt;pp_name);\n"
"\t\treturn (0);\n"
"\t}\n"
"\treturn (ENXIO);\n"
"}"

#. (itstool) path: sect2/para
#: book.translate.xml:23704
#, fuzzy
msgid ""
"Here we have a simple pccard probe routine that matches a few devices. As "
"stated above, the name may vary (if it is not <function>foo_pccard_probe()</"
"function> it will be <function>foo_pccard_match()</function>). The function "
"<function>pccard_product_lookup()</function> is a generalized function that "
"walks the table and returns a pointer to the first entry that it matches. "
"Some drivers may use this mechanism to convey additional information about "
"some cards to the rest of the driver, so there may be some variance in the "
"table. The only requirement is that each row of the table must have a "
"<function>struct</function> <varname remap=\"structname\">pccard_product</"
"varname> as the first element."
msgstr ""
"Aqui temos uma simples rotina de teste pccard que combina com alguns "
"dispositivos. Como dito acima, o nome pode variar (se n�o for <function> "
"foo_pccard_probe () </function> ser� <function> foo_pccard_match () </"
"function> ). A fun��o <function> pccard_product_lookup () </function> � uma "
"fun��o generalizada que percorre a tabela e retorna um ponteiro para a "
"primeira entrada correspondente. Alguns drivers podem usar esse mecanismo "
"para transmitir informa��es adicionais sobre alguns cart�es para o restante "
"do driver, portanto, pode haver alguma varia��o na tabela. O �nico requisito "
"� que cada linha da tabela deve ter um <function> struct </function><varname "
"remap=\"structname\"> pccard_product </varname> como o primeiro elemento \""

#. (itstool) path: sect2/para
#: book.translate.xml:23718
#, fuzzy
msgid ""
"Looking at the table <varname remap=\"structname\">wi_pccard_products</"
"varname>, one notices that all the entries are of the form "
"<function>PCMCIA_CARD(<replaceable>foo</replaceable>, <replaceable>bar</"
"replaceable>, <replaceable>baz</replaceable>)</function>. The "
"<replaceable>foo</replaceable> part is the manufacturer ID from "
"<filename>pccarddevs</filename>. The <replaceable>bar</replaceable> part is "
"the product ID. <replaceable>baz</replaceable> is the expected function "
"number for this card. Many pccards can have multiple functions, and some way "
"to disambiguate function 1 from function 0 is needed. You may see "
"<literal>PCMCIA_CARD_D</literal>, which includes the device description from "
"<filename>pccarddevs</filename>. You may also see <literal>PCMCIA_CARD2</"
"literal> and <literal>PCMCIA_CARD2_D</literal> which are used when you need "
"to match both CIS strings and manufacturer numbers, in the <quote>use the "
"default description</quote> and <quote>take the description from pccarddevs</"
"quote> flavors."
msgstr ""
"Olhando para a mesa <varname remap=\"structname\"> wi_pccard_products </"
"varname> , percebe-se que todas as entradas s�o da forma <function> "
"PCMCIA_CARD ( <replaceable> foo </replaceable> , <replaceable> Barra </"
"replaceable> , <replaceable> baz </replaceable> ) </function> . o "
"<replaceable> foo </replaceable> parte � o ID do fabricante de <filename> "
"pccarddevs </filename> . o <replaceable> Barra </replaceable> parte � o ID "
"do produto. <replaceable> baz </replaceable> � o n�mero da fun��o esperada "
"para este cart�o. Muitos pccards podem ter m�ltiplas fun��es, e alguma "
"maneira de desambiguar a fun��o 1 da fun��o 0 � necess�ria. Voc� pode ver "
"<literal> PCMCIA_CARD_D </literal> , que inclui a descri��o do dispositivo "
"de <filename> pccarddevs </filename> . Voc� tamb�m pode ver <literal> "
"PCMCIA_CARD2 </literal> e <literal> PCMCIA_CARD2_D </literal> que s�o usados "
"​​quando voc� precisa combinar as seq��ncias de caracteres do CIS e os "
"n�meros do fabricante, no <quote> use a descri��o padr�o </quote> e <quote> "
"Pegue a descri��o do pccarddevs </quote> sabores. "

#. (itstool) path: sect2/title
#: book.translate.xml:23741
#, fuzzy
msgid "Putting it All Together"
msgstr "Colocando tudo junto"

#. (itstool) path: sect2/para
#: book.translate.xml:23743
#, fuzzy
msgid ""
"To add a new device, one must first obtain the identification information "
"from the device. The easiest way to do this is to insert the device into a "
"PC Card or CF slot and issue <command>devinfo -v</command>. Sample output:"
msgstr ""
"Para adicionar um novo dispositivo, � necess�rio primeiro obter as "
"informa��es de identifica��o do dispositivo. A maneira mais f�cil de fazer "
"isso � inserir o dispositivo em um slot e cart�o PC Card ou CF. <command> "
"devinfo -v </command> . Exemplo de sa�da: "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23749
#, no-wrap
msgid ""
"        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice="
"0x0300 class=0x060700 at slot=10 function=1\n"
"          cardbus1\n"
"          pccard1\n"
"            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor="
"\"BUFFALO\" cisproduct=\"WLI2-CF-S11\" function_type=6 at function=0"
msgstr ""
"        cbb1 pnpinfo vendor=0x104c device=0xac51 subvendor=0x1265 subdevice="
"0x0300 class=0x060700 at slot=10 function=1\n"
"          cardbus1\n"
"          pccard1\n"
"            unknown pnpinfo manufacturer=0x026f product=0x030c cisvendor="
"\"BUFFALO\" cisproduct=\"WLI2-CF-S11\" function_type=6 at function=0"

#. (itstool) path: sect2/para
#: book.translate.xml:23754
#, fuzzy
msgid ""
"<literal>manufacturer</literal> and <literal>product</literal> are the "
"numeric IDs for this product, while <literal>cisvendor</literal> and "
"<literal>cisproduct</literal> are the product description strings from the "
"CIS."
msgstr ""
" <literal> fabricante </literal> e <literal> produtos </literal> s�o os IDs "
"num�ricos para este produto, enquanto <literal> cisvendor </literal> e "
"<literal> cisproduto </literal> s�o as strings de descri��o do produto do "
"CIS. "

#. (itstool) path: sect2/para
#: book.translate.xml:23760
#, fuzzy
msgid ""
"Since we first want to prefer the numeric option, first try to construct an "
"entry based on that. The above card has been slightly fictionalized for the "
"purpose of this example. The vendor is BUFFALO, which we see already has an "
"entry:"
msgstr ""
"Como queremos primeiro preferir a op��o num�rica, primeiro tente construir "
"uma entrada com base nisso. O cart�o acima foi ligeiramente ficcionalizado "
"para o prop�sito deste exemplo. O fornecedor � BUFFALO, que j� vemos com uma "
"entrada:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23766
#, no-wrap
msgid "vendor BUFFALO\t\t\t0x026f\tBUFFALO (Melco Corporation)"
msgstr "vendor BUFFALO\t\t\t0x026f\tBUFFALO (Melco Corporation)"

#. (itstool) path: sect2/para
#: book.translate.xml:23768
#, fuzzy
msgid "But there is no entry for this particular card. Instead we find:"
msgstr ""
"Mas n�o h� entrada para este cart�o em particular. Em vez disso, encontramos:"
""

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23771
#, no-wrap
msgid ""
"/* BUFFALO */\n"
"product BUFFALO WLI_PCM_S11\t0x0305\tBUFFALO AirStation 11Mbps WLAN\n"
"product BUFFALO LPC_CF_CLT\t0x0307\tBUFFALO LPC-CF-CLT\n"
"product\tBUFFALO\tLPC3_CLT\t0x030a\tBUFFALO LPC3-CLT Ethernet Adapter\n"
"product BUFFALO WLI_CF_S11G\t0x030b\tBUFFALO AirStation 11Mbps CF WLAN"
msgstr ""
"/* BUFFALO */\n"
"product BUFFALO WLI_PCM_S11\t0x0305\tBUFFALO AirStation 11Mbps WLAN\n"
"product BUFFALO LPC_CF_CLT\t0x0307\tBUFFALO LPC-CF-CLT\n"
"product\tBUFFALO\tLPC3_CLT\t0x030a\tBUFFALO LPC3-CLT Ethernet Adapter\n"
"product BUFFALO WLI_CF_S11G\t0x030b\tBUFFALO AirStation 11Mbps CF WLAN"

#. (itstool) path: sect2/para
#: book.translate.xml:23777
#, fuzzy
msgid ""
"To add the device, we can just add this entry to <filename>pccarddevs</"
"filename>:"
msgstr ""
"Para adicionar o dispositivo, podemos adicionar essa entrada para <filename> "
"pccarddevs </filename> : "

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23780
#, no-wrap
msgid ""
"product BUFFALO WLI2_CF_S11G\t0x030c\tBUFFALO AirStation ultra 802.11b CF"
msgstr ""
"product BUFFALO WLI2_CF_S11G\t0x030c\tBUFFALO AirStation ultra 802.11b CF"

#. (itstool) path: sect2/para
#: book.translate.xml:23782
#, fuzzy
msgid ""
"Once these steps are complete, the card can be added to the driver. That is "
"a simple operation of adding one line:"
msgstr ""
"Depois que essas etapas forem conclu�das, o cart�o pode ser adicionado ao "
"driver. Essa � uma opera��o simples de adicionar uma linha:"

#. (itstool) path: sect2/programlisting
#: book.translate.xml:23786
#, no-wrap
msgid ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"+\tPCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};"
msgstr ""
"static const struct pccard_product wi_pccard_products[] = {\n"
"\tPCMCIA_CARD(3COM, 3CRWE737A, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_PCM_S11, 0),\n"
"\tPCMCIA_CARD(BUFFALO, WLI_CF_S11G, 0),\n"
"+\tPCMCIA_CARD(BUFFALO, WLI_CF2_S11G, 0),\n"
"\tPCMCIA_CARD(TDK, LAK_CD011WL, 0),\n"
"\t{ NULL }\n"
"};"

#. (itstool) path: sect2/para
#: book.translate.xml:23795
#, fuzzy
msgid ""
"Note that I have included a '<literal>+</literal>' in the line before the "
"line that I added, but that is simply to highlight the line. Do not add it "
"to the actual driver. Once you have added the line, you can recompile your "
"kernel or module and test it. If the device is recognized and works, please "
"submit a patch. If it does not work, please figure out what is needed to "
"make it work and submit a patch. If the device is not recognized at all, you "
"have done something wrong and should recheck each step."
msgstr ""
"Note que eu inclu� um '; <literal> + </literal> ' na linha antes da linha "
"que eu adicionei, mas isso � simplesmente para destacar a linha. N�o o "
"adicione ao driver real. Depois de adicionar a linha, voc� pode recompilar "
"seu kernel ou m�dulo e test�-lo. Se o dispositivo for reconhecido e "
"funcionar, envie um patch. Se isso n�o funcionar, descubra o que � "
"necess�rio para que funcione e envie um patch. Se o dispositivo n�o for "
"reconhecido, voc� fez algo errado e deve verificar novamente cada etapa. "

#. (itstool) path: sect2/para
#: book.translate.xml:23805
#, fuzzy
msgid ""
"If you are a FreeBSD src committer, and everything appears to be working, "
"then you can commit the changes to the tree. However, there are some minor "
"tricky things to be considered. <filename>pccarddevs</filename> must be "
"committed to the tree first. Then <filename>pccarddevs.h</filename> must be "
"regenerated and committed as a second step, ensuring that the right "
"$FreeBSD$ tag is in the latter file. Finally, commit the additions to the "
"driver."
msgstr ""
"Se voc� � um commitcador do FreeBSD src, e tudo parece estar funcionando, "
"ent�o voc� pode cometer as mudan�as na �rvore. No entanto, existem algumas "
"pequenas coisas complicadas a serem consideradas. <filename> pccarddevs </"
"filename> deve ser comprometido com a primeira �rvore. Ent�o <filename> "
"pccarddevs.h </filename> deve ser regenerado e confirmado como uma segunda "
"etapa, garantindo que a tag $ FreeBSD $ correta esteja no �ltimo arquivo. "
"Finalmente, confirme as adi��es ao driver. "

#. (itstool) path: sect2/title
#: book.translate.xml:23816
#, fuzzy
msgid "Submitting a New Device"
msgstr "Enviando um novo dispositivo"

#. (itstool) path: sect2/para
#: book.translate.xml:23818
#, fuzzy
msgid ""
"Please do not send entries for new devices to the author directly. Instead, "
"submit them as a PR and send the author the PR number for his records. This "
"ensures that entries are not lost. When submitting a PR, it is unnecessary "
"to include the <filename>pccardevs.h</filename> diffs in the patch, since "
"those will be regenerated. It is necessary to include a description of the "
"device, as well as the patches to the client driver. If you do not know the "
"name, use OEM99 as the name, and the author will adjust OEM99 accordingly "
"after investigation. Committers should not commit OEM99, but instead find "
"the highest OEM entry and commit one more than that."
msgstr ""
"Por favor, n�o envie entradas para novos dispositivos para o autor "
"diretamente. Em vez disso, envie-os como um PR e envie ao autor o n�mero PR "
"para seus registros. Isso garante que as entradas n�o sejam perdidas. Ao "
"enviar um PR, n�o � necess�rio incluir a <filename> pccardevs.h </filename> "
"diffs no patch, desde que esses ser�o regenerados. � necess�rio incluir uma "
"descri��o do dispositivo, bem como os patches para o driver cliente. Se voc� "
"n�o souber o nome, use OEM99 como o nome e o autor ajustar� o OEM99 "
"adequadamente ap�s a investiga��o. Os committers n�o devem confirmar o "
"OEM99, mas, em vez disso, encontrar a entrada OEM mais alta e cometer um a "
"mais do que isso. "

#. (itstool) path: part/title
#: book.translate.xml:23880
#, fuzzy
msgid "Appendices"
msgstr "Ap�ndices"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23886
msgid ""
"<personname><firstname>Marshall</firstname><othername role=\"Middle\">Kirk</"
"othername><surname>McKusick</surname></personname>"
msgstr ""
"<personname><firstname>Marshall</firstname><othername role=\"Middle\">Kirk</"
"othername><surname>McKusick</surname></personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23887
msgid ""
"<personname><firstname>Keith</firstname><surname>Bostic</surname></"
"personname>"
msgstr ""
"<personname><firstname>Keith</firstname><surname>Bostic</surname></"
"personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23888
msgid ""
"<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
"othername><surname>Karels</surname></personname>"
msgstr ""
"<personname><firstname>Michael</firstname><othername role=\"MI\">J</"
"othername><surname>Karels</surname></personname>"

#. (itstool) path: authorgroup/author
#: book.translate.xml:23889
msgid ""
"<personname><firstname>John</firstname><othername role=\"MI\">S</"
"othername><surname>Quarterman</surname></personname>"
msgstr ""
"<personname><firstname>John</firstname><othername role=\"MI\">S</"
"othername><surname>Quarterman</surname></personname>"

#. (itstool) path: biblioentry/copyright
#: book.translate.xml:23892
msgid ""
"<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"
msgstr ""
"<year>1996</year> <holder>Addison-Wesley Publishing Company, Inc.</holder>"

#. (itstool) path: biblioentry/biblioid
#: book.translate.xml:23897
msgid "0-201-54979-4"
msgstr "0-201-54979-4"

#. (itstool) path: publisher/publishername
#: book.translate.xml:23900
msgid "Addison-Wesley Publishing Company, Inc."
msgstr "Addison-Wesley Publishing Company, Inc."

#. (itstool) path: biblioentry/citetitle
#: book.translate.xml:23903
msgid "The Design and Implementation of the 4.4 BSD Operating System"
msgstr "The Design and Implementation of the 4.4 BSD Operating System"

#. (itstool) path: biblioentry/pagenums
#: book.translate.xml:23905
msgid "1-2"
msgstr "1-2"
